(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["ExpandTraits"]
PackageExport["ExpandGs"]


ExpandTraits::usage="Expand traits across components.";


(*ExpandTraits[rulelist_]:=If[transitionbased,
	rulelist/.Flatten[Table[Table[{
		(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Join[{Subscript[trait, i]->val},Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}]],
		(trait\[Rule]val_)\[Rule]Sequence@@Join[{trait->val},Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]]}
	,{trait,gtraits[gu]}],{gu,guilds}]],
	rulelist];*)


(*ExpandTraits[rulelist_]:=rulelist/.DeleteNulls@Flatten@Table[
	If[ngcomps[gu]>1,
		Table[{
			(*(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Join[{Subscript[trait, i]->val},Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}]],
			(trait\[Rule]val_)\[Rule]Sequence@@Join[{trait->val},Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]]}*)
			(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}],
			(trait\[Rule]val_)\[Rule]Sequence@@Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]}
		,{trait,gtraits[gu]}]
	]
,{gu,guilds}]*)


ExpandTraits[rulelist_]:=Module[{},
	If[moments==True,
		rulelist/.DeleteNulls@Flatten@Table[
			If[ngcomps[gu]>1,
				Table[{
				(*(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Join[{Subscript[trait, i]->val},Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}]],
				(trait\[Rule]val_)\[Rule]Sequence@@Join[{trait->val},Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]]}*)
					(Subscript[trait, i_]->val_)->Sequence@@Table[Subscript[trait[gcomp], i]->val,{gcomp,gcomps[gu]}],
					(trait->val_)->Sequence@@Table[trait[gcomp]->val,{gcomp,gcomps[gu]}]}
				,{trait,gtraits[gu]}]
			]
		,{gu,guilds}]
	,
		rulelist
	]
];


ExpandGs::usage="Expand variance/covariances across species and components.";


(* \[ScriptCapitalN]s not given *)
ExpandGs[rulelist_]:=rulelist/.Flatten@Table[Table[
	If[ngcomps[gu]>1,
		(Subscript[entry, i_]->val_)->Sequence@@Table[Subscript[entry[gcomp], i]->val,{gcomp,gcomps[gu]}],
		{}]
	,{entry,Flatten@MakeGMatrix[gu]}]
,{gu,guilds}];


(*(* \[ScriptCapitalN]s given *)
ExpandGs[in_,nsps_]:=Module[{trsub,tmp},
tmp=Flatten[in/.(G[gu_]->vals_):>(Thread[Flatten[MakeGMatrix[gu]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
tmp=Flatten[tmp/.(Subscript[G[gu_], sp_]->vals_):>(Thread[Flatten[MakeGMatrix[Subscript[gu, sp]]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
(*tmp=tmp/.Flatten@Table[Table[
	If[ngcomps[gu]>1,
		(Subscript[entry, i_]\[Rule]val_)\[Rule]Sequence@@Table[Subscript[entry[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}],
		{}]
	,{entry,Flatten@MakeGMatrix[gu]}]
,{gu,guilds}];
Print["tmp=",tmp];*)
Flatten@Table[
	Table[
		Table[
			(*Print[entry," ",Subscript[entry, i]," ",Replace[Subscript[entry, i],tmp]];*)
			Which[
				(*Print["species-defined"];*)
				Replace[Subscript[entry, i],tmp]=!=Subscript[entry, i],
				Subscript[entry, i]->(Subscript[entry, i]/.tmp),
				(*Print["guild-defined"];*)
				Replace[entry,tmp]=!=entry,
				trsub=Table[gtrait->Subscript[gtrait, i],{gtrait,gtraits[gu]}];
				(*Print["trsub=",trsub];*)
				Subscript[entry, i]->(entry/.tmp/.trsub),
				Else,(*Print["undefined"];*){}
			]
		,{i,\[FormalCapitalN][gu]/.nsps}]
	,{entry,Flatten@MakeGMatrix[gu]}]
,{gu,guilds}]
]*)


(* \[ScriptCapitalN]s given *)
ExpandGs[in_,nsps_]:=Module[{trsub,tmp},
tmp=Flatten[in/.(G[gu_]->vals_):>(Thread[Flatten[MakeGMatrix[gu]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
tmp=Flatten[tmp/.(Subscript[G[gu_], sp_]->vals_):>(Thread[Flatten[MakeGMatrix[Subscript[gu, sp]]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
If[moments,
	tmp=tmp/.Flatten@Table[Table[
		If[ngcomps[gu]>1,{
			(Subscript[entry, i_]->val_)->Sequence@@Table[Subscript[entry[gcomp], i]->val,{gcomp,gcomps[gu]}],
			(entry->val_)->Sequence@@Table[entry[gcomp]->val,{gcomp,gcomps[gu]}]
			},{}]
		,{entry,Flatten@MakeGMatrix[gu]}]
	,{gu,guilds}]
];
(*Print["tmp=",tmp];*)
If[moments,
	Flatten@Table[
		Table[
			Table[
				Table[
					(*Print[entry," ",Subscript[entry, i]," ",Replace[Subscript[entry, i],tmp]];*)
					Which[
						(*Print["species-defined"];*)
						Replace[Subscript[entry, i],tmp]=!=Subscript[entry, i],
						Subscript[entry, i]->(Subscript[entry, i]/.tmp),
						(*Print["guild-defined"];*)
						Replace[entry,tmp]=!=entry,
						trsub=Table[gtrait->Subscript[gtrait, i],{gtrait,gtraits[gu]}];
						(*Print["trsub=",trsub];*)
						Subscript[entry, i]->(entry/.tmp/.trsub),
						Else,(*Print["undefined"];*){}
					]
				,{i,\[FormalCapitalN][gu]/.nsps}]
			,{entry,Flatten@MakeGMatrix[gcomp]}]
		,{gcomp,gcomps[gu]}]
	,{gu,guilds}]
,
	Flatten@Table[
		Table[
			Table[
				(*Print[entry," ",Subscript[entry, i]," ",Replace[Subscript[entry, i],tmp]];*)
				Which[
					(*Print["species-defined"];*)
					Replace[Subscript[entry, i],tmp]=!=Subscript[entry, i],
					Subscript[entry, i]->(Subscript[entry, i]/.tmp),
					(*Print["guild-defined"];*)
					Replace[entry,tmp]=!=entry,
					trsub=Table[gtrait->Subscript[gtrait, i],{gtrait,gtraits[gu]}];
					(*Print["trsub=",trsub];*)
					Subscript[entry, i]->(entry/.tmp/.trsub),
					Else,(*Print["undefined"];*){}
				]
			,{i,\[FormalCapitalN][gu]/.nsps}]
		,{entry,Flatten@MakeGMatrix[gu]}]
	,{gu,guilds}]
]
]
