(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["FindRoots"]


FindRoots::usage="FindRoots[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}] finds all roots of \!\(\*
StyleBox[\"f\", \"TI\"]\) in the range \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\) <= \!\(\*
StyleBox[\"x\", \"TI\"]\) <= \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\).
FindRoots[{\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), \[Ellipsis]}, {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}, \[Ellipsis]] finds all roots of {\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), \[Ellipsis]}.";


FindRoots[eqnsin_List,ranges__?VarRangeQ,opts___?OptionQ]:=

Module[{
(* options *)
numseeds,method,pad,plotopts,findrootopts,deq,checkroots,accuracygoal,
verbose,
(* other variables *)
eqns,dim,roots,seeds,peqns,var,min,max,dvar,vars,plot,f},

Block[{verbosity},

(* set verbosity *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindRoots]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindRoots]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindRoots]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[FindRoots]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindRoots]}]];
method=Evaluate[Method/.Flatten[{opts,Options[FindRoots]}]];
numseeds=Evaluate[NumSeeds/.Flatten[{opts,Options[FindRoots]}]];
pad=Evaluate[Padding/.Flatten[{opts,Options[FindRoots]}]];
deq=Evaluate[DEq/.Flatten[{opts,Options[FindRoots]}]];
checkroots=Evaluate[CheckRoots/.Flatten[{opts,Options[FindRoots]}]];
accuracygoal=Evaluate[AccuracyGoal/.Flatten[{opts,Options[FindRoots]}]];

eqns=eqnsin/.(lhs_==rhs_)->rhs-lhs; (* convert equations into functions *)
dim=Length[eqns];
If[dim!=Length[{ranges}],Message[FindRoots::baddim];Abort[]];

Do[
	{var[i],min[i],max[i]}={ranges}[[i]];
	dvar[i]=(max[i]-min[i]);
,{i,dim}];
vars=Table[var[i],{i,dim}];

(* set seeds *)
If[
	method===Automatic,
	Which[
		dim==1,
		plot=Plot[Evaluate[eqns/.{var[1]->x}],{x,min[1]-pad*dvar[1],max[1]+pad*dvar[1]}];
		VPrint[3,plot];
		seeds=Mean/@Map[First,Select[Split[ExtractPlotPoints[plot][[1]],Sign[Last[#2]]==-Sign[Last[#1]]&],Length[#1]==2&],{2}]/.{x_?NumericQ->{x}};
		seeds=Join[seeds,{{min[1]},{max[1]}}]
	,
		dim==2,
		peqns=Drop[eqns,{deq}];
		plot=ContourPlot[Evaluate[peqns/.{var[1]->x,var[2]->y}],
			{x,min[1]-1.1*pad*dvar[1],max[1]+pad*dvar[1]},{y,min[2]-pad*dvar[2],max[2]+1.1*pad*dvar[2]},
			Contours->{0},ContourShading->False,Evaluate[Sequence@@plotopts]];
		VPrint[3,plot];
		f=Compile[{x,y},Evaluate[eqns[[deq]]/.{var[1]->x,var[2]->y}]];
		seeds=Flatten[Pick[Rest@#,Rest[#]Most[#]&@Sign@Apply[f,#,2],-1]&/@ExtractPlotPoints[plot],1];
		seeds=Join[seeds,Tuples[Table[{min[i],max[i]},{i,dim}]]]
	,
		dim==3,
		peqns=Drop[eqns,{deq}];
		plot=ContourPlot3D[Evaluate[peqns/.{var[1]->x,var[2]->y,var[3]->z}],
			{x,min[1]-1.1*pad*dvar[1],max[1]+pad*dvar[1]},{y,min[2]-pad*dvar[2],max[2]+1.1*pad*dvar[2]},{z,min[3]-1.05*pad*dvar[3],max[3]+1.05*pad*dvar[3]},
			BoundaryStyle->{1->None,2->None,{1,2}->{}},ContourStyle->None,Mesh->None,
			Evaluate[Sequence@@plotopts]];
		VPrint[3,plot];
		f=Compile[{x,y,z},Evaluate[eqns[[deq]]/.{var[1]->x,var[2]->y,var[3]->z}]];
		seeds=Flatten[Pick[Rest[#],Most[#] Rest[#]&@Sign@Apply[f,#,2],-1]&/@ExtractPlotPoints[plot],1];
		seeds=Join[seeds,Tuples[Table[{min[i],max[i]},{i,dim}]]]
	,
		Else,
		method=Grid
	];
];
Which[
	method===Grid,
	If[numseeds==Automatic,numseeds=5];
	If[IntegerQ[numseeds],numseeds=Table[numseeds,{dim}]];
	seeds=Tuples[Table[Range[min[i],max[i],(max[i]-min[i])/(numseeds[[i]]-1)],{i,dim}]]
,
	method===Random,
	If[numseeds==Automatic,numseeds=10];
	seeds=RandomVariate[UniformDistribution[Table[{min[i],max[i]},{i,dim}]],numseeds]	
];
VPrint[1,"seeds=",seeds];

If[seeds!={},
	roots=Union[
		Chop[Map[Quiet@Check[
			FindRoot[eqns,Evaluate[Transpose[{vars,#}]],Evaluate[Sequence@@findrootopts]],Null,{FindRoot::jsing}]&,seeds]]//DeleteNulls,
		SameTest->(RuleListDistance[#1,#2]<10^-8&)
		];
	VPrint[1,"roots=",roots];
	If[checkroots,
		VPrint[2,"norm=",Table[Norm[eqns/.root],{root,roots}]];
		roots=Select[roots,Norm[eqns/.#]<10^-accuracygoal&];
		VPrint[1,"checked roots=",roots]
	];
	roots=Select[roots,And@@Table[min[i]-$MachineEpsilon<=#[[i,2]]<=max[i]+$MachineEpsilon,{i,dim}]&];
	VPrint[1,"filtered roots=",roots]
,
	roots={}	
];
Return[roots]

]];


Options[FindRoots]={Method->Automatic,NumSeeds->Automatic,FindRootOpts->{},PlotOpts->{},Padding->10^-3,DEq->-1,CheckRoots->True,AccuracyGoal->8,
Verbose->False,Verbosity->0};


FindRoots::baddim="Number of functions does not match number of unknowns.";


(* handle one-function case *)
FindRoots[func_,range_?VarRangeQ,opts___?OptionQ]:=FindRoots[{func},range,opts];



