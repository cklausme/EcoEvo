(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["FindExtrema"]
PackageExport["FindMinima"]
PackageExport["FindMaxima"]


FindExtrema::usage=
"FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local extrema of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* InterpolatingFunction *)
FindExtrema[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]==0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindExtrema[if_InterpolatingFunction]:=FindExtrema[if,if["Domain"][[1]]];


(* TemporalData *)
FindExtrema[td_TemporalData]:=Sort[Join[FindMinima[td],FindMaxima[td]]];
FindExtrema[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindExtrema[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindExtrema[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(x->FindExtrema[val,opts]));
FindExtrema[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindExtrema[val,{tmin,tmax},opts]);


(* List *)
FindExtrema[l_List]:=FindExtrema[TimeSeries[l]];
FindExtrema[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindExtrema[TimeSeries[l],{tmin,tmax}];


FindMinima::usage=
"FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local minima of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* InterpolatingFunction *)
FindMinima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]>0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindMinima[if_InterpolatingFunction]:=FindMinima[if,if["Domain"][[1]]];


(* TemporalData *)
FindMinima[td_TemporalData]:=Normal[TimeSeriesMap[Minus,FindPeaks[TimeSeriesMap[Minus,td]]]];
FindMinima[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMinima[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindMinima[f_?RuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->FindMinima[val,opts]);
FindMinima[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindMinima[val,{tmin,tmax},opts]);


(* List *)
FindMinima[l_List]:=FindMinima[TimeSeries[l]];
FindMinima[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMinima[TimeSeries[l],{tmin,tmax}];


FindMaxima::usage=
"FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local maxima of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* InterpolatingFunction *)
FindMaxima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]<0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindMaxima[if_InterpolatingFunction]:=FindMaxima[if,if["Domain"][[1]]];


(* TemporalData *)
FindMaxima[td_TemporalData]:=Normal[FindPeaks[td]];
FindMaxima[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMaxima[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindMaxima[f_?RuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->FindMaxima[val,opts]);
FindMaxima[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindMaxima[val,{tmin,tmax},opts]);


(* List *)
FindMaxima[l_List]:=FindMaxima[TimeSeries[l]];
FindMaxima[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMaxima[TimeSeries[l],{tmin,tmax}];



