(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["PlotTrajectory"]


PlotTrajectory::usage="PlotTrajectory[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots a trajectory of temporal rule list \!\(\*
StyleBox[\"sol\", \"TI\"]\) in two or three dimensions.
PlotTrajectory[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\).
PlotTrajectory[{\!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(2\)]\), \[Ellipsis]}] plots multiple trajectories.";


PlotTrajectory[solsin_?RuleListListQ,varsin_List:{All},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotTrajectory"],
(* options *)
plotstyle,axeslabel,plotrange,
parametricplotopts,parametricplot3dopts,listplotopts,listlineplotopts,listpointplot3dopts,listlineplot3dopts,
(* other variables *)
sol,sols,lookup,vars},
	
Block[{\[ScriptCapitalN]},

(*If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];*)
If[Global`debug,Print["In ",func]];

(* handle options *)

plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotTrajectory]}]];
If[plotstyle===Automatic,plotstyle=ColorData[97,"ColorList"]];
If[!ListQ[plotstyle],plotstyle={plotstyle}];

axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotTrajectory]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PlotTrajectory]}]];

parametricplotopts=FilterRules[Flatten[{opts,Options[PlotTrajectory]}],Options[ParametricPlot]];
parametricplot3dopts=FilterRules[Flatten[{opts,Options[PlotTrajectory]}],Options[ParametricPlot3D]];
listplotopts=FilterRules[Flatten[{opts,Options[PlotTrajectory]}],Options[ListPlot]];
listlineplotopts=FilterRules[Flatten[{opts,Options[PlotTrajectory]}],Options[ListLinePlot]];
listpointplot3dopts=FilterRules[Flatten[{opts,Options[PlotTrajectory]}],Options[ListPointPlot3D]];
listlineplot3dopts=FilterRules[Flatten[{opts,Options[PlotTrajectory]}],Options[MyListLinePlot3D]];

(* figure out number of species in guilds *)
(*Set\[ScriptCapitalN][ExtractTraits[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]],ExtractVariables[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];*)

(* find vars for plotting *)
If[varsin==={All},
	vars=solsin[[1,All,1]],
	vars=varsin
];
(*Print["vars=",vars];*)
If[Length[vars]!=2&&Length[vars]!=3,Message[PlotTrajectory::baddim,Length[vars]];Return[$Failed]];

(* split up subscripted variables (gcomps & gtraits) *)
lookup=LookUp[vars[[1]]];
If[MemberQ[{"gcomp","gtrait"},lookup[[1]]]&&Length[lookup]==3,
	sols=Flatten[GatherBy[#,#[[1,2]]&]&/@solsin,1]/.Replace[vars,var_->(Subscript[var, _]->var),1],
	sols=solsin
];
(*Print[sols];*)

If[axeslabel===Automatic,axeslabel=vars];
(*Print["axeslabel=",axeslabel];*)

Which[
	Length[vars]==2,
	If[plotrange===Automatic,
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],If[comptype[vars[[2]]]==="Extensive",{0,All},All]}
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			(*Print["parametricplotopts=",parametricplotopts];*)
			ParametricPlot[{vars[[1]][t],vars[[2]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplotopts]],
			Head[sol[[1,2]]]===List,
			ListLinePlot[Transpose[(vars/.sol)[[All,All,2]]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]],
			Head[sol[[1,2]]]===TemporalData,
			ListLinePlot[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]]
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,FrameLabel->axeslabel,PlotRange->plotrange]],
	Length[vars]==3,
	If[plotrange===Automatic,
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],
			If[comptype[vars[[2]]]==="Extensive",{0,All},All],
			If[comptype[vars[[3]]]==="Extensive",{0,All},All]}
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			ParametricPlot3D[{vars[[1]][t],vars[[2]][t],vars[[3]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplot3dopts]],
			Head[sol[[1,2]]]===List,
			MyListLinePlot3D[Transpose[vars/.sol],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]],
			Head[sol[[1,2]]]===TemporalData,
			MyListLinePlot3D[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]]
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,PlotRange->plotrange]]
];

]];


PlotTrajectory[sol_?RuleListQ,rest___]:=PlotTrajectory[{sol},rest];


Options[PlotTrajectory]={
	PlotStyle->Automatic,AxesLabel->Automatic,PlotRange->Automatic,
	PlotRangeClipping->False,BoxRatios->1,AspectRatio->1/GoldenRatio
};


PlotTrajectory::baddim="PlotTrajectory requires two- or three-dimensional data (# of dimensions=`1`).";



