(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["GaussianIntegral"]


GaussianIntegral::usage="GaussianIntegral[\!\(\*
StyleBox[\"func\", \"TI\"]\), {\!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"mean\", \"TI\"]\), \!\(\*
StyleBox[\"varcov\", \"TI\"]\)}] calculates the Gaussian integral with respect to \!\(\*
StyleBox[\"vars\", \"TI\"]\) of \!\(\*
StyleBox[\"func\", \"TI\"]\) multiplied by a multinormal distibution with \!\(\*
StyleBox[\"mean\", \"TI\"]\) and \!\(\*
StyleBox[\"varcov\", \"TI\"]\).";


GaussianIntegral[func_,{x_List,mean_List,var_List},opts___?OptionQ]:=Module[{method,timeconstraint,res},
	method=Evaluate[Method/.Flatten[{opts,Options[GaussianIntegral]}]];
	timeconstraint=Evaluate[TimeConstraint/.Flatten[{opts,Options[GaussianIntegral]}]];
	res=TimeConstrained[
		Expectation[func,x\[Distributed]MultinormalDistribution[mean,var],Method->method],
		timeconstraint,Message[GaussianIntegral::time,timeconstraint];Return[$Failed]];
	If[Head[res]===Expectation,Message[GaussianIntegral::failed];Return[$Failed]];
	RealSimplify[res]
];

GaussianIntegral[func_,{x1_List,mean1_List,var1_List},{x2_List,mean2_List,var2_List},opts___?OptionQ]:=Module[{method,timeconstraint},
	method=Evaluate[Method/.Flatten[{opts,Options[GaussianIntegral]}]];
	RealSimplify[Expectation[Expectation[func,x1\[Distributed]MultinormalDistribution[mean1,var1],Method->method],x2\[Distributed]MultinormalDistribution[mean2,var2],Method->method],(#>=0)&/@Flatten[{var1,var2}]]
];


GaussianIntegral[func_,{x_,mean_,var_},opts___?OptionQ]:=GaussianIntegral[func,{{x},{mean},{{var}}},opts];
GaussianIntegral[func_,{x1_,mean1_,var1_},{x2_,mean2_,var2_},opts___?OptionQ]:=GaussianIntegral[func,{{x1},{mean1},{{var1}}},{{x2},{mean2},{{var2}}},opts];


Options[GaussianIntegral]={Method->Automatic,TimeConstraint->5};


GaussianIntegral::time = "Time spent on GaussianIntegral exceeded `1` seconds, so it was aborted. Increasing the value of TimeConstraint may result in an answer.";
GaussianIntegral::failed = "Expectation failed to calculate GaussianIntegral.";



