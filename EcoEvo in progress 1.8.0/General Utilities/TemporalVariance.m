(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["TemporalVariance"]


TemporalVariance::usage=
"TemporalVariance[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the variance of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=\!\(\*
StyleBox[\"t\", \"TI\"]\)).
TemporalVariance[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] ranges from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
TemporalVariance[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* thread over ParametricDynamicss *)
TemporalVariance[pd_ParametricDynamics,opts___?OptionQ]:=Which[
	pd["Type"]=="Discrete",
	Table[var->AssociationToArray[TemporalVariance/@pd[[1]],var],{var,pd["Variables"]}]
,
	pd["Type"]=="Continuous",
	RuleListInterpolation[TemporalVariance/@pd[[1]]]
];


(* main *)
TemporalVariance[f_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg},
	method=Evaluate[Method/.Flatten[{opts,Options[TemporalVariance]}]];
	If[InterpolatingFunctionFunctionQ[f]==True,method="NIntegrate"];
	If[TemporalDataFunctionQ[f]==True,method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avg=TemporalMean[f,{var,varmin,varmax},Method->method];
	Which[
		method=="Integrate",
		Return[Integrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[(f-avg)^2,{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Message[General::badmtd];Return[$Failed];
	];
];


(* work on InterpolatingFunctions *)
TemporalVariance[f_InterpolatingFunctions,opts___?OptionQ]:=RuleListInterpolation[MapAt[TemporalVariance,Normal[f],{All,2}]];


(* thread over RuleLists *)
TemporalVariance[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(Var[x]->TemporalVariance[val,opts]));
TemporalVariance[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["rulelist2"];*)
f/.(x_->val_):>(Var[x]->TemporalVariance[val,{var,varmin,varmax},opts]));


(* InterpolatingFunctionFunctions *)
TemporalVariance[if_?InterpolatingFunctionFunctionQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalVariance]}]];
		
	ifdomains=Map[#["Domain"][[1]]&,Cases[if,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Message[TemporalVariance::norange],
		numifdomains>1,
		Message[TemporalVariance::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[TemporalVariance[if,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


(* InterpolatingFunctions *)
TemporalVariance[f_InterpolatingFunction,opts___?OptionQ]:=((*Print["raw IF"];*)TemporalVariance[f[t],opts]);
TemporalVariance[f_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)TemporalVariance[f[t],{var,varmin,varmax},opts]);


(* TemporalData *)
TemporalVariance[f_TemporalData,opts___?OptionQ]:=Module[{n},
(*Print["td"];*)
	n=(f["LastTimes"]-f["FirstTimes"])[[1]]+1;
	Variance[f]*(n-1)/n
];

TemporalVariance[f_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{n},
(*Print["td2"];*)
	n=varmax-varmin+1;
	Variance[TimeSeriesWindow[f,{varmin,varmax}]]*(n-1)/n
];


(* TemporalDataFunctions *)
TemporalVariance[f_?TemporalDataFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{domains,numdomains,varmin,varmax},
	
	domains=Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f,_TemporalData,\[Infinity],Heads->True]];
	numdomains=Length[Union[domains]];

	Which[
		numdomains==0,
		Message[TemporalVariance::norange],
		numdomains>1,
		Message[TemporalVariance::unkrange],
		Else,
		{varmin,varmax}=domains[[1]];
		Return[TemporalVariance[f,{var,varmin,varmax},opts]]
	];
];


(* fallthrough *)
TemporalVariance[f_?NumericQ,opts___?OptionQ]:=((*Print["otherwise"];*)0);


Options[TemporalVariance]={IntegrateOpts->{},NIntegrateOpts->{},TemporalMeanOpts->{},Method->"Integrate"};
