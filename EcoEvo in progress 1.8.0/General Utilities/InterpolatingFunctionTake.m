(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["InterpolatingFunctionTake"]


InterpolatingFunctionTake::usage=
"InterpolatingFunctionTake[\!\(\*
StyleBox[\"if\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] takes part of an InterpolatingFunction from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";


ClearAll[ifnPart];
ifnPart["Domain"]=Sequence[1];(*bounding box for domain*)
ifnPart["X1"]=Sequence[1,1];(*lower bound for first coordinate*)
ifnPart["X2"]=Sequence[1,2];(*upper bound for first coordinate*)
ifnPart["Version"]=Sequence[2,1];
ifnPart["Flags"]=Sequence[2,2];(*flags indicating properties:bit field positions-inferred,perhaps mistaken $extrapolation=0;whether to warn about extrapolation $fullArrayBit=1;interpolation data is a full array (not ragged) $packed=2;packed array form (???) $repeatedBit=4;whether repeated abscissae are permitted*)
ifnPart["DerivativeOrder"]=Sequence[2,3];(*max derivative order*)
ifnPart["NGrid"]=Sequence[2,4];(*number of points in each coordinate grid*)
ifnPart["InterpolationOrder"]=Sequence[2,5];(*interpolation order*)
ifnPart["Derivative"]=Sequence[2,6];(*derivative to evaluate:0-->f[x],1-->f'[x],...*)
ifnPart["Periodic"]=Sequence[2,7];
ifnPart["ExtrapolationHandler"]=Sequence[2,10];
ifnPart["Coordinates"]=Sequence[3];(*list of lists,abscissae of interpolation grid*)
ifnPart["InterpolationData"]=Sequence[4];(*interpolation data (values or coefficients)*)
ifnPart["Offsets"]=Sequence[4,2];(*offsets in function/derivative array (PackedArrayForm)*)
ifnPart["FlatData"]=Sequence[4,3];(*flattened function/derivative values (PackedArrayForm)*)
ifnPart["InterpolationStructure"]=Sequence[5];(*{Automatic},or dense output interpolation structure:list of types for each unit/subinterval*)ifnPart["UnitIndices"]=Sequence[5,1,1];(*dense output:Indices (to grid) for corresponding coefficients*)
ifnPart["UnitTypes"]=Sequence[5,1,2];(*dense output types:Automatic|NDSolve`CubicHermite|NDSolve`LocalSeries|ChebyshevT*)
ifnPart["Properties"]=Cases[DownValues[ifnPart],Verbatim[ifnPart][prop_]:>prop,Infinity];

ifnPart["ValidPartQ","Chebyshev"|"Local Taylor Series","UnitIndices"|"UnitTypes",_]:=True;
ifnPart["ValidPartQ",_,"UnitIndices"|"UnitTypes",_]:=False;
ifnPart["ValidPartQ","Hermite","Offsets"|"FlatData",Developer`PackedArrayForm]:=True;
ifnPart["ValidPartQ",_,"Offsets"|"FlatData",_]:=False;
ifnPart["ValidPartQ",method_String,part_String,_]/;MemberQ[method,"Chebyshev"|"Local Taylor Series"|"Hermite"]&&MemberQ[part,ifnPart["Properties"]]:=True;
ifnPart["ValidPartQ",_,_,_]:=False;
ifnPart[if_InterpolatingFunction,part_String]/;ifnPart["ValidPartQ",if["InterpolationMethod"],part,if[[4,1]]]:=if~Part~ifnPart[part];


dupeLast[list_]:=Append[list,Last@list];

iDataTake["Local Taylor series"|"Chebyshev",data_,span_]:=Join[{data[[First@span,1;;2]]},data[[First@span+1;;Last@span]]];
iDataTake["Hermite",data:{Developer`PackedArrayForm,_,_},span:{s1_,s2_}]:=
	ReplacePart[data,{Rest@{ifnPart["Offsets"]}->data[[2,s1;;s2+1]]-data[[2,s1]],Rest@{ifnPart["FlatData"]}->data[[3,data[[2,s1]]+1;;data[[2,s2+1]]]]}];
iDataTake["Hermite",data:{__List},span_]:=data[[Span@@span]];

iStructureTake["Local Taylor series"|"Chebyshev",structure_,span_]:=
	ReplacePart[structure,{Rest@{ifnPart["UnitIndices"]}->Join[{{1}},1+structure[[##2&@ifnPart["UnitIndices"],First@span+1;;Last@span]]-structure[[##2&@ifnPart["UnitIndices"],First@span,-1]]//dupeLast],Rest@{ifnPart["UnitTypes"]}->Join[{Automatic},structure[[##2&@ifnPart["UnitTypes"],First@span+1;;Last@span]]//dupeLast]}];
iStructureTake["Hermite",structure_,span_]:=structure;

InterpolatingFunctionTake[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]/;Length@if["Domain"]==1:=Module[
{coords,newif=Hold@@if,span,method},

method=if["InterpolationMethod"];
coords=First@if["Coordinates"];
span=Clip[SparseArray[UnitStep[coords-tmin] UnitStep[tmax-coords]]["AdjacencyLists"][[{1,-1}]]+{-1,1},{1,Length@coords}];
newif[[ifnPart["Domain"]]]={{tmin,tmax}};
newif[[ifnPart["NGrid"]]]=1+Differences@span;
newif[[ifnPart["Coordinates"]]]=Developer`ToPackedArray@{coords[[Span@@span]]};
newif[[ifnPart["InterpolationData"]]]=iDataTake[method,if[[ifnPart["InterpolationData"]]],span];
newif[[ifnPart["InterpolationStructure"]]]=iStructureTake[method,if[[ifnPart["InterpolationStructure"]]],span];
InterpolatingFunction@@newif
];



