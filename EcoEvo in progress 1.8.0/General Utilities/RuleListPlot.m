(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]
PackageExport["RuleListPlot"]


RuleListPlot::usage=
"RuleListPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots a two- or three-dimensional rule list.
RuleListPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\).
RuleListPlot[{\!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(2\)]\), \[Ellipsis]}] plots multiple rule lists.";


RuleListPlot[solsin_?RuleListListQ,varsin_List:{All},opts___?OptionQ]:=

Module[{
func=FuncStyle["RuleListPlot"],
(* options *)
plotstyle,plotmarkers,axeslabel,plotrange,
stablemarker,unstablemarker,indeterminatemarker,
parametricplotopts,parametricplot3dopts,listplotopts,listlineplotopts,listpointplot3dopts,listlineplot3dopts,
(* other variables *)
sol,sols,lookup,vars},
	
Block[{\[ScriptCapitalN]},

(*If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];*)
If[Global`debug,Print["In ",func]];

(* handle options *)

plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[RuleListPlot]}]];
If[plotstyle===Automatic,plotstyle=ColorData[97,"ColorList"]];
If[!ListQ[plotstyle],plotstyle={plotstyle}];

stablemarker=Evaluate[StableMarker/.Flatten[{opts,Options[RuleListPlot]}]];
unstablemarker=Evaluate[UnstableMarker/.Flatten[{opts,Options[RuleListPlot]}]];
indeterminatemarker=Evaluate[IndeterminateMarker/.Flatten[{opts,Options[RuleListPlot]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[RuleListPlot]}]]/.
	{True->stablemarker,False->unstablemarker,Indeterminate->indeterminatemarker};
Which[
	plotmarkers===Automatic,
	plotmarkers={"\[FilledCircle]","\[FilledSquare]","\[FilledDiamond]","\[FilledUpTriangle]","\[FilledDownTriangle]","\[EmptyCircle]","\[EmptySquare]","\[EmptyDiamond]","\[EmptyUpTriangle]","\[EmptyDownTriangle]"},
	plotmarkers==="OpenMarkers",
	plotmarkers={"\[EmptyCircle]","\[EmptySquare]","\[EmptyDiamond]","\[EmptyUpTriangle]","\[EmptyDownTriangle]"},
	plotmarkers==="FilledMarkers",
	plotmarkers={"\[FilledCircle]","\[FilledSquare]","\[FilledDiamond]","\[FilledUpTriangle]","\[FilledDownTriangle]"}
];
(*Print[plotmarkers];*)

axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[RuleListPlot]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[RuleListPlot]}]];

parametricplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ParametricPlot]];
parametricplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ParametricPlot3D]];
listplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListPlot]];
listlineplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListLinePlot]];
listpointplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListPointPlot3D]];
listlineplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[MyListLinePlot3D]];

(* figure out number of species in guilds *)
(*Set\[ScriptCapitalN][ExtractTraits[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]],ExtractVariables[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];*)

(* find vars for plotting *)
If[varsin==={All},
	vars=solsin[[1,All,1]],
	vars=varsin
];
(*Print["vars=",vars];*)
If[Length[vars]!=2&&Length[vars]!=3,Message[RuleListPlot::baddim,Length[vars]];Return[$Failed]];

(* split up subscripted variables (gcomps & gtraits) *)
lookup=LookUp[vars[[1]]];
If[MemberQ[{"gcomp","gtrait"},lookup[[1]]]&&Length[lookup]==3,
	sols=Flatten[GatherBy[#,#[[1,2]]&]&/@solsin,1]/.Replace[vars,var_->(Subscript[var, _]->var),1],
	sols=solsin
];
(*Print[sols];*)

If[axeslabel===Automatic,axeslabel=vars];
(*Print["axeslabel=",axeslabel];*)

Which[
	Length[vars]==2,
	If[plotrange===Automatic,
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],If[comptype[vars[[2]]]==="Extensive",{0,All},All]}
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			(*Print["parametricplotopts=",parametricplotopts];*)
			ParametricPlot[{vars[[1]][t],vars[[2]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplotopts]],
			Head[sol[[1,2]]]===List,
			ListLinePlot[Transpose[(vars/.sol)[[All,All,2]]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]],
			Head[sol[[1,2]]]===TemporalData,
			ListLinePlot[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]],
			Else,
			(*Print["listplotopts=",listplotopts];*)
			ListPlot[{vars/.sol},PlotStyle->ModPart[plotstyle,i],PlotMarkers->ModPart[plotmarkers,i],
				PlotRange->plotrange,Evaluate[Sequence@@listplotopts]]
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,FrameLabel->axeslabel,PlotRange->plotrange]],
	Length[vars]==3,
	If[plotrange===Automatic,
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],
			If[comptype[vars[[2]]]==="Extensive",{0,All},All],
			If[comptype[vars[[3]]]==="Extensive",{0,All},All]}
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			ParametricPlot3D[{vars[[1]][t],vars[[2]][t],vars[[3]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplot3dopts]],
			Head[sol[[1,2]]]===List,
			MyListLinePlot3D[Transpose[vars/.sol],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]],
			Head[sol[[1,2]]]===TemporalData,
			MyListLinePlot3D[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]],
			Else,
			ListPointPlot3D[{vars/.sol},PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@listpointplot3dopts]]
				(*/.Point[a___]\[RuleDelayed]Text[ModPart[plotmarkers,i],a]*)
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,PlotRange->plotrange]]
];

]];


RuleListPlot[sol_?RuleListQ,rest___]:=RuleListPlot[{sol},rest];


Options[RuleListPlot]={
	PlotStyle->Automatic,AxesLabel->Automatic,PlotRange->Automatic,
	PlotMarkers->{Graphics[{Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	StableMarker->{Graphics[{Black,Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	UnstableMarker->{Graphics[{EdgeForm[{Black}],FaceForm[White],Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	IndeterminateMarker->{Graphics[{EdgeForm[{Black}],FaceForm[Gray],Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	PlotRangeClipping->False,BoxRatios->1,AspectRatio->1/GoldenRatio
};


RuleListPlot::baddim="RuleListPlot requires two- or three-dimensional data (# of dimensions=`1`).";
