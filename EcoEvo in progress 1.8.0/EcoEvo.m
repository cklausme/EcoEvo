(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Package["EcoEvo`"]


(* hack to address <https://mathematica.stackexchange.com/questions/167143/setdelayedwrsym-on-first-use-of-formalx> *)
Plot[0,{x,0,1}];
ContourPlot[0,{x,0,1},{y,0,1}];


$EcoEvoVersion="1.7.3 (December 10, 2023)";


modelloaded=False;


SetOptions[NDSolve,MaxSteps->Infinity];
If[$VersionNumber>=12.2,SetOptions[Solve,Assumptions->{}]]; (* <https://mathematica.stackexchange.com/questions/270045> *)
(*SetOptions[NIntegrate,MaxRecursion\[Rule]30];*)


Set\[ScriptCapitalN][attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{}]:=Module[{tmp,interxns,tnsp,pnsp,insp},

If[ninteractions!=0,interxns=ExtractInteractions[attributes]];

Do[
	If[IntegerQ[\[FormalCapitalN][gu]/.attributes], (* if \[FormalCapitalN] passed, just use that *)
		tnsp[gu]=insp[gu]=(\[FormalCapitalN][gu]/.attributes),
		(*If[attributes\[NotEqual]{},*)
			(* tnsp = nsp determined from traits *)
			If[ngtraits[gu]!=0,
				(*tmp=Table[Max[Select[Select[attributes,#\[LeftDoubleBracket]1,0\[RightDoubleBracket]\[Equal]Subscript&],#\[LeftDoubleBracket]1,1\[RightDoubleBracket]\[Equal]gtrait&]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket]],{gtrait,gtraits[gu]}];*)
				tmp=Table[Max[Select[
					Select[Select[attributes,#[[1,0]]==Subscript&],(#[[1,1]]==gtrait||#[[1,1,0]]==gtrait)&][[All,1,2]],NumericQ]],{gtrait,gtraits[gu]}];
(*Print[ExtractTraits[attributes,gu]];
Print[ExtractTraits[attributes,gu]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket]];
				tmp=ExtractTraits[attributes,gu]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket];*)
				If[Length[Union[tmp]]==1,
					tnsp[gu]=tmp[[1]],
					Message[Set\[ScriptCapitalN]::badtrait,gu,tmp];
					Abort[]
				];
(*Print["tnsp[gu]=",tnsp[gu]];*)
				If[tnsp[gu]==-\[Infinity],tnsp[gu]=0];
			,
				tnsp[gu]=None
			];
			(* insp = nsp determined from interactions *)
			If[Length[interactionpos[gu]]!=0,
				tmp=Table[Max[Select[interxns,#[[1,1]]==pos[[1]]&][[All,1,pos[[2]]+1]]],{pos,interactionpos[gu]}];
				(*Print[tmp];*)
				If[Length[Union[tmp]]==1,
					insp[gu]=tmp[[1]],
					Message[Set\[ScriptCapitalN]::badinterxn,gu,tmp];
					Abort[]
				];
			,
				insp[gu]=None
			]
		(*];*)
	];
	If[IntegerQ[\[FormalCapitalN][gu]/.variables], (* if \[FormalCapitalN] passed, just use that *)
		pnsp[gu]=(\[FormalCapitalN][gu]/.variables),
		(*If[variables\[NotEqual]{},*)
			(* pnsp = nsp determined from variables *)
			(*tmp=Table[Max[Select[Select[Select[variables,#\[LeftDoubleBracket]1,0\[RightDoubleBracket]\[Equal]Subscript&],#\[LeftDoubleBracket]1,1\[RightDoubleBracket]\[Equal]gcomp&]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket],NumericQ]],{gcomp,gcomps[gu]}];*)
			tmp=Table[Max[Select[Select[variables,#[[1,0]]==Subscript&],#[[1,1]]==gcomp&][[All,1,2]]],{gcomp,gcomps[gu]}];
			If[Length[Union[tmp]]==1,
				pnsp[gu]=tmp[[1]],
				Message[Set\[ScriptCapitalN]::badcomm,gu,tmp];
				Abort[]
			];(*,
			pnsp[gu]=None
		];*)
(*Print["pnsp[gu]=",pnsp[gu]];*)
		If[pnsp[gu]==-\[Infinity],pnsp[gu]=0];
	];

	If[Global`debug,Print["Set\[ScriptCapitalN]: (",gu," tnsp=",tnsp[gu]," insp=",insp[gu]," pnsp=",pnsp[gu],")"]];
	
	Which[
		(* no traits given \[LongDash] remove in 1.7.3 ?! *)
		attributes=={},
		\[ScriptCapitalN][gu]=pnsp[gu],
		(* gu has traits & interactions *)
		ngtraits[gu]!=0&&Length[interactionpos[gu]]!=0,
		If[pnsp[gu]==tnsp[gu]==insp[gu]||(variables=={}&&tnsp[gu]==insp[gu]),
			\[ScriptCapitalN][gu]=tnsp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],tnsp[gu],insp[gu]}];
			Abort[]
		],
		(* gu has only interactions *)
		ngtraits[gu]==0&&Length[interactionpos[gu]]!=0,
		If[pnsp[gu]==insp[gu]||variables=={},
			\[ScriptCapitalN][gu]=insp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],None,insp[gu]}];
			Abort[]
		],
		(* gu has only traits *)
		ngtraits[gu]!=0&&Length[interactionpos[gu]]==0,
		If[pnsp[gu]==tnsp[gu]||variables=={},
			\[ScriptCapitalN][gu]=tnsp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],insp[gu],None}];
			Abort[]
		]
	]
,{gu,guilds}]

]/;(nguilds!=0);


Set\[ScriptCapitalN]::badnsp=
"Number of species in guild `1` inconsistent: {pnsp,tnsp,insp}= `2`.";

Set\[ScriptCapitalN]::badtrait=
"Number of traits in guild `1` inconsistent: `2`.";

Set\[ScriptCapitalN]::badcomm=
"Number of components in guild `1` inconsistent: `2`.";

Set\[ScriptCapitalN]::badinterxn=
"Number of interactions in guild `1` inconsistent: `2`.";


FromUnks::usage="Internal usage only ;)";
ToUnks::usage="Internal usage only ;)";
ToUnkRules::usage="Internal usage only ;)";


FromUnks:=Unk[stuff___]->stuff


ToUnks:=Flatten[{
	Table[Table[Subscript[gcomp,\[FormalS]_]->Unk[Subscript[gcomp,\[FormalS]]],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}],
	Table[Table[Subscript[gtrait,\[FormalS]_]->Unk[Subscript[gtrait,\[FormalS]]],{gtrait,gtraits[gu]}],{gu,guilds}]
}]


(*ToUnks:=Flatten[Table[Table[Subscript[gtrait,\[FormalS]_]\[Rule]Unk[Subscript[gtrait,\[FormalS]]],{gtrait,gtraits[gu]}],{gu,guilds}]];*)


ToUnkRules:=Flatten[Join[
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_][t])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]][t])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[(pcomp->pcomp)->(pcomp->Unk[pcomp]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[(pcomp->pcomp[t])->(pcomp->Unk[pcomp][t]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[(aux->aux)->(aux->Unk[aux]),{aux,auxs}],
	Table[(aux->aux[t])->(aux->Unk[aux][t]),{aux,auxs}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]])
	,{gtrait,gtraits[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_][t])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]][t])
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]]


AllTraits::usage="Internal usage only ;)";
AllVariables::usage="Internal usage only ;)";
AllPopsAndAuxs::usage="Internal usage only ;)";


AllTraits:=Flatten[Table[Table[Table[
	{Subscript[gtrait,sp],Table[Subscript[gtrait[gcomp],sp],{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


AllVariables:=Flatten[Join[
	Table[Table[Table[Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


AllPopsAndAuxs:=Flatten[Join[
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


BlankTraits::usage="Internal usage only ;)";
BlankUnkTraits::usage="Internal usage only ;)";
BlankVariables::usage="Internal usage only ;)";
BlankUnkVariables::usage="Internal usage only ;)";


BlankTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Subscript[gtrait,sp],{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


BlankUnkTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Unk[Subscript[gtrait,sp]],{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


BlankVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->aux,{aux,auxs}]
]];


BlankUnkVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Unk[Subscript[gcomp,sp]],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}]
]];


FixAttributes::usage="Internal usage only ;)";
FixVariables::usage="Internal usage only ;)";


FixAttributes[attributes_]:=attributes/.(var_->arr_?ArrayQ):>Sequence@@ArrayToRuleList[var,arr]/.{Subscript[\[ScriptCapitalN], gu_]->Subscript[\[FormalCapitalN], gu],\[ScriptCapitalN][gu_]->\[FormalCapitalN][gu]};


FixVariables[variables_]:=variables/.{Subscript[\[ScriptCapitalN], gu_]->Subscript[\[FormalCapitalN], gu],\[ScriptCapitalN][gu_]->\[FormalCapitalN][gu]};


ExpRule::usage="Internal: make rule list var[t]\[Rule]E^log[var][t] for all logged vars.";


(*ExpRule[vars_List,logged_]:=DeleteCases[Table[If[logged===True&&comptype[var]==="Extensive",var[t]\[Rule]E^log[var][t]],{var,vars}],Null];*)
(*ExpRule[vars_List,logged_]:=DeleteNulls@Flatten@Table[If[logged===True&&comptype[var]==="Extensive",{var[t]\[Rule]E^log[var][t],(var\[Rule]Unk[var][t])\[Rule](var\[Rule]E^log[Unk[var]][t])}],{var,vars}];*)
ExpRule[vars_List,logged_]:=DeleteNulls@Flatten@Table[If[logged===True&&comptype[var]==="Extensive",{log[var]->log[var],var->E^log[var],(var->Unk[var])->(var->E^log[Unk[var]])}],{var,vars}];


AddUnkts::usage="Internal usage only ;)";
AddVariablets::usage="Internal usage only ;)";
AddTraitts::usage="Internal usage only ;)";
AddVarCovts::usage="Internal usage only ;)";
FixVarCovts::usage="Internal usage only ;)";
RemoveVariablets::usage="Internal usage only ;)";
RemoveTraitts::usage="Internal usage only ;)";
RemoveVarCovts::usage="Internal usage only ;)";


AddUnkts:=(var_->Unk[stuff___])->(var->Unk[stuff][t]);


AddVariablets:=Which[
	modeltype=="ContinuousTime",
	DeleteDuplicates[Flatten[Join[
		Table[Table[{
			Subscript[gcomp,\[FormalS]_]'->Subscript[gcomp,\[FormalS]]'[t],Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]][t],
			log[Subscript[gcomp,\[FormalS]_]]'->log[Subscript[gcomp,\[FormalS]]]'[t],log[Subscript[gcomp,\[FormalS]_]]->log[Subscript[gcomp,\[FormalS]]][t],
			Unk[Subscript[gcomp, \[FormalS]_]]'->Unk[Subscript[gcomp, \[FormalS]]]'[t],Unk[Subscript[gcomp, \[FormalS]_]]->Unk[Subscript[gcomp, \[FormalS]]][t]}
		,{gcomp,gcomps[gu]}],{gu,guilds}],
		Table[Table[{
			pcomp'->pcomp'[t],pcomp->pcomp[t],
			log[pcomp]'->log[pcomp]'[t],log[pcomp]->log[pcomp][t],
			Unk[pcomp]'->Unk[pcomp]'[t],Unk[pcomp]->Unk[pcomp][t]}
		,{pcomp,pcomps[pop]}],{pop,pops}],
		Table[{
			aux'->aux'[t],aux->aux[t],
			Unk[aux]'->Unk[aux]'[t],Unk[aux]->Unk[aux][t]}
		,{aux,auxs}]
	]]],
	modeltype=="DiscreteTime",
	DeleteDuplicates[Flatten[Join[
		Table[Table[{
			Subscript[gcomp,\[FormalS]_]'->Subscript[gcomp,\[FormalS]][t+1],Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]][t],
			Unk[Subscript[gcomp, \[FormalS]_]]'->Unk[Subscript[gcomp, \[FormalS]]][t+1],Unk[Subscript[gcomp, \[FormalS]_]]->Unk[Subscript[gcomp, \[FormalS]]][t]}
		,{gcomp,gcomps[gu]}],{gu,guilds}],
		Table[Table[{
			pcomp'->pcomp[t+1],pcomp->pcomp[t],
			log[pcomp]'->log[pcomp][t+1],log[pcomp]->log[pcomp][t],
			Unk[pcomp]'->Unk[pcomp][t+1],Unk[pcomp]->Unk[pcomp][t]}
		,{pcomp,pcomps[pop]}],{pop,pops}],
		Table[{
			aux'->aux[t+1],aux->aux[t],
			Unk[aux]'->Unk[aux][t+1],Unk[aux]->Unk[aux][t]}
		,{aux,auxs}]
	]]]
];


AddTraitts:=Which[
	modeltype=="ContinuousTime",
	DeleteDuplicates[Flatten[
		Table[Table[{
			Unk[Subscript[gtrait, \[FormalS]_]]'->Unk[Subscript[gtrait, \[FormalS]]]'[t],Unk[Subscript[gtrait, \[FormalS]_]]->Unk[Subscript[gtrait, \[FormalS]]][t],
			Subscript[gtrait, \[FormalS]_]'->Subscript[gtrait, \[FormalS]]'[t],Subscript[gtrait, \[FormalS]_]->Subscript[gtrait, \[FormalS]][t],
			Table[{Subscript[gtrait[gcomp], \[FormalS]_]'->Subscript[gtrait[gcomp], \[FormalS]]'[t],Subscript[gtrait[gcomp], \[FormalS]_]->Subscript[gtrait[gcomp], \[FormalS]][t]},{gcomp,gcomps[gu]}]}
	,{gtrait,gtraits[gu]}],{gu,guilds}]]],
	modeltype=="DiscreteTime",
	DeleteDuplicates[Flatten[
	Table[Table[{
		Unk[Subscript[gtrait, \[FormalS]_]]'->Unk[Subscript[gtrait, \[FormalS]]][t+1],Unk[Subscript[gtrait, \[FormalS]_]]->Unk[Subscript[gtrait, \[FormalS]]][t],
		Subscript[gtrait, \[FormalS]_]'->Subscript[gtrait, \[FormalS]][t+1],Subscript[gtrait, \[FormalS]_]->Subscript[gtrait, \[FormalS]][t],
		Table[{Subscript[gtrait[gcomp], \[FormalS]_]'->Subscript[gtrait[gcomp], \[FormalS]][t+1],Subscript[gtrait[gcomp], \[FormalS]_]->Subscript[gtrait[gcomp], \[FormalS]][t]},{gcomp,gcomps[gu]}]}
	,{gtrait,gtraits[gu]}],{gu,guilds}]]]
];


AddVarCovts:=Flatten[
	Table[Table[{
		Table[{
			{Subscript[Var[gtrait][gcomp],\[FormalS]_]'->Subscript[Var[gtrait][gcomp],\[FormalS]]'[t],Subscript[Var[gtrait][gcomp],\[FormalS]_]->Subscript[Var[gtrait][gcomp],\[FormalS]][t]},
			Table[
				{Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]'->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]]'[t],
				Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]][t]}
			,{gtrait\[Prime],gtraits[gu]}]
			}
		,{gcomp,gcomps[gu]}],
		{Subscript[Var[gtrait],\[FormalS]_]'->Subscript[Var[gtrait],\[FormalS]]'[t],Subscript[Var[gtrait],\[FormalS]_]->Subscript[Var[gtrait],\[FormalS]][t]},
		Table[
			{Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]'->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]]'[t],
			Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]][t]}
		,{gtrait\[Prime],gtraits[gu]}]
		}
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]


FixVarCovts:={Var[Subscript[\[FormalT]_,\[FormalS]_][t]]->Var[Subscript[\[FormalT],\[FormalS]]][t],Cov[Subscript[\[FormalT]_,\[FormalS]_][t],Subscript[\[FormalCapitalT]_,\[FormalS]_][t]]->Cov[Subscript[\[FormalT],\[FormalS]],Subscript[\[FormalCapitalT],\[FormalS]]][t]};


RemoveVariablets:=DeleteDuplicates[Flatten[Join[
	Table[Table[
		Subscript[gcomp,\[FormalS]_][t]->Subscript[gcomp,\[FormalS]]
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp[t]->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux[t]->aux,{aux,auxs}]
]]];


RemoveTraitts:=Flatten[Table[Table[{
	Subscript[gtrait,\[FormalS]_][t]->Subscript[gtrait,\[FormalS]],
	Table[Subscript[gtrait[gcomp],\[FormalS]_][t]->Subscript[gtrait[gcomp],\[FormalS]],{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{gu,guilds}]];


(* ::Code::Initialization:: *)
RemoveVarCovts:=Flatten[Table[Table[{
	Subscript[Var[gtrait],\[FormalS]_][t]->Subscript[Var[gtrait],\[FormalS]],
	Table[Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}],
	Table[{
		Subscript[Var[gtrait][gcomp],\[FormalS]_][t]->Subscript[Var[gtrait][gcomp],\[FormalS]],
		Table[Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}]}
	,{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{gu,guilds}]];


DefaultICs::usage="Internal usage only ;)";


DefaultICs:=Quiet[Flatten[{
	Table[Table[Table[Subscript[gcomp,sp]->Min[(Min[range[gcomp]]+Max[range[gcomp]])/2,Min[range[gcomp]]+1],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->Min[(Min[range[pcomp]]+Max[range[pcomp]])/2,Min[range[pcomp]]+1],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Min[(Min[range[aux]]+Max[range[aux]])/2,Min[range[aux]]+1],{aux,auxs}]
}]/.Indeterminate->0,{Infinity::indet}];


SetAttributes[DoubleRightArrow,HoldAllComplete];


InterpretTransitions::usage="";


InterpretTransitions[DoubleRightArrow[Times[c1_,var1_],Times[c2_,var2_]]]:={c1,var1,c2,var2};
InterpretTransitions[DoubleRightArrow[var1_,Times[c2_,var2_]]]:={1,var1,c2,var2};
InterpretTransitions[DoubleRightArrow[Times[c1_,var1_],var2_]]:={c1,var1,1,var2};
InterpretTransitions[DoubleRightArrow[var1_,var2_]]:={1,var1,1,var2};

InterpretTransitions[Rule[var_,Plus[c_,var_]]]:={0,Global`\[EmptySet],c,var};


DoubleRightArrowsToTrans:={
DoubleRightArrow[Times[c1_,var1_],Times[c2_,var2_]]->{var1->var1-c1,var2->var2+c2},
DoubleRightArrow[var1_,Times[c2_,var2_]]->{var1->var1-1,var2->var2+c2},
DoubleRightArrow[Times[c1_,var1_],var2_]->{var1->var1-c1,var2->var2+1},
DoubleRightArrow[var1_,var2_]->{var1->var1-1,var2->var2+1}
}


AddProceduralToSum::usage="Add Method->\"Procedural\" to Sum[\!\(\*
StyleBox[\"stuff\", \"TI\"]\), {\!\(\*
StyleBox[\"ind\", \"TI\"]\), \[ScriptCapitalN][\!\(\*
StyleBox[\"gu\", \"TI\"]\)]}]'s.";


AddProceduralToSum[expr_]:=
Inactivate[expr,Sum]/.Inactive[Sum][stuff___,{ind_,\[ScriptCapitalN][gu_]},sumopts___]:>Sum[stuff,{ind,\[ScriptCapitalN][gu]},Method->"Procedural",sumopts]


ZeroGs::usage = "ZeroGs is a replacement rule to remove G-matrix entries (Var and Cov).";


ZeroGs:={Subscript[Var[_], _]->0,Subscript[Var[_][_], _]->0,Subscript[Cov[_,_], _]->0,Subscript[Cov[_][_,_], _]->0};


TrackEq::usage=
"TrackEq[\!\(\*
StyleBox[\"eqns\", \"TI\"]\), \!\(\*
StyleBox[\"ics\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"initpar\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] tracks an equilibrium of \!\(\*
StyleBox[\"eqns\", \"TI\"]\), varying \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\), starting at \!\(\*
StyleBox[\"initpar\", \"TI\"]\).";


TrackEq[eqnsin_List,initvars_?RuleListQ,{par:(_Symbol|_Subscript),initpar_?NumericQ,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=Module[{
(* options *)
method,findrootopts,ndsolveopts,wheneventopts,smin,smax,teststability,monitor,
(* other variables *)
sval,parname,rhs,j,maxev,evs,whenevents,unks,subrule,breaks,isol,ics,deqns,sol,s1,s2,res,respart,pts},

Block[{func="TrackEq"},

(* handle options *)
method=Evaluate[Method/.Flatten[{opts,Options[TrackEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[TrackEq]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[TrackEq]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[TrackEq]}]];
smin=Evaluate[SMin/.Flatten[{opts,Options[TrackEq]}]];
smax=Evaluate[SMax/.Flatten[{opts,Options[TrackEq]}]];
Which[
	initpar==parmin,smin=0,
	initpar==parmax,smax=0
];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[TrackEq]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[TrackEq]}]];

(*Print["eqnsin=",eqnsin];*)

parname=ToString[TraditionalForm@par];
rhs=eqnsin/.RHS;
(*Print["rhs=",rhs];*)
unks=eqnsin[[All,1]]/.Derivative[1][var_]->var;
(*Print["unks=",unks];*)
If[modeltype=="DiscreteTime",rhs=rhs-unks];
(*Print["rhs=",rhs];*)

(* jacobian matrix *)
j=D[rhs,{unks}];
(*Print["j=",j];*)

(*maxev[parval_?NumericQ,state_]:=(Print[parval," ",state];Max[Re[evs=Eigenvalues[j/.Thread[unks->state]/.par->parval]]]);*)
Which[
	modeltype=="ContinuousTime",
	maxev[parval_?NumericQ,state_]:=Max[Re[evs=Eigenvalues[j/.Thread[unks->state]/.par->parval]]],
	modeltype=="DiscreteTime",
	maxev[parval_?NumericQ,state_]:=Max[Abs[evs=Eigenvalues[j/.Thread[unks->state]/.par->parval]]]-1
];

(* use FindRoot to improve initial guess *)
(*isol=FindRoot[rhs/.par->initpar,initvars/.{(var_->val_)->{var,val}},Evaluate[Sequence@@findrootopts]];*)
CreateBlock[{par},{initpar},isol=FindRoot[rhs,initvars/.{(var_->val_)->{var,val}},Evaluate[Sequence@@findrootopts]]];
VPrint[3,"isol=",isol];
(*Print["isol=",isol];*)

whenevents={};

Which[
	method=="Direct",
	subrule=Table[unk->unk[par],{unk,unks}];
	ics=Table[unk[initpar]==(unk/.isol),{unk,unks}];
	(*Print["ics=",ics];*)
	deqns=Map[#==0&,D[rhs/.subrule,par]];
	(*Print["deqns=",deqns];*)
	If[teststability,
		AppendTo[whenevents,
			WhenEvent[event,action]/.{
				event->maxev[par,Table[unk[par],{unk,unks}]]==0,
				action:>(Message[TrackEq::chst,parname,par,Chop@evs];AppendTo[breaks,par])
			}]
	];
	(*Print["whenevents="];Print[whenevents];*)
	breaks={}; (* capture bifurcation points *)
	(* track root with NDSolve *)
	sol=NDSolve[Join[deqns,ics,whenevents],unks,{par,parmin,parmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	(*Return[sol]*)
	(* beginning and ending par *)
	(*{par1,par2}=(unks[[1]]/.sol)["Domain"]\[LeftDoubleBracket]1\[RightDoubleBracket];*)
	(* add endpoints to breaks *)
	breaks=Sort[Join[N[{parmin,parmax}],breaks]];
	breaks=DeleteDuplicates[breaks,NEqual[#1,#2,SameThreshold->10^-6(parmax-parmin)]&];
	(*Print["breaks=",breaks];*)
	(* construct interpolatingfunctions (unk vs par) for each segment (between breaks) *)
	res={};
	Do[
		respart={};
		Do[
			pts=DeleteDuplicatesBy[Chop@Join[
				{{breaks[[i]],unk[breaks[[i]]]}/.sol},
				Transpose[{(unk/.sol)["Coordinates"][[1]],(unk/.sol)["ValuesOnGrid"]}],
				{{breaks[[i+1]],unk[breaks[[i+1]]]}/.sol}
			],First];
			AppendTo[respart,unk->Interpolation[Select[pts,breaks[[i]]<=#[[1]]<=breaks[[i+1]]&],"ExtrapolationHandler"->{Indeterminate&,"WarningMessage"->False}][par]];
		,{unk,unks}];
		AppendTo[res,respart];
	,{i,Length[breaks]-1}];
	Return[Join[res]]
,
	method=="PseudoArcLength",
	If[monitor,AppendTo[ndsolveopts,EvaluationMonitor:>{sval=s}];PrintTemporary["s=",Dynamic[sval]]];
	subrule=Append[Table[unk->unk[s],{unk,unks}],par->par[s]];
	ics=Join[
		Table[unk[0]==(unk/.isol),{unk,unks}],
		{par[0]==initpar}
	];
	(*Print["ics=",ics];*)
	whenevents=Join[whenevents,{
		WhenEvent[par[s]==parmin,"StopIntegration"],
		WhenEvent[par[s]==parmax,"StopIntegration"],
		WhenEvent[par'[s]==0,AppendTo[breaks,s]]
	}];
	If[teststability,
		AppendTo[whenevents,
			WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.
				{event->maxev[par[s],Table[unk[s],{unk,unks}]]==0,
				action:>(Message[TrackEq::chst,parname,par[s],Chop@evs];AppendTo[breaks,s])
			}]
	];
	(*Print["rhs=",rhs];
	Print["subrule=",subrule];*)
	deqns=Join[
		Map[#==0&,rhs/.subrule],
		{Total[D[unks/.subrule,s]]^2+D[par[s],s]^2==1},
		{par'[0]==1}
	];
(*Print["deqns="];Print[deqns];*)
	(* track root with NDSolve *)
	breaks={}; (* capture bifurcation points *)
(*Print["ndsolveopts=",ndsolveopts];*)
	sol=NDSolve[Join[deqns,ics,whenevents],Join[unks,{par}],{s,smin,smax},Evaluate[Sequence@@ndsolveopts]][[1]];
	(* beginning and ending s *)
	{s1,s2}=(par/.sol)["Domain"][[1]];
	(* add endpoints to breaks *)
	breaks=Sort[Join[{s1,s2},breaks]];
	(*Print["par[breaks]=",par/@breaks/.sol];*)
	breaks=DeleteDuplicates[breaks,NEqual[par[#1]/.sol,par[#2]/.sol,SameThreshold->10^-4(parmax-parmin)]&];
	(* construct interpolatingfunctions (unk vs par) for each segment (between breaks) *)
	res={};
	Do[
		respart={};
		Do[
			pts=DeleteDuplicatesBy[Chop@Join[
				{{breaks[[i]],par[breaks[[i]]],unk[breaks[[i]]]}/.sol},
				Transpose[{(par/.sol)["Coordinates"][[1]],(par/.sol)["ValuesOnGrid"],(unk/.sol)["ValuesOnGrid"]}],
				{{breaks[[i+1]],par[breaks[[i+1]]],unk[breaks[[i+1]]]}/.sol}
			],First];
			AppendTo[respart,unk->Interpolation[Select[pts,breaks[[i]]<=#[[1]]<=breaks[[i+1]]&][[All,2;;3]],"ExtrapolationHandler"->{Indeterminate&,"WarningMessage"->False}][par]];
		,{unk,unks}];
		AppendTo[res,respart];
	,{i,Length[breaks]-1}];
	Return[Join[res]]
	,
	Else,
	Message[TrackRoot::badmtd];Return[$Failed]
];

]]


TrackEq::chst="Stability change at `1`=`2`, eigenvalues=`3`.";


(* no initpar - assume initpar=parmin *)
TrackEq[in___,{par:(_Symbol|_Subscript),parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=TrackEq[in,{par,parmin,parmin,parmax},opts,SMin->0];


Options[TrackEq]={
FindRootOpts->{},NDSolveOpts->{AccuracyGoal->4},Method->"PseudoArcLength",SMin->-100,SMax->100,
TestStability->True,WhenEventOpts->{},Monitor->True};


SetModel::usage=
"SetModel[\!\(\*
StyleBox[\"model\", \"TI\"]\)] sets an EcoEvo \!\(\*
StyleBox[\"model\", \"TI\"]\) for analysis.";


SetModel[model_?RuleListQ,opts___?OptionQ]:=Module[{
(* options *)
colors,linestyles,plotmarkers,assumptions,parametersin,momentmethod,gaussianintegralopts,
(* other *)
parameterstmp,parintervals,stylecount,basestyle,indexcount,in,gradients,gradient,
sourcec,source,destc,dest,protectedfuncs,
(* funcs *)
FixEqn,FixGuildEqn,AddBars,RemoveBars},

Block[{verbosity,func="SetModel"},

(* set verbosity *)

If[Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]]===True,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

colors=Evaluate[Colors/.Flatten[{opts,Options[SetModel]}]];
linestyles=Evaluate[LineStyles/.Flatten[{opts,Options[SetModel]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[SetModel]}]];
momentmethod=Evaluate[MomentMethod/.Flatten[{opts,Options[SetModel]}]];
assumptions=Evaluate[Assumptions/.Flatten[{model,Options[SetModel]}]];
gaussianintegralopts=Evaluate[GaussianIntegralOpts/.Flatten[{opts,Options[SetModel]}]];


FixEqn[f_]:=Module[{agent,gifs},
f/.Sum[fs_,{i_,\[ScriptCapitalN][gu\[Prime]_]},sumopts___]:>(
If[ngcomps[gu\[Prime]]==1,
	agent=comps[gu\[Prime]][[1]],
	agent=Cases[fs,Subscript[_[_], i],All][[1,1,1]];
];
VPrint[3,"agent=",agent];
gifs=momentmethod[fs,{MakeTraitVector[Subscript[agent, i]],MakeTraitVector[Subscript[agent, i]]/.AddBars,MakeGMatrix[Subscript[agent, i]]},Evaluate[Sequence@@gaussianintegralopts]];
VPrint[3,"gifs=",gifs];
Sum[FullSimplify[gifs/.RemoveBars],{i,\[ScriptCapitalN][gu\[Prime]]},sumopts]
)];

FixGuildEqn[f_,traits_,G_]:=Module[{tmp,tmp2},
VPrint[3,"f=",f];
tmp=Distribute[gi[f/.UnfactorSums,{traits,traits/.AddBars,G}]];
VPrint[3,"tmp=",tmp];
tmp2=tmp/.gi[Sum[fs_,{i_,\[ScriptCapitalN][gu\[Prime]_]},sumopts___],giopts___]:>
Sum[gi[fs,{MakeTraitVector[Subscript[gu\[Prime], i]],MakeTraitVector[Subscript[gu\[Prime], i]]/.AddBars,MakeGMatrix[Subscript[gu\[Prime], i]]},giopts],{i,\[ScriptCapitalN][gu\[Prime]]},sumopts];
VPrint[3,"tmp2=",tmp2];
FullSimplify[tmp2/.gi->momentmethod/.RemoveBars]
];

AddBars:=Subscript[var_, sp_]->Subscript[mean[var], sp];
RemoveBars:=Subscript[mean[var_], sp_]->Subscript[var, sp];

protectedfuncs={"Color","LineStyle","PlotMarker"};
Unprotect[Evaluate[protectedfuncs]];

ClearParameters;UnsetModel;

modelloaded=True;

If[momentmethod===None||momentmethod==="None",moments=False,moments=True];

(* model name - default="UnnamedModel"*)
modelname=ModelName/.Append[model,ModelName->"UnnamedModel"];

(* model type - default="ContinuousTime" *)
modeltype=(ModelType/.Append[model,ModelType->"ContinuousTime"]);
If[!MemberQ[{"ContinuousTime","DiscreteTime"},modeltype],Message[SetModel::unktype]];

(* model whenevents - default={} *)
modelwhenevents:=WhenEvents/.Append[model,WhenEvents->{}];

(* period - default=0 (unforced) *)
modelperiod:=Period/.Append[model,Period->0];

(* transition-based? *)
transitions=Transitions/.model;
If[transitions=!=Transitions,transitionbased=True,transitionbased=False];


(* Transitions *) (* placeholder for later *)

If[transitionbased,
	VPrint[3,"Processing Transitions..."];
];


(* Parameters *)

VPrint[2,"Processing Parameters..."];
parametersin=Evaluate[Parameters/.Flatten[{model,Options[SetModel]}]];
(*Print["parametersin=",parametersin];*)
If[parametersin=!={},
	{parameters,parintervals}=Transpose[InequalityToInterval[parametersin]/.Element->List]
];
(*Print["parameters=",parameters];
Print["parintervals=",parintervals];*)

(* parameter assumptions *)
$Assumptions=Select[parametersin,MemberQ[{Greater,GreaterEqual,Less,LessEqual},Head[#]]&];
parnames=ToString/@parameters;
Do[range[parameters[[i]]]=parintervals[[i]],{i,Length[parameters]}];
VPrint[2,"paramaters=",parameters];

indexcount=0;

(* Guilds *)

VPrint[2,"Processing Guilds..."];

stylecount=0;

If[(Guilds/.model)===Guilds,
	guilds=Select[model,#[[1,0]]==Guild&][[All,1,1]],
	guilds=Guilds/.model
];
VPrint[3,"guilds=",guilds];
nguilds=Length[guilds];

Do[
	VPrint[3,"Guild[",gu,"]=",Guild[gu]/.model];
	type[gu]="guild";
	LookUp[gu]={"guild",gu};
	LookUp[Subscript[gu,sp_]]=LookUp[_[Subscript[gu,sp_]]]={"guild",gu,sp};
	If[!transitionbased,
		(*Print["old comps"];*)
		comps[gu]=gcomps[gu]=Select[Guild[gu]/.model,#[[1,0]]==Component&][[All,1,1]]
	,
		(*Print["new comps"];*)
		comps[gu]=gcomps[gu]=Components/.(Guild[gu]/.model)
	];
	If[Length[gcomps[gu]]==0,comps[gu]=gcomps[gu]={Guild[gu][[1]]}];
	VPrint[3,"comps[",gu,"]=",comps[gu]];
	comps[Subscript[gu_,sp_]]:=Replace[comps[gu],var_->Subscript[var,sp],1];
	ncomps[gu]=ngcomps[gu]=Length[gcomps[gu]];
	
	If[(Traits/.(Guild[gu]/.model))===Traits,
		(*Print["old traits"];*)
		gtraits[gu]=Select[Guild[gu]/.model,#[[1,0]]==Trait&][[All,1,1]],
		(*Print["new traits"];*)
		gtraits[gu]=Cases[(Traits/.(Guild[gu]/.model)),_Symbol,\[Infinity]];
		(*Print["gtraits[gu]=",gtraits[gu]];*)
		ranges=(InequalityToInterval/@(Traits/.(Guild[gu]/.model)))[[All,2]];
		(*Print["ranges=",ranges];*)
		Do[
			range[gtraits[gu][[i]]]=ranges[[i]];
			range[Subscript[gtraits[gu][[i]],_]]=ranges[[i]];
		,{i,Length[gtraits[gu]]}];
	];
	ngtraits[gu]=Length[gtraits[gu]];
	VPrint[3,"{gcomps[",gu,"], gtraits[",gu,"]}=",{gcomps[gu],gtraits[gu]}];

	If[nguilds==1(*&&ngcomps[guilds\[LeftDoubleBracket]1\[RightDoubleBracket]]\[Equal]1&&ngtraits[guilds\[LeftDoubleBracket]1\[RightDoubleBracket]]\[Equal]1*),
		gradients={"Rainbow","DarkerRainbow","LighterRainbow"},
		gradients={"EEGreens","EEReds","EEBlues"}
	];
	Do[
		VPrint[3,"gcomp=",gcomp];
		indexcount++;stylecount++;
		basestyle[gu]=stylecount;
		in=If[RuleListQ[Component[gcomp]/.(Guild[gu]/.model)],Component[gcomp]/.(Guild[gu]/.model),Guild[gu]/.model];
		type[Subscript[gcomp,_]]="gcomp";
		index[Subscript[gcomp,_]]=index[gcomp]=indexcount;
		comptype[Subscript[gcomp,_]]=comptype[gcomp]=Type/.Append[in,Type->"Extensive"];
		range[Subscript[gcomp,_]]=range[gcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		gradient=Color/.Append[in,Color->ModPart[gradients,stylecount]];
		Color[Subscript[gcomp,_]]=Color[_[Subscript[gcomp,_]]]=With[{cd=ColorData[gradient]},cd[#]&];
		Color[gcomp]=Color[_[gcomp]]=With[{cd=ColorData[gradient]},cd[0.5]];
		LineStyle[Subscript[gcomp,_]]=LineStyle[gcomp]=LineStyle[_[gcomp]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		PlotMarker[Subscript[gcomp,_]]=PlotMarker[gcomp]=PlotMarker[_[gcomp]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[gcomp]=LookUp[_[gcomp]]=LookUp[gcomp[_]]={"gcomp",gu,gcomp};
		LookUp[Subscript[gcomp,sp_]]=LookUp[_[Subscript[gcomp,sp_]]]=LookUp[Subscript[gcomp,sp_][_]]={"gcomp",gu,gcomp,sp};
	,{gcomp,gcomps[gu]}];
	
	Color[gu]=Color[_[gu]]=With[{cd=ColorData[gradient]},cd[0.5]];

,{gu,guilds}];

Do[
	Do[
		VPrint[3,"gtrait=",gtrait];
		indexcount++;
		stylecount=basestyle[gu];
		If[(Traits/.(Guild[gu]/.model))===Traits,
			in=Trait[gtrait]/.(Guild[gu]/.model),
			in={}
		];
		type[Subscript[gtrait,_]]="gtrait";
		index[Subscript[gtrait,_]]=index[gtrait]=indexcount;
		If[(Traits/.(Guild[gu]/.model))===Traits,
			range[Subscript[gtrait,_]]=range[gtrait]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]]
		];
		gradient=Color/.Join[in,Guild[gu]/.model,{Color->ModPart[gradients,stylecount]}];
		Color[Subscript[gtrait,_]]=Color[_[Subscript[gtrait,_]]]=With[{cd=ColorData[gradient]},cd[#]&];
		(*Color[Subscript[gtrait[gcomp_],sp_]]=Color[Subscript[_[gtrait][gcomp_],sp_]]=Color[Subscript[gcomp, sp]];*)
		Color[gtrait]=Color[_[gtrait]]=With[{cd=ColorData[gradient]},cd[0.5]];
		LineStyle[Subscript[gtrait,_]]=LineStyle[gtrait]=LineStyle[_[gtrait]]=LineStyle/.Join[in,Guild[gu]/.model,{LineStyle->ModPart[linestyles,stylecount]}];
		PlotMarker[Subscript[gtrait,_]]=PlotMarker[gtrait]=PlotMarker/.Join[in,Guild[gu]/.model,{PlotMarker->ModPart[plotmarkers,stylecount]}];
		LookUp[gtrait]=LookUp[_[gtrait]]={"gtrait",gu,gtrait};
		LookUp[Subscript[gtrait,sp_]]=LookUp[_[Subscript[gtrait,sp_]]]={"gtrait",gu,gtrait,sp};
		Do[
			Color[Subscript[gtrait[gcomp],sp_]]=Color[Subscript[_[gtrait][gcomp],sp_]]=Color[Subscript[gcomp, sp]];
			LookUp[Subscript[gtrait[gcomp],sp_]]=LookUp[_[Subscript[gtrait[gcomp],sp_]]]={"gtrait",gu,gtrait[gcomp],sp};
			LookUp[Subscript[Var[gtrait][gcomp],sp_]]=LookUp[_[Subscript[Var[gtrait][gcomp],sp_]]]={"var",gu,gtrait[gcomp],sp};
		,{gcomp,gcomps[gu]}];
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];

(* Pops *)

VPrint[2,"Processing Pops..."];
pops=Select[model,#[[1,0]]==Pop&][[All,1,1]];
VPrint[3,"pops=",pops];
npops=Length[pops];

Do[
	in=Pop[pop]/.model;
	type[pop]="pop";
	LookUp[pop]={"pop",pop};
	comps[pop]=pcomps[pop]=Select[in,#[[1,0]]==Component&][[All,1,1]];
	If[pcomps[pop]=={},comps[pop]=pcomps[pop]={pop}];
	VPrint[3,"pcomps["<>ToString@pop<>"]=",pcomps[pop]];
	ncomps[pop]=npcomps[pop]=Length[pcomps[pop]];
	Do[
		in=If[RuleListQ[Component[pcomp]/.(Pop[pop]/.model)],Component[pcomp]/.(Pop[pop]/.model),Pop[pop]/.model];
		raweqn=Equation/.If[RuleListQ[Component[pcomp]/.in],Component[pcomp]/.in,in];
		VPrint[3,"raweqn=",raweqn];
		If[!moments,
			Unprotect[Equation];Equation[pcomp]:=Evaluate[raweqn];Protect[Equation]
		,
			f=AddProceduralToSum[raweqn];
			VPrint[3,"f=",f];
			f\[Prime]=FixEqn[f];
			VPrint[3,"f\[Prime]=",f\[Prime]];
			dndtnaive[pcomp]=f;
			dndt[pcomp]=f\[Prime];
			Unprotect[Equation];Equation[pcomp]=f\[Prime];Protect[Equation];
		];
		indexcount++;stylecount++;
		type[pcomp]="pcomp";
		index[pcomp]=indexcount;
		comptype[pcomp]=Type/.Append[in,Type->"Extensive"];
		range[pcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		Color[pcomp]=Color[_[pcomp]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
		LineStyle[pcomp]=LineStyle[_[pcomp]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		PlotMarker[pcomp]=PlotMarker[_[pcomp]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[pcomp]=LookUp[_[pcomp]]=LookUp[pcomp[_]]={"pcomp",pop,pcomp};
	,{pcomp,pcomps[pop]}];
,{pop,pops}];

(* Auxs *)

VPrint[2,"Processing Auxs..."];

auxs=Select[model,#[[1,0]]==Aux&][[All,1,1]];
VPrint[3,"auxs=",auxs];
nauxs=Length[auxs];

If[nauxs!=0,
	Do[
		raweqn=Equation/.(Aux[aux]/.model);
		VPrint[3,"raweqn=",raweqn];
		If[!moments,
			Unprotect[Equation];Equation[aux]:=Evaluate[raweqn];Protect[Equation]
		,
			f=AddProceduralToSum[raweqn];
			VPrint[3,"f=",f];
			f\[Prime]=FixEqn[f];
			VPrint[3,"f\[Prime]=",f\[Prime]];
			dndtnaive[aux]=f;
			dndt[aux]=f\[Prime];
			Unprotect[Equation];Equation[aux]=f\[Prime];Protect[Equation];
		];	
		indexcount++;stylecount++;
		type[aux]="aux";
		index[aux]=indexcount;
		in=Aux[aux]/.model;
		range[aux]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
		Color[aux]=Color[_[aux]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
		LineStyle[aux]=LineStyle[_[aux]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		PlotMarker[aux]=PlotMarker[_[aux]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[aux]=LookUp[_[aux]]=LookUp[aux[_]]={"aux",aux};
	,{aux,auxs}];
];

(* build moment eqns *)

VPrint[2,"Setting Guild Equations..."];

Do[Do[
	VPrint[3,"gcomp=",gcomp];
	raweqn=Evaluate[Equation/.If[RuleListQ[Component[gcomp]/.(Guild[gu]/.model)],Component[gcomp]/.(Guild[gu]/.model),Guild[gu]/.model]];
	If[!moments,
		Unprotect[Equation];Equation[Subscript[gcomp, i_]]:=Evaluate[raweqn/.\[FormalI]->i/.Mutated[rate_,M_]:>rate];Protect[Equation]
		,
		VPrint[3,"raweqn=",raweqn];
		desttraits=MakeTraitVector[Subscript[gcomp, \[FormalI]]];
		VPrint[3,"desttraits=",desttraits];
		destG=MakeGMatrix[Subscript[gcomp, \[FormalI]]];
		VPrint[3,"destG=",destG];
		Thread[{dndtnaive[gcomp],dxdtnaive[gcomp],dGdtnaive[gcomp],dndt[gcomp],dxdt[gcomp],dGdt[gcomp]}=Sum[
			VPrint[3,"adding contributions from ",source];
			sourcetraits=MakeTraitVector[Subscript[source, \[FormalI]]];
			VPrint[3,"sourcetraits=",sourcetraits];
			(*sourceG=MakeGMatrix[Subscript[gcomp, \[FormalI]]];*)
			sourceG=MakeGMatrix[Subscript[source, \[FormalI]]];
			VPrint[3,"sourceG=",sourceG];
			f=AddProceduralToSum[Coefficient[(raweqn/.Mutated[Subscript[source, \[FormalI]] stuff___,M_]:>Subscript[source, \[FormalI]] Mutated[stuff,M]),Subscript[source, \[FormalI]],1]];
			VPrint[3,"f=",f];
			mut=Total[Cases[f,Mutated[_,_:Except[_List]]]/.Mutated[rate_,var_]->rate*{{var}}]+
				Total[Cases[f,Mutated[_,_List]]/.Mutated[rate_,var_]->rate*var];
			VPrint[3,"mut=",mut];
			mut\[Prime]=FixGuildEqn[mut,desttraits,destG];
			VPrint[3,"mut\[Prime]=",mut\[Prime]];
			f=f/.Mutated[rate_,_]->rate; (* remove Mutated *)
			f\[Prime]=FixGuildEqn[f,desttraits,destG];
			VPrint[3,"f\[Prime]=",f\[Prime]];
			df=Simplify@D[f,{sourcetraits,1}];
			VPrint[3,"df=",df];
			d2f=Simplify@HessianMatrix[f,sourcetraits];
			VPrint[3,"d2f=",d2f];
			df\[Prime]=Simplify@D[f\[Prime],{sourcetraits,1}];
			VPrint[3,"df\[Prime]=",df\[Prime]];
			d2f\[Prime]=Simplify@HessianMatrix[f\[Prime],sourcetraits];
			VPrint[3,"d2f\[Prime]=",d2f\[Prime]];
			{Subscript[source, \[FormalI]]f,
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]]*(f(sourcetraits-desttraits)+sourceG . df),
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]](mut+f(sourceG-destG+(sourcetraits-desttraits)^2)+sourceG . d2f . sourceG
				+df*sourceG . Transpose[sourcetraits-desttraits]+(sourcetraits-desttraits) . Transpose[sourceG . df]),
			Subscript[source, \[FormalI]]f\[Prime],
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]]*(f\[Prime](sourcetraits-desttraits)+sourceG . df\[Prime]),
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]](mut\[Prime]+f\[Prime](sourceG-destG+(sourcetraits-desttraits)^2)+sourceG . d2f\[Prime] . sourceG
				+df\[Prime]*sourceG . Transpose[sourcetraits-desttraits]+(sourcetraits-desttraits) . Transpose[sourceG . df\[Prime]])
			}
		,{source,gcomps[gu]}]];
		Unprotect[Equation];Equation[Subscript[gcomp, i_]]:=Evaluate[dndt[gcomp]/.\[FormalI]->i];Protect[Equation];
		VPrint[3,"Equation[",Subscript[gcomp, \[FormalI]],"]=",Equation[Subscript[gcomp, \[FormalI]]]];
		If[ngcomps[gu]==1,
			Do[
				dxdt[gtraits[gu][[i]]]=dxdt[gcomp][[i]];
				dxdtnaive[gtraits[gu][[i]]]=dxdtnaive[gcomp][[i]];
				dGdt[Var[gtraits[gu][[i]]]]=dGdt[gcomp][[i,i]];
				dGdtnaive[Var[gtraits[gu][[i]]]]=dGdtnaive[gcomp][[i,i]];
				Do[
					dGdt[Cov[gtraits[gu][[i]],gtraits[gu][[j]]]]=dGdt[gcomp][[i,j]];
					dGdtnaive[Cov[gtraits[gu][[i]],gtraits[gu][[j]]]]=dGdtnaive[gcomp][[i,j]];
				,{j,ngtraits[gu]}];
			,{i,ngtraits[gu]}];
		,
			Do[
				dxdt[gtraits[gu][[i]][gcomp]]=dxdt[gcomp][[i]];
				dxdtnaive[gtraits[gu][[i]][gcomp]]=dxdtnaive[gcomp][[i]];
				dGdt[Var[gtraits[gu][[i]]][gcomp]]=dGdt[gcomp][[i,i]];
				dGdtnaive[Var[gtraits[gu][[i]]][gcomp]]=dGdtnaive[gcomp][[i,i]];
				Do[
					dGdt[Cov[gtraits[gu][[i]],gtraits[gu][[j]]][gcomp]]=dGdt[gcomp][[i,j]];
					dGdtnaive[Cov[gtraits[gu][[i]],gtraits[gu][[j]]][gcomp]]=dGdtnaive[gcomp][[i,j]];
				,{j,ngtraits[gu]}];
			,{i,ngtraits[gu]}];
		];
	];
,{gcomp,gcomps[gu]}],{gu,guilds}];


(* Interactions *)

VPrint[2,"Processing Interactions..."];

interactions=Select[model,#[[1,0]]==Interaction&][[All,1,1]];
VPrint[3,"interactions=",interactions];
ninteractions=Length[interactions];

Do[interactionpos[gu]={},{gu,guilds}];

Do[
	VPrint[3,"interaction=",interaction];
	in=Interaction[interaction]/.model;
	type[Subscript[interaction,_]]=(*index[gtrait]=*)"interaction";
	index[Subscript[interaction,_]]=index[interaction]=indexcount;
	range[Subscript[interaction,_]]=range[interaction]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
	{guild1[interaction],guild2[interaction]}=Guilds/.in;
	AppendTo[interactionpos[guild1[interaction]],{interaction,1}];
	AppendTo[interactionpos[guild2[interaction]],{interaction,2}];
	LookUp[interaction]=LookUp[_[interaction]]={"interaction",guild1[interaction],guild2[interaction],interaction};
	LookUp[Subscript[interaction,sp1_,sp2_]]=LookUp[_[Subscript[interaction,sp1_,sp2_]]]=
		{"interaction",guild1[interaction],guild2[interaction],interaction,sp1,sp2};
,{interaction,interactions}];


(* model assumptions - default={} *)

VPrint[2,"Processing Assumptions..."];

$Assumptions=Flatten[assumptions/.Automatic->Join[
	Select[parametersin,MemberQ[{Greater,GreaterEqual,Less,LessEqual},Head[#]]&],
	(*Table[Region`SpecialRegionProperty[range[aux],{aux},"ImplicitDescription"],{aux,auxs}],*)
	Table[Table[Region`SpecialRegionProperty[range[pcomp],{pcomp},"ImplicitDescription"],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gcomp],{Subscript[gcomp,sp]},"ImplicitDescription"],{sp,0,2}],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gtrait],{Subscript[gtrait,sp]},"ImplicitDescription"],{sp,0,2}],{gtrait,gtraits[gu]}],{gu,guilds}]
]];
VPrint[2,"$Assumptions=",$Assumptions];

assumptionstrings=ToString/@$Assumptions;

(* get rid of this? *)
Which[
	modeltype=="ContinuousTime",
	DT[var_]:=var'(*[t]*)
,
	modeltype=="DiscreteTime",
	DT[var_]:=var'
];

Protect[Evaluate[protectedfuncs]];

]]


Options[SetModel]={
	LineStyles->{{}},PlotMarkers->Graphics`PlotMarkers[],
	Colors->ColorData[97,"ColorList"],
	Assumptions->{Automatic},
	Parameters->{},
	ApproximationOrder->3,
	GaussianIntegralOpts->{},
	MomentMethod->None
};


SetModel::unktype=
"Unknown ModelType (\"ContinuousTime\", \"DiscreteTime\" currently supported).";
SetModel::badpar=
"One or more Parameters already defined. Clear them before running SetModel.";
SetModel::badmut=
"Bad mutation kernel `1`.";


UnsetModel::usage=
"UnsetModel clears the currently set EcoEvo model.";


UnsetModel:=Module[{dvs},
	modelloaded=False;
	Quiet[Clear[LookUp,type,range,comptype,DT,
	modeltype,modelwhenevents,modelperiod,moments,
	pops,npops,npcomps,pcomps,pcompeqn,
	auxs,nauxs,auxeqn,
	guilds,nguilds,gcomps,ngcomps,gtraits,ngtraits,
	eqns,
	dndt,dxdt,dGdt,assumptionstrings,
	parameters],{Clear::wrsym}];
	dvs={Color,LineStyle,PlotMarker};
	Unprotect[dvs];
	Do[DownValues[func]={},{func,dvs}];
	Protect[dvs];
	$Assumptions={};
];


ModelInfo::usage=
"ModelInfo gives a summary of the currently loaded EcoEvo model.";


ModelInfo:=(

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[]];

(* model name *)
Print["modelname=",modelname];

(* model type *)
Print["modeltype=",modeltype,", modelperiod=",modelperiod];

(* aux vars *)
Print["auxs=",auxs," (nauxs=",nauxs,")"];
Do[
	Print["  ",FuncStyle[aux]];
	Print["  Equation[",aux,"]=",Equation[aux]];
	Print["  range[",aux,"]=",range[aux]];
,{aux,auxs}];

(* pops *)

Print["pops=",pops," (npops=",npops,")"];
Do[
	Print["  pcomps[",pop,"]=",pcomps[pop]," (npcomps[",pop,"]=",npcomps[pop],")"];
	Do[
		Print["    ",FuncStyle[pcomp]];
		Print["    Equation[",pcomp,"]=",Equation[pcomp]];
		Print["    comptype[",pcomp,"]=",comptype[pcomp]];
		Print["    range[",pcomp,"]=",range[pcomp]];
	,{pcomp,pcomps[pop]}];
,{pop,pops}];

(* guilds *)

Print["guilds=",guilds," (nguilds=",nguilds,")"];
Do[
	Print["  gcomps[",gu,"]=",gcomps[gu]," (ngcomps[",gu,"]=",ngcomps[gu],")"];
	Do[
		Print["    ",FuncStyle[gcomp]];
		Print["    Equation[",Subscript[gcomp,Global`i],"]=",Equation[Subscript[gcomp,Global`i]]];
		Print["    comptype[",gcomp,"]=",comptype[gcomp]];
		Print["    range[",gcomp,"]=",range[gcomp]];
	,{gcomp,gcomps[gu]}];
	Print["  gtraits[",gu,"]=",gtraits[gu]," (ngtraits[",gu,"]=",ngtraits[gu],")"];
	Do[
		Print["    ",FuncStyle[gtrait]];
		Print["    range[",gtrait,"]=",range[gtrait]];
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];

);


MatrixToPopComponents::usage=
"MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";

MatrixToGuildComponents::usage=
"MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";


MatrixToPopComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[(Sum[a[[c,c\[Prime]]]var[c\[Prime]],{c\[Prime],ncomps}])]},{c,ncomps}];
	On[Part::partd];
	Return[res]
];


MatrixToGuildComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[Sum[a[[c,c\[Prime]]]var[c\[Prime]],{c\[Prime],ncomps}]]/.{var[c_]->Subscript[var[c],\[FormalI]]}},{c,ncomps}];
	On[Part::partd];
	Return[res/.{(Equation:>eqn_)->(Equation:>(eqn))}]
];


WeightedAbundance::usage = 
"WeightedAbundance[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] totals components in all guilds and pops.";


WeightedAbundance[sol_?RuleListQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WeightedAbundance"],
(* options *)
weightfunction,minpop,
(* other variables *)
f,gu,sp
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WeightedAbundance]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[WeightedAbundance]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractAttributes[sol],ExtractVariables[sol]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Which[
	weightfunction==="Total",
	f[var_]:=Total[Select[comps[var],comptype[#]==="Extensive"&]],
	weightfunction==="Components",
	f[var_]:=Select[comps[var],comptype[#]==="Extensive"&],
	weightfunction==="PresenceAbsence",
	f[var_]:=If[Total[Select[comps[var],comptype[#]==="Extensive"&]]>minpop,1,0],
	Else,
	f[Subscript[gu_,sp_]]:=weightfunction/.(#->Subscript[#,sp]&/@comps[gu]);
	f[pop_]:=weightfunction;
];

Return[Flatten@Join[
	Table[Table[Subscript[gu, sp]->Reinterpolation[f[Subscript[gu, sp]]/.sol],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[pop->Reinterpolation[f[pop]/.sol],{pop,pops}],
	ExtractAuxs[sol],
	ExtractAttributes[sol]
]]
]];


Options[WeightedAbundance]={WeightFunction->"Total",MinPop->10^-10};


TotalAbundance::usage = 
"TotalAbundance[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the total abundance in guilds.";


TotalAbundance[solin_,opts___?OptionQ]:=
Module[{
func=FuncStyle["TotalAbundance"],
(* options *)
weightfunction,
(* other variables *)
sol,wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TotalAbundance]}]];

sol=ExtractVariables[solin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][{},sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];
Return[Table[gu->Reinterpolation[Sum[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]/.wa],{gu,guilds}]]

]];


Options[TotalAbundance]={WeightFunction->"Total"};


TraitMean::usage = 
"TraitMean[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the mean traits in guilds.";


TraitMean[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["TraitMean"],
(* options *)
weightfunction,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TraitMean]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];

Return[
	Flatten@Table[Table[
		gtrait->Reinterpolation[Moment[WeightedData[Table[Subscript[gtrait, i],{i,\[ScriptCapitalN][gu]}]/.traits,Chop[Table[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]]],1]/.wa]
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]

]];


Options[TraitMean]={
	WeightFunction->"Total"
};


(* split traitsandvariables *)
TraitMean[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
TraitMean[ExtractTraits[eesol],ExtractVariables[eesol],opts];


TraitVariance::usage = 
"TraitVariance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the variance of traits in guilds.";


TraitVariance[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["TraitVariance"],
(* options *)
weightfunction,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TraitVariance]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];

Return[
	Flatten@Table[Table[
		Var[gtrait]->Reinterpolation[CentralMoment[WeightedData[Table[Subscript[gtrait, i],{i,\[ScriptCapitalN][gu]}]/.traits,Chop[Table[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]/.wa]],2]]
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]

]];


Options[TraitVariance]={
	WeightFunction->"Total"
};


(* split traitsandvariables *)
TraitVariance[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
TraitVariance[ExtractTraits[eesol],ExtractVariables[eesol],opts];


TraitDistance::usage =
"TraitDistance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sp1\", \"TI\"]\), \!\(\*
StyleBox[\"sp2\", \"TI\"]\)] returns the trait distance between two species.
TraitDistance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"guild\", \"TI\"]\)] returns a trait distance matrix between all species in a guild (default=first).";


TraitDistance[traits_?RuleListQ,sp1_Subscript,sp2_Subscript,opts___?OptionQ]:=

Module[{
func=FuncStyle["TraitDistance (2sp)"],
(* options *)
rulelistdistanceopts
},

Block[{},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
rulelistdistanceopts=FilterRules[Flatten[{opts,Options[TraitDistance]}],Options[RuleListDistance]];

(*Print[DeleteSubscripts@ExtractTraits[traits,sp1]];
Print[DeleteSubscripts@ExtractTraits[traits,sp2]];
Print[Evaluate[Sequence@@rulelistdistanceopts]];*)

Return[Reinterpolation[RuleListDistance[DeleteSubscripts@ExtractTraits[traits,sp1],DeleteSubscripts@ExtractTraits[traits,sp2],
	Evaluate[Sequence@@rulelistdistanceopts]]]];

]];


TraitDistance[traits_?RuleListQ,gu:(_Symbol|_Integer):Automatic,opts___?OptionQ]:=

Module[{
func=FuncStyle["TraitDistance (guild)"]
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

If[gu==="Automatic",gu=guilds[[1]]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractTraits@traits,{}];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Return[Table[TraitDistance[traits,Subscript[gu, i],Subscript[gu, j],opts],{i,\[ScriptCapitalN][gu]},{j,\[ScriptCapitalN][gu]}]];

]];


Options[TraitDistance]={};


TraitDistance[traits_?RuleListQ,sp1_Subscript,sp1_Subscript,opts___?OptionQ]:=0;


FunctionalDistinctiveness::usage =
"FunctionalDistinctiveness[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] calculates the functional distinctiveness of \!\(\*
StyleBox[\"target\", \"TI\"]\).";


FunctionalDistinctiveness[traits_?TraitsQ,sol:(_?VariablesQ):{},target:(_Symbol|_Integer|_Subscript):Automatic,opts___?OptionQ]:=
Module[{
func=FuncStyle["FunctionalDistinctiveness"],
(* options *)
verbose,method,weightfunction,traitdistanceopts,normalizedistance,excludefocalspecies,
(* other variables *)
gu,sp,dists,distnorm,denom,abunds,totalabundance
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
If[sol==={},method="Species",method=Evaluate[Method/.Flatten[{opts,Options[FunctionalDistinctiveness]}]]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
traitdistanceopts=Evaluate[TraitDistanceOpts/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
normalizedistance=Evaluate[NormalizeDistance/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
excludefocalspecies=Evaluate[ExcludeFocalSpecies/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,{}];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Which[
	(* species target *)
	Head[target]===Subscript,
	gu=target[[1]];sp=target[[2]],
	(* automatic *)
	target===Automatic,
	gu=guilds[[1]];sp="All",
	(* guild target *)
	Head[target]===Integer||Head[target]==Symbol,
	gu=target;sp="All",
	Else,
	Message[FunctionalDistinctiveness::badtgt];
	Return[$Aborted];
];

dists=TraitDistance[traits,gu,Evaluate[Sequence@@traitdistanceopts]];
If[verbose,Print[func,": dists=",dists]];
distnorm=If[normalizedistance==True,Max[Flatten[dists]],1];
If[verbose,Print[func,": distnorm=",distnorm]];

Which[
	method==="Species",
	If[excludefocalspecies==True,denom=Subscript[\[ScriptCapitalN], gu]-1,denom=Subscript[\[ScriptCapitalN], gu]];
	If[sp==="All",
		Return[Table[FunctionalDistinctiveness[Subscript[gu, sp]]->Reinterpolation[Sum[dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)],{sp,Subscript[\[ScriptCapitalN], gu]}]],
		Return[Reinterpolation[Sum[dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]]
	],
	method==="AbundanceWeighted",
	abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];
	If[verbose,Print[func,": abunds=",abunds]];
	totalabundance=gu/.TotalAbundance[sol,WeightFunction->weightfunction];
	If[verbose,Print[func,": totalabundance=",totalabundance]];
	If[sp==="All",
		Return[Table[
			If[excludefocalspecies==True,denom=totalabundance-(Subscript[gu, sp]/.abunds),denom=totalabundance];
			FunctionalDistinctiveness[Subscript[gu, sp]]->Reinterpolation[Sum[(Subscript[gu, sp\[Prime]]/.abunds)*dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]
		,{sp,Subscript[\[ScriptCapitalN], gu]}]],
		If[excludefocalspecies==True,denom=totalabundance-(Subscript[gu, sp]/.abunds),denom=totalabundance];
		Return[Reinterpolation[Sum[(Subscript[gu, sp]/.abunds)*dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]]
	],
	Else,
	Message[FunctionalDistinctiveness::badmtd];Return[$Failed]
];

]]


Options[FunctionalDistinctiveness]={
	Verbose->False,
	Method->"Species",WeightFunction->"Total",TraitDistanceOpts->{},NormalizeDistance->True,ExcludeFocalSpecies->True
};


(* break up combned traitsandpops *)
FunctionalDistinctiveness[traitsandpops_?AttributesAndVariablesQ,target:(_Symbol|_Integer|_Subscript):Automatic,opts___?OptionQ]:=
FunctionalDistinctiveness[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],target,opts];


FunctionalDistinctiveness::badmtd="The Method option should be a built-in method name (\"Species\" or \"AbundanceWeighted\").";
FunctionalDistinctiveness::badtgt="The target should be a guild, a species, or Automatic.";


ExtinctSpecies::usage=
"ExtinctSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives a list of extinct species in \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


ExtinctSpecies[sol_?RuleListQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["ExtinctSpecies"],
(* options *)
verbose,weightfunction,time,minpop,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[ExtinctSpecies]}]];
If[Global`debug,verbose=True];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[ExtinctSpecies]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[ExtinctSpecies]}]];
time=Evaluate[Time/.Flatten[{opts,Options[ExtinctSpecies]}]];

wa=ExtractSpecies[WeightedAbundance[sol,WeightFunction->weightfunction]];
(*If[verbose,Print[func,": wa=",wa]];*)

If[time===t,
	Which[
		modelperiod==0,
		wa=FinalSlice[wa],
		modelperiod<\[Infinity],
		wa=TemporalMean[FinalSlice[wa,modelperiod]],
		Else,
		wa=TemporalMean[wa]
	]
,
	wa=Slice[wa,time]
];
If[verbose,Print[func,": WeightedAbundance=",wa]];

Return[Keys[Select[Association[wa],#<=minpop&]]]
]];


Options[ExtinctSpecies]={Verbose->False,MinPop->10^-10,WeightFunction->"Total",Time->t};


ExtantSpecies::usage=
"ExtantSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives a list of extant species in \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


ExtantSpecies[sol_?RuleListQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["ExtantSpecies"],
(* options *)
verbose,weightfunction,time,minpop,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[ExtantSpecies]}]];
If[Global`debug,verbose=True];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[ExtantSpecies]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[ExtantSpecies]}]];
time=Evaluate[Time/.Flatten[{opts,Options[ExtantSpecies]}]];

wa=ExtractSpecies[WeightedAbundance[sol,WeightFunction->weightfunction]];
(*If[verbose,Print[func,": wa=",wa]];*)

If[time===t,
	Which[
		modelperiod==0,
		wa=FinalSlice[wa],
		modelperiod<\[Infinity],
		wa=TemporalMean[FinalSlice[wa,modelperiod]],
		Else,
		wa=TemporalMean[wa]
	]
,
	wa=Slice[wa,time]
];
If[verbose,Print[func,": WeightedAbundance=",wa]];

Return[Keys[Select[Association[wa],#>minpop&]]]
]];


Options[ExtantSpecies]={Verbose->False,MinPop->10^-10,WeightFunction->"Total",Time->t};


Subscript[\[ScriptCapitalN], gu_]:=\[ScriptCapitalN][gu];
Subscript[\[FormalCapitalN], gu_]:=\[FormalCapitalN][gu];


ClearParameters::usage="ClearParameters clears all model parameters.";


ClearParameters:=Quiet[Clear[Evaluate[Sequence@@EcoEvo`Private`parnames]],{Clear::wrsym}];


ParameterValues::usage="ParameterValues returns a rulelist of current definitions of model parameters.";


ParameterValues:=Thread[EcoEvo`Private`parnames->EcoEvo`Private`parameters];


MakeGMatrix::usage="MakeGMatrix[\!\(\*
StyleBox[\"var\", \"TI\"]\)] makes a G-matrix of Var and Cov for guild/gcomp \!\(\*
StyleBox[\"var\", \"TI\"]\).";


MakeGMatrix[var_]:=Module[{type,gu},
	{type,gu}=LookUp[var][[1;;2]];
	(*Print[{type,gu}];*)
	Which[
		type=="guild"||ngcomps[gu]==1,
		Table[Table[
			Which[
				i<j,Cov[gtraits[gu][[i]],gtraits[gu][[j]]],
				i==j,Var[gtraits[gu][[i]]],
				i>j,Cov[gtraits[gu][[j]],gtraits[gu][[i]]]
			]
		,{j,ngtraits[gu]}],{i,ngtraits[gu]}]
		,
		type=="gcomp",
		Table[Table[
			Which[
				i<j,Cov[gtraits[gu][[i]],gtraits[gu][[j]]][var],
				i==j,Var[gtraits[gu][[i]]][var],
				i>j,Cov[gtraits[gu][[j]],gtraits[gu][[i]]][var]
			]
		,{j,ngtraits[gu]}],{i,ngtraits[gu]}]
	]
];


MakeGMatrix[Subscript[var_,sp_]]:=Replace[MakeGMatrix[var],x_->Subscript[x, sp],{2}];


MakeTraitVector::usage="MakeTraitVector[\!\(\*
StyleBox[\"var\", \"TI\"]\)] makes a trait vector for guild/gcomp \!\(\*
StyleBox[\"var\", \"TI\"]\)."


MakeTraitVector[var_]:=Module[{type,gu},
	{type,gu}=LookUp[var][[1;;2]];
	(*Print[{type,gu}];*)
	Which[
		type=="guild"||ngcomps[gu]==1,
		gtraits[gu],
		type=="gcomp",
		Table[gtrait[var],{gtrait,gtraits[gu]}]
	]
];


MakeTraitVector[Subscript[var_,sp_]]:=Replace[MakeTraitVector[var],x_->Subscript[x, sp],{1}];


EcoEqns::usage=
"EcoEqns[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] sets up ecological equations using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoEqns[attributesin:(_?AttributesQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,logged,fixed,fixedvars,fixedvariables,timescale,percapita,zerogrowthby,ignorevar,
(* other variables *)
attributes,zeroby,nonfixedvars,fixed2,eqn,eqns,gco,sp},

Block[{\[ScriptCapitalN],verbosity,func="EcoEqns"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEqns]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEqns]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEqns]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEqns]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoEqns]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[EcoEqns]}]];
nonfixedvars=Evaluate[NonFixedVars/.Flatten[{opts,Options[EcoEqns]}]];
zerogrowthby=Flatten[{Evaluate[ZeroGrowthBy/.Flatten[{opts,Options[EcoEqns]}]]}];

Do[
(*Print["zvar=",zvar];
Print["LookUp[zvar]=",LookUp[zvar]];*)
	Which[
		LookUp[zvar][[1]]=="gcomp",
		Do[
			zeroby[Subscript[gcomp, LookUp[zvar][[4]]]]=zvar
		,{gcomp,gcomps[LookUp[zvar][[2]]]}],
		LookUp[zvar][[1]]=="pcomp",
		Do[
			zeroby[pcomp]=zvar
		,{pcomp,pcomps[LookUp[zvar][[2]]]}]
	];
,{zvar,zerogrowthby}];

ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEqns]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEqns]}]];
fixedvars=fixed[[All,1]];
fixedvariables=ExtractVariables[fixed];
VPrint[3,"fixedvars=",fixedvars];

(* fix attributes *)
attributes=FixAttributes[attributesin];
(*Print["attributes=",attributes];*)

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[nonfixedvars===Automatic,nonfixedvars=OrderedComplement[AllVariables,fixedvars]];
VPrint[3,"nonfixedvars=",nonfixedvars];

(*Print["making eqns"];*)
eqns=Table[
	If[ignorevar,eqn=Simplify[Equation[var]/.ZeroGs],eqn=Equation[var]];
	Which[
		logged===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			log[var]'==log[var]+RealSimplify[timescale*Log[eqn/var]],
			modeltype=="ContinuousTime",
			log[var]'==timescale*(eqn/var)
		]
	,
		percapita===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			var'==var+RealSimplify[timescale*Log[eqn/var]],
			modeltype=="ContinuousTime",
			var'==timescale*eqn/var
		]
	,
		Else,
		Which[
			modeltype=="DiscreteTime",
			var'==timescale*eqn,
			modeltype=="ContinuousTime",
			(*Print[zeroby[var]];*)
			If[Head[zeroby[var]]===Subscript||Head[zeroby[var]]===Symbol,
				var'==timescale*(eqn-Equation[zeroby[var]]*var/zeroby[var]),
				var'==timescale*eqn
			]
		]
	]
,{var,nonfixedvars}];
(*Print["eqns=",eqns];
Print["ExpandTraits[attributes]=",ExpandTraits[attributes]];
Print["nonfixedvars=",nonfixedvars];
Print["logged=",logged];*)

(*Return[DeleteDuplicates[eqns/.ExpRule[nonfixedvars,logged]/.Dispatch[ExpandTraits[attributes]]/.fixed]]*)
Return[DeleteDuplicates[eqns/.fixed/.ExpRule[nonfixedvars,logged]/.Dispatch[ExpandTraits[attributes]]]]

]];


Options[EcoEqns]={Verbose->False,Verbosity->0,
Fixed->{},TimeScale->1,Logged->False,PerCapita->False,NonFixedVars->Automatic,ZeroGrowthBy->{},IgnoreVar->False};


EcoSim::usage=
"EcoSim[\!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates ecological dynamics, with initial densities in \!\(\*
StyleBox[\"init\", \"TI\"]\), from time \!\(\*
StyleBox[\"t\", \"TI\"]\)=0 to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
EcoSim[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoSim[in1___,tmax_?NumericQ,in2___]:=Module[{func=EcoSim,args,opts,pars,atts,Gs,vars,varslist},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

args=Join[ExtractArgs[{in1},func]];
opts=ExtractOpts[{in2},func];
(*Print["args=",args];
Print["opts=",opts];*)

pars=ExtractParameters[args];
atts=ExtractAttributes[args];
Gs=ExtractVarCovs[args];
vars=ExtractVariables[args];
varslist=Select[Select[args,RuleListQ],VariablesQ];
(*Print["pars=",pars];
Print["atts=",atts];
Print["Gs=",Gs];
Print["vars=",vars];
Print["varslist=",varslist];*)

If[varslist=={},
	iEcoSim[pars,atts,Gs,vars,tmax,opts],
	iEcoSim[pars,atts,Gs,#,tmax,opts]&/@varslist
]];


iEcoSim[pars_,attributesin_,Gsin_,initin_,tmax_?NumericQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,method,
ndsolveopts,logged,interpolationpoints,interpolationopts,fixed,fixedvars,whenevents,timescale,outputtmin,randomseeding,
output,tmin,minpop,wheneventopts,
icsensitivity,parametersensitivity,
(* other variables *)
attributes,nonfixedvars,Gs,luv,sp,eqns,unks,ics,tic,exprule,sol,res,fixedres,minwhens,minvar,minval,
init,delayedics,icwhens,var,t0,var0,j},

Block[{\[ScriptCapitalN],verbosity,func="EcoSim"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[EcoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoSim]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[EcoSim]}]];
whenevents=Evaluate[WhenEvents/.Flatten[{opts,Options[EcoSim]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoSim]}]];
If[output=="FinalSlice",outputtmin=tmax];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoSim]}]];
If[outputtmin===Automatic,outputtmin=tmin];
randomseeding=Evaluate[RandomSeeding/.Flatten[{opts,Options[EcoSim]}]];
If[IntegerQ[randomseeding],SeedRandom[randomseeding]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[EcoSim]}]];
icsensitivity=Evaluate[ICSensitivity/.Flatten[{opts,Options[EcoSim]}]];
parametersensitivity=Evaluate[ParameterSensitivity/.Flatten[{opts,Options[EcoSim]}]];
(*parametersensitivity=Evaluate[ParameterSensitivity/.Flatten[{opts,Options[EcoSim]}]];*)
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoSim]}]];
interpolationopts=FilterRules[Flatten[{opts,Options[EcoSim]}],Options[Interpolation]];
interpolationpoints=Evaluate[InterpolationPoints/.Flatten[{opts,Options[EcoSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoSim]}]];
fixedvars=fixed[[All,1]];

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* set t=0 ICs for delayed ICs *)
init=initin/.Flatten[Table[{(var[tmin]->val_)->(var->val),(var[_?NumericQ]->val_)->(var->0)},{var,AllVariables}]];
VPrint[3,"init=",init];

nonfixedvars=init[[All,1]]; (* nonfixedvars are those given ICs *)
VPrint[3,"nonfixedvars=",nonfixedvars];

(* look for variables not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],
		AppendTo[fixed,var->0];
		AppendTo[fixedvars,var];
	]
,{var,AllVariables}];

(* setup delayed IC WhenEvents *)
delayedics=Complement[initin,init];
VPrint[3,"delayedics=",delayedics];

icwhens=Table[
	{var,t0,var0}={dic[[1,0]],dic[[1,1]],dic[[2]]};
	If[tmin<t0<tmax,WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->t==t0,action->var[t]->var0}]
,{dic,delayedics}]//DeleteNulls;
VPrint[3,"icwhens=",icwhens];

(* set up MinPop WhenEvents *)
Which[
	NumberQ[minpop],
	minwhens=Table[
		If[comptype[var]==="Extensive",
			If[logged===False,
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->var[t]<minpop,action->var[t]->0},
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->log[var][t]<Log[minpop],action->log[var][t]->-10^10}
			]]
	,{var,nonfixedvars}]//DeleteNulls,
	RuleListQ[minpop],
	minwhens=Table[
		{minvar,minval}={rule[[1]],rule[[2]]};
		If[logged===False,
			WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->minvar[t]<minval,action->minvar[t]->0},
			WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->log[minvar][t]<Log[minval],action->log[minvar][t]->-10^10}
		]
	,{rule,minpop}]//DeleteNulls,
	minpop===Automatic,
	minwhens=Table[
		If[comptype[var]==="Extensive"&&Min[range[var]]>0,
			If[logged===False,
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->var[t]<Min[range[var]],action->var[t]->0},
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->log[var][t]<Log[Min[range[var]]],action->log[var][t]->-10^10}
			]]
	,{var,nonfixedvars}]//DeleteNulls,
	Else,
	minwhens={}
];
VPrint[3,"minwhens=",minwhens];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-10^-15]; (* hack to ensure that events are triggered at t=tmin *)

(* set eqns, unks and ics *)
(*Print["calling EcoEqns..."];*)
eqns=EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,opts]/.AddVariablets/.Gs/.ZeroGs;
unks=Table[If[logged===True&&comptype[var]==="Extensive",log[var],var],{var,nonfixedvars}];
ics=Table[If[logged===True&&comptype[var]==="Extensive",log[var][tic]==Log[var/.init],var[tic]==(var/.init)],{var,nonfixedvars}];

(* sensitivity analysis *)
If[icsensitivity||parametersensitivity=!={},
	j=EcoJacobian[Fixed->fixed]/.AddVariablets/.Gs/.ZeroGs/.pars;
	VPrint[3,"j=",j];
	neqns=Length[eqns];
];

(* parameter sensitivity *)

(* good itemized *)
If[parametersensitivity=!={},
	npars=Length[parametersensitivity];
	Do[Do[
(*Print["par=",par];
Print["D[(eqns/.RHS)[[i]],par]=",D[(eqns/.RHS)[[i]],par]];*)
			AppendTo[eqns,Sensitivity[unks[[i]],ToString@par]'[t]==timescale*j[[i]] . Table[Sensitivity[unks[[j]],ToString@par][t],{j,neqns}]+D[(eqns/.RHS)[[i]],par]];
			AppendTo[unks,Sensitivity[unks[[i]],ToString@par]];
			AppendTo[ics,Sensitivity[unks[[i]],ToString@par][0]==0]
		,{i,neqns}],{par,parametersensitivity}];
];

(* good matrix *)
(*If[parametersensitivity=!={},
	npars=Length[parametersensitivity];
	AppendTo[eqns,ParameterSensitivity'[t]\[Equal]j.ParameterSensitivity[t]+D[eqns/.RHS,{parametersensitivity}]];
	AppendTo[unks,ParameterSensitivity];
	AppendTo[ics,ParameterSensitivity[0]==ConstantArray[0,{neqns,npars}]];
];*)

(* bad matrix *)
(*If[parametersensitivity=!={},
	npars=Length[parametersensitivity];
Print["j=",j];
Print["dx=",Transpose@D[eqns/.RHS,{parametersensitivity}]];
Print["ic=",ConstantArray[0,{npars,neqns}]];

	AppendTo[eqns,ParameterSensitivity'[t]\[Equal]Transpose[j.(Transpose@ParameterSensitivity[t])]+Transpose@D[eqns/.RHS,{parametersensitivity}]];
	AppendTo[unks,ParameterSensitivity];
	AppendTo[ics,ParameterSensitivity[0]==ConstantArray[0,{npars,neqns}]];
];*)

(* IC sensitivity *)
If[icsensitivity,
	AppendTo[eqns,ICSensitivity'[t]==timescale*j . ICSensitivity[t]];
	AppendTo[unks,ICSensitivity];
	AppendTo[ics,ICSensitivity[0]==IdentityMatrix[neqns]];
];

VPrint[3,"eqns=",eqns];
VPrint[3,"unks=",unks];
VPrint[3,"ics=",ics];

(* solve it *)
(*Print["calling NDSolve..."];*)
Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	If[verbosity>=1,
		With[{ndsolveeqns=Join[eqns/.pars,ics,modelwhenevents,whenevents,minwhens,icwhens],unks=unks,outputtmin=outputtmin,options=Sequence@@ndsolveopts},
			PrintCall[Global`sol=NDSolve[ndsolveeqns,unks,{t,outputtmin,tmax},options][[1]]]
	]];
	Global`gsol=sol=NDSolve[Join[eqns/.pars,ics,modelwhenevents,whenevents,minwhens,icwhens],unks,{t,outputtmin,tmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	If[logged===True,
		If[output=="FinalSlice",Return[SortRuleList[FinalSlice[sol]/.(log[var_]->val_)->(var->E^val),Join[AllVariables,{ICSensitivity,Sensitivity}]]]];
		res=Table[If[comptype[var]==="Extensive",
			var->Reinterpolation[E^log[var]/.sol,InterpolationPoints->interpolationpoints,Evaluate[Sequence@@interpolationopts]],
			var->(var/.sol)]
		,{var,nonfixedvars}]
	,
		(*res=FilterRules[sol,Append[nonfixedvars,Join[AllVariables,{ICSensitivity,Sensitivity}]]]*)
		res=sol
	];
	res=Join[res,fixed(*Table[fixedvar\[Rule]Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder\[Rule]0],{fixedvar,fixedvars}]*)];
	,
	modeltype=="DiscreteTime",
	If[verbosity>=1,
		With[{rteqns=Join[eqns,ics],unks=unks,tmin=tmin},
			PrintCall[Global`res=RecurrenceTable[rteqns,unks,{t,tmin,tmax}]]
	]];
	sol=Transpose[Replace[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax},Method->{Compiled->True}],n_?NumericQ->{n},1]]; (* Replace to deal with weird RecurrenceTable bug <https://mathematica.stackexchange.com/questions/128371/> *)
	res=Join[Table[
		If[Head[unks[[i]]]===log,unks[[i,1]],unks[[i]]]->TimeSeries[Transpose[{Table[t,{t,outputtmin,tmax}],If[Head[unks[[i]]]===log,E^sol[[i]],sol[[i,outputtmin-tmin+1;;tmax-tmin+1]]]}]]
	,{i,Length[unks]}],
	Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

VPrint[3,"res=",res];

If[output=="FinalSlice",Return[SortRuleList[FinalSlice[res],Join[AllVariables,{ICSensitivity,Sensitivity}]]]];

(*Return[res];*)
Return[SortRuleList[res,AllVariables]];

]];


Options[EcoSim]={Verbose->False,Verbosity->0,
Method->Automatic,NDSolveOpts->{},Logged->False,Fixed->{},WhenEvents->{},InterpolationOrder->7,InterpolationPoints->1000,
EqStop->False,EqThreshold->10^-8,TimeScale->1,TMin->0,OutputTMin->Automatic,Output->"Dynamics",TMin->0,RandomSeeding->None,
MinPop->None,WhenEventOpts->{},ZeroGrowthBy->None,ICSensitivity->False,ParameterSensitivity->{}};


EcoSimTable::usage=
"EcoSimTable[\!\(\*
StyleBox[\"ics\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\), \!\(\*
StyleBox[\"dpar\", \"TI\"]\)}] makes a table of EcoSims, varying parameter \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\), in steps of \!\(\*
StyleBox[\"dpar\", \"TI\"]\).";


EcoSimTable[in1___,tmax_?NumericQ,{par_,parmin_?NumericQ,parmax_?NumericQ,dpar_},in2___]:=Module[{
func=EcoSimTable,args,opts,pars,atts,Gs,vars,varslist},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

args=Join[ExtractArgs[{in1},func]];
opts=ExtractOpts[{in2},func];
(*Print["args=",args];
Print["opts=",opts];*)

pars=ExtractParameters[args];
atts=ExtractAttributes[args];
Gs=ExtractVarCovs[args];
vars=ExtractVariables[args];
(*Print["pars=",pars];
Print["atts=",atts];
Print["Gs=",Gs];
Print["vars=",vars];*)

iEcoSimTable[pars,atts,Gs,vars,tmax,{par,parmin,parmax,dpar},opts]
];
(*SetAttributes[EcoSimTable, HoldAll];*)


iEcoSimTable[parsin_,attsin_,Gs_,icsin_,tmax_,{par_,parmin_,parmax_,dpar_},opts___?OptionQ]:=

Module[{
(* options *)
verbose,monitor,printtrace,
continuationorder,initialwarmup,warmup,ecosimopts,perturbation,break,
(* other variables *)
atts,parname,ics,sol,res
},

Block[{\[ScriptCapitalN],verbosity,func="EcoSimTable"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoSimTable]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoSimTable]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoSimTable]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)
monitor=Evaluate[Monitor/.Flatten[{opts,Options[EcoSimTable]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[EcoSimTable]}]];
initialwarmup=Evaluate[InitialWarmUp/.Flatten[{opts,Options[EcoSimTable]}]];
warmup=Evaluate[WarmUp/.Flatten[{opts,Options[EcoSimTable]}]];
continuationorder=Evaluate[ContinuationOrder/.Flatten[{opts,Options[EcoSimTable]}]];
ecosimopts=FilterRules[{opts},Options[EcoSim]];
perturbation=Evaluate[Perturbation/.Flatten[{opts,Options[EcoSimTable]}]];
break=Evaluate[Break/.Flatten[{opts,Options[EcoSimTable]}]];

If[monitor,PrintTemporary[par,"=",Dynamic[parval]]];

(* see if par is a trait *)
If[LookUp[par][[1]]==="gtrait",
	mode="trait";
	atts:=Join[attsin,{par->parval}];
	pars=parsin,
	mode="par";
	pars:=Join[parsin,{par->parval}];
	atts=attsin
];
(*Print["pars=",pars];
Print["atts=",atts];*)

parval=parmin;
ics=EcoSim[pars,atts,Gs,icsin,initialwarmup,Output->"FinalSlice",Evaluate[Sequence@@ecosimopts]];

If[initialwarmup>0,
	ics=EcoSim[pars,atts,Gs,icsin,initialwarmup,Output->"FinalSlice",Evaluate[Sequence@@ecosimopts]]];

parname=ToString[FullForm@par];

Clear[parval];
res=Association@@Reap[Do[
	If[warmup>0,ics=EcoSim[pars,atts,Gs,ics,warmup,Output->"FinalSlice",Evaluate[Sequence@@ecosimopts]]];
	sol=EcoSim[pars,atts,Gs,ics,tmax,Evaluate[Sequence@@ecosimopts]];
(*Print[parval," ",FinalSlice[sol]," ",Global`x10/.FinalSlice[sol]," ",Or@@Evaluate[break/.Global`SOL->sol]];*)
	If[Or@@Evaluate[break/.Global`SOL->sol],(*Print["hey"];*)Break[]];
	Which[
		continuationorder==0,
		ics=RuleListAdd[FinalSlice[sol],perturbation];
	];
	If[printtrace,Print[parname,"=",NumberForm@parval," FinalSlice[sol]=",ics]];
	Sow[(ToString[parval])->sol]
,{parval,parmin,parmax,dpar}]][[2,1]];

Return[ParametricDynamics[res,Parameter->parname,Type->"Discrete",ModelType->modeltype]]
]];


Options[EcoSimTable]={Verbose->False,Monitor->True,PrintTrace->False,
WarmUp->0,InitialWarmUp->0,ContinuationOrder->0,Perturbation->0,Break->{}};


EcoEq::usage = 
"EcoEq[] solves for ecological equilibria.
EcoEq[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).";

SolveEcoEq::usage = 
"SolveEcoEq[] solves for ecological equilibria.
SolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";

NSolveEcoEq::usage = 
"NSolveEcoEq[] numerically solves for ecological equilibria.
NSolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses traits/interactions \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";

FindEcoEq::usage = 
"FindEcoEq[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological equilibrium using initial guess / range \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and initial guess / range \!\(\*
StyleBox[\"init\", \"TI\"]\).";


EcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},init:(_?VariablesQ):{},vars:(__List|All):All,opts___?OptionQ]:=

Module[{
(* options *)
method,solveopts,nsolveopts,findrootopts,findrootsopts,
boundarydetection,time,fixed,chop,qss,percapita,verbose,ignorevar,ecoeqnsopts,
(* other variables *)
attributes,nonvars,nonfixedvars,fixedvars,Gs,removets,eqns,unks,newunk,sol,res},

Block[{\[ScriptCapitalN],verbosity,func="EcoEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[EcoEq]}]];
If[method===Automatic,If[init!={},method="FindRoot",method="Solve"]];
VPrint[3,"method=",method];

solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EcoEq]}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EcoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EcoEq]}]];
findrootsopts=Evaluate[FindRootsOpts/.Flatten[{opts,Options[EcoEq]}]];

boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEq]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEq]}]];
qss=Evaluate[QSS/.Flatten[{opts,Options[EcoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[EcoEq]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEq]}]];
ecoeqnsopts=FilterRules[Flatten[{opts,Options[EcoEq]}],Options[EcoEqns]];
(*Print["ecoeqnsopts=",ecoeqnsopts];*)

(* EcoEq doesn't work on Periodic models *)
If[modelperiod=!=0&&time===t&&method=="FindRoot",Message[EcoEq::noneq];Return[]];

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
VPrint[3,"Gsin=",Gsin];
If[method=="FindRoot"||method=="FindRoots",
	If[moments,
		If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
		Gs={}]
	,
	Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
];
VPrint[3,"Gs=",Gs];

If[vars===All,
	nonvars={},
	nonvars=OrderedComplement[AllVariables,vars]
];
VPrint[3,"nonvars=",nonvars];

If[qss==False,
	fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->0),1]],
	fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->x),1]]
];
VPrint[3,"fixed=",fixed];

fixedvars=fixed[[All,1]];
nonfixedvars=OrderedComplement[AllVariables,fixedvars];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* set eqns *)
(*eqns=EcoEqns[attributes,Fixed\[Rule]fixed,PerCapita\[Rule]percapita,IgnoreVar->ignorevar]/.Eq/.t\[Rule]time/.fixed/.attributes/.Gs;*)
eqns=EcoEqns[attributes,Fixed->fixed,Evaluate[Sequence@@ecoeqnsopts]]/.Eq/.t->time(*/.fixed/.attributes*)/.Gs;
VPrint[3,"eqns=",eqns];

(* solve it *)
Which[
	method=="Solve",
	unks=nonfixedvars;
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@solveopts},PrintCall[Global`sol=Solve[eqns,unks,options]]]];
	sol=Solve[eqns,unks,Evaluate[Sequence@@solveopts]];
	If[Head[sol]===Solve,sol=Solve[eqns,unks,Reals,Evaluate[Sequence@@solveopts]]]
	,

	method=="NSolve",
	unks=nonfixedvars;
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@nsolveopts},PrintCall[Global`sol=NSolve[eqns,unks,options]]]];
	sol=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]];
	If[Head[sol]===NSolve,sol=NSolve[eqns,unks,Reals,Evaluate[Sequence@@nsolveopts]]]
	,

	method=="FindRoot",
	unks=Table[
		newunk={var,(var/.Append[init,var->0])};
		If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
		newunk,{var,nonfixedvars}];
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@findrootopts},PrintCall[Global`sol=FindRoot[eqns,unks,options]]]];
	sol=FindRoot[eqns,unks,Evaluate[Sequence@@findrootopts]],

	method=="FindRoots",
	unks=vars;
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@findrootsopts},PrintCall[Global`sol=FindRoots[eqns,unks,options]]]];
	sol=FindRoots[eqns,unks,Evaluate[Sequence@@findrootsopts]],
	Else,
	Message[EcoEq::badmtd];Return[$Failed];
];

VPrint[3,"sol=",sol];
If[MemberQ[{Solve,NSolve},Head[sol]],Message[EcoEq::nosol,Head[sol]];Return[$Failed]];

(* add in Fixed variables *)
Which[
	MemberQ[{"Solve","NSolve","FindRoots"},method],
	res=Join[DeleteCases[fixed,var_->var_],#]& /@ sol,
	method=="FindRoot",
	res=Join[DeleteCases[fixed,var_->var_],sol]
];
VPrint[3,"res=",res];

If[chop,
	Return[SortRuleList[EqSort[Chop[res]],AllVariables]],
	Return[SortRuleList[EqSort[res],AllVariables]]
];

]];


Options[EcoEq]={Method->Automatic,
SolveOpts->{},NSolveOpts->{Method->"EndomorphismMatrix"},FindRootOpts->{},FindRootsOpts->{},
PerCapita->False,Fixed->{},Chop->True,QSS->False,Time->t,Verbose->False,Verbosity->0,IgnoreVar->False};


(* break up combined traitsandpops *)
SolveEcoEq[sol_?AttributesAndGsQ,opts___?OptionQ]:=SolveEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],opts];
NSolveEcoEq[sol_?AttributesAndGsQ,opts___?OptionQ]:=NSolveEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],opts];
FindEcoEq[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=((*Print["breaking AVG"];*)FindEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],ExtractVariables[sol],opts]);
FindEcoEq[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=FindEcoEq[ExtractAttributes[sol],ExtractVariables[sol],opts];


SolveEcoEq[args___]:=EcoEq[args,Method->"Solve"];
NSolveEcoEq[args___]:=EcoEq[args,Method->"NSolve"];
FindEcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},init:(_?VariablesQ):{},opts___?OptionQ]:=
	EcoEq[attributesin,Gsin,init,opts,Method->"FindRoot"];
FindEcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},vars__List,opts___?OptionQ]:=
	EcoEq[attributesin,Gsin,vars,opts,Method->"FindRoots"];


EcoEq::noneq=
"Can't find equilibrium of periodically forced model with FindRoot.  Give Time option or try FindEcoCycle instead.";
EcoEq::nosol="`1` couldn't find a solution.  Try FindEcoEq instead.";
EcoEq::badmtd="Method is not known (\"Solve\",\"NSolve\",\"FindRoot\",\"FindRoots\").";


FindEcoEqBifurcation::usage = 
"FindEcoEqBifurcation[\!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"par\", \"TI\"]\)->\!\(\*
StyleBox[\"parinit\", \"TI\"]\)] finds an ecological equilibrium bifurcation in \!\(\*
StyleBox[\"par\", \"TI\"]\) using initial guesses \!\(\*
StyleBox[\"init\", \"TI\"]\) and \!\(\*
StyleBox[\"parinit\", \"TI\"]\).
FindEcoEqBifurcation[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"par\", \"TI\"]\)->\!\(\*
StyleBox[\"parinit\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


FindEcoEqBifurcation[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},init:(_?VariablesQ):{},parname_->parinit_?NumericQ,opts___?OptionQ]:=

Module[{
(* options *)
findrootopts,
boundarydetection,time,fixed,chop,verbose,ignorevar,
(* other variables *)
attributes,nonfixedvars,fixedvars,Gs,removets,eqns,j,unks,newunk,sol,res,maxev},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoEqBifurcation"},

(*Print["attributesin=",attributesin];
Print["Gsin=",Gsin];
Print["init=",init];
Print["parname->parinit=",parname->parinit];
Print["opts=",opts];*)

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEqBifurcation]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEqBifurcation]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEqBifurcation]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEqBifurcation]}]];

boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEqBifurcation]}]];
time=Evaluate[Time/.Flatten[{opts,Options[FindEcoEqBifurcation]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEqBifurcation]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEqBifurcation]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[FindEcoEqBifurcation]}]];


(* FindEcoEqBifurcation doesn't work on Periodic models *)
If[modelperiod=!=0&&time===t,Message[FindEcoEqBifurcation::noneq];Return[]];

(* fix attributes *)
attributes=FixAttributes[attributesin];

(*Print["LookUp[parname][[1]]=",LookUp[parname][[1]]];*)
(* see if par is a trait *)
If[
	LookUp[parname][[1]]==="gtrait"
,
	mode="trait";
	attributes:=Join[attributesin,{parname->parname}];
,
	mode="par";
	Evaluate[parname]:=parname;
	attributes=attributesin
];
(*Print["attributes=",attributes];*)

(* figure out number of species in guilds *)
(*Set\[ScriptCapitalN][attributes];*)
Set\[ScriptCapitalN][init];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}
];
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

fixedvars=fixed[[All,1]];
nonfixedvars=OrderedComplement[AllVariables,fixedvars];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* set eqns *)
eqns=EcoEqns[attributes,Fixed->fixed,IgnoreVar->ignorevar]/.Eq/.t->time/.fixed/.attributes/.Gs;
VPrint[3,"eqns=",eqns];

j=EcoJacobian[attributes];
VPrint[3,"j=",j];
Which[
	modeltype=="ContinuousTime",
	maxev[unkvals_List,parval_?NumericQ]:=Module[{},
		Max[Re[Eigenvalues[j/.parname->parval/.Table[nonfixedvars[[i]]->unkvals[[i]],{i,Length[nonfixedvars]}]]]]
	],
	modeltype=="DiscreteTime",
	maxev[unkvals_List,parval_?NumericQ]:=Max[Abs[Eigenvalues[j/.parname->parval/.Table[nonfixedvars[[i]]->unkvals[[i]],{i,Length[nonfixedvars]}]]]]-1
];

(* solve it *)
unks=Append[Table[
	newunk={var,(var/.Append[init,var->0])};
	If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
	newunk,{var,nonfixedvars}],
	{parname,parinit}];
VPrint[3,"unks=",unks];
If[verbosity>=1,
	With[{eqns=Append[eqns,0==Global`maxev[nonfixedvars,parname]],unks=unks,options=Sequence@@findrootopts},PrintCall[Global`sol=FindRoot[eqns,unks,options]]]];
sol=FindRoot[Append[eqns,0==maxev[nonfixedvars,parname]],unks,Evaluate[Sequence@@findrootopts](*,EvaluationMonitor:>Print[{par,maxev[par]}]*)];

VPrint[3,"sol=",sol];

(* add in Fixed variables *)
res=Join[DeleteCases[fixed,var_->var_],sol];

If[chop,res=Chop[res]];

Return[SortRuleList[EqSort[res],Join[parameters,AllVariables]]]

]];


Options[FindEcoEqBifurcation]={
FindRootOpts->{},
Fixed->{},Chop->True,Time->t,Verbose->False,Verbosity->0,
IgnoreVar->False};


FindEcoEqBifurcation::noneq=
"Can't find equilibrium of periodically forced model with FindRoot.  Give Time option or try FindEcoCycle instead.";


(*TrackEcoEq::usage=
"TrackEcoEq[sol, {par, parmin, parmax}] tracks an ecological equilibrium, with initial guess sol, over parameter par from parmin to parmax.
TrackEcoEq[sol, {par, parmin, parmax, dpar}] uses initial step size dpar.";*)


(*TrackEcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},init_?VariablesQ,{parname_,parmin_?NumericQ,parmax_?NumericQ,initialstepsize_:Automatic},opts___?OptionQ]:=

Module[{
(* options *)
verbose,monitor,printtrace,
teststability,testbend,
findbifurcation,
initialsteps,minstepsize,maxstepsize,maxsteps,maxrecursion,maxexpansion,
maxbend,maxchange,
findecoeqopts,interpolationopts,
(* other variables *)
mode,par,dpar,parold,tmp,tmp2,ics,ics\[Prime],per,unks,count,sol,initialstability,
m0,m1,list,bif,traits
},

Block[{\[ScriptCapitalN],verbosity,func="TrackEcoEq"},

If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[TrackEcoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[TrackEcoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

monitor=Evaluate[Monitor/.Flatten[{opts,Options[TrackEcoEq]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[TrackEcoEq]}]];

initialsteps=Evaluate[InitialSteps/.Flatten[{opts,Options[TrackEcoEq]}]];
If[initialstepsize===Automatic,dpar=N[(parmax-parmin)/initialsteps],dpar=N[initialstepsize]];

maxexpansion=Evaluate[MaxExpansion/.Flatten[{opts,Options[TrackEcoEq]}]];
maxrecursion=Evaluate[MaxRecursion/.Flatten[{opts,Options[TrackEcoEq]}]];
minstepsize=Evaluate[MinStepSize/.Flatten[{opts,Options[TrackEcoEq]}]];
If[minstepsize===Automatic,minstepsize=dpar*2^-maxrecursion];
maxstepsize=Evaluate[MaxStepSize/.Flatten[{opts,Options[TrackEcoEq]}]];
If[maxstepsize===Automatic,maxstepsize=dpar*2^maxexpansion];
maxsteps=Evaluate[MaxSteps/.Flatten[{opts,Options[TrackEcoEq]}]];

maxbend=Evaluate[MaxBend/.Flatten[{opts,Options[TrackEcoEq]}]];
maxchange=Evaluate[MaxChange/.Flatten[{opts,Options[TrackEcoEq]}]];

findbifurcation=Evaluate[FindBifurcation/.Flatten[{opts,Options[TrackEcoEq]}]];

teststability=Evaluate[TestStability/.Flatten[{opts,Options[TrackEcoEq]}]];
testbend=Evaluate[TestBend/.Flatten[{opts,Options[TrackEcoEq]}]];

findecoeqopts=Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[TrackEcoEq]}]];
interpolationopts=Evaluate[InterpolationOpts/.Flatten[{opts,Options[TrackEcoEq]}]];


If[monitor,PrintTemporary[Dynamic[count]," ",parname,"=",Dynamic[par]," d",parname,"=",Dynamic[dpar]]];

(* see if par is a trait *)
If[
	LookUp[parname][[1]]==="gtrait"
,
	mode="trait";
	traits:=Join[attributesin,{parname->par}];
,
	mode="par";
	Evaluate[parname]:=par;
	traits=attributesin
];

unks=Keys[init];
tmp2={};
tmp={};
parold=par=N[parmin];
dpar=dpar/2;
ics=init;
count=0;


sol=Check[Quiet[FindEcoEq[traits,ics,Evaluate[Sequence@@findecoeqopts]],FindRoot::lstol],"err"];
If[sol==="err",Message[TrackEcoEq::ferr,Defer@parname,NumberForm@par];Return[$Aborted]];
If[teststability,initialstability=EcoStableQ[traits,sol]];
VPrint[3,"initialstability=",initialstability];
ics=sol;

While[count<maxsteps,
(*Pause[0.01];*)
	count++;
(*Print[ics];*)
	sol=Check[Quiet[FindEcoEq[traits,ics,Evaluate[Sequence@@findecoeqopts]],FindRoot::lstol],"err"];
	If[printtrace&&sol=!="err",Print[Defer@parname,"=",NumberForm@par," sol=",sol," EcoStableQ=",EcoStableQ[traits,sol]]];
	Which[
		sol==="err",
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," FindEcoEq error"]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEq::err,Defer@parname,NumberForm@par];Break[]];
		par=parold+dpar;
(*Print["error {dpar\[Prime],par\[Prime]}=",{dpar,par}];*)		
	,	
		teststability
		&&EcoStableQ[traits,sol]=!=initialstability,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," stability change, EcoEigenvalues[sol]=",EcoEigenvalues[traits,sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],
			If[findbifurcation,
				If[mode=="par",Clear[parname]];
				bif=FindEcoEqBifurcation[attributesin,sol,parname->par];
				VPrint[3,"bif=",bif];
				If[mode=="par",
					par=parname=(parname/.bif),
					par=(parname/.bif)
				];
				If[printtrace,Print[Defer@parname,"=",NumberForm@par," bifurcation, sol=",ExtractVariables@bif," EcoEigenvalues=",EcoEigenvalues[traits,ExtractVariables@bif]]];
				Message[TrackEcoEq::chst,initialstability,!initialstability,Defer@parname,NumberForm@par,EcoEigenvalues[traits,ExtractVariables@bif]];
				tmp[[-1]]={par,ExtractVariables[bif]};
			,
				Message[TrackEcoEq::chsta,initialstability,!initialstability,Defer@parname,NumberForm@parold,NumberForm@par,EcoEigenvalues[traits,sol]];
			];
			Break[]
		];
		par=parold+dpar;
	,
		testbend
		&&Length[tmp]\[GreaterEqual]2&&CompoundOr[Table[
				m1=((unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])-(unk/.tmp\[LeftDoubleBracket]-2,2\[RightDoubleBracket]))/(tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]-tmp\[LeftDoubleBracket]-2,1\[RightDoubleBracket]);
				m0=((unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket]))/(par-tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]);
				list=Table[unk/.ent\[LeftDoubleBracket]2\[RightDoubleBracket],{ent,tmp}];
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]]>maxbend
				&&
				Abs[(unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])]/(10^-10+Differences[{Min[list],Max[list]}]\[LeftDoubleBracket]1\[RightDoubleBracket])>maxchange
			,{unk,unks}]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," MaxBend exceeded"]];
		If[dpar>0,dpar=Max[minstepsize,dpar/2],dpar=Min[minstepsize,dpar/2]];
		par=parold+dpar;		
	,
		Else, (* success *)
		AppendTo[tmp,{par,sol}];
		If[par\[Equal]parmax,Break[]]; (* reached end *)
		If[dpar>0,
			dpar=Min[maxstepsize,2dpar];
			parold=par;
			par=Min[parmax,par+dpar];
		,
			dpar=Max[maxstepsize,2dpar];
			parold=par;
			par=Max[parmax,par+dpar];
		];
		(*Print["OK {dpar\[Prime],par\[Prime]}=",{dpar,par}];*)
	];
	ics=Quiet[Slice[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]],par],{Interpolation::inhr,InterpolatingFunction::dmval}];
];

If[count\[Equal]maxsteps,Message[TrackEcoEq::mxst,maxsteps,Defer@parname,NumberForm@par]];

If[mode=="par",Clear[parname]];

Return[Join[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]](*,{Parameter->parname}*)]]
]];*)


(*Options[TrackEcoEq]={
	Verbose\[Rule]False,Verbosity->1,
	PrintTrace\[Rule]False,Monitor\[Rule]True,
	InitialSteps->100,
	MinStepSize\[Rule]Automatic,MaxStepSize\[Rule]Automatic,MaxSteps\[Rule]200,MaxRecursion->10,MaxExpansion->3,
	FindEcoEqOpts\[Rule]{},InterpolationOpts\[Rule]{},
	TestStability->True,TestBend->True,
	FindBifurcation->True,
	MaxBend\[Rule]3,MaxChange\[Rule]0.01
};*)


(*TrackEcoEq::err="FindEcoEq failed at `1`=`2`.";
TrackEcoEq::ferr="FindEcoEq failed at initial parameter value,`1`=`2`, can not continue.";
TrackEcoEq::chst="Stability change from `1` to `2` at `3`=`4`, eigenvalues=`5`.";
TrackEcoEq::chsta="Stability change from `1` to `2` between `3`=`4` and `3`=`5`, eigenvalues=`6`.";
TrackEcoEq::mxst="Maximum number of `1` steps reached at `2`=`3`.";*)


TrackEcoEq::usage="TrackEcoEq[\!\(\*
StyleBox[\"initvars\", \"TI\"]\), \!\(\*
StyleBox[\"initpar\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] tracks an ecological equilibrium, with initial guess \!\(\*
StyleBox[\"initvars\", \"TI\"]\)\!\(\*
StyleBox[\"  \", \"TI\"]\)at \!\(\*
StyleBox[\"initpar\", \"TI\"]\), over parameter \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\).
TrackEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"initvars\", \"TI\"]\), \!\(\*
StyleBox[\"initpar\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


TrackEcoEq[in___,{par_,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=Module[{func=TrackEcoEq,args,pars,atts,Gs,vars,initpar},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

args=Flatten[{in}];

pars=ExtractParameters[args];
atts=ExtractAttributes[args];
Gs=ExtractVarCovs[args];
vars=ExtractVariables[args];
initpar=par/.args;

(*Print["pars=",pars];
Print["atts=",atts];
Print["Gs=",Gs];
Print["vars=",vars];
Print["initpar=",initpar];*)

iTrackEcoEq[atts,Gs,vars,{par,initpar,parmin,parmax},opts]];


iTrackEcoEq[attributesin_,Gsin_,init_,{parname_,initpar_,parmin_,parmax_},opts___?OptionQ]:=

Module[{
(* options *)
verbose,
fixed,percapita,ignorevar,teststability,trackeqopts,
(* other variables *)
attributes,mode,eqns,tr
},

Block[{\[ScriptCapitalN],verbosity,func="TrackEcoEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[TrackEcoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[TrackEcoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[TrackEcoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[TrackEcoEq]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[TrackEcoEq]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[TrackEcoEq]}]];
trackeqopts=FilterRules[Flatten[{opts,Options[TrackEcoEq]}],Options[TrackEq]];

(* see if par is a trait *)
If[
	LookUp[parname][[1]]==="gtrait"
,
	mode="trait";
	attributes:=Join[{parname->parname},attributesin]
,
	mode="par";
	attributes=attributesin
];
(*Print["attributes=",attributes];*)

eqns=EcoEqns[attributes,Fixed->fixed,PerCapita->percapita,IgnoreVar->ignorevar](*/.t\[Rule]time/.fixed/.attributes/.Gs*);
VPrint[3,"EcoEqns=",eqns];

tr=TrackEq[eqns,init,{parname,initpar,parmin,parmax},Evaluate[Sequence@@trackeqopts]];

Return[tr];

]];


Options[TrackEcoEq]={
	Verbose->False,Verbosity->1,
	FindEcoEqOpts->{},InterpolationOpts->{},
	TestStability->True,
	Fixed->{},PerCapita->False,IgnoreVar->False
};


FindEcoCycle::usage = 
"FindEcoCycle[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological limit cycle using initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoCycle[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


FindEcoCycle[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},initin:(_?VariablesQ):{},opts:OptionsPattern[]]:=

Module[{
(* options *)
verbose,period,method,monitor,printtrace,
findrootopts,ecosimopts,ndsolveopts,
maxiterations,accuracygoal,precisiongoal,logged,fixed,
triggervar,warmup1,warmup2,warmup3,wheneventopts,ignorevar,minamplitude,
(* other variables *)
attributes,Gs,nonfixedvars,fixedvars,init,extrema,triggerpos,triggerval,max,ics2,ics3,ics4,diff,tmax,eq,
ic,nb,thing,eqns,unks,logd,vars,unksics,ics,bcs,res,sol,per},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoCycle"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

monitor=OptionValue[Monitor];
printtrace=OptionValue[PrintTrace];
period=OptionValue[Period];
If[period===Automatic,
	Which[
		TemporalRuleListQ[initin],
		period=ExtractPeriod[initin]
	,
		0<modelperiod<\[Infinity],
		period=modelperiod
	]
];	
VPrint[3,"period=",period];
method=OptionValue[Method];
If[method===Automatic,
	If[
		period=!=Automatic,
		method="FindRoot"
	,
		method="EcoSim"
]];
VPrint[3,"method=",method];

findrootopts=OptionValue[FindRootOpts];
ecosimopts=OptionValue[EcoSimOpts];
ndsolveopts=OptionValue[NDSolveOpts];
maxiterations=OptionValue[MaxIterations];
accuracygoal=OptionValue[AccuracyGoal];
triggervar=OptionValue[TriggerVariable];
warmup1=OptionValue[WarmUp];
warmup2=OptionValue[WarmUp2];
warmup3=OptionValue[WarmUp3];
tmax=OptionValue[TMax];
wheneventopts=OptionValue[WhenEventOpts];
logged=OptionValue[Logged];
fixed=OptionValue[Fixed];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
ignorevar=OptionValue[IgnoreVar];
minamplitude=OptionValue[MinAmplitude];


$FindEcoCycleSteps=0;

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* fix init *)
init=If[TemporalRuleListQ[initin],FinalSlice[initin],initin];

(* set up thing & unks *)
nonfixedvars=init[[All,1]];
(*VPrint[3,"nonfixedvars=",nonfixedvars];*)

(* build various lists of vars *)
unks=Table[eq[var],{var,nonfixedvars}];
vars=Table[If[logged&&comptype[var]==="Extensive",Log[var],var],{var,nonfixedvars}];
ics=vars/.init;
unksics=Transpose[{unks,ics}];
logd=Table[If[logged&&comptype[var]==="Extensive",True,False],{var,nonfixedvars}];

VPrint[3,"unks=",unks];
VPrint[3,"unksics=",unksics];
VPrint[3,"ics=",ics];
VPrint[3,"logd=",logd];
VPrint[3,"vars=",vars];


Which[
	method=="Shooting", (* 1.7.3 \[Dash] needs Logged, periodic models *)
	VPrint[3,"Method Shooting"];
	eqns=EcoEqns[attributes,Fixed->fixed,Logged->logged]/.AddVariablets/.Gs/.ZeroGs(*/.pars*);
	eqns=eqns/.{lhs_==rhs_->lhs==Period[t]*rhs};
	AppendTo[eqns,Period'[t]==0];
	VPrint[3,"eqns=",eqns];
	bcs=Append[Replace[vars,var_->var[0]==var[1],1],Period[0]==Period[1]];
	VPrint[3,"bcs=",bcs];
	unks=Append[vars,Period];
	VPrint[3,"unks=",unks];
	ics=Append[
		Table[If[logged===True&&comptype[var]==="Extensive",log[var][0]==Log[var/.init],var[0]==(var/.init)],{var,vars}],
		Period[0]==period];
	VPrint[3,"ics=",ics];
	res=NDSolve[Join[eqns,bcs],unks,{t,0,1},
		Method->{"Shooting","StartingInitialConditions"->ics,"MaxIterations"->maxiterations},Evaluate[Sequence@@ndsolveopts]][[1]];
	VPrint[3,"res=",res];
	per=Period[0]/.res;
	res=FilterRules[res,Except[Period]];
	sol=Normal@Map[InterpolatingFunctionStretch[#,per]&,Association@res];
,
	method=="EcoSim",
	VPrint[3,"Method EcoSim"];
	If[!(modeltype=="ContinuousTime"&&modelperiod==0),Message[FindEcoCycle::noecosim];Return[$Failed]];
	If[triggervar===Automatic,
		If[Length[Select[init,#[[2]]!=0&]]!=0,
			triggervar=SelectFirst[init,#[[2]]!=0&][[1]],
			Message[FindEcoCycle::notriggervar];Return[$Failed]
		];
		VPrint[1,"triggervar=",triggervar];
	];
	triggerpos=Position[nonfixedvars,triggervar][[1,1]];

	(* warmup #1 to get on limit cycle *)
	ics2=If[warmup1>0,
		FinalSlice[EcoSim[attributes,Gs,init,warmup1,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]],
		init];
	VPrint[1,"ics2=",ics2];
	
	(* warmup #2 to find maxima *)
	extrema={};
	EcoSim[attributes,Gs,ics2,warmup2,WhenEvents->{
		WhenEvent[event,AppendTo[extrema,Table[var[t],{var,nonfixedvars}]],Evaluate[Sequence@@wheneventopts]]
		/.event->(triggervar'[t]==0)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

	If[extrema=={},Message[FindEcoCycle::nomaxima];Return[$Failed]];

	max=Last@Sort[extrema,#1[[triggerpos]]<#2[[triggerpos]]&];
	ics3=Table[nonfixedvars[[i]]->max[[i]],{i,Length[nonfixedvars]}];
	VPrint[1,"ics3=",ics3];
	
	(* warmup #3 to move a wee bit beyond the maximum *)
	ics4=FinalSlice[EcoSim[attributes,Gs,ics3,warmup3,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]];

	VPrint[1,"ics4=",ics4];

	Do[
		triggerval=triggervar/.ics4;
		sol=EcoSim[attributes,Gs,ics4,tmax,WhenEvents->{
			WhenEvent[event,"StopIntegration",Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar[t]<triggerval)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

		diff=Sum[Abs[(var/.FinalSlice[sol])-(var/.ics4)],{var,nonfixedvars}];
		If[diff<10^-accuracygoal,Break[]];

		ics4=FinalSlice[sol];
	,{maxiterations}];

	If[diff>10^-accuracygoal,Message[FindEcoCycle::cvmit,maxiterations]];
	res=sol;
,
	method=="FixedPoint"||method=="FindRoot",

	If[(modeltype=="ContinuousTime"&&modelperiod==0),
		AppendTo[unks,per];
		AppendTo[unksics,{per,period}];
		AppendTo[ics,period];
	,
		If[period===Automatic,per=modelperiod,per=period];
	];

	VPrint[3,"unks=",unks];
	VPrint[3,"unksics=",unksics];
	VPrint[3,"ics=",ics];

	(* function to advance model *)

	thing[ps_?NumericListQ]:=Module[{popz,rez},
		$FindEcoCycleSteps++;
		If[(modeltype=="ContinuousTime"&&modelperiod==0),tmax=ps[[-1]],tmax=per];
		popz=Table[If[logd[[i]],nonfixedvars[[i]]->E^ps[[i]],nonfixedvars[[i]]->ps[[i]]],{i,Length[nonfixedvars]}];
		sol=EcoSim[attributes,Gs,popz,tmax,Fixed->fixed,Evaluate[Sequence@@ecosimopts],Logged->logged];
		rez=vars/.FinalSlice[sol];
		If[(modeltype=="ContinuousTime"&&modelperiod==0),AppendTo[rez,ps[[-1]]]];
		If[printtrace,Print[$FindEcoCycleSteps,": ",FinalSlice[sol]]];
		Return[rez];
	];

	Which[
		method=="FindRoot",
		VPrint[3,"Method FindRoot"];
		res=FindRoot[thing[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]]
	,
		method=="FixedPoint",
		VPrint[3,"Method FixedPoint"];
		res=FixedPoint[thing[#]&,ics,maxiterations,SameTest->(Max[Abs[#1-#2]]<10^-accuracygoal&)];
		If[$FindEcoCycleSteps==maxiterations,Message[FindEcoCycle::cvmit,maxiterations];Return[$Failed]]
	],
	Else,
	Message[FindEcoCycle::badmtd];Return[$Failed]
];

If[modeltype=="DiscreteTime",(* drop last point *)
	sol=ReplaceAll[sol,{(var_->td_List):>(var->Drop[td,-1]),(var_->td_TemporalData)->(var->TimeSeriesWindow[td,{0,per-1}])}]
];

(* make InterpolatingFunctions Periodic *)
sol=sol/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if];

(* test relative amplitude *)
If[Max[Values[RelativeAmplitude[sol]]]<minamplitude,Message[FindEcoCycle::relamp,Max[Values[RelativeAmplitude[sol]]],minamplitude]];

(* return answer *)
Return[Sort[sol]];

]];


Options[FindEcoCycle]={Verbose->False,Verbosity->0,
Method->Automatic,Fixed->{},
FindRootOpts->{},EcoSimOpts->{},NDSolveOpts->{},
MaxIterations->100,AccuracyGoal->6,Logged->False,
WarmUp->1000,WarmUp2->100,WarmUp3->0.1,TMax->1000,TriggerVariable->Automatic,
WhenEventOpts->{"DetectionMethod"->"Interpolation","LocationMethod"->{"Brent",MaxIterations->1000}},
Period->Automatic,
MinAmplitude->10.^-3,
Monitor->False,PrintTrace->False,IgnoreVar->False
};


(* split traitsandvariables *)
FindEcoCycle[traitsandvariables_?AttributesAndVariablesQ,opts:OptionsPattern[]]:=
FindEcoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],opts];


FindEcoCycle::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoCycle::nomaxima=
"Found no maxima in warmup #3, probably not periodic solution.";

FindEcoCycle::badmtd=
"The Method option should be a built-in method name (\"FindRoot\", \"FixedPoint\", \"EcoSim\" or \"Automatic\")";

FindEcoCycle::noecosim=
"\"EcoSim\" Method only applicable to unforced ContinuousTime models.";

FindEcoCycle::notriggervar=
"Found no non-zero variable to set as trigger variable. Give one manually with option \"TriggerVar\".";

FindEcoCycle::relamp="Warning: EcoCycle relative amplitude `1` < MinAmplitude = `2`.";


$FindEcoCycleSteps::usage="Counts the number of EcoSim calls in FindEcoCycle.";


FindEcoCycleBifurcation::usage = 
"FindEcoCycleBifurcation[\!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"par\", \"TI\"]\)->\!\(\*
StyleBox[\"parinit\", \"TI\"]\)] finds an ecological limit cycle bifurcation in \!\(\*
StyleBox[\"par\", \"TI\"]\) using initial guesses \!\(\*
StyleBox[\"init\", \"TI\"]\) and \!\(\*
StyleBox[\"parinit\", \"TI\"]\).
FindEcoCycleBifurcation[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"par\", \"TI\"]\)->\!\(\*
StyleBox[\"parinit\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


FindEcoCycleBifurcation[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},initin:(_?VariablesQ):{},par_->parinit_?NumericQ,opts:OptionsPattern[]]:=

Module[{
(* options *)
verbose,period,method,monitor,printtrace,
findrootopts,ecosimopts,maxiterations,accuracygoal,precisiongoal,logged,fixed,
triggervar,warmup1,warmup2,warmup3,wheneventopts,ignorevar,
(* other variables *)
attributes,Gs,nonfixedvars,fixedvars,init,tmax,eq,
ic,thing,eqns,unks,logd,vars,ics,unksics,res,sol,per},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoCycleBifurcation"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

monitor=OptionValue[Monitor];
printtrace=OptionValue[PrintTrace];
period=OptionValue[Period];
If[period===Automatic,
	Which[
		TemporalRuleListQ[initin],
		period=ExtractPeriod[initin]
	,
		0<modelperiod<\[Infinity],
		period=modelperiod
	]
];	
VPrint[3,"period=",period];
If[period===Automatic,period=ExtractPeriod[init]];
(*Print["period=",period];*)

findrootopts=OptionValue[FindRootOpts];
ecosimopts=OptionValue[EcoSimOpts];
maxiterations=OptionValue[MaxIterations];
accuracygoal=OptionValue[AccuracyGoal];
logged=OptionValue[Logged];
fixed=OptionValue[Fixed];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
ignorevar=OptionValue[IgnoreVar];


$FindEcoCycleBifurcationSteps=0;

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* fix init *)
init=If[TemporalRuleListQ[initin],FinalSlice[initin],initin];


(* set up thing & unks *)
nonfixedvars=init[[All,1]];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* build various lists of vars *)
unks=Table[eq[var],{var,nonfixedvars}];
vars=Table[If[logged&&comptype[var]==="Extensive",Log[var],var],{var,nonfixedvars}];
ics=vars/.init;
unksics=Transpose[{unks,ics}];
logd=Table[If[logged&&comptype[var]==="Extensive",True,False],{var,nonfixedvars}];

If[(modeltype=="ContinuousTime"&&modelperiod==0),
	AppendTo[unks,per];
	AppendTo[unksics,{per,period}];
,
	If[period===Automatic,per=modelperiod,per=period];
];

(*AppendTo[unks,par];
AppendTo[unksics,{par,parinit}];*)

VPrint[3,"unks=",unks];
VPrint[3,"ics=",ics];
VPrint[3,"unksics=",unksics];
VPrint[3,"logd=",logd];
VPrint[3,"vars=",vars];

(* function to advance model *)

thing[{ps_?NumericListQ,parval_?NumericQ}]:=Module[{popz,rez,evs,ev,ret},
	par=parval;
	$FindEcoCycleBifurcationSteps++;
	If[modeltype=="ContinuousTime"&&modelperiod==0,tmax=ps[[-1]],tmax=per];
	popz=Table[If[logd[[i]],nonfixedvars[[i]]->E^ps[[i]],nonfixedvars[[i]]->ps[[i]]],{i,Length[nonfixedvars]}];
(*Print[popz];*)
	sol=EcoSim[attributes,Gs,popz,tmax,Fixed->fixed,ICSensitivity->True,Evaluate[Sequence@@ecosimopts],Logged->logged];
	rez=vars/.FinalSlice[sol];
(*Print[PlotDynamics[sol]];*)
	If[modeltype=="ContinuousTime"&&modelperiod==0,AppendTo[rez,ps[[-1]]]];
	Which[
		modeltype=="ContinuousTime",
		evs=Eigenvalues[ICSensitivity/.FinalSlice[sol]],
		modeltype=="DiscreteTime",
		evs=EcoEigenvalues[attributes,Gs,InitialSlice[sol,per-1]]
	];
	If[printtrace,Print[$FindEcoCycleBifurcationSteps,": ",Defer@par->parval," ",FinalSlice[sol], "evs=",evs]];
	Clear[par];
	ev=If[modeltype=="ContinuousTime"&&modelperiod==0,Sort[Abs[evs],Less][[-2]],Max[Abs[evs]]];
	ret={rez,ev};
(*Print[ret];*)
	Return[ret];
];

res=FindRoot[thing[{unks,param}]=={unks,1},Join[unksics,{{param,parinit}}],Evaluate[Sequence@@findrootopts]];
(* trying to calculate Jacobian - needs more sensitivity *)
(*J[x_?VectorQ]:=FinalSlice[Sensitivity/.sol];
res=FindRoot[thing[{unks,param}]\[Equal]{unks,1},Join[unksics,{{param,parinit}}],Jacobian->J[x],Evaluate[Sequence@@findrootopts]];*)
(*Print[res];*)

If[modeltype=="DiscreteTime",(* drop last point *)
	sol=ReplaceAll[sol,
		{(var_->td_List):>(var->Drop[td,-1]),(var_->td_TemporalData)->(var->TimeSeriesWindow[td,{0,per-1}])}]
];

(* make InterpolatingFunctions Periodic *)
sol=sol/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if];

(* return answer *)
Return[Join[{par->(param/.res)},SortRuleList[sol,AllVariables]]];

]];


(*(* 1.7.2 *)
FindEcoCycleBifurcation[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},init:(_?VariablesQ):{},par_->parinit_?NumericQ,opts:OptionsPattern[]]:=

Module[{
(* options *)
verbose,period,method,monitor,printtrace,
findrootopts,ecosimopts,maxiterations,accuracygoal,precisiongoal,logged,fixed,
triggervar,warmup1,warmup2,warmup3,wheneventopts,ignorevar,
(* other variables *)
attributes,Gs,nonfixedvars,fixedvars,extrema,triggerpos,triggerval,max,ics2,ics3,ics4,diff,tmax,eq,
ic,nb,thing,eqns,unks,logd,vars,unksics,ics,res,sol,per},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoCycleBifurcation"},

If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

monitor=OptionValue[Monitor];
printtrace=OptionValue[PrintTrace];
period=OptionValue[Period];
If[period===Automatic,period=ExtractPeriod[init]];
(*Print["period=",period];*)

findrootopts=OptionValue[FindRootOpts];
ecosimopts=OptionValue[EcoSimOpts];
maxiterations=OptionValue[MaxIterations];
accuracygoal=OptionValue[AccuracyGoal];
logged=OptionValue[Logged];
fixed=OptionValue[Fixed];
fixedvars=fixed\[LeftDoubleBracket]All,1\[RightDoubleBracket];
VPrint[3,"fixedvars=",fixedvars];
ignorevar=OptionValue[IgnoreVar];


$FindEcoCycleBifurcationSteps=0;

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]\[Rule]\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* set up thing & unks *)
nonfixedvars=init\[LeftDoubleBracket]All,1\[RightDoubleBracket];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* build various lists of vars *)
unks=Table[eq[var],{var,nonfixedvars}];
vars=Table[If[logged&&comptype[var]==="Extensive",Log[var],var],{var,nonfixedvars}];
If[TemporalRuleListQ[init],ics=vars/.FinalSlice[init],ics=vars/.init];
unksics=Transpose[{unks,ics}];
logd=Table[If[logged&&comptype[var]==="Extensive",True,False],{var,nonfixedvars}];

If[(modeltype\[Equal]"ContinuousTime"&&modelperiod\[Equal]0),
	AppendTo[unks,per];
	AppendTo[unksics,{per,period}];
	AppendTo[ics,period];
,
	If[period===Automatic,per=modelperiod,per=period];
];

(*AppendTo[unks,par];
AppendTo[unksics,{par,parinit}];*)

VPrint[3,"unks=",unks];
VPrint[3,"unksics=",unksics];
VPrint[3,"ics=",ics];
VPrint[3,"logd=",logd];
VPrint[3,"vars=",vars];

(* function to advance model *)

thing[{ps_?NumericListQ,parval_?NumericQ}]:=Module[{popz,rez,evs,ev,ret},
	par=parval;
(*Print[Defer@par," ",par];*)
	$FindEcoCycleBifurcationSteps++;
	If[modeltype\[Equal]"ContinuousTime"&&modelperiod\[Equal]0,tmax=ps\[LeftDoubleBracket]-1\[RightDoubleBracket],tmax=per];
	popz=Table[If[logd\[LeftDoubleBracket]i\[RightDoubleBracket],nonfixedvars\[LeftDoubleBracket]i\[RightDoubleBracket]\[Rule]E^ps\[LeftDoubleBracket]i\[RightDoubleBracket],nonfixedvars\[LeftDoubleBracket]i\[RightDoubleBracket]\[Rule]ps\[LeftDoubleBracket]i\[RightDoubleBracket]],{i,Length[nonfixedvars]}];
(*Print[popz];*)
	sol=EcoSim[attributes,Gs,popz,tmax,Fixed\[Rule]fixed,Evaluate[Sequence@@ecosimopts],Logged\[Rule]logged];
	rez=vars/.FinalSlice[sol];
(*Print[PlotDynamics[sol]];*)
	If[modeltype\[Equal]"ContinuousTime"&&modelperiod\[Equal]0,AppendTo[rez,ps\[LeftDoubleBracket]-1\[RightDoubleBracket]]];
	If[printtrace,Print[$FindEcoCycleBifurcationSteps,": ",FinalSlice[sol]]];
	Which[
		modeltype=="ContinuousTime",
		evs=EcoEigenvalues[attributes,Gs,sol,Multipliers->True],
		modeltype=="DiscreteTime",
		evs=EcoEigenvalues[attributes,Gs,InitialSlice[sol,per-1]]
	];
	Clear[par];
	ev=If[modeltype=="ContinuousTime"&&modelperiod==0,Sort[Abs[evs],Less][[-2]],Max[Abs[evs]]];
	ret={rez,ev};
(*Print[ret];*)
	Return[ret];
];


(*Print[thing[{ics,parinit}]];*)

res=FindRoot[thing[{unks,param}]\[Equal]{unks,1},Join[unksics,{{param,parinit}}],Evaluate[Sequence@@findrootopts]];
(*Print[res];*)

If[modeltype\[Equal]"DiscreteTime",(* drop last point *)
	sol=ReplaceAll[sol,
		{(var_\[Rule]td_List)\[RuleDelayed](var\[Rule]Drop[td,-1]),(var_\[Rule]td_TemporalData)\[Rule](var\[Rule]TimeSeriesWindow[td,{0,per-1}])}]
];

(* make InterpolatingFunctions Periodic *)
sol=sol/.if_InterpolatingFunction\[Rule]MakeInterpolatingFunctionPeriodic[if];

(* return answer *)
Return[Join[Sort[sol],{par->(param/.res)}]];

]];*)


Options[FindEcoCycleBifurcation]={Verbose->False,Verbosity->0,
Period->Automatic,Fixed->{},FindRootOpts->{},EcoSimOpts->{},MaxIterations->100,AccuracyGoal->6,Logged->False,
Monitor->False,PrintTrace->False,IgnoreVar->False
};


(* split traitsandvariables *)
FindEcoCycleBifurcation[traitsandvariables_?AttributesAndVariablesQ,opts:OptionsPattern[]]:=
FindEcoCycleBifurcation[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],opts];


$FindEcoCycleBifurcationSteps::usage="Counts the number of EcoSim calls in FindEcoCycleBifurcation.";


TrackEcoCycle::usage=
"TrackEcoCycle[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] tracks an ecological limit cycle, with initial guess \!\(\*
StyleBox[\"sol\", \"TI\"]\), over parameter \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\).
TrackEcoCycle[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\), \!\(\*
StyleBox[\"dpar\", \"TI\"]\)}] uses initial step size \!\(\*
StyleBox[\"dpar\", \"TI\"]\).";


TrackEcoCycle[attributesin:(_?AttributesQ):{},Gs:(_?GsQ):{},init_?VariablesQ,{parname_,parmin_?NumericQ,parmax_?NumericQ,initialstepsize_:Automatic},opts___?OptionQ]:=

Module[{
(* options *)
verbose,monitor,printtrace,
method,period,

teststability,testbend,testamplitude,
findbifurcation,

initialsteps,(*initialstepsize,*)minstepsize,maxstepsize,maxsteps,maxrecursion,maxexpansion,
maxbend,maxchange,
mindist,minamplitude,
findecocycleopts,interpolationopts,

(* other variables *)
par,dpar,parold,tmp,tmp2,ics,ics\[Prime],per,unks,count,sol,initialstability,
m0,m1,list,traits,bif
},

Block[{\[ScriptCapitalN],verbosity,func="TrackEcoCycle"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[TrackEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[TrackEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoCycle]}]];
If[Global`debug,verbose=True];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[TrackEcoCycle]}]];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[TrackEcoCycle]}]];

initialsteps=Evaluate[InitialSteps/.Flatten[{opts,Options[TrackEcoCycle]}]];
If[initialstepsize===Automatic,dpar=N[(parmax-parmin)/initialsteps],dpar=N[initialstepsize]];
(*Print["dpar=",dpar];*)

maxexpansion=Evaluate[MaxExpansion/.Flatten[{opts,Options[TrackEcoCycle]}]];
maxrecursion=Evaluate[MaxRecursion/.Flatten[{opts,Options[TrackEcoCycle]}]];
minstepsize=Evaluate[MinStepSize/.Flatten[{opts,Options[TrackEcoCycle]}]];
If[minstepsize===Automatic,minstepsize=dpar*2^-maxrecursion];
maxstepsize=Evaluate[MaxStepSize/.Flatten[{opts,Options[TrackEcoCycle]}]];
If[maxstepsize===Automatic,maxstepsize=dpar*2^maxexpansion];
maxsteps=Evaluate[MaxSteps/.Flatten[{opts,Options[TrackEcoCycle]}]];

maxbend=Evaluate[MaxBend/.Flatten[{opts,Options[TrackEcoCycle]}]];
maxchange=Evaluate[MaxChange/.Flatten[{opts,Options[TrackEcoCycle]}]];

findbifurcation=Evaluate[FindBifurcation/.Flatten[{opts,Options[TrackEcoCycle]}]];

teststability=Evaluate[TestStability/.Flatten[{opts,Options[TrackEcoCycle]}]];
testbend=Evaluate[TestBend/.Flatten[{opts,Options[TrackEcoCycle]}]];
testamplitude=Evaluate[TestAmplitude/.Flatten[{opts,Options[TrackEcoCycle]}]];

minamplitude=Evaluate[MinAmplitude/.Flatten[{opts,Options[TrackEcoCycle]}]];

findecocycleopts=Evaluate[FindEcoCycleOpts/.Flatten[{opts,Options[TrackEcoCycle]}]];
interpolationopts=Evaluate[InterpolationOpts/.Flatten[{opts,Options[TrackEcoCycle]}]];

method=Evaluate[Method/.Flatten[{opts,Options[TrackEcoCycle]}]];
If[method===Automatic&&TemporalRuleListQ[init],AppendTo[findecocycleopts,Method->"FindRoot"]];
(*Print["findecocycleopts=",findecocycleopts];*)

period=Evaluate[Period/.Flatten[{opts,Options[TrackEcoCycle]}]];
If[period===Automatic&&TemporalRuleListQ[init],per=ExtractPeriod[init],per=period];


If[monitor,PrintTemporary[Dynamic[count]," ",parname,"=",Dynamic[par]," d",parname,"=",Dynamic[dpar]]];

(* see if par is a trait *)
If[
	LookUp[parname][[1]]==="gtrait"
,
	mode="trait";
	traits:=Join[attributesin,{parname->par}];
,
	mode="par";
	Evaluate[parname]:=par;
	traits=attributesin
];
(*Print["traits=",traits];*)

unks=Keys[init];
tmp2={};
tmp={};
parold=par=parmin;
dpar=dpar/2;
ics=init;
count=0;
(*Print["ics=",ics];
Print["per=",per];*)

sol=Check[Quiet[FindEcoCycle[traits,Gs,ics,Period->per,Evaluate[Sequence@@findecocycleopts]],FindRoot::lstol],"err"];
(*Print["initial sol=",sol];*)
If[sol==="err",Message[TrackEcoCycle::ferr,Defer@parname,NumberForm@par];Return[$Aborted]];
If[teststability,initialstability=EcoStableQ[traits,Gs,sol]];
(*Print["initial ev=",EcoEigenvalues[traits,Gs,sol,Multipliers->True]];
Print["initialstability=",initialstability];*)
per=ExtractPeriod[sol];
If[modeltype=="ContinuousTime"&&modelperiod==0,
	ics=Slice[sol,(t/.FindMinimum[unks[[1]][t]/.sol,{t,0,per}][[2]])+per/1000],
	ics=InitialSlice[sol]
];
(*Print["ics=",ics];*)
(*Print["entering main loop"];*)

While[count<maxsteps,
	count++;
	sol=Check[Quiet[FindEcoCycle[traits,Gs,ics,Period->per,Evaluate[Sequence@@findecocycleopts]],FindRoot::lstol],"err"];
	If[printtrace&&sol=!="err",Print[Defer@parname,"=",NumberForm@par," InitialSlice[sol]=",InitialSlice[sol],
		" Period=",per," ev=",EcoEigenvalues[traits,Gs,sol,Multipliers->True]]];
	If[sol=!="err",
		If[modeltype=="ContinuousTime"&&modelperiod==0,
			ics\[Prime]=Slice[sol,(t/.FindMinimum[unks[[1]][t]/.sol,{t,0,per}][[2]])+per/1000],
			ics\[Prime]=InitialSlice[sol]
		]
	];
	Which[
		sol==="err",
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," Rejected: FindEcoCycle error"]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoCycle::err,Defer@parname,NumberForm@par];Break[]];
		If[dpar>0,par=Min[parmax,parold+dpar],par=Max[parmax,par+dpar]];
	,
		testamplitude&&Max[Values[RelativeAmplitude[sol]]]<minamplitude,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," Rejected: Max[RelativeAmplitude[sol]]=",Max[Values[RelativeAmplitude[sol]]]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],
			Message[TrackEcoCycle::relamp,RelativeAmplitude[sol],Defer@parname,NumberForm@parold];Break[]];
		If[dpar>0,par=Min[parmax,parold+dpar],par=Max[parmax,par+dpar]];
	,	
		teststability&&EcoStableQ[traits,Gs,sol]=!=initialstability,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," Rejected: stability change, EcoEigenvalues[sol,Multipliers->True]=",EcoEigenvalues[sol,Multipliers->True]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],
			If[findbifurcation,
				If[mode=="par",Clear[parname]];
				bif=FindEcoCycleBifurcation[traits,Gs,sol,parname->par];
				VPrint[3,"bif=",bif];
				If[mode=="par",
					par=parname=(parname/.bif),
					par=(parname/.bif)
				];
				If[printtrace,Print[Defer@parname,"=",NumberForm@par," bifurcation, sol=",ExtractVariables@bif," EcoEigenvalues=",EcoEigenvalues[traits,ExtractVariables@bif,Multipliers->True]]];
				Message[TrackEcoCycle::chst,initialstability,!initialstability,Defer@parname,NumberForm@par,EcoEigenvalues[traits,ExtractVariables@bif,Multipliers->True]];
				tmp[[-1]]={par,ExtractVariables[bif]}; (* ??? *)
				AppendTo[tmp2,{ToString@(par/.bif)->ExtractVariables[bif]}];
			,
				Message[TrackEcoCycle::chsta,initialstability,!initialstability,Defer@parname,NumberForm@parold,NumberForm@par,EcoEigenvalues[traits,sol]];
			];
			Break[]
		];
		(*par=parold+dpar;*)
		If[dpar>0,par=Min[parmax,parold+dpar],par=Max[parmax,par+dpar]];
	,
		testbend&&
			Length[tmp]>=2&&CompoundOr[Table[
				m1=((unk/.tmp[[-1,2]])-(unk/.tmp[[-2,2]]))/(tmp[[-1,1]]-tmp[[-2,1]]);
				m0=((unk/.ics\[Prime])-(unk/.tmp[[-1,2]]))/(par-tmp[[-1,1]]);
				list=Table[unk/.ent[[2]],{ent,tmp}];
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]]>maxbend
				&&
				Abs[(unk/.ics\[Prime])-(unk/.tmp[[-1,2]])]/(10^-10+Differences[{Min[list],Max[list]}][[1]])>maxchange
			,{unk,unks}]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," Rejected: MaxBend exceeded"]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoCycle::bend,Defer@parname,NumberForm@par];Break[]];
		If[dpar>0,par=Min[parmax,parold+dpar],par=Max[parmax,par+dpar]];
	,
		Else, (* success *)
		AppendTo[tmp,{par,ics\[Prime]}];
		AppendTo[tmp2,{ToString@par->sol}];
		per=ExtractPeriod[sol];
		If[par==parmax,Break[]]; (* reached end *)
		If[dpar>0,
			dpar=Min[maxstepsize,2dpar];
			parold=par;
			par=Min[parmax,par+dpar];
		,
			dpar=Max[maxstepsize,2dpar];
			parold=par;
			par=Max[parmax,par+dpar];
		];
		(*Print["OK {dpar\[Prime],par\[Prime]}=",{dpar,par}];*)
	];
	ics=Quiet[Slice[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]],par],{Interpolation::inhr,InterpolatingFunction::dmval}];
];

If[count==maxsteps,Message[TrackEcoCycle::mxst,maxsteps,Defer@parname,NumberForm@par]];

Quiet@Unset[parname];

Return[ParametricDynamics[Association@@tmp2,Parameter->(*ToString@*)parname,Type->"Continuous",ModelType->modeltype]]
]];


Options[TrackEcoCycle]={
	Verbose->False,Verbosity->1,
	PrintTrace->False,Monitor->True,
	InitialSteps->100,
	MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->200,MaxRecursion->10,MaxExpansion->3,
	TestStability->True,TestBend->True,TestAmplitude->True,
	FindBifurcation->True,
	FindEcoCycleOpts->{},InterpolationOpts->{},
	MinDistance->10^-10,MaxBend->3,MaxChange->0.01,
	MinAmplitude->10.^-3,
	Period->Automatic,Method->Automatic
};


TrackEcoCycle::err="FindEcoCycle failed at `1`=`2`.";
TrackEcoCycle::ferr="FindEcoCycle failed at initial parameter value,`1`=`2`, can not continue.";
TrackEcoCycle::chst="Stability change from `1` to `2` at `3`=`4`, Floquet multipliers=`5`.";
TrackEcoCycle::chsta="Stability change from `1` to `2` between `3`=`4` and `3`=`5`, Floquet multipliers=`6`.";
TrackEcoCycle::mxst="Maximum number of `1` steps reached at `2`=`3`.";
TrackEcoCycle::relamp="EcoCycle amplitude `1` < MinAmplitude at `2`=`3`.";
TrackEcoCycle::bend="MaxBend reached at `1`=`2`. Try a smaller initial step size (or it could be a bifurcation point).";


EcoJacobian::usage = 
"EcoJacobian[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] returns the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"sol\", \"TI\"]\).
EcoJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoJacobian[in___]:=Module[{func=EcoJacobian,args,opts,pars,atts,Gs,vars,varslist},
args=Join[ExtractArgs[{in},func]];
opts=ExtractOpts[{in},func];

pars=ExtractParameters[args];
atts=ExtractAttributes[args];
Gs=ExtractVarCovs[args];
vars=ExtractVariables[args];
varslist=Select[Select[args,RuleListQ],VariablesQ];

If[varslist=={},
	iEcoJacobian[pars,atts,Gs,vars,opts],
	iEcoJacobian[pars,atts,Gs,#,opts]&/@varslist
]];


iEcoJacobian[pars_,attributesin_,Gsin_,variables_,opts___?OptionQ]:=

Module[{
(* options *)
verbose,time,fixed,method,\[Epsilon]in,
(* other variables *)
attributes,fixedvars,Gs,eqns,unks,jmat},

Block[{\[ScriptCapitalN],verbosity,func="EcoJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoJacobian]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoJacobian]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoJacobian]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoJacobian]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoJacobian]}]];
method=Evaluate[Method/.Flatten[{opts,Options[EcoJacobian]}]];
\[Epsilon]in=Evaluate[AbsoluteStepSize/.Flatten[{opts,Options[EcoJacobian]}]];
fixedvars=fixed[[All,1]];

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Join[Gsin,ExtractVarCovs[attributesin]]==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}
];

(*Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]\[Rule]\[ScriptCapitalN][gu],{gu,guilds}]];*)
VPrint[3,"Gs=",Gs];

eqns=EcoEqns[attributes,opts]/.RHS/.Gs/.pars/.t->time;
VPrint[1,"eqns=",eqns];

unks=OrderedComplement[AllVariables,fixedvars];
VPrint[1,"unks=",unks];

(* set up \[Epsilon]'s *)
Which[
	NumberQ[\[Epsilon]in],Do[\[Epsilon][ToString@unk]=\[Epsilon]in,{unk,unks}],
	ListQ[\[Epsilon]in],Table[\[Epsilon][ToString@unk],{unk,unks}]=\[Epsilon]in
];

(* set up jacobian *)
Which[
	method===Automatic,
	jmat=D[eqns,{unks}]//DerivativesToFiniteDifferences,
	method==="FiniteDifference",
	jmat=Table[((eqns/.unk->unk+\[Epsilon]/2)-(eqns/.unk->unk-\[Epsilon]/2))/\[Epsilon],{unk,unks}]
];
VPrint[3,"jmat=",jmat];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&(variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t,
	Return[TimeSeries[Table[{t\[Prime],jmat/.AddVariablets/.t->t\[Prime]},{t\[Prime],variables[[1,2]]["Times"]}]/.variables/.attributes]];
,
	(* ContinuousTime cycle *)
	variables!={}&&(variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinuousTime"&&modelperiod=!=0))&&time===t,
	Return[jmat/.AddVariablets/.variables/.attributes];
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	If[time===t,
		Return[jmat/.Dispatch[variables]/.Dispatch[attributes]],
		(*Return[jmat/.variables/.attributes],*)
		Return[jmat/.Slice[variables,time]/.attributes]
	];
];

]];


Options[EcoJacobian]={Verbose->False,Verbosity->0,IgnoreVar->True,
Time->t,Fixed->{},Method->Automatic,AbsoluteStepSize->10.^-6};


EcoEigenvalues::usage = 
"EcoEigenvalues[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] returns the eigenvalues of the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"sol\", \"TI\"]\).
EcoEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoEigenvalues[in___]:=Module[{func=EcoEigenvalues,args,opts,pars,atts,Gs,vars,varslist},
(*Print[func];*)
args=Join[ExtractArgs[{in},func]];
opts=ExtractOpts[{in},func];
(*Print["args=",args];
Print["opts=",opts];*)

pars=ExtractParameters[args];
atts=ExtractAttributes[args];
Gs=ExtractVarCovs[args];
vars=ExtractVariables[args];
varslist=Select[Select[args,RuleListQ],VariablesQ];
(*Print["pars=",pars];
Print["atts=",atts];
Print["Gs=",Gs];
Print["vars=",vars];
Print["varslist=",varslist];*)

If[varslist=={},
	iEcoEigenvalues[pars,atts,Gs,vars,opts],
	iEcoEigenvalues[pars,atts,Gs,#,opts]&/@varslist
]];


iEcoEigenvalues[pars_,attributesin_,Gsin_,variables_,opts___?OptionQ]:=

Module[{
(* options *)
verbose,chop,time,ndsolveopts,multipliers,fixed,ignorevar,eigenvaluesopts,
(* other variables *)
attributes,j,dim,per,xsol,res},

Block[{\[ScriptCapitalN],verbosity,func="EcoEigenvalues"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEigenvalues]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEigenvalues]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEigenvalues]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEigenvalues]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEigenvalues]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEigenvalues]}]];
multipliers=Evaluate[Multipliers/.Flatten[{opts,Options[EcoEigenvalues]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEigenvalues]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEigenvalues]}]];
eigenvaluesopts=Evaluate[EigenvaluesOpts/.Flatten[{opts,Options[EcoEigenvalues]}]];

attributes=FixAttributes[attributesin];

j=EcoJacobian[pars,attributes,Gsin,variables,Time->time,Fixed->fixed,IgnoreVar->ignorevar,Verbosity->verbosity];
VPrint[1,"j=",j];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&((variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t),
	res=Eigenvalues[ListMultiplier[Table[j[t\[Prime]],{t\[Prime],j["Times"]}]],Sequence@@eigenvaluesopts]
,
	(* ContinousTime cycle *)
	variables!={}&&((variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinousTime"&&modelperiod=!=0))&&time===t),
	dim=Length[j];
	per=FinalTime[variables];
	xsol=NDSolve[{x'[t]==j . x[t],x[0]==IdentityMatrix[dim]},x,{t,0,per},Sequence@@ndsolveopts][[1]];
	If[Global`debug,Print[func,": x[per]/.xsol=",x[per]/.xsol]];
	If[multipliers,
		res=Eigenvalues[x[per]/.xsol],
		res=Log[Chop[Eigenvalues[x[per]/.xsol,Sequence@@eigenvaluesopts]]]/per
	]
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	res=Eigenvalues[j/.t->time,Sequence@@eigenvaluesopts]
];

If[chop,Return[Chop[res]],Return[res]];

]];


Options[EcoEigenvalues]={Verbose->False,Verbosity->0,
Chop->True,Time->t,NDSolveOpts->{},Multipliers->False,Fixed->{},EigenvaluesOpts->{},
IgnoreVar->False};


EcoStableQ::usage=
"EcoStableQ[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] reports the linear stability of ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) as True, False, or Indeterminate.
EcoStableQ[\!\(\*
StyleBox[\"attribues\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


(* make listable across variables *)
EcoStableQ[par:(_?ParametersQ):{},attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=
(EcoStableQ[par,attributes,Gsin,#,opts]&/@variables);
(* break up traitsandpops *)
EcoStableQ[par:(_?ParametersQ):{},traitsandpops_?AttributesAndVariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=EcoStableQ[
	par,ExtractAttributes[traitsandpops],Gsin,ExtractVariables[traitsandpops],opts];


EcoStableQ[parsin:(_?ParametersQ):{},attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},variablesin:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{
(* options *)
method,verbose,time,ecoeigenvaluesopts,tolerance,simplifyresult,simplifyopts,fixed,ignorevar,parameter,
(* other variables *)
pars,attributes,Gs,variables,midpt,j,evs,res},

Block[{\[ScriptCapitalN],verbosity,func="EcoStableQ"},

(*Print["parsin=",parsin];
Print["attributesin=",attributesin];
Print["Gsin=",Gsin];
Print["variablesin=",variablesin];*)

If[ParametricRuleListQ[variablesin],
	midpt=(InitialParameterValue[variablesin]+FinalParameterValue[variablesin])/2;
	pars=Append[parsin,ParameterName[variablesin]->midpt];
	variables=Slice[variablesin,midpt];
,
	pars=parsin;
	variables=variablesin;
];

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoStableQ]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoStableQ]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoStableQ]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[EcoStableQ]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoStableQ]}]];
ecoeigenvaluesopts=Evaluate[EcoEigenvaluesOpts/.Flatten[{opts,Options[EcoStableQ]}]];
tolerance=Evaluate[Tolerance/.Flatten[{opts,Options[EcoStableQ]}]];
simplifyresult=Evaluate[SimplifyResult/.Flatten[{opts,Options[EcoStableQ]}]];
simplifyopts=Evaluate[SimplifyOpts/.Flatten[{opts,Options[EcoStableQ]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoStableQ]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoStableQ]}]];
parameter=Evaluate[Parameter/.variables];
(*Print["variables=",variables];
Print["parameter=",parameter];*)

(* fix attributes *)
attributes=FixAttributes[attributesin];

j="undefined";

If[method===Automatic,
	If[modeltype=!="ContinuousTime"||modelperiod=!=0||InterpolatingFunctionFunctionQ[variables]==True||Length[variables]>=4,
		method="Eigenvalues"
	,
		j=EcoJacobian[pars,attributes,Gsin,variables,Time->time,Fixed->fixed,IgnoreVar->ignorevar];
		If[NumericFlattenedListQ[j],method="Eigenvalues",method="RouthHurwitz"]
	];
	VPrint[3,"method=",method];
];

Which[
	method=="RouthHurwitz",
	If[j==="undefined",j=EcoJacobian[pars,attributes,Gsin,variables,Time->time,Fixed->fixed,IgnoreVar->ignorevar]];
	res=RouthHurwitzCriteria[j];
,
	method=="Eigenvalues",
	If[j==="undefined",
		evs=EcoEigenvalues[pars,attributes,Gsin,variables,Time->time,Fixed->fixed,IgnoreVar->ignorevar,Evaluate[Sequence@@ecoeigenvaluesopts]],
		evs=Eigenvalues[j/.t->time]
	];
	VPrint[1,"evs=",evs];
	If[tolerance===Automatic,
		If[NumericQ[Max[Re[evs]]],
			If[modeltype=="ContinuousTime"&&modelperiod==0&&InterpolatingFunctionFunctionQ[variables]==True,
				tolerance=10^-6,
				tolerance=10^-8],
			tolerance=0
		];
	];
	VPrint[3,"tolerance=",tolerance];
	Which[
		modeltype=="DiscreteTime",
		res=Piecewise[{
			{True,Max[Abs[evs]]<1+tolerance},
			{False,Max[Abs[evs]]>1+tolerance}
		},Indeterminate],
		modeltype=="ContinuousTime",
		res=Piecewise[{
			{True,Max[Re[evs]]<tolerance},
			{False,Max[Re[evs]]>tolerance}
		},Indeterminate]
	];
];

VPrint[3,"res=",res];

Which[
	simplifyresult===True,
	CheckAssumptions;
	Return[Simplify[res,Evaluate[Sequence@@simplifyopts]]],
	simplifyresult===Full,
	CheckAssumptions;
	Return[FullSimplify[res,Evaluate[Sequence@@simplifyopts]]],
	simplifyresult===Real,
	CheckAssumptions;
	Return[RealSimplify[res,Evaluate[Sequence@@simplifyopts]]],
	Else,
	Return[res]
];


]];


Options[EcoStableQ]={Verbose->False,Verbosity->0,
Parameter->None,
Method->Automatic,SimplifyResult->Real,SimplifyOpts->{Assumptions:>DeleteCases[$Assumptions,False]},
Time->t,EcoEigenvaluesOpts->{},Tolerance->Automatic,Fixed->{},IgnoreVar->False};


SelectEcoStable::usage=
"SelectEcoStable[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects stable equilibria from \!\(\*
StyleBox[\"sol\", \"TI\"]\).
SelectEcoStable[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


SelectEcoStable[attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},sol_?ListOfVariablesQ,opts___?OptionQ]:=
Module[{stableqopts},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

stableqopts=FilterRules[Flatten[{opts,Options[SelectEcoStable]}],Options[EcoStableQ]];

Return[Select[sol,EcoStableQ[attributes,Gsin,#,Evaluate[Sequence@@stableqopts]]&]]

];


SelectEcoStable[attributes:(_?AttributesQ):{},{},opts___?OptionQ]:={};


Options[SelectEcoStable]={};


FindEcoAttractor::usage=
"FindEcoAttractor[] tries to find an ecological attractor.
FindEcoAttractor[\!\(\*
StyleBox[\"init\", \"TI\"]\)] uses initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoAttractor[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
FindEcoAttractor[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and \!\(\*
StyleBox[\"init\", \"TI\"]\).";


FindEcoAttractor[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables:(_?VariablesQ):{},vars:(_List|All):All,opts___?OptionQ]:=

Module[{
(*options*)
verbose,method,chop,numtries,eqtolerance,
solveecoeqopts,nsolveecoeqopts,findecoeqopts,ecosimopts,findecocycleopts,
warmup,tmax,finaltmax,eqthreshold,time,period,maxperiod,maxperiodmultiplier,
testvalidity,teststability,fixed,ignorevar,
(*other variables*)
attributes,Gs,nonvars,eq,valideq,tmp,evs,ics,stableeq,res,essol,ddt,eqflag,per,ecosimflag},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoAttractor"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoAttractor]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoAttractor]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[!MemberQ[{Automatic,"SolveEcoEq","NSolveEcoEq","FindEcoEq","EcoSim","FindEcoCycle"},method],
	Message[FindEcoAttractor::badmtd];Return[$Failed]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoAttractor]}]];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqtolerance=Evaluate[EqTolerance/.Flatten[{opts,Options[FindEcoAttractor]}]];
solveecoeqopts=Evaluate[SolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
nsolveecoeqopts=Evaluate[NSolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecoeqopts=Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecocycleopts=Evaluate[FindEcoCycleOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
warmup=Evaluate[WarmUp/.Flatten[{opts,Options[FindEcoAttractor]}]];
tmax=Evaluate[TMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[tmax===Automatic,If[modelperiod==0||modelperiod==\[Infinity],tmax=1000,tmax=100*modelperiod]];
finaltmax=Evaluate[FinalTMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[finaltmax===Automatic,finaltmax=tmax];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqthreshold=Evaluate[EqThreshold/.Flatten[{opts,Options[FindEcoAttractor]}]];
time=Evaluate[Time/.Flatten[{opts,Options[FindEcoAttractor]}]];
period=Evaluate[Period/.Flatten[{opts,Options[FindEcoAttractor]}]];
maxperiod=Min[tmax-1,Evaluate[MaxPeriod/.Flatten[{opts,Options[FindEcoAttractor]}]]];
maxperiodmultiplier=Evaluate[MaxPeriodMultiplier/.Flatten[{opts,Options[FindEcoAttractor]}]];
testvalidity=Evaluate[TestValidity/.Flatten[{opts,Options[FindEcoAttractor]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[FindEcoAttractor]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoAttractor]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[FindEcoAttractor]}]];

ecosimflag=False;

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

If[vars===All,
	nonvars={},
	nonvars=OrderedComplement[AllVariables,vars]
];
(*Print["nonvars=",nonvars];*)

fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->0),1]];
(*Print["fixed=",fixed];*)

solveecoeqopts=Join[solveecoeqopts,{Fixed->fixed,IgnoreVar->ignorevar}];
nsolveecoeqopts=Join[nsolveecoeqopts,{Fixed->fixed,IgnoreVar->ignorevar}];
findecoeqopts=Join[findecoeqopts,{Fixed->fixed,IgnoreVar->ignorevar}];
ecosimopts=Join[ecosimopts,{Fixed->fixed,IgnoreVar->ignorevar}];
findecocycleopts=Join[findecocycleopts,{Fixed->fixed,IgnoreVar->ignorevar}];

If[method===Automatic,
	Which[
		modelperiod==\[Infinity]&&time===t,
		method="EcoSim",
		0<modelperiod<\[Infinity]&&time===t,
		method="FindEcoCycle",
		variables=={},
		method="NSolveEcoEq",
		Else,
		If[nauxs+npops+Sum[\[ScriptCapitalN][gu]*ngcomps[gu],{gu,guilds}]-Length[fixed]<=4,
			method="NSolveEcoEq",
			method="FindEcoEq"
		];
	];
];
VPrint[3,"method=",method];

Which[
	method=="EcoSim",Goto[ecosim],
	method=="FindEcoCycle",If[icsin=={},Message[FindEcoAttractor::novars,"FindEcoCycle"];Return[$Failed],ics=icsin];
	Goto[findecocycle]
];


(* method FindEcoEq *)

If[method=="FindEcoEq",
	VPrint[1,"FindEcoEq Mode"];
	If[variables=={},Message[FindEcoAttractor::novars,"FindEcoEq"];Return[$Failed]];
	If[warmup>0,
		VPrint[1,"Warming Up..."];
		If[verbosity>=1,
			With[{warmup=warmup,time=time,attributes=attributes,Gs=Gs,options=Sequence@@ecosimopts},
				PrintCall[Global`ics=FinalSlice[EcoSim[attributes,Gs,variables,warmup,Time->time,options]]]]
		];
		ics=FinalSlice[EcoSim[attributes,Gs,variables,warmup,Time->time,Evaluate[Sequence@@ecosimopts]]];
	, (* else *)
		ics=variables;
	];
	If[verbosity>=1,
		With[{ics=ics,time=time,attributes=attributes,Gs=Gs,options=Sequence@@findecoeqopts},
			PrintCall[Global`eq=FindEcoEq[attributes,Gs,ics,Time->time,options]]]
	];
	eq={FindEcoEq[attributes,Gs,ics,Time->time,Evaluate[Sequence@@findecoeqopts]]};

	(* try more initial conditions if required *)

	If[numtries>=2,
		Do[
			(* perturb ICs *)
			ics=ReplacePart[#,2->#[[2]]*10^RandomReal[{-1,1}]]& /@ variables;
			If[verbosity>=1,
				With[{ics=ics,time=time,attributes=attributes,Gs=Gs,options=Sequence@@findecoeqopts},
					PrintCall[Global`tmp=FindEcoEq[attributes,Gs,ics,Time->time,options]]]
			];
			tmp=FindEcoEq[attributes,Gs,ics,Time->time,Evaluate[Sequence@@findecoeqopts]];
			(* if distinct eq, add to tmp *)
			If[tmp!={},
				If[CompoundAnd[Table[RuleListDistance[tmp,bar,DistanceFunction->ChessboardDistance]>eqtolerance,{bar,eq}]],AppendTo[eq,tmp]];
			];
		,{numtries-1}];
	];	
];


(* method SolveEcoEq *)

If[method=="SolveEcoEq",
	VPrint[1,"SolveEcoEq Mode"];
	If[verbosity,
		With[{time=time,attributes=attributes,Gs=Gs,options=Sequence@@solveecoeqopts},
			PrintCall[Global`eq=SolveEcoEq[attributes,Gs,Time->time,options]]]
	];
	eq=SolveEcoEq[attributes,Gs,Time->time,Evaluate[Sequence@@solveecoeqopts]];
];


(* method NSolveEcoEq *)

If[method=="NSolveEcoEq",
	VPrint[1,"NSolveEcoEq Mode"];
	If[verbosity>=1,
		With[{time=time,attributes=attributes,Gs=Gs,options=Sequence@@nsolveecoeqopts},
			PrintCall[Global`eq=Union[NSolveEcoEq[attributes,Gs,Time->time,options]]]]
	];
	eq=Union[Flatten[{NSolveEcoEq[attributes,Gs,Time->time,Evaluate[Sequence@@nsolveecoeqopts]]},1]];
];


(* method FindEcoCycle *)

Label[findecocycle];
If[method=="FindEcoCycle",
	VPrint[1,"FindEcoCycle Mode"];
	If[variables=={},Message[FindEcoAttractor::novars,"FindEcoCycle"];Abort[]];

	(* figure out period to try *)
	If[period===Automatic,
		Which[
			modelperiod=!=0,
			per=modelperiod,
			modeltype=="DiscreteTime",
			per=1
		]
	,
		per=period
	];

	If[ecosimflag==False, (* if we haven't already been through ecosim *)
		If[warmup>0,
			VPrint[1,"Warming up..."];
			If[verbosity>=1,
				With[{warmup=warmup,per=per,time=time,attributes=attributes,Gs=Gs,options=Sequence@@ecosimopts},
					PrintCall[Global`ics=FinalSlice[EcoSim[attributes,Gs,variables,Floor[warmup,per],Time->time,options]]]]
			];
			ics=FinalSlice[EcoSim[attributes,Gs,variables,Floor[warmup,per],Time->time,Evaluate[Sequence@@ecosimopts]]];
		, (* else *)
			ics=variables;
		],
		ics=FinalSlice[essol] (* if we have been through ecosim *)
	];
	
	Which[
		modeltype=="DiscreteTime",
		If[verbosity>=1,
			With[{ics=ics,per=per,maxperiodmultiplier=maxperiodmultiplier,attributes=attributes,Gs=Gs,options=Sequence@@findecocycleopts},
				PrintCall[Global`eq=Table[FindEcoCycle[attributes,ics,Gs,options,Period->Global`permult*per],{Global`permult,maxperiodmultiplier}]]]
		];
		eq=Table[
			FindEcoCycle[attributes,ics,Gs,Evaluate[Sequence@@findecocycleopts],Period->permult*per]
		,{permult,maxperiodmultiplier}];
		(* remove $Failed & multiple period solutions *)
		eq=Select[eq,#=!=$Failed&&FindPeriod[#]==#[[1,2]]["PathLength"]&];
	,
		modeltype=="ContinuousTime",
		If[verbosity>=1,
			With[{ics=ics,attributes=attributes,Gs=Gs,options=Sequence@@findecocycleopts},
				PrintCall[Global`eq=FindEcoCycle[attributes,ics,Gs,options]]]
		];
		eq=Select[{FindEcoCycle[attributes,ics,Gs,Evaluate[Sequence@@findecocycleopts]]},#=!=$Failed&]
	];	
];

VPrint[1,"eq=",eq];


(* assess validity and stability of eq *)

If[testvalidity,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		valideq={}
	, 
		If[Head[eq[[1,1,2]]]=!=InterpolatingFunction,
			valideq=SelectValid[eq];
			VPrint[1,"valideq=",valideq];
		,
			valideq=eq (* SelectValid doesn't work on InterpolatingFunctions yet *)
		]
	];
	If[valideq=={},Message[FindEcoAttractor::novalideq]];
];

If[teststability,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		stableeq={}
	,
		stableeq=SelectEcoStable[attributes,Gs,valideq,Time->time,Fixed->fixed,IgnoreVar->ignorevar];
		VPrint[1,"stableeq=",stableeq];
	]
,
	stableeq=valideq
];

If[Length[stableeq]==0, (* no stable eq, try EcoSim once *)
	If[ecosimflag==False,
		Message[FindEcoAttractor::nosteq,attributes];
		method="EcoSim"
	,
		Message[FindEcoAttractor::giveup];
		(*Return[EcoSim[attributes,FinalSlice[essol],finaltmax,Time\[Rule]time,Evaluate[Sequence@@ecosimopts],VerboseAll\[Rule]verboseall]]*)
		Return[essol]
	]
];
If[Length[stableeq]==1,res=stableeq[[1]];Goto[done]]; (* successful *)
If[Length[stableeq]>=2,Message[FindEcoAttractor::musteq,Length[stableeq],attributes];method="EcoSim"(*;Goto[done]*)];


(* if we're still here, no stable equilibrium, so switch to EcoSim *)

(* method EcoSim *)

Label[ecosim];
If[method=="EcoSim",
	VPrint[1,"EcoSim Mode"];
	If[variables=={},Message[FindEcoAttractor::novars,"EcoSim"];Abort[]];
	
	If[Length[ics]==0,ics=variables];
	
	If[verbosity>=1,
		With[{ics=ics,tmax=tmax,time=time,attributes=attributes,Gs=Gs,options=Sequence@@ecosimopts},
			PrintCall[Global`essol=EcoSim[attributes,Gs,ics,tmax,Time->time,options]]]
	];

	Global`essol=essol=EcoSim[attributes,Gs,ics,tmax,Time->time,Evaluate[Sequence@@ecosimopts]];
	VPrint[1,PlotDynamics[essol]];
	
	(* if aperiodically forced, we're done *)
	If[modelperiod===\[Infinity],res=essol;Goto[done]];
	
	(* otherwise check for equilibrium (or modelperiod cycle) *)
	If[0<modelperiod,
		ddt=FinalDerivatives[essol,modelperiod][[All,2]],
		ddt=FinalDerivatives[essol][[All,2]]
	];
	VPrint[1,"d/dt=",ddt];
	If[Max[Abs[ddt]]<eqthreshold,
		VPrint[1,": Equilibrium found"];
		(* construct stableeq *)
		If[modelperiod=!=0,
			If[modeltype=="ContinuousTime",res=FinalSlice[essol,modelperiod]];
			If[modeltype=="DiscreteTime",res=FinalSlice[essol,modelperiod-1]]
		,
			res=FinalSlice[essol]
		];
		Goto[done];
	,
		(* steady state eq failed *)
		Message[FindEcoAttractor::nostst,ddt,tmax];
		If[SelectValid[{FinalSlice[essol]}]!={},
			(* attempt to find Period using FindEcoCycle approach *)
			ecosimflag=True; (* already been through ecosim *)
			method="FindEcoCycle";
			ics=FinalSlice[essol];
			period=FindPeriod[essol,MaxPeriod->maxperiod];
			Goto[findecocycle],
			Message[FindEcoAttractor::giveup2];
			Return[essol]
		];
	];
];

Label[done];

If[chop,
	Return[Chop[res]],
	Return[res]
];

]];


Options[FindEcoAttractor]={Verbose->False,Verbosity->0,
Method->Automatic,Chop->True,NumTries->1,EqTolerance->10^-10;
SolveEcoEqOpts->{},NSolveEcoEqOpts->{},FindEcoEqOpts->{},EcoSimOpts->{},FindEcoCycleOpts->{},
WarmUp->0,TMax->Automatic,EqThreshold->10^-5,Time->t,Period->Automatic,MaxPeriod->16,MaxPeriodMultiplier->2,
TestValidity->True,TestStability->True,FinalTMax->Automatic,Fixed->{},IgnoreVar->False};


FindEcoAttractor::badmtd=
"The Method option should be a built-in method name (\"SolveEcoEq\", \"NSolveEcoEq\", \"FindEcoEq\", or \"EcoSim\")";

FindEcoAttractor::novars=
"No initial population sizes given, cannot continue with `1`.";

FindEcoAttractor::nocycle=
"Warning: couldn't find a cycle with period less than MaxPeriod=`1`.";

FindEcoAttractor::novalideq=
"Couldn't find a valid equilibrium.";

FindEcoAttractor::giveup=
"Couldn't find an equilibrium or cycle, returing EcoSim.";

FindEcoAttractor::nosteq=
"Warning: couldn't find a stable equilibrium with attributes `1`. Trying EcoSim.";

FindEcoAttractor::musteq=
"Warning: found `1` stable equilibria with attributes `2`.";

FindEcoAttractor::nostst=
"Warning: EcoSim did not find a steady state (d/dt=`1` at t=`2`). Trying FindEcoCycle.";


PlotEcoIsoclines::usage =
"PlotEcoIsoclines[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoIsoclines[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)},{\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoIsoclines[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,fixed,time,percapita,isoclinestyle,framelabel,contourplotopts,ignorevar,
(* other variables *)
attributes,Gs,fixedvars,nonfixedvars,lookup1,lookup2,style1,style2,label1,label2,g,res1,res2},

Block[{\[ScriptCapitalN],verbosity,func="PlotEcoIsoclines"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoIsoclines]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoIsoclines]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];

time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
(*isoclinelabels=Evaluate[IsoclineLabels/.Flatten[{opts,Options[PlotEcoIsoclines]}]];*)
{label1,label2}={ToString[var1],ToString[var2]};

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* figure out what are the components on the x- and y-axes *)
lookup1=LookUp[var1];
lookup2=LookUp[var2];

(* set up isocline styles *)
Which[
	lookup1[[1]]=="gcomp",
	style1=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var1]}],{Thickness[0.005],Color[var1][0]}],isoclinestyle[[1]]],
	lookup1[[1]]=="pcomp"||lookup1[[1]]=="aux",
	style1=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var1]}],{Thickness[0.005],Color[var1]}],isoclinestyle[[1]]]
];

Which[
	lookup2[[1]]=="gcomp",
	style2=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var2]}],{Thickness[0.005],Color[var2][1]}],isoclinestyle[[2]]],
	lookup2[[1]]=="pcomp"||lookup2[[1]]=="aux",
	style2=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var2]}],{Thickness[0.005],Color[var2]}],isoclinestyle[[2]]]
];

(*Print[{style1,style2}];*)

nonfixedvars={var1,var2};

(* look for aux and pcomps not in the vars, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

contourplotopts=FilterRules[Flatten[{opts,ContourShading->None,Options[PlotEcoIsoclines]}],Options[ContourPlot]];
(*Print["contourplotopts=",contourplotopts];*)

g=(EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,IgnoreVar->ignorevar,opts]/.RHS/.Gs/.{t->time})
	-Which[modeltype=="DiscreteTime"&&percapita==False,{var1,var2},modeltype=="DiscreteTime"&&percapita==True,{1,1},Else,{0,0}];
VPrint[1,"g=",g];

res1=ContourPlot[g[[1]]==0,{var1,var1min-10^-8(var1max-var1min),var1max},{var2,var2min-10^-8(var2max-var2min),var2max},
	ContourStyle->style1,Evaluate[Sequence@@contourplotopts],FrameLabel->framelabel,
	ContourLabels->{None,Tooltip[Null,DisplayForm[OverDot[var1]==0]]&}];
	
res2=ContourPlot[g[[2]]==0,{var1,var1min-10^-8(var1max-var1min),var1max},{var2,var2min-10^-8(var2max-var2min),var2max},
	ContourStyle->style2,Evaluate[Sequence@@contourplotopts],FrameLabel->framelabel,
	ContourLabels->{None,Tooltip[Null,DisplayForm[OverDot[var2]==0]]&}];

If[monitor,NotebookClose[nb]];

Return[Show[res1,res2]]

]];


Options[PlotEcoIsoclines]={Verbose->False,Verbosity->0,
Time->t,PerCapita->False,Fixed->{},IgnoreVar->False,IsoclineStyle->Automatic,FrameLabel->Automatic,MaxRecursion->5};


PlotEcoStreams::usage =
"PlotEcoStreams[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoStreams[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoStreams[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoStreams"],
(* options *)
verbose,verboseall,fixed,time,framelabel,streamplotopts,ignorevar,
(* other variables *)
attributes,Gs,fixedvars,nonfixedvars,g,res},

Block[{\[ScriptCapitalN],verbosity,func="PlotEcoStreams"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoStreams]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoStreams]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoStreams]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];

time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoStreams]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[PlotEcoStreams]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEcoStreams]}],Options[StreamPlot]];

nonfixedvars={var1,var2};

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

g=(EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,IgnoreVar->ignorevar,opts]/.RHS/.Gs/.{t->time})
	-If[modeltype=="DiscreteTime",{var1,var2},{0,0}];
VPrint[1,"g=",g];

res=MyStreamPlot[g,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@streamplotopts],PlotRange->{{0,1},{0,1}},FrameLabel->framelabel];
		
If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotEcoStreams]={Verbose->False,Verbosity->0,
Fixed->{},Time->t,IgnoreVar->False,FrameLabel->Automatic,PlotRangePadding->Scaled[0.02],StreamStyle->Gray,StreamColorFunction->None};


PlotEcoPhasePlane::usage=
"PlotEcoPhasePlane[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams and isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoPhasePlane[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoPhasePlane[attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{nonfixedvars,eq,Gs,
(* options *)
fixed,fixedvars,
findecoeqopts,plotecoisoclinesopts,plotecostreamsopts,ecostableqopts,rulelistplotopts,
verbose},

Block[{verbosity},

(* handle options *)

plotecoisoclinesopts=FilterRules[
	Flatten[{Evaluate[PlotEcoIsoclinesOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoIsoclines],Options[ContourPlot]]];
plotecostreamsopts=FilterRules[
	Flatten[{Evaluate[PlotEcoStreamsOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoStreams],Options[StreamPlot]]];
findecoeqopts=FilterRules[
	Flatten[{Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Options[EcoEq]];
ecostableqopts=FilterRules[
	Flatten[{Evaluate[EcoStableQOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Options[EcoStableQ]];
rulelistplotopts=Evaluate[RuleListPlotOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]];
	
(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoPhasePlane]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoPhasePlane]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoPhasePlane]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

eq=FindEcoEq[attributes,Gsin,{var1,var1min,var1max},{var2,var2min,var2max},findecoeqopts];
VPrint[1,"eq=",eq];

Return[Show[DeleteNulls[{
	PlotEcoStreams[attributes,Gsin,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecostreamsopts]],
	PlotEcoIsoclines[attributes,Gsin,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecoisoclinesopts]],
	If[eq!={},
		RuleListPlot[eq,{var1,var2},PlotMarkers->EcoStableQ[attributes,Gsin,eq,Evaluate[Sequence@@ecostableqopts]],
		Evaluate[Sequence@@rulelistplotopts]]
	]
}]]]

]];


Options[PlotEcoPhasePlane]={
Fixed->{},Time->t,FrameLabel->Automatic,
PlotEcoIsoclinesOpts->{},PlotEcoStreamsOpts->{},EcoStableQOpts->{},RuleListPlotOpts->{},FindEcoEqOpts->{},
Verbose->False,Verbosity->0};


PrestonPlot::usage =
"PrestonPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] makes a Preston species abundance distribution plot based on \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PrestonPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PrestonPlot"],
(* options *)
gu,minpop,bandwidth,kernel,scaled,showspecies,markerstyle,plotopts,listplotopts,plotrange,axesorigin,weightfunction,time,plotstyle,
coresatellite,plotmarkers,plotmin,
(* other variables *)
f,abunds,data,points,\[ScriptCapitalD],hist,stix
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[PrestonPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[PrestonPlot]}]];
bandwidth=Evaluate[Bandwidth/.Flatten[{opts,Options[PrestonPlot]}]];
kernel=Evaluate[Kernel/.Flatten[{opts,Options[PrestonPlot]}]];
scaled=Evaluate[Scaled/.Flatten[{opts,Options[PrestonPlot]}]];
showspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PrestonPlot]}]];
plotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[Plot]];
If[Evaluate[ListPlotOpts/.{opts}]=!=ListPlotOpts,
	listplotopts=Evaluate[Join[ListPlotOpts/.{opts},ListPlotOpts/.Options[PrestonPlot]]],
	listplotopts=Evaluate[ListPlotOpts/.Options[PrestonPlot]]
];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PrestonPlot]}]];
plotmin=Evaluate[PlotMin/.Flatten[{opts,Options[PrestonPlot]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[PrestonPlot]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PrestonPlot]}]];
axesorigin=Evaluate[AxesOrigin/.Flatten[{opts,Options[PrestonPlot]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PrestonPlot]}]];
coresatellite=Evaluate[CoreSatellite/.Flatten[{opts,Options[PrestonPlot]}]];

If[showspecies,
	plotmarkers=PlotMarkers/.listplotopts;
	If[plotmarkers==Automatic,
		If[coresatellite>0,
			plotmarkers={{"\[FilledSmallCircle]",9},{"\[SmallCircle]",12}},
			plotmarkers=Style["|",{Bold,12}]
		]
	]
];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][sol];

abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];

If[time===t,
	abunds=TemporalMean[abunds],
	abunds=Slice[abunds,time];
];

data=Select[abunds[[All,2]],#>minpop&];
If[plotmin===Automatic,plotmin=Min[data]];
If[coresatellite>0,
	Global`points=points={Select[data,#>=coresatellite&&#>=plotmin&],Select[data,plotmin<=#<coresatellite&]};
	\[ScriptCapitalD]1=SmoothKernelDistribution[Log[points[[1]]],0.01,{"Bounded",{Min[Log[data]],Max[Log[data]]},kernel}];
	\[ScriptCapitalD]2=SmoothKernelDistribution[Log[points[[2]]],bandwidth,{"Bounded",{Min[Log[data]],Max[Log[data]]},kernel}];
	\[ScriptCapitalD]=MixtureDistribution[{Length[points[[1]]],Length[points[[2]]]}/Length[Flatten@points],{\[ScriptCapitalD]1,\[ScriptCapitalD]2}];
,
	points=data;
	\[ScriptCapitalD]=SmoothKernelDistribution[Log[data],bandwidth,{"Bounded",{Min[Log[data]],Max[Log[data]]},kernel}];
];

If[scaled==True,f=1,f=Length[data]];

Which[
	axesorigin=="Left",axesorigin={Min[data],0},
	axesorigin=="Right",axesorigin={Max[data],0}
];
(*Print["axesorigin=",axesorigin];
Print["plotrange=",plotrange];*)

(*\[ScriptCapitalD]=SmoothKernelDistribution[data,bandwidth,{"Bounded",{Min[data],Max[data]},kernel}];*)
hist=LogLinearPlot[f*PDF[\[ScriptCapitalD],Log[x]],{x,plotmin,Max[data]},PlotStyle->plotstyle,PlotRange->plotrange,AxesOrigin->axesorigin];
(*Print[hist];*)
If[showspecies,
	stix=ListLogLinearPlot[
		points/.val_?NumericQ->{val,0},
		PlotMarkers->plotmarkers,
		Evaluate[Sequence@@listplotopts]
	],
	stix={}];
(*Print[stix];*)
Return[Show[hist,stix]];

]];


Options[PrestonPlot]={
Guild->Automatic,WeightFunction->"Total",Time->t,
MinPop->0,Bandwidth->"Scott",Kernel->"Gaussian",Scaled->True,
PlotStyle->Gray,
ShowSpecies->True,PlotRange->{0,All},AxesOrigin->{"Left","Bottom"},
ListPlotOpts->{PlotMarkers->Automatic,PlotStyle->Black},
CoreSatellite->0,PlotMin->Automatic};


WhittakerPlot::usage =
"WhittakerPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] makes a Whittaker rank-abundance plot based on \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


WhittakerPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WhittakerPlot"],
(* options *)
gu,minpop,listplotopts,weightfunction,time,coresatellite,scaled,
(* other variables *)
abunds,dat
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[WhittakerPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WhittakerPlot]}]];
listplotopts=FilterRules[Flatten[{opts,Options[WhittakerPlot]}],Options[ListLogPlot]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[WhittakerPlot]}]];
time=Evaluate[Time/.Flatten[{opts,Options[WhittakerPlot]}]];
coresatellite=Evaluate[CoreSatellite/.Flatten[{opts,Options[WhittakerPlot]}]];
scaled=Evaluate[Scaled/.Flatten[{opts,Options[WhittakerPlot]}]];


If[(PlotMarkers/.listplotopts)==Automatic,
	Which[
		(Filling/.listplotopts)===Axis,PrependTo[listplotopts,PlotMarkers->""],
		coresatellite>0,PrependTo[listplotopts,PlotMarkers->{{"\[FilledSmallCircle]",9},{"\[SmallCircle]",12}}],
		coresatellite==0,PrependTo[listplotopts,PlotMarkers->{"\[FilledSmallCircle]",9}]
	]
];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][sol];

abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];
If[time===t,
	abunds=TemporalMean[abunds],
	abunds=Slice[abunds,time];
];

abunds=Sort[Table[Subscript[gu,i],{i,Subscript[\[ScriptCapitalN], gu]}]/.abunds,Greater];
abunds=Select[abunds,#>minpop&];
If[scaled==True,
	dat=Transpose[{(Range[Length[abunds]]-1)/(Length[abunds]-1),abunds}],
	dat=Transpose[{Range[Length[abunds]],abunds}]
];

If[coresatellite>0,dat={Select[dat,#[[2]]>=coresatellite&],Select[dat,#[[2]]<coresatellite&]}];

Return[ListLogPlot[dat,Evaluate[Sequence@@listplotopts]]];

]];


Options[WhittakerPlot]={Guild->Automatic,MinPop->0,PlotRange->All,PlotMarkers->Automatic,WeightFunction->"Total",Time->t,CoreSatellite->0,Scaled->False};


PlotGuild::usage =
"PlotGuild[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots abundance vs trait/species for the species in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PlotGuild[attributesin:(_?AttributesQ):{},solin_?VariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=
Module[{
(* options *)
plottype,plotpoints,plotlayout,
listplotopts,arrayplotopts,listplot3dopts,listlineplot3dopts,plotopts,ridgelineplot3dopts,
logged,minpop,plotstyle,time,weightfunction,plotrange,
gu,tr,species,
coresatellite,plotmarkers,
(* other variables *)
traitrange,res,dat,tmin,tmax,framelabel,
sol,traits,abunds,pos,plotmin,xcoord,
plotrangemin,plotrangemax
},

Block[{\[ScriptCapitalN],verbosity,func="PlotGuild"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotGuild]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotGuild]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotGuild]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotGuild]}]];
plotlayout=Evaluate[PlotLayout/.Flatten[{opts,Options[PlotGuild]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotGuild]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[PlotGuild]}]];

listplotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ListPlot]],
	Evaluate[ListPlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
(*Print["listplotopts=",listplotopts];*)
arrayplotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ArrayPlot]],
	Evaluate[ArrayPlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
listplot3dopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ListPlot3D]],
	Evaluate[ListPlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]]];
listlineplot3dopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[MyListLinePlot3D]],
	Evaluate[ListLinePlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]]];
plotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[Plot]],
	Evaluate[PlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
(*Print["plotopts=",plotopts];*)
ridgelineplot3dopts=Evaluate[RidgelinePlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]];

plotpoints=Evaluate[PlotPoints/.Flatten[{opts,Options[PlotGuild]}]];
traitrange=Evaluate[TraitRange/.Flatten[{opts,Options[PlotGuild]}]];

gu=Evaluate[Guild/.Flatten[{opts,Options[PlotGuild]}]];
If[gu===Automatic,gu=guilds[[1]]];
tr=Evaluate[Trait/.Flatten[{opts,Options[PlotGuild]}]];
If[tr===Automatic,If[gtraits[gu]=!={},tr=gtraits[gu][[1]],tr=None]];
VPrint[3,"{gu,tr}=",{gu,tr}];

minpop=Evaluate[MinPop/.Flatten[{opts,Options[PlotGuild]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotGuild]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[PlotGuild]}]];
(*If[weightfunction==="Components",weightfunction=Select[gcomps[gu],comptype[#]==="Extensive"&]];*)
species=Evaluate[Species/.Flatten[{opts,Options[PlotGuild]}]];
coresatellite=Evaluate[CoreSatellite/.Flatten[{opts,Options[PlotGuild]}]];

(* expand traits *)
traits=ExpandTraits[attributesin];

If[ngcomps[gu]>1&&Gsin=={},
	sol=WeightedAbundance[ExtractGuilds[solin,gu],WeightFunction->weightfunction],
	sol=ExtractGuilds[solin,gu]
];
VPrint[3,"sol=",sol];


(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributesin,solin];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];


If[TemporalRuleListQ[sol]&&time===t, (* temporal dynamics *)
	{tmin,tmax}={InitialTime[sol],FinalTime[sol]};
	Which[
		plottype=="ArrayPlot",
		If[plotpoints===Automatic,plotpoints=200];
		If[tr=!=None,
			traitrange={Min[Table[Subscript[tr, sp],{sp,Subscript[\[ScriptCapitalN], gu]}]/.attributesin],Max[Table[Subscript[tr, sp],{sp,Subscript[\[ScriptCapitalN], gu]}]/.attributesin]};
			framelabel={tr,"t"},
			traitrange={1,Subscript[\[ScriptCapitalN], gu]};
			framelabel={"sp","t"}
		];
		If[InterpolatingFunctionFunctionQ[sol],
			dat=Table[Subscript[gu, sp][t]/.sol,{sp,Subscript[\[ScriptCapitalN], gu]},{t,tmin,tmax,(tmax-tmin)/plotpoints}],
			dat=Table[(Subscript[gu, sp]/.sol)["Values"],{sp,Subscript[\[ScriptCapitalN], gu]}]
		];		
		res=ArrayPlot[Reverse@dat,Evaluate[Sequence@@arrayplotopts],DataRange->{{tmin,tmax},traitrange},FrameLabel->framelabel]
	,
		plottype=="Plot3D",
		If[plotpoints===Automatic,plotpoints=100];
		If[InterpolatingFunctionFunctionQ[sol],
			dat=Flatten[Table[{t,Subscript[tr, sp]/.attributesin,Subscript[gu, sp][t]/.sol},{sp,Subscript[\[ScriptCapitalN], gu]},{t,tmin,tmax,(tmax-tmin)/plotpoints}],1],
			dat=Flatten[Table[Insert[Subscript[tr, sp]/.attributesin,2]/@(Subscript[gu, sp]/.sol)["Path"],{sp,Subscript[\[ScriptCapitalN], gu]}],1]
		];
		res=ListPlot3D[dat,Evaluate[Sequence@@listplot3dopts],AxesLabel->{"t",tr,gu}]
	,
		plottype=="LinePlot3D",
		If[plotstyle===Automatic,plotstyle=Table[Color[Subscript[tr,1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}]];
		If[InterpolatingFunctionFunctionQ[sol],
			res=ParametricPlot3D[Evaluate[Table[{t,Subscript[tr, sp]/.attributesin,Subscript[gu, sp][t]/.sol},{sp,Subscript[\[ScriptCapitalN], gu]}]],{t,tmin,tmax},
				PlotStyle->plotstyle,Evaluate[Sequence@@listlineplot3dopts],AxesLabel->{"t",tr,gu}]
		,
			dat=Table[Insert[Subscript[tr, sp]/.attributesin,2]/@(Subscript[gu, sp]/.sol)["Path"],{sp,Subscript[\[ScriptCapitalN], gu]}];
			res=MyListLinePlot3D[dat,PlotStyle->plotstyle,Evaluate[Sequence@@listlineplot3dopts],AxesLabel->{"t",tr,gu}]
		]
	,
		Else,
		Message[PlotGuild::badmtd];Return[$Failed]
	];
	Return[res]
];

(* non-temporal dynamics *)

sol=Slice[sol,time];
traits=Slice[traits,time];
(*Print["sol=",sol];
Print["traits=",traits];*)

If[plotstyle===Automatic,
	If[weightfunction==="Components",
		plotstyle=Reverse[Table[Directive[ColorData[97,i],Thick,Opacity[1]],{i,Length[Select[gcomps[gu],comptype[#]==="Extensive"&]]}]]
	,
		If[species=!=None,
			plotstyle=Table[If[i==species,
				Directive[Thick,Color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]],
				Directive[Thin,Color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]]
			],{i,Subscript[\[ScriptCapitalN], gu]}],
			plotstyle=Table[Color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}]
		];
	];
];

If[tr===None,
	xcoord=i;
	framelabel={"sp",Subscript[gu,"sp"]},
	xcoord=Subscript[tr,i];
	framelabel={Subscript[tr,"i"],Subscript[gu,"i"]}
];

If[Gsin!={},  (* moment-based *)
	VPrint[3,"moment-based"];

	(* expand Gs *)
	Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
	VPrint[3,"Gs=",Gs];
	
	{plotrangemin,plotrangemax}=Visualization`Utilities`PlotRangeExpand[PlotRange/.plotopts][[1]]/.
		{{Automatic,Automatic}->{\[Infinity],-\[Infinity]},{min_,Automatic}->{min,-\[Infinity]},{Automatic,max_}->{\[Infinity],max},{All,All}->{\[Infinity],-\[Infinity]},{min_,All}->{min,-\[Infinity]},{All,max_}->{\[Infinity],max}};
	zrange=Visualization`Utilities`PlotRangeExpand[PlotRange/.plotopts][[2]];
	VPrint[3,"{{plotrangemin,plotrangemax},zrange}=",{{plotrangemin,plotrangemax},zrange}];
	{xmin,xmax}={
		Min[plotrangemin,If[ngcomps[gu]==1,Table[Subscript[tr, i]-3Sqrt[Subscript[Var[tr], i]],{i,Subscript[\[ScriptCapitalN], gu]}],Table[Subscript[tr[gcomp], i]-3Sqrt[Subscript[Var[tr][gcomp], i]],{i,Subscript[\[ScriptCapitalN], gu]},{gcomp,gcomps[gu]}]]],
		Max[plotrangemax,If[ngcomps[gu]==1,Table[Subscript[tr, i]+3Sqrt[Subscript[Var[tr], i]],{i,Subscript[\[ScriptCapitalN], gu]}],Table[Subscript[tr[gcomp], i]+3Sqrt[Subscript[Var[tr][gcomp], i]],{i,Subscript[\[ScriptCapitalN], gu]},{gcomp,gcomps[gu]}]]]
	}/.sol/.traits/.Gs;
	VPrint[3,"{xmin,xmax}=",{xmin,xmax}];
	If[ngcomps[gu]==1,
		res=Plot[Evaluate[Table[Subscript[gu, i]PDF[NormalDistribution[Subscript[tr, i],Sqrt[Subscript[Var[tr], i]]]][x],{i,Subscript[\[ScriptCapitalN], gu]}]/.sol/.traits/.Gs],{x,xmin,xmax},
				PlotStyle->plotstyle,Evaluate[Sequence@@plotopts],PlotRange->All,AxesLabel->{tr,gu}];
		Return[res]
	,
		If[plotstyle=="Ridgeline3D",
			res=ListLinePlot3D[Evaluate@Flatten[Table[Table[gcomp=gcomps[gu][[j]];
				Table[{x,j+0.002*i,Subscript[gcomp, i]PDF[NormalDistribution[Subscript[tr[gcomp], i],Sqrt[Subscript[Var[tr][gcomp], i]]]][x]}/.sol/.traits/.Gs,{x,xmin,xmax,(xmax-xmin)/plotpoints}]
			,{i,Subscript[\[ScriptCapitalN], gu]}],{j,ngcomps[gu]}],1],
			PlotRange->{{xmin,xmax},{0.9,Subscript[\[ScriptCapitalN], gu]+0.1},zrange},Evaluate[Sequence@@ridgelineplot3dopts],AxesOrigin->{xmin,0.9,0},Ticks->{Automatic,Table[{i,gcomps[gu][[i]]},{i,ngcomps[gu]}],Automatic},
			PlotStyle->Table[{Color[Subscript[gcomp, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]},{i,\[ScriptCapitalN][gu]}],AxesLabel->{tr,None,None}];
			Return[res]
		];
		res=Table[
			plotstyle=Table[Color[Subscript[gcomp, 1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}];
			Plot[Evaluate[Table[Subscript[gcomp, i]PDF[NormalDistribution[Subscript[tr[gcomp], i],Sqrt[Subscript[Var[tr][gcomp], i]]]][x],{i,Subscript[\[ScriptCapitalN], gu]}]/.sol/.traits/.Gs],{x,xmin,xmax},
				PlotStyle->plotstyle,Evaluate[Sequence@@plotopts],PlotRange->All,AxesLabel->{tr,gcomp}]
		,{gcomp,gcomps[gu]}];
		If[plotlayout===Automatic,plotlayout="Column"];
		Which[
			plotlayout=="Column",
			Return[GraphicsColumn[res]],
			plotlayout=="Row",
			Return[GraphicsRow[res]],
			Else,
			Return[res]
		];
	];
];

If[weightfunction==="Components",
		Return[ListPlot[
			Reverse[Transpose[{Table[xcoord,{i,Subscript[\[ScriptCapitalN], gu]}],#}/.traits]&/@Accumulate[Transpose[Table[Subscript[gu,i],{i,Subscript[\[ScriptCapitalN], gu]}]/.sol]]],
			Filling->Table[j->{Axis,ModPart[plotstyle,j]},{j,Length[Select[gcomps[gu],comptype[#]==="Extensive"&]]}],
			PlotStyle->None,
			Evaluate[Sequence@@listplotopts],
			PlotRange->All,AxesLabel->framelabel
		]]
];

If[(PlotMarkers/.listplotopts)==Automatic,
	Which[
		(Filling/.listplotopts)===Axis,PrependTo[listplotopts,PlotMarkers->""],
		coresatellite>0,PrependTo[listplotopts,PlotMarkers->{{"\[FilledSmallCircle]",9},{"\[SmallCircle]",12}}],
		coresatellite==0,PrependTo[listplotopts,PlotMarkers->{"\[FilledSmallCircle]",9}]
	]
];

If[logged==False,
	(* non-logged *)
	Return[ListPlot[
		Table[{{xcoord,0},{xcoord,Subscript[gu,i]}},{i,Subscript[\[ScriptCapitalN], gu]}]/.traits/.sol,
			PlotStyle->plotstyle,
			Evaluate[Sequence@@listplotopts],
			PlotRange->All,Joined->True,AxesLabel->framelabel
	]]
,
	(* logged *)
	sol=Select[sol,#[[2]]>minpop&];
	pos=sol[[All,1,2]]; (* positions *)
	{traitrange,{plotrangemin,plotrangemax}}=Visualization`Utilities`PlotRangeExpand[PlotRange/.listplotopts];
	If[plotrangemin===All,plotrangemin=Min[Table[Subscript[gu,i],{i,pos}]/.sol]];
	Which[
		coresatellite>0,
		dat=Table[{xcoord,Subscript[gu,i]},{i,pos}]/.traits/.sol;
		dat={Select[dat,#[[2]]>=coresatellite&],Select[dat,#[[2]]<coresatellite&]},
		(Joined/.listplotopts)===True||(Filling/.listplotopts)===None,
		dat=Table[{xcoord,Subscript[gu,i]},{i,pos}]/.traits/.sol,
		Else,
		dat=Table[{{xcoord,Subscript[gu,i]}},{i,pos}]/.traits/.sol
	];
	Return[ListLogPlot[dat,
		PlotStyle->plotstyle,
		PlotRange->{traitrange,{plotrangemin,plotrangemax}},
		Evaluate[Sequence@@listplotopts],
		AxesLabel->framelabel
	]]
];


]];


Options[PlotGuild]={Verbose->False,Verbosity->0,
PlotType->"ArrayPlot",PlotStyle->Automatic,PlotLayout->Automatic,PlotPoints->200,
ListPlotOpts->{PlotMarkers->Automatic,Filling->Axis,FillingStyle->Thickness[0.004],(*AxesOrigin->{Left,Bottom},*)PlotRange->{0,All}},
ListPlot3DOpts->{BoxRatios->{2,1,1},PlotRange->{0,All},ColorFunction->"ThermometerColors",Mesh->None},
ArrayPlotOpts->{AspectRatio->1/2,ImageSize->Large,ColorFunction->"ThermometerColors",Mesh->None,FrameTicks->{All,All,False,False},PlotRange->All},
ListLinePlot3DOpts->{BoxRatios->{2,1,1},PlotRange->{All,All,{0,All}}},
PlotOpts->{Filling->Axis,PlotRange->{0,All}},
RidgelinePlot3DOpts->{Boxed->False,BoxRatios->{1,0.6,0.4},Filling->Axis,ViewPoint->{0,-3,0.6},PlotRange->{0,All}},
Guild->Automatic,Trait->Automatic,Species->None,
WeightFunction->"Total",
Logged->False,MinPop->0,Time->t,CoreSatellite->0};


(* split combined traitsandpopsandGs *)
PlotGuild[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
PlotGuild[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];
(* split combined traitsandpops *)
PlotGuild[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=
PlotGuild[ExtractTraits[sol],ExtractVariables[sol],opts];


PlotGuild::badmtd="The Method option should be a built-in method name (\"ArrayPlot\", \"Plot3D\", or \"ListLinePlot3D\" for temporal dynamics).";


ImpactVector::usage=
"ImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\)] returns the impact of \!\(\*
StyleBox[\"sp\", \"TI\"]\) on {\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}.";


ImpactVector[{var1_,var2_},sp_]:=D[{Equation[var1],Equation[var2]}/.RemoveVariablets,sp];


PlotImpactVector::usage=
"PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] plots the impact vector of \!\(\*
StyleBox[\"sp\", \"TI\"]\) on {\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)} at \!\(\*
StyleBox[\"point\", \"TI\"]\).
PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, {\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"sp\", \"TI\"], \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"sp\", \"2\"], \"TI\"]\), \[Ellipsis]}, \!\(\*
StyleBox[\"point\", \"TI\"]\)] plots impact vectors of multiple species.
PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\), {\!\(\*
StyleBox[SubscriptBox[\"point\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"point\", \"2\"], \"TI\"]\), \[Ellipsis]}] plots at multiple points.";


(* make listable across points *)
PlotImpactVector[{var1_,var2_},sp_,points_?RuleListListQ,opts___?OptionQ]:=(PlotImpactVector[{var1,var2},sp,#,opts]&/@points);


(* make listable across sps *)
PlotImpactVector[{var1_,var2_},sps_List,point_?RuleListQ,opts___?OptionQ]:=Module[{plotstyles,nsp},
	plotstyles=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotImpactVector]}]];
	nsp=Length[sps];
	If[plotstyles===Automatic,plotstyles=Table[Automatic,{nsp}]];
	Table[
		PlotImpactVector[{var1,var2},sps[[i]],point,PlotStyle->ModPart[plotstyles,i],opts]
	,{i,nsp}]
];


PlotImpactVector[{var1_,var2_},sp_,ptin_?RuleListQ,opts___?OptionQ]:=Module[{
scale,scale1,scale2,plotstyle,plotstyle1,plotstyle2,
impactvector,pt},
(* handle options *)
scale=Evaluate[Scale/.Flatten[{opts,Options[PlotImpactVector]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotImpactVector]}]];

Which[
	Length[scale]==2,
	{scale1,scale2}=scale,
	NumericQ[scale],
	scale1=scale,
	Else,
	scale1=1;
];
(*Print[{scale1,scale2}];*)

Which[
	plotstyle===Automatic,
	{plotstyle1,plotstyle2}={Automatic,Automatic},
	Length[plotstyle]==2&&Length[scale]==2,
	{plotstyle1,plotstyle2}=plotstyle,
	Else,
	plotstyle1=plotstyle2=plotstyle
];
If[plotstyle1===Automatic,plotstyle1=Color[sp]];
If[plotstyle2===Automatic,plotstyle2={Color[sp],Dashed}];
(*Print[{plotstyle1,plotstyle2}];*)

pt={var1,var2}/.ptin;
impactvector=Normalize@ImpactVector[{var1,var2},sp]/.ptin;

{PlotVector[scale1*impactvector,pt,PlotStyle->plotstyle1],
If[NumericQ[scale2],Graphics[Join[Flatten[{plotstyle2}],{Line[{pt,pt+scale2*impactvector}]}]]]}//DeleteNulls
];


Options[PlotImpactVector]={Scale->1,PlotStyle->Automatic};


PlotEcoEq::usage=
"PlotEcoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] plots ecological equilibria \!\(\*
StyleBox[\"sol\", \"TI\"]\) as function of \!\(\*
StyleBox[\"par\", \"TI\"]\).
PlotEcoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] plots only \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


PlotEcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},eq_?RuleListQ,var:(_Symbol|_Subscript),{par:(_Symbol|_Subscript),parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,
teststability,stablestyle,unstablestyle,
plotopts,plotrange,axeslabel,
(* other variables *)
lookup,color,yaxislabel,j,\[Lambda]
},

Block[{\[ScriptCapitalN],verbosity,func="PlotEcoEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoEq]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[PlotEcoEq]}]];
stablestyle=Flatten[{Evaluate[StableStyle/.Flatten[{opts,Options[PlotEcoEq]}]]}];
unstablestyle=Flatten[{Evaluate[UnstableStyle/.Flatten[{opts,Options[PlotEcoEq]}]]}];
plotopts=FilterRules[Flatten[{opts,Options[PlotEcoEq]}],Options[Plot]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PlotEcoEq]}]];
If[plotrange===Automatic,If[comptype[var]=="Extensive",plotrange={0,All}]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotEcoEq]}]];
If[axeslabel===Automatic,axeslabel={par,var}];

(* figure out number of species in guilds *)
(*Set\[ScriptCapitalN][Join[{par->parval},attributesin],eq];*)
Set\[ScriptCapitalN][attributesin,eq];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

lookup=LookUp[var];
(*Print["lookup=",lookup];*)
Which[
	(lookup[[1]]==="gcomp"||lookup[[1]]==="gtrait"||lookup[[1]]==="var")&&Length[lookup]==4,
	color=Color[var][SpFrac[lookup[[4]],\[ScriptCapitalN][lookup[[2]]]]]
,
	(lookup[[1]]==="gcomp"||lookup[[1]]==="gtrait")&&Length[lookup]==3,
	color=Color[var]
,
	lookup[[1]]==="pcomp"||lookup[[1]]==="aux",
	color=Color[var]
,
	Else,
	color=ColorData[97][1];
];
(*Print["var=",var," color=",color];*)

If[teststability,
	plotopts=Join[plotopts,
		{MeshStyle->Opacity[0],MeshFunctions->{\[Lambda][#1,eq]&},Mesh->{{0}},
		MeshShading->{Directive[Evaluate[Sequence@@stablestyle],color],Directive[Evaluate[Sequence@@unstablestyle],color]}}],
	plotopts=Join[plotopts,{PlotStyle->color,LineStyle[var]}]
];
(*Print[plotopts];*)

(*Print["attributesin=",attributesin];*)
(*Print["Join[{par->parval},attributesin]=",Join[{par->parval},attributesin]];*)

j=EcoJacobian[Join[{par->par},attributesin],Gsin];
(*Print["j=",j];*)

\[Lambda][parval_?NumericQ,pt_]:=Which[
	(*modeltype=="ContinuousTime",Max[Re[EcoEigenvalues[Join[{par->parval},attributesin],Gsin,pt/.par->parval]]],*)
	modeltype=="ContinuousTime",Max[Re[Eigenvalues[j/.pt/.par->parval]]],
	modeltype=="DiscreteTime",Max[Abs[Re[EcoEigenvalues[Join[{par->parval},attributesin],Gsin,pt/.par->parval]]]]-1
];

(*Print[Plot[\[Lambda][par,eq],{par,parmin,parmax}]];*)
(*Print[\[Lambda][0.5,eq]];*)

(*Print[eq];
Print[var];
Print[var/.eq];
Print[par];*)

Return[Plot[var/.eq,{par,parmin,parmax},PlotRange->plotrange,AxesLabel->axeslabel,Evaluate[Sequence@@plotopts]]];

]];


Options[PlotEcoEq]={
	TestStability->True,StableStyle->{},UnstableStyle->{Dashed},
	PlotRange->{All,{0,All}},AxesLabel->Automatic,PlotRangePadding->Scaled[0.02],
	Verbose->False,Verbosity->0
};


(* no par range given *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eq_?VariablesQ,opts___?OptionQ]:=((*Print[1];*)
	PlotEcoEq[attributes,Gs,eq,{ParameterName[eq],InitialParameterValue[eq],FinalParameterValue[eq]},opts]);
	
(* no par range given *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eq_?VariablesQ,vars_?SymbolListQ,opts___?OptionQ]:=((*Print[2];*)
	PlotEcoEq[attributes,Gs,eq,vars,{ParameterName[eq],InitialParameterValue[eq],FinalParameterValue[eq]},opts]);

(* no vars given = All *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eq_?VariablesQ,{par:(_Symbol|_Subscript),parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=((*Print[3];*)
	PlotEcoEq[attributes,Gs,eq,Keys[eq],{par,parmin,parmax},opts]);
	
(* thread over vars *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eq_?VariablesQ,vars_?SymbolListQ,{par:(_Symbol|_Subscript),parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=Module[{axeslabel},
	(*Print[4];*)
	axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotEcoEq]}]];
	If[axeslabel===Automatic,axeslabel={par,Row[Sort[Union[vars]],","]}];
	Show[Table[PlotEcoEq[attributes,Gs,eq,var,{par,parmin,parmax},opts],{var,vars}],AxesLabel->axeslabel]
];

(* thread over eqs \[LongDash] vars, par *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eqs_?RuleListListQ,varorvars_?!OptionQ,{par:(_Symbol|_Subscript),parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=((*Print[5];*)
	Show[Table[PlotEcoEq[attributes,Gs,eq,varorvars,{par,parmin,parmax},opts],{eq,eqs}],
	FilterRules[Flatten[{opts,Options[PlotEcoEq]}],PlotRange]]);
	
(* thread over eqs \[LongDash] no vars, par *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eqs_?RuleListListQ,{par:(_Symbol|_Subscript),parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=((*Print[6];*)
	Show[Table[PlotEcoEq[attributes,Gs,eq,{par,parmin,parmax},opts],{eq,eqs}],
	FilterRules[Flatten[{opts,Options[PlotEcoEq]}],PlotRange]]);
	
(* thread over eqs \[LongDash] vars, no par *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eqs_?RuleListListQ,vars_?SymbolListQ,opts___?OptionQ]:=((*Print[7];*)
	Show[Table[PlotEcoEq[attributes,Gs,eq,vars,opts],{eq,eqs}],
	FilterRules[Flatten[{opts,Options[PlotEcoEq]}],PlotRange]]);
	
(* thread over eqs \[LongDash] no vars, no par *)
PlotEcoEq[attributes:(_?AttributesQ):{},Gs:(_?GsQ):{},eqs_?RuleListListQ,opts___?OptionQ]:=((*Print[8];*)
	Show[Table[PlotEcoEq[attributes,Gs,eq,opts],{eq,eqs}],
	FilterRules[Flatten[{opts,Options[PlotEcoEq]}],PlotRange]]);


Inv::usage=
"Inv[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

StablePopulationStructure::usage=
"StablePopulationStructure[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

ReproductiveValues::usage =
"ReproductiveValues[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the reproductive values of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the reproductive value of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

InvSPS::usage =
"InvSPS[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate and stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate and stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";


InvSPS[traitspopsandgs_?AttributesVariablesAndGsQ,opts:OptionsPattern[]]:=InvSPS[
	DeleteInvaders@ExtractAttributes[traitspopsandgs],DeleteInvaders@ExtractVariables[traitspopsandgs],DeleteInvaders@ExtractVarCovs[traitspopsandgs],
	ExtractInvaders@ExtractAttributes[traitspopsandgs],ExtractInvaders@ExtractVarCovs[traitspopsandgs],
	opts];
InvSPS[traitsandpops_?AttributesAndVariablesQ,invaderin:(_?InvaderQ):{},invaderGsin:(_?GsQ):{},opts:OptionsPattern[]]:=InvSPS[
	ExtractAttributes[traitsandpops],ExtractVariables[traitsandpops],{},invaderin,invaderGsin,opts];


InvSPS[attributesin:(_?NotInvaderTraitsQ):{},solin:(_?VariablesQ):{},Gsin:(_?GsQ):{},invaderin:(_?InvaderQ):{},invaderGsin:(_?GsQ):{},opts:OptionsPattern[]]:=Module[{
(* options *)
verbose,verboseall,method,
guild,time,simplifyresult,frominv,rv,qssics,
qssmethod,equalinvtraits,
ndsolveopts,nintegrateopts,integrateopts,
solveopts,nsolveopts,findrootopts,
findecocycleopts,eigensystemopts,simplifyopts,
(* other variables *)
attributes,invader,invtraits,variables,Gs,
invtype,invid,invunk,zeropcomps,sol,invaderGs,
inveqns,invunks,qsseqns,qssunks,qsssubs,mode,
tstart,tend,removets,qsssols,qsssol,eval,evec,invsol,j,tempIF},

Block[{\[ScriptCapitalN],verbosity,func="InvSPS"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[InvSPS]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[InvSPS]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[InvSPS]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=OptionValue[Method];
time=OptionValue[Time];
qssmethod=OptionValue[QSSMethod]; 
ndsolveopts=OptionValue[NDSolveOpts];
nintegrateopts=OptionValue[NIntegrateOpts];
integrateopts=OptionValue[IntegrateOpts];
solveopts=OptionValue[SolveOpts];
nsolveopts=OptionValue[NSolveOpts];
findrootopts=OptionValue[FindRootOpts];
findecocycleopts=OptionValue[FindEcoCycleOpts];
eigensystemopts=OptionValue[EigensystemOpts];
simplifyresult=OptionValue[SimplifyResult];
simplifyopts=OptionValue[SimplifyOpts];
guild=OptionValue[Guild];
If[guild===Automatic,guild=Append[guilds,1][[1]]];
frominv=OptionValue[FromInv];
rv=OptionValue[RV];
qssics=OptionValue[QSSICs];
equalinvtraits=OptionValue[EqualInvTraits];

(* fix attributes *)
attributes=FixAttributes[attributesin];
VPrint[3,"attributesin=",attributesin];
VPrint[3,"attributes=",attributes];

(* expand Gs *)
Gs=ExpandGs[Gsin];
VPrint[3,"Gsin=",Gsin];
VPrint[3,"Gs=",Gs];

(* fix variables *)
variables=FixVariables[solin];
VPrint[3,"solin=",solin];
VPrint[3,"variables=",variables];

VPrint[3,"invaderin=",invaderin];
VPrint[3,"invaderGsin=",invaderGsin];

VPrint[3,"opts=",opts];

$InvCount++; (* increment $InvCount *)

(* figure out number of species in guilds *)

Set\[ScriptCapitalN][attributes,variables];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[modelwhenevents!={},Message[InvSPS::whenevents]];

(* what kind of invader do we have? *)

invader=Flatten[{invaderin}];
VPrint[3,"invader=",invader];

invtraits={};
Which[
	(* no invader given *)
	invader==={},
	VPrint[3,"no invader given"];
	Which[
		nguilds!=0,{invtype,invid}={"guild ghost",guild},
		npops!=0,{invtype,invid}={"pop",pops[[1]]}
	];
,
	(* specific guild ghost invader *)
	AttributesQ[invader],
	VPrint[3,"specific guild ghost invader"];
	{invtype,invid}={"guild ghost",LookUp[invader[[1,1]]][[2]]};
	invtraits=ExtractAttributes[invader];
,
	(* whole-guild ghost invader *)
	LookUp[invader[[1]]][[1]]=="guild"&&Length[LookUp[invader[[1]]]]==2,
	VPrint[3,"whole-guild ghost invader"];
	{invtype,invid}={"guild ghost",invader[[1]]};
,
	(* whole-gcomp ghost invader -- is this even a good idea?! *)
	LookUp[invader[[1]]][[1]]=="gcomp"&&Length[LookUp[invader[[1]]]]==3,
	VPrint[3,"whole-gcomp ghost invader"];
	{invtype,invid}={"gcomp ghost",invader[[1]]};
	Return[{Simplify[Equation[Subscript[invid,0]]/Subscript[invid,0]/.sol/.attributes],"N/A"}]
,
	(* guild member invader *)
	LookUp[invader[[1]]][[1]]=="guild"||LookUp[invader[[1]]][[1]]=="gcomp",
	VPrint[3,"guild member invader"];
	{invtype,invid}={"guild member",invader[[1]]};
	VPrint[3,invid," -- ",invid/.WeightedAbundance[variables]];
	If[(invid/.WeightedAbundance[variables])>0,Message[InvSPS::nonzero](*;Abort[]*)]
,
	(* pop invader *)
	LookUp[invader[[1]]][[1]]=="pop"||LookUp[invader[[1]]][[1]]=="pcomp",
	VPrint[3,"pop invader"];
	{invtype,invid}={"pop",LookUp[invader[[1]]][[2]]};
	VPrint[3,invid," -- ",invid/.WeightedAbundance[variables]];
(*Print[comps[invid]];
Print[FilterRules[sol,comps[invid]]];
Print[TemporalMean@FilterRules[sol,comps[invid]]];
Print[WeightedAbundance@TemporalMean@FilterRules[sol,comps[invid]]];*)
	If[(invid/.WeightedAbundance@TemporalMean@FilterRules[variables,comps[invid]])>0,Message[InvSPS::nonzero](*;Abort[]*)]
,
	Else,
	Message[InvSPS::unkinv];Return[$Failed]
];

VPrint[3,"{invtype,invid}=",{invtype,invid}];
VPrint[3,"invtraits=",invtraits];

(* assemble sol [resident state] *)

(* in case any extensive pops weren't given, assume they're 0 *)
zeropcomps=Flatten[Table[Table[
	If[comptype[pcomp]=="Extensive"&&invtype=="pop",pcomp->0,pcomp->pcomp] (* maybe make it pop-specific?? *)
,{pcomp,pcomps[pop]}],{pop,pops}]];
sol=JoinFirst[variables,zeropcomps];
(*Print[sol];*)

(* if a time given, evaluate sol there *)
If[time=!=t&&!NumericRuleListQ[sol],sol=Slice[sol,time]];

VPrint[3,"sol=",sol];


(* process Gs *)
If[moments,
	invaderGs=ExpandGs[Join[invaderGsin,Thread[Flatten@MakeGMatrix[Subscript[invid, 0]]->Flatten@ConstantArray[0,{ngtraits[invid],ngtraits[invid]}]]]],
	invaderGs={}
];
VPrint[1,"invaderGs=",invaderGs];

(* set up inveqns, invunks, qss stuff *)

inveqns=invunks={};
qsssubs=qsseqns=qssunks={};

Do[
(*Print["comp=",comp];*)
	invunk=Switch[invtype,"guild ghost",Subscript[comp,0],"guild member",Subscript[comp,invid[[2]]],"pop",comp];
	If[comptype[invunk]=="Extensive",
		AppendTo[inveqns,Equation[invunk]];
		AppendTo[invunks,invunk];
		If[invtype=="guild ghost",AppendTo[qsssubs,invunk->0]];
	];
	If[comptype[invunk]=="Intensive",
		AppendTo[qsseqns,Equation[invunk]==0];
		If[qssmethod=="FindRoot",
			AppendTo[qssunks,{invunk,Min[range[invunk]]+0.01}],
			AppendTo[qssunks,invunk];
		];
	];
,{comp,Switch[invtype,"guild ghost",gcomps[invid],"guild member",gcomps[LookUp[invader[[1,1]]][[2]]],"pop",pcomps[invid]]}];

VPrint[3,"inveqns=",inveqns];
VPrint[3,"invunks=",invunks];
VPrint[3,"qsseqns=",qsseqns];
VPrint[3,"qsssubs=",qsssubs];
VPrint[3,"qssunks=",qssunks];

(* decide on mode *)

Which[
	(modelperiod==0&&(Length[sol]==0||!MemberQ[{InterpolatingFunction,TemporalData},Head[sol[[1,2]]]]))
	||(modelperiod=!=0&&(method==="Instantaneous"||time=!=t)),
	mode="eigenvalue",
	modeltype=="ContinuousTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===InterpolatingFunction)),
	mode="continuoustime floquet",
	modeltype=="DiscreteTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===TemporalData)),
	mode="discretetime floquet"
];
VPrint[3,"mode=",mode];


(* calculate invasion fitness *)

Which[
	(* ContinuousTime Floquet mode *)
	mode=="continuoustime floquet",
	VPrint[1,"ContinuousTime Floquet mode"];

	(* figure out period *)
	If[sol!={}&&Head[sol[[1,2]]]===InterpolatingFunction,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	VPrint[3,"{tstart,tend}=",{tstart,tend}];
	
	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[qssics===Automatic, (* no QSS ICs given? then average corresponding components from residents *)
			qssics=Table[qssunk->
				Mean[Select[Select[FinalSlice[sol],(#[[1,0]]==Subscript)&],(#[[1,1]]==qssunk[[1]])&][[All,2]]]
			,{qssunk,qssunks}];
		];
		If[verbose,
			With[{tr=Join[attributes,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[attributes,invtraits],Join[FinalSlice[sol],qssics],Sequence@@findecocycleopts];
		If[qsssol==$Failed,Message[InvSPS::noqsssol];Return[{$Failed}]];
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	VPrint[3,"qsssol=",qsssol];


	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		Which[
			method===Automatic||method=="NIntegrate",
			VPrint[1,"ContinuousTime Floquet mode (1 comp): NIntegrate"];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@nintegrateopts},
				PrintCall[Global`eval=NIntegrate[eq/.Global`sol/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=NIntegrate[Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@nintegrateopts]]/(tend-tstart);
			Return[{eval,"?"}]
		,
			method=="NDSolve",
			VPrint[3,"ContinuousTime Floquet mode (1 comp): NDSolve"];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
				PrintCall[Global`invsol=NDSolve[{Global`x'[t]==eq/.Global`qsssol,Global`x[tstart]==0},Global`x,{t,tstart,tend},op]];
				PrintCall[Global`eval=Global`x[tend]/dt/.Global`invsol]
			]];
			invsol=NDSolve[{x'[t]==Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,x[tstart]==0},x,
				{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]][[1]];
			eval=x[tend]/(tend-tstart)/.invsol;
			Return[{eval,"?"}];
		,
			method=="Integrate",
			VPrint[1,"ContinuousTime Floquet mode (1 comp): Integrate"];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@integrateopts},
				PrintCall[Global`eval=Integrate[eq/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=Integrate[Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@integrateopts]]/(tend-tstart);
			Return[{Chop[eval],"?"}];
		,
			method=="EcoSim",
			sol=EcoSim[];
		,
			Else,
			Message[InvSPS::bdmtd];
			Return[]
		];
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		VPrint[1,"ContinuousTime Floquet mode (2+ comps)"];
		removets={Subscript[x_/;(comptype[x]=="Extensive"),0][t]->Subscript[x,0],t->time};
(*Print[removets];*)
		j=D[inveqns/.AddVariablets/.attributes/.removets,{invunks}];
		VPrint[3,"j=",j];
		If[verbose,
			With[{j=j/.invtraits,liu=Length[invunks],tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
			PrintCall[Global`invsol=NDSolve[{Global`x'[t]==j . Global`x[t]/.Global`sol/.Global`qsssol,Global`x[tstart]==IdentityMatrix[liu]},Global`x,{t,tstart,tend},op]];
			PrintCall[Global`eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[Global`x[tend]/.Global`invsol]/dt]
		]];
		invsol=NDSolve[{x'[t]==j . x[t]/.invtraits/.sol/.qsssol,x[tstart]==IdentityMatrix[Length[invunks]]},x,{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]];
		eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[x[tend]/.invsol]/(tend-tstart);
		Return[{eval,"?"}];
	]
,
	(* DiscreteTime Floquet mode *)
	mode=="discretetime floquet",
	VPrint[1,"DiscreteTime Floquet mode"];

	(* figure out time range *)
	If[Head[sol[[1,2]]]===TemporalData,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	VPrint[3,"{tstart,tend}=",{tstart,tend}];

	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[verbose,
			With[{tr=Join[attributes,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[attributes,invtraits],Join[FinalSlice[sol],qssics],Evaluate[Sequence@@findecocycleopts]]
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	VPrint[3,": qsssol=",qsssol];

	removets={Subscript[x_/;comptype[x]=="Extensive",0][t]->Subscript[x,0],t->time};

	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		VPrint[1,"DiscreteTime Floquet mode (1 comp)"];
		If[verbose,
			With[{eq=Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits]/.SimplifyLogE],tstart=tstart,tend=tend,te=tend-tstart+1},
			(*PrintCall[Global`eval=Product[eq/.Global`sol/.Global`qsssol,{t,tstart,tend}]^(1/te)]*)
			PrintCall[Global`eval=Sum[eq/.Global`sol/.Global`qsssol,{t,tstart,tend}]/te]
		]];
		(*eval=Product[inveqns\[LeftDoubleBracket]1\[RightDoubleBracket]/invunks\[LeftDoubleBracket]1\[RightDoubleBracket]/.AddVariablets/.invtraits/.sol/.qsssol,{t,tstart,tend}]^(1/(tend-tstart+1));
		(*Print["eval=",eval];*)
		Return[{(Log@Chop@ComplexExpand[eval])/.SimplifyLogE,"?"}]*)
		eval=Sum[Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol]/.SimplifyLogE],{t,tstart,tend}]/(tend-tstart+1);
		If[tend==\[Infinity],
			Return[{With[{tstart=tstart,tend=tend,eq=Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol]/.SimplifyLogE]},Unevaluated@Defer[Sum[eq,{t,tstart,tend}]/\[Infinity]]],"?"}],
			Return[{eval,"?"}]
		]
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		VPrint[1,": DiscreteTime Floquet mode (2+ comps)"];
		j=D[inveqns/.AddVariablets/.attributes/.removets,{invunks}];
		If[verbose,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,tend=tend,te=tend+1},
			PrintCall[Global`invsol=ListMultiplier[Table[j/.Global`sol/.Global`qsssol,{t,0,tend}]]];
			PrintCall[Global`eval=Log[Max@Re@Chop@Sort@Eigenvalues[Global`invsol]^(1/te)]]
		]];
		invsol=ListMultiplier[Table[j/.invtraits/.sol/.qsssol,{t,0,tend}]];		
		Return[{Log[Max@Re@Chop@Sort@Eigenvalues[invsol]^(1/(tend+1))],"?"}];
	]
,
	(* Eigenvalue mode *)
	mode=="eigenvalue",
	VPrint[1,"eigenvalue mode"];
	
	(* subrule to remove [t]'s *)
	(*removets={t\[Rule]time};*)

	(* are there any Intensive components to be solved for? *)

	If[Length[qssunks]>0,
		Which[
			qssmethod=="Solve",
			qsssols=Solve[qsseqns/.qsssubs/.attributes/.Gs/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@solveopts]],
			qssmethod=="NSolve",
			qsssols=NSolve[qsseqns/.qsssubs/.attributes/.Gs/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@nsolveopts]],
			qssmethod=="FindRoot",
			qsssols={FindRoot[qsseqns/.qsssubs/.attributes/.Gs/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@findrootopts]]}
		];
	,
		qsssols={{}}];
	VPrint[1,"qsssols=",qsssols];
	If[VectorQ[qsssols,NumericRuleListQ[#]&],
		qsssol=SelectValid[qsssols], (* should add SelectEcoStable here? *)
		qsssol=qsssols
	];
	VPrint[1,"qsssol=",qsssol];
	If[Length[qsssol]!=1,Message[InvSPS::noqsssol,Length[qsssol]];Return[{$Failed}]];
	If[Length[invunks]==1,
		VPrint[3,"Cancel[(inveqns\[LeftDoubleBracket]1\[RightDoubleBracket]/invunks\[LeftDoubleBracket]1\[RightDoubleBracket])]=",Cancel[(inveqns[[1]]/invunks[[1]])]];
		j={{Cancel[(inveqns[[1]]/invunks[[1]])]/.qsssol[[1]]/.qsssubs/.sol/.invtraits/.attributes/.Gs/.invaderGs/.t->time}}
	,
		(* make Jacobian matrix of Extensive components *)
		(* what about 0th order terms?! *)
		j=D[inveqns/.attributes/.Gs/.qsssol[[1]]/.invtraits,{invunks}]/.sol/.invaderGs/.t->time;
		(* equalize traits *)
		(*Print["gtraits[invid]=",gtraits[invid]];*)
		(*Print["invtype=",invtype];*)
		If[invtype=!="pop"&&equalinvtraits,j=j/.Table[tr[_]->tr,{tr,gtraits[invid]}]];
	];

	VPrint[3,"j=",j];

	Which[
		Length[j]==1, (* 1 extensive component *)
		VPrint[1,"1 extensive component"];
		eval=j[[1,1]];
		evec={1};
	,
		Length[j]>1, (* >1 extensive component *)
	
		(* calculate eigenvalues *)

		If[(MatrixQ[#,NumericQ]&)[j/.qsssubs],
			(* numerical jacobian *)
			VPrint[1,"numerical Jacobian"];
			
			If[rv,
				{{eval},{evec}}=SortedEigensystem[Transpose[j/.qsssubs],1,Sequence@@eigensystemopts],
				{{eval},{evec}}=SortedEigensystem[j/.qsssubs,1,Sequence@@eigensystemopts]
			];
			evec=evec/Sign[evec[[1]]]
		,
			(* symbolic jacobian *)
			VPrint[1,"symbolic Jacobian"];
			j=j/.qsssubs;
			If[Dimensions[j]=={2,2},
				eval=(*Simplify@*)Re[1/2*(j[[1,1]]+j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])];
				If[rv,
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[1,2]]),1}],
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[2,1]]),1}]
				]
			,
				eval=Max[Re[Eigenvalues[j/.qsssubs,Sequence@@eigensystemopts]]];
				evec="?";
				If[!frominv,Message[InvSPS::nosymev]];
			];
		];
	];
	
	(* add [t] to InterpolatingFunctions (but not ones with [var]) *)
	eval=eval/.x_InterpolatingFunction->x[t]/.x_InterpolatingFunction[t][var_]->x[var];

	VPrint[1,"eigenvalue=",eval];
	VPrint[1,"eigenvector=",evec];

	(* return answer *)
	Quiet[Which[
		modeltype=="ContinuousTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			simplifyresult===Real,
			Return[RealSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			Else,
			Return[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
	,
		modeltype=="DiscreteTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			Else,
			Return[{(Log@Max@Chop@ComplexExpand[eval])/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
		(*Return[{Simplify[Log@Max@Chop@ComplexExpand[eval],Assumptions\[Rule]{_\[Element]Reals}],evec}];*)
	],{Simplify::time,Simplify::gtime}];


];

]];


(*Options[Inv]=*)Options[InvSPS]={Verbose->False,Verbosity->0,
Method->Automatic,Time->t,
NIntegrateOpts->{Method->{Automatic,"SymbolicProcessing"->0}},IntegrateOpts->{},NDSolveOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},EigensystemOpts->{},FindEcoCycleOpts->{},
QSSMethod->"NSolve",QSSICs->Automatic,
SimplifyResult->True,SimplifyOpts->{_\[Element]Reals,TimeConstraint->{0.1,1}},
Guild->Automatic,FromInv->False,RV->False,
EqualInvTraits->True};


Inv[args___]:=InvSPS[args,FromInv->True][[1]];
(*Inv[args___,opts_?OptionQ]:=InvSPS[DeleteInvaders@ExtractTraits[Flatten[{args}]],DeleteInvaders@ExtractVariables[Flatten[{args}]],
	ExtractInvaders@ExtractTraits[Flatten[{args}]],ExtractInvaders@ExtractVarCovs[Flatten[{args}]],FromInv\[Rule]True,opts]\[LeftDoubleBracket]1\[RightDoubleBracket];*)
StablePopulationStructure[args___]:=InvSPS[args][[2]];
ReproductiveValues[args___]:=InvSPS[args,RV->True][[2]];


InvSPS::nosymev=
"Warning: don't know how to find analytical StablePopulationStructure for > 2x2 matrix.";

InvSPS::unkinv=
"Can't figure out who's invading: please specify.";

InvSPS::nonzero=
"Warning: invasion rate only defined for rare invaders.";

InvSPS::noqsssol=
"Found `1` QSS solutions for invader's Intensive components, need one.";

InvSPS::notraits=
"Trait of invader not defined, so NIntegrate can't work.  Try Method->\"Integrate\" or give invader traits.";

InvSPS::whenevents=
"Warning: WhenEvents involving populations and guilds are not handled properly in InvSPS yet.";


$InvCount::usage = "Counts number of times Inv called.";
$InvCount=0;


DInv::usage =
"DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] calculates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"sol\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where DInv will be evaluated.
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives derivatives for all traits in Guild (default=first).";

NDInv::usage =
"NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] numerically approximates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident traits \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"sol\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where NDInv will be evaluated.
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives derivatives for all traits in Guild (default=first).";


Options[DInv]={Verbose->False,Verbosity->0,
Fixed->{},InvOpts->{},Method->"D",Guild->Automatic,Species->All,FindEcoAttractorOpts->{},
Chop->True,SimplifyResult->False,RelativeStepSize->0.001,AbsoluteStepSize->0.001,Time->t,Verbose->False};

notDInvOpts=Except[Alternatives@@Replace[Options[DInv],h_[a_,_]:>h[a,_],1]];


NumDInv[traitsin_?NumericRuleListQ,rest___]:=DInv[traitsin,rest];


DInv[traitsin:(_?TraitsQ):{},solin:(_?VariablesQ):{},{var_:All,ord_?NumberQ},pointin:notDInvOpts:{},opts:OptionsPattern[]]:=

Module[{
(* options *)
verbose,fixed,fixedattributes,fixedvariables,method,\[Epsilon]r,\[Epsilon]a,invopts,guild,species,time,simplifyresult,chop,findecoattractoropts,
(* other variables *)
sol,res,res2,traits,traits2,point,targetgu,targettrait,inv,sp,vars,
pt1,pt2,
h,h1,h2,invl,invr,invc},

If[solin==$Failed,Return[$Failed]];

Block[{\[ScriptCapitalN],verbosity,func="DInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[DInv]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[DInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[DInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=OptionValue[Fixed];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
If[Global`debug,Print[func,": fixedattributes=",fixedattributes]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];

invopts=OptionValue[InvOpts];
method=OptionValue[Method];
\[Epsilon]a=OptionValue[AbsoluteStepSize];
\[Epsilon]r=OptionValue[RelativeStepSize];
guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
species=OptionValue[Species];
time=OptionValue[Time];
AppendTo[invopts,Time->time];
simplifyresult=OptionValue[SimplifyResult];
chop=OptionValue[Chop];
findecoattractoropts=OptionValue[FindEcoAttractorOpts];

(* handle blanks & figure out number of species in guilds *)
traits=DeleteInvaders[FixAttributes[traitsin]];
(*Print["traits=",traits];*)
sol=FixVariables[solin];

(* set number of species *)
Set\[ScriptCapitalN][Join[traits,fixedattributes]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[solin==="FindEcoAttractor",
	If[verbosity>=1,
		With[{tr=traits,op=Sequence@@findecoattractoropts},
		PrintCall[Global`sol=FindEcoAttractor[tr,op]]
	]];
	sol=FindEcoAttractor[traits,Evaluate[Sequence@@findecoattractoropts]]
];
VPrint[1,"sol=",sol];

(* thread a list of points *)
If[Length[Dimensions[pointin]]==2,
	(*Print["mapping over points"];*)
	Return[Map[DInv[traits,sol,{var,ord},#,opts]&,pointin]]
];

VPrint[3,"pointin=",pointin];
VPrint[3,"species=",species];

(* figure out point where to evaluate derivative *)
If[pointin=={},
	(* no point given *)
	If[var===All,
		targetgu=guild,
		If[ListQ[var],targetgu=LookUp[var[[1]]][[2]],targetgu=LookUp[var][[2]]]
	];
	If[species===All,If[\[ScriptCapitalN][targetgu]==0,species=0,species=Table[sp,{sp,\[ScriptCapitalN][targetgu]}]]];
	If[ListQ[species],
		If[method=="NDInv",Return[Table[DInv[traits,sol,{var,ord},{},Species->sp,opts],{sp,species}]]];
		point=Table[Table[Subscript[gtrait,0]->Subscript[gtrait,sp],{gtrait,gtraits[targetgu]}],{sp,species}]/.traits
	,
		pt1=Table[
			If[guild1[interaction]===targetgu,Subscript[interaction,0,sp\[Prime]_]->(Subscript[interaction,species,sp\[Prime]]/.traitsin),Nothing]
		,{interaction,interactions}];
		pt2=Table[
			If[guild2[interaction]===targetgu,Subscript[interaction,sp\[Prime]_,0]->(Subscript[interaction,sp\[Prime],species]/.traitsin),Nothing]
		,{interaction,interactions}];
		point=Join[pt1,pt2,Table[Subscript[gtrait,0]->(Subscript[gtrait,species]/.traitsin),{gtrait,gtraits[targetgu]}]]
	];
,
	(* point given *)
	targetgu=LookUp[pointin[[1,1]]][[2]];
	point=pointin
];
VPrint[3,"targetgu=",targetgu];
VPrint[3,"point=",point];

If[var===All,
	vars=Table[Subscript[gtrait,0],{gtrait,gtraits[targetgu]}],
	vars=var
];
VPrint[3,"vars=",vars];

VPrint[3,"method=",method];
Which[
	method=="D",
	If[verbosity>=1,
		With[{tr=traits,so=sol,tg=targetgu,op=Sequence@@invopts},
		PrintCall[Global`inv=Simplify[Inv[tr,so,Guild->tg,op],Assumptions->_\[Element]Reals]]
	]];
	inv=Inv[Join[traits,fixedattributes],Join[sol,fixedvariables],Guild->targetgu,Evaluate[Sequence@@invopts]];
	VPrint[1,"inv=",inv];
	If[verbosity>=1,
		With[{vars=vars,inv=inv,point=point,traits=traits},
		PrintCall[Global`res=D[inv,{vars,ord}]/.point/.traits]
	]];
	res=D[inv,{vars,ord}]/.point/.traits/.fixed; (* is /.traits necessary?? *)
	VPrint[1,"res=",res];
,
	method=="NDInv",
	Which[
		ord==1,
		If[ListQ[vars],
			(* gradient *)
			Return[DInv[traits,sol,{#,ord},point,opts]& /@ vars];
		, (* first derivative *)
			VPrint[3,"1st derivative (finite difference)"];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invl=",invl];
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invr=",invr];
			If[invl==$Failed||invr==$Failed,Return[$Failed]];
			res=(invr-invl)/(2h);
		]
	,
		ord==2, 
		If[ListQ[vars],
			(* Hessian matrix *)
			VPrint[3,"Hessian matrix (finite difference)"];
			res=ConstantArray[0,{Length[vars],Length[vars]}];
			Do[
				(* diagonal entries *)		
				h=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
				res=ReplacePart[res,{v1,v1}->
					(Inv[traits,sol,RuleListTweak[point,vars[[v1]],h],Evaluate[Sequence@@invopts]]
					-2Inv[traits,sol,point,Evaluate[Sequence@@invopts]]
					+Inv[traits,sol,RuleListTweak[point,vars[[v1]],-h],Evaluate[Sequence@@invopts]])/(h^2)
				];
				(* offdiagonal entries *)
				Do[
					h1=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
					h2=(\[Epsilon]r*vars[[v2]]/.point)+\[Epsilon]a;
					res=ReplacePart[res,{{v1,v2},{v2,v1}}->
						(Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,-h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,h2}],Evaluate[Sequence@@invopts]]
						+Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,-h2}],Evaluate[Sequence@@invopts]])/(4*h1*h2)
					];					
				,{v2,v1+1,Length[vars]}]
			,{v1,1,Length[vars]}];
		, (* second derivative *)
			VPrint[3,"2nd derivative (finite difference)"];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invl=",invl];
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invr=",invr];
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=point,op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invc=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invc=Inv[tr,so,pt,op]]
				]
			]];
			invc=Inv[traits,sol,point,Evaluate[Sequence@@invopts]];
			VPrint[1,"invc=",invc];
			If[invl==$Failed||invr==$Failed||invc==$Failed,Return[$Failed]];
			res=(invr-2invc+invl)/(h^2);
			];
		]
	,
		Else,
		Message[DInv::badmtd];
		Return[$Failed];
	];

(* postprocess & return answer *)

Which[
	simplifyresult===True,
	res2=Simplify[res/.traits],
	simplifyresult===Real,
	res2=RealSimplify[res/.traits],
	simplifyresult===Full,
	res2=FullSimplify[res/.traits,Assumptions:>{_\[Element]Reals}],
	Else,
	res2=res/.traits
];

If[chop==True,Return[Chop[res2]],Return[res2]];

]];


(* first derivative abbreviated syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,1];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no point syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_?NumberQ},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,2];*)
	If[Global`debug,Print["DInv: no point given"]];
	DInv[traits,solin,{var,ord},Guild->Automatic,opts]
);


(* no order *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,3];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,4];*)
	If[Global`debug,Print["Dinv: no order, no point"]];
	DInv[traits,solin,{var,1},Guild->1,opts]
);


(* no var, no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,opts___?OptionQ]:=(
	(*AppendTo[Global`uses,5];*)
	If[Global`debug,Print["DInv: no var, no order, no point"]];
	DInv[traits,solin,{All,1},opts]
);


(* first derivative abbreviated syntax & break up traitsandpops *)
DInv[eesol_?AttributesAndVariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,6];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax & break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,1},pointin,opts]
);


(* general derivative abbreviated syntax *)
DInv[eesol_?AttributesAndVariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_Integer},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,7];*)
	If[Global`debug,Print["DInv: general derivative abbreviated syntax"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,ord},pointin,opts]
);


(* break up traitsandpops *)
DInv[eesol_?AttributesAndVariablesQ,rest___]:=(
	(*AppendTo[Global`uses,8];*)
	If[Global`debug,Print["DInv: break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],rest]
);


(* first derivative abbreviated syntax, no traits or variables *)
DInv[var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,9];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax, no traits or variables"]];
	DInv[{},{},{var,1},pointin,opts]
);


NDInv[args___]:=DInv[args,Method->"NDInv"];


MaximizeInv::usage = 
"MaximizeInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds the trait value(s) that maximize invasion fitness into a community with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


MaximizeInv[traits:(_?AttributesQ):{},sol:(_?VariablesQ):{},opts:OptionsPattern[]]:=
 
Module[{
(* options *)
verbose,guild,delayinv,invopts,maximizeopts,method,constraints,
(* other variables *)
vars,unks,eps,inv,res},

Block[{\[ScriptCapitalN],verbosity,func="MaximizeInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[MaximizeInv]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[MaximizeInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[MaximizeInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
delayinv=OptionValue[DelayInv];
invopts=OptionValue[InvOpts];
maximizeopts=OptionValue[MaximizeOpts];
method=OptionValue[Method];
constraints=OptionValue[Constraints];

(* reset $InvCount *)
$InvCount=0;

vars=Table[Subscript[gtrait,0],{gtrait,gtraits[guild]}];
unks=Table[Unk[Subscript[gtrait,0]],{gtrait,gtraits[guild]}];

Which[
	constraints==="None",
	constraints={};
,
	constraints===Automatic,
	constraints=Table[
		eps=(10.^-8)(Max[range[gtrait]]-Min[range[gtrait]]);
		Min[range[gtrait]]+eps<=Subscript[gtrait,0]<=Max[range[gtrait]]-eps
	,{gtrait,gtraits[guild]}]
];

VPrint[1,"constraints=",constraints];

If[delayinv==True,
	inv[varz_?NumericListQ]:=Inv[traits,sol,Thread[vars->varz],Evaluate[Sequence@@invopts]];
	res=NMaximize[Prepend[constraints/.ToUnks,inv[unks]],unks,Evaluate[Sequence@@maximizeopts]];
	, (* else *)
	Off[NIntegrate::inumr];
	inv=Inv[traits,sol,Guild->guild,Evaluate[Sequence@@invopts]];
	VPrint[1,"inv=",inv];
	Which[
		method=="Maximize",
		res=Maximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]],
		method=="NMaximize",
		(* see https://mathematica.stackexchange.com/questions/245404/ *)
		If[$VersionNumber==12.2,
			Block[{Optimization`UseConvexMinimize=False},res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]]],
			res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]]
		],
		Else,
		Message[MaximizeInv::badmtd];
		Return[$Failed]
	];
	On[NIntegrate::inumr]
];

Return[res/.FromUnks];

]];


Options[MaximizeInv]={Verbose->False,Verbosity->0,
Guild->Automatic,DelayInv->False,InvOpts->{},MaximizeOpts->{},Constraints->Automatic,Method->"NMaximize"};


(* break up combined traitsandpops *)
MaximizeInv[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=MaximizeInv[ExtractAttributes[sol],ExtractVariables[sol],opts];


GlobalESSQ::usage =
"GlobalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks global ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


GlobalESSQ[traits_?AttributesQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,
maximizeinvopts,invthreshold,
(* other variables *)
inv,tmp},

Block[{\[ScriptCapitalN],verbosity,func="GlobalESSQ"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[GlobalESSQ]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[GlobalESSQ]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[GlobalESSQ]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

maximizeinvopts=Evaluate[MaximizeInvOpts/.Flatten[{opts,Options[GlobalESSQ]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[GlobalESSQ]}]];

(* find max invader rate .. if > invthreshold, then not globaless *)

Do[
	tmp[gu]=MaximizeInv[traits,sol,Guild->gu,maximizeinvopts];
	VPrint[1,"MaximizeInv guild ",gu,"=",tmp[gu]];
,{gu,guilds}];

Return[{
	Table[If[tmp[gu][[1]]>invthreshold,False,True],{gu,guilds}],
	Table[{tmp[gu][[1]],Table[gtrait->(Subscript[gtrait,0]/.tmp[gu][[2]]),{gtrait,gtraits[gu]}]},{gu,guilds}]}
];

]];


Options[GlobalESSQ]={Verbose->False,Verbosity->0,
MaximizeInvOpts->{},InvThreshold->10^-10};


GlobalESSQ[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
	GlobalESSQ[ExtractAttributes[eesol],ExtractVariables[eesol],opts];


LocalESSQ::usage=
"LocalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks local ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


LocalESSQ[traits_?AttributesQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["LocalESSQ"],
(* options *)
verbose,
(* other variables *)
res
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

res=Table[
	NegativeDefiniteMatrixQ/@DInv[traits,sol,{Replace[gtraits[gu],var_Symbol->Subscript[var, 0],1],2}]
,{gu,guilds}];

Return[res]
]];


Options[LocalESSQ]={
};


LocalESSQ[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=LocalESSQ[ExtractAttributes[eesol],ExtractVariables[eesol],opts];


PlotInv::usage =
"PlotInv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] plots a fitness landscape, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).";


PlotInv[attributes:(_?AttributesQ):{},sol:(_?VariablesQ):{},invaderGs:(_?GsQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,monitor,
fixed,species,delayinv,invopts,time,plotopts,plotspecies,markerstyle,plotguildopts,tf,axeslabel,plotrange,tadplotrange,
(* other variables *)
nb,x,iplot,
iopts,imin,imax,tmin,tmax,s,iaspectratio,iticks,iaxesorigin,iplotrangepadding,resplotrange,lmin,
gu,tr,per,res,inv,epilog,tad},

Block[{\[ScriptCapitalN],verbosity,func="PlotInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotInv]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotInv]}]];
species=Evaluate[Species/.Flatten[{opts,Options[PlotInv]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotInv]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotInv]}]];
If[delayinv===Automatic,If[modelperiod=!=0,delayinv=True,delayinv=False]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotInv]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotInv]}]];
plotspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PlotInv]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PlotInv]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PlotInv]}]];
plotguildopts=Join[Evaluate[PlotGuildOpts/.Flatten[{opts,Options[PlotInv]}]],{PlotRange->{0,All}}];
tadplotrange=PlotRange/.plotguildopts;
tf=Evaluate[TADVerticalScale/.Flatten[{opts,Options[PlotInv]}]];
plotopts=FilterRules[Flatten[{opts,Options[PlotInv]}],Options[Plot]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotInv]}]];
If[axeslabel===Automatic,axeslabel={trait1}];

(* figure out what trait is on the x-axis *)
{gu,tr}=LookUp[trait1][[2;;3]];

(* add to fixed if species is given *)
If[species=!=None,
	fixed=Flatten@{
		fixed,
		Table[
			{If[guild1[interaction]===gu,Subscript[interaction,0,sp\[Prime]_]->(Subscript[interaction,species,sp\[Prime]]/.attributes),Nothing],
			If[guild2[interaction]===gu,Subscript[interaction,sp\[Prime]_,0]->(Subscript[interaction,sp\[Prime],species]/.attributes),Nothing]}
		,{interaction,EcoEvo`Private`interactions}],
		Table[If[Subscript[gtrait,0]=!=trait1,Subscript[gtrait,0]->(Subscript[gtrait,species]/.attributes),Nothing],{gtrait,gtraits[gu]}]
		}
];
(*Print["fixed=",fixed];*)

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes,sol];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[monitor,PrintTemporary[Dynamic[ToString[TraditionalForm@trait1]<>"="<>ToString[TraditionalForm@x]]]];

(* plot fitness function *)
If[delayinv,
	(* delay inv *)
	inv[\[FormalX]_?NumberQ]:=Inv[attributes,sol,Join[{Subscript[tr,0]->\[FormalX]},fixed],invaderGs,Guild->gu,Evaluate[Sequence@@invopts],Time->time];
	iplot=Plot[(x=\[FormalX];Evaluate[inv[\[FormalX]]]),{\[FormalX],trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
,
	(* nondelay inv *)
	Off[NIntegrate::inumr];
	inv=Inv[attributes,sol,invaderGs,Guild->gu,Evaluate[Sequence@@invopts],Time->time]/.fixed/.attributes;
	VPrint[1,"inv=",inv];
	iplot=Plot[inv,{trait1,trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
	On[NIntegrate::inumr]
];

(*Print[iplot];*)

(* plot species markers *)
If[Subscript[\[ScriptCapitalN], gu]==0,plotspecies="None"];
Which[
	plotspecies==="Axis",
	If[markerstyle===Automatic,
		epilog=Table[{PointSize[0.015],Color[Subscript[tr,sp]][SpFrac[sp,\[ScriptCapitalN][gu]]],Point[{Subscript[tr,sp]/.attributes,0}]},{sp,\[ScriptCapitalN][gu]}],
		epilog=MapThread[Append,{PadRight[{},\[ScriptCapitalN][gu],
			Map[Flatten[{#}]&,markerstyle]],Table[Point[{Subscript[tr,sp]/.attributes,0}],{sp,\[ScriptCapitalN][gu]}]}]
	];
	res=Show[iplot,Epilog->epilog]
,
	plotspecies==="TAD",
	epilog={};
	tad=PlotGuild[attributes,TemporalMean[sol],PlotRange->{{trait1min,trait1max},tadplotrange},Evaluate[Sequence@@plotguildopts],
		ImagePadding->{{0,0},{0,Scaled[0.05]}},Axes->False,Guild->gu,Species->species,Time->time];
	{tmin,tmax}=(PlotRange/.AbsoluteOptions[tad,PlotRange])[[2]];
	iopts=AbsoluteOptions[iplot];
	{imin,imax}=(PlotRange/.iopts)[[2]];
	(*Print["{imin,imax}=",{imin,imax}];
	Print["{tmin,tmax}=",{tmin,tmax}];*)
	iaspectratio=AspectRatio/.iopts;
	iticks=Ticks/.iopts;
	iaxesorigin=AxesOrigin/.iopts;
	iplotrangepadding=PlotRangePadding/.iopts;
	(*Print["iaxesorigin=",iaxesorigin];
	Print["iplotrangepadding=",iplotrangepadding];*)
	s=Max[tf*imin/(tmax(tf-1)),tf*(imax-Min[0,imin])/tmax]; (* scale TAD *)
	(*Print["s=",s];*)
	resplotrange={Min[imin,tmin],Max[imax,s*tmax]};
	If[Head[iplotrangepadding[[2,2]]]===Scaled,
		lmin=imax+1.01*Differences[resplotrange][[1]]*iplotrangepadding[[2,2,1]],
		lmin=imax+iplotrangepadding[[2,2]]+0.01*Differences[resplotrange][[1]]
	];
	(*Print["lmin=",lmin];*)
	res=Show[iplot,
		PlotRange->{{trait1min,trait1max},resplotrange},Ticks->iticks,
		Prolog->{{White,Thick,Line[{{iaxesorigin[[1]],lmin},{iaxesorigin[[1]],10^10}}]},
		Inset[Show[tad,AspectRatio->iaspectratio*tf],{0,0},{0,0},Scaled[1]]}];
	(*res=Show[
		iplot,
		PlotRange\[Rule]{{trait1min,trait1max},plotrange},Ticks\[Rule]iticks,
		Epilog\[Rule]{{White,Line[{{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],lmin},{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],10^10}}]},
		Inset[Show[tad,AspectRatio\[Rule]iaspectratio*tf],{0,0},{0,0},Scaled[1]],
		Inset[Show[iplot,Axes\[Rule]False,PlotRange\[Rule]{{trait1min,trait1max},resplotrange}],{0,0},{0,0},Scaled[1]]}]*)
,
	Else,
	res=iplot
];

If[monitor,NotebookClose[nb]];

Return[res]
]];


(* split combined traitsandpops *)
PlotInv[traitsandpops_?AttributesAndVariablesQ,invaderGs:(_?GsQ):{},{trait1_,trait1min_,trait1max_},opts___?OptionQ]:=
PlotInv[ExtractAttributes[traitsandpops],ExtractVariables[traitsandpops],invaderGs,{trait1,trait1min,trait1max},opts];


Options[PlotInv]={Verbose->False,Verbosity->0,
InvOpts->{},Fixed->{},Species->None,
DelayInv->Automatic,Time->t,
MarkerStyle->Automatic,ShowSpecies->"TAD",PlotGuildOpts->{},TADVerticalScale->0.25,
AxesLabel->Automatic,PlotRange->Automatic,
PlotStyle->Gray,PlotPoints->5,
Monitor->False
};


PlotZIP::usage =
"PlotZIP[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] creates a zero invasion plot, with invader \!\(\*
StyleBox[\"inv\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(inferred if omitted).
PlotZIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PlotZIP[solin_:"FindEcoAttractor",{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},
invaderin:(_?InvaderQ):Automatic,opts___?OptionQ]:=

Module[{
(* options *)
verbose,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,ics,invthreshold,guild,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
fixedvars,traitinv,subrule,luv1,luv2,gu,tr1,tr2,invader,sol,inv,res},

Block[{\[ScriptCapitalN],verbosity,func="PlotInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotZIP]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotZIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotZIP]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotZIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotZIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotZIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotZIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotZIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotZIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotZIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotZIP]}]];
If[invthreshold===Automatic,invthreshold=If[modeltype=="DiscreteTime",1,0]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotZIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotZIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotZIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

fixedvars=fixed[[All,1]];

(* figure out what are the traits on the x- and y-axes *)

luv1=LookUp[var1];
luv2=LookUp[var2];
VPrint[3,"LookUp[var1]=",luv1," LookUp[var2]=",luv2];

traitinv={};subrule={};
If[luv1[[1]]==="gtrait",
	{gu,tr1}=luv1[[2;;3]];
	AppendTo[traitinv,var1->\[FormalX]],
	AppendTo[subrule,var1->\[FormalX]]
];
If[luv2[[1]]==="gtrait",
	If[luv1[[1]]==="gtrait"&&(luv2[[2]]!=gu),Message[PlotZIP::diffsp];Return[$Failed]];
	{gu,tr2}=luv2[[2;;3]];
	AppendTo[traitinv,var2->\[FormalY]],
	AppendTo[subrule,var2->\[FormalY]]
];

(*Print["gu=",gu];
Print["traitinv=",traitinv];
Print["subrule=",subrule];*)

If[
	invaderin===Automatic,
	If[MemberQ[guilds,gu],
		invader=traitinv,
		Message[PlotZIP::unkinv];Return[$Failed]
	]
,
	invader=invaderin
];
(*Print["invader=",invader];*)

If[boundarystyle===Automatic,
	If[LookUp[invader][[1]]=="pcomp",
		boundarystyle={Color[invader],Opacity[1]},
		boundarystyle={Black,Opacity[1]}]
];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={var1,var2,"inv"},
		framelabel={var1,var2}
	]
];

(* define resident sol *)
If[solin==="FindEcoAttractor",
	If[fixed=={},
		sol[\[FormalX]_,\[FormalY]_]={}
	,
		If[ics=={},
			(* figure out number of species in guilds *)
			Set\[ScriptCapitalN][fixed];
			VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
			ics=DefaultICs;
			VPrint[1,"ics=",ics];
		];
		If[verbose,
			With[{tr=fixed,ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[\[FormalX],\[FormalY]]=FindEcoAttractor[trait,ics,op]]
		]];
		sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
			result=FindEcoAttractor[fixed,ics,Evaluate[Sequence@@findecoattractoropts]];
			If[printtrace,Print["EcoAttractor (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
			If[result=={$Failed},Message[PlotZIP::feafail,\[FormalX],\[FormalY]]];
			Return[result]
		];
		delayinv=True]
,
		If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{var1->\[FormalX],var2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{var1->\[FormalX],var2->\[FormalY]};
	VPrint[1,"sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]];
];

(* define inv *)

If[delayinv,
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[\[FormalX],\[FormalY]]=Inv[tr,so,in,op]/.{var1->\[FormalX],var2->\[FormalY]}]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[fixed,sol[\[FormalX],\[FormalY]],invader,Evaluate[Sequence@@invopts]]/.subrule;
		If[printtrace,Print["Inv (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts,sr=subrule,trinv=traitinv},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,in,op]/.sr/.trinv]
	]];
	inv[\[FormalX]_,\[FormalY]_]=Inv[fixed,sol[\[FormalX],\[FormalY]],invader/.Subscript[var_, sub_]->Subscript[var, 0],Evaluate[Sequence@@invopts]]/.subrule/.traitinv;
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]]
];

If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[var1],TextCell["="],Dynamic[x]},
		{ExpressionCell[var2],TextCell["="],Dynamic[y]}
		}],WindowTitle->"PlotZIP Progress...",WindowSize->All];
];


Which[
	plottype=="Plot3D",
	res=Plot3D[({x,y}={\[FormalX],\[FormalY]};{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold}),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"]],
	plottype=="ContourPlot",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,PlotRange->{{var1min,var1max},{var2min,var2max}}],
	plottype=="RegionZIP", 
	res=RegionPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="ZIP",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,
		ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,
		PlotRange->{{var1min,var1max},{var2min,var2max}}],
	Else,
	Message[PlotZIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotZIP]={Verbose->False,Verbosity->0,
FindEcoAttractorOpts->{},InvOpts->{},
DelayInv->False,PlotType->"ZIP",ICs->{},Fixed->{},InvThreshold->Automatic,
PlotOpts->{MaxRecursion->3},
BoundaryStyle->Automatic,InvStyle->Gray,NonInvStyle->Opacity[0],
Monitor->False
};


PlotZIP::unkinv=
"Can't figure out who's invading: please specify.";

PlotZIP::diffsp=
"\!\(\*
StyleBox[\"x\", \"TI\"]\)- and \!\(\*
StyleBox[\"y\", \"TI\"]\)-axes should have the same species.";


PlotZNGI::usage =
"PlotZNGI[\!\(\*
StyleBox[\"sp\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots a zero net growth isocline of \!\(\*
StyleBox[\"sp\", \"TI\"]\).
PlotZNGI[{\!\(\*
StyleBox[\"sp1\", \"TI\"]\), \!\(\*
StyleBox[\"sp2\", \"TI\"]\), \[Ellipsis]}, {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots multiple ZNGIs.
PlotZNGI[\!\(\*
StyleBox[\"traits\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ZNGIs with \!\(\*
StyleBox[\"traits\", \"TI\"]\).";


PlotZNGI[invaders_?RuleListQ,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
plotstyle,
(* other variables *)
boundarystyle
},
Block[{\[ScriptCapitalN],verbosity,func="PlotInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotZNGI]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotZNGI]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotZNGI]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotZNGI]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][invaders];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

Return[Show[Table[Table[
	If[plotstyle===Automatic,
		boundarystyle={Color[Subscript[gcomps[gu][[1]],0]][SpFrac[sp,\[ScriptCapitalN][gu]]],Opacity[1]},
		boundarystyle=Flatten[{plotstyle,Opacity[1]}]
	];
	PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},Table[Subscript[gtrait, 0]->Subscript[gtrait, sp]/.invaders,{gtrait,gtraits[gu]}],
		opts,InvStyle->Opacity[0],BoundaryStyle->boundarystyle]
,{sp,\[ScriptCapitalN][gu]}],{gu,guilds}]]]
]
];


PlotZNGI[invaders_List,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=
	Show[PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},#,opts,InvStyle->Opacity[0]]&/@invaders];


PlotZNGI[invader_,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=
	PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},invader,opts,InvStyle->Opacity[0]];


Options[PlotZNGI]={Verbose->False,Verbosity->0,
PlotStyle->Automatic};


PlotPIP::usage =
"PlotPIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a pairwise invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotPIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.";


PlotPIP[solin_:"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,randomseeding,
plotopts,plottype,ics,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,res,sol,resinv,inv},

Block[{\[ScriptCapitalN],verbosity,func="PlotPIP"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotPIP]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotPIP]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotPIP]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];
If[verbosity>=1,verbose=True];

(* handle options *)

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotPIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotPIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotPIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotPIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotPIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotPIP]}]];
randomseeding=Evaluate[RandomSeeding/.Flatten[{opts,Options[PlotPIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotPIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotPIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotPIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotPIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotPIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotPIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotPIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotPIP]}]];

If[zerodiagonal,inv[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={trait1,Subscript[tr1,0],"inv"},
		framelabel={trait1,Subscript[tr1,0]}
	]
];

(* fixed traits for invader *)
invfixed=Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}];

(* define resident sol *)

Which[
	solin==="FindEcoAttractor",
	If[ics=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Append[fixed,trait1->trait1]];
		VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
		ics=DefaultICs;
		VPrint[1,"ics=",ics];
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ]:=Global`sol[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol[\[FormalX]_?NumberQ]:=sol[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],EcoSimOpts->{RandomSeeding->randomseeding}];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotPIP::feafail,trait1,\[FormalX]]];
		Return[result]
	];
	delayinv=True;
,
	TemporalRuleListQ[solin],
	sol[\[FormalX]_]=solin/.(var_->if_)->(var->if[\[FormalX]]);
,
	Else,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_]=solin/.trait1->\[FormalX]]];
	sol[\[FormalX]_]=solin/.trait1->\[FormalX];
	VPrint[1,"sol[\[FormalX]]=",sol[\[FormalX]]];
];

(* define inv *)
If[delayinv,
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
				PrintCall[Global`resinv[(System`\[FormalX])_?NumberQ]:=Global`resinv[System`\[FormalX]]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_?NumberQ]:=resinv[\[FormalX]]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts]];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Global`sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
		If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		If[subtractdiagonal,result=result-resinv[\[FormalX]]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
			PrintCall[Global`resinv[(System`\[FormalX])_]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_]=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts]];
		VPrint[1,"resinv[\[FormalX]]=",resinv[\[FormalX]]];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_,\[FormalY]_]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]]
			-If[subtractdiagonal==True,resinv[\[FormalX]],0];
	VPrint[1,"inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]];
];

If[monitor,PrintTemporary[Grid[{{Dynamic[ToString[TraditionalForm@trait1]<>"="<>ToString[TraditionalForm@x]],
Dynamic[ToString[TraditionalForm@Subscript[tr1,0]]<>"="<>ToString[TraditionalForm@y]]}},ItemSize->10,Alignment->Left]]];

Which[
	plottype=="Plot3D",
	res=Plot3D[{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold},{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"],EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="ContourPlot",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="RegionPlot", 
	res=RegionPlot[Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="PIP",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	Else,
	Message[PlotPIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotPIP]={Verbose->False,Verbosity->0,
FindEcoAttractorOpts->{},InvOpts->{},RandomSeeding->1234,
DelayInv->False,PlotType->"PIP",ICs->{},ZeroDiagonal->False,Fixed->{},SubtractDiagonal->False,InvThreshold->0,
PlotOpts->{MaxRecursion->3},FrameLabel->Automatic,
BoundaryStyle->Black,InvStyle->Gray,NonInvStyle->White,
Monitor->False
};


PlotPIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";


PlotMIP::usage =
"PlotMIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a mutual invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotMIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotMIP[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotMIP[{\!\(\*
StyleBox[\"sol1\", \"TI\"]\), \!\(\*
StyleBox[\"sol2\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibria \!\(\*
StyleBox[\"sol1\", \"TI\"]\) and \!\(\*
StyleBox[\"sol2\", \"TI\"]\).";


PlotMIP[{solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",solin2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,icsin,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,spcolors,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,gu2,tr2,sp2,ics,sol1,sol2,inv12,inv21,pip1,pip2,res},

Block[{\[ScriptCapitalN],verbosity,func="PlotMIP"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotMIP]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotMIP]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotMIP]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotMIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotMIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotMIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotMIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotMIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotMIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotMIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotMIP]}]];
icsin=Evaluate[ICs/.Flatten[{opts,Options[PlotMIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotMIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotMIP]}]];
spcolors=Evaluate[SpeciesColors/.Flatten[{opts,Options[PlotMIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotMIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotMIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

If[zerodiagonal,inv12[\[FormalX]_,\[FormalX]_]=inv21[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* fixed traits for invader [why are there 2 of these?] *)
invfixed=Flatten[Join[
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}],
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu2],{tr2}]}]
]];

(* define resident sol *)

Which[
	solin1==="FindEcoAttractor",
	If[icsin=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Append[fixed,trait1->trait1]];
		VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
		ics=DefaultICs;
		VPrint[1,"ics=",ics];
	,
		ics=icsin
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol1[(System`\[FormalX])_?NumberQ]:=Global`sol1[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol1[\[FormalX]_?NumberQ]:=sol1[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts]];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotMIP::feafail,trait1,\[FormalX]]];
		Return[result];
	];
	delayinv=True;
,
	TemporalRuleListQ[solin1],
	sol1[\[FormalX]_]=solin1/.(var_->if_)->(var->if[\[FormalX]]);
,
	Else,
	If[verbose,PrintCall[Global`sol1[(System`\[FormalX])_]=solin1/.trait1->\[FormalX]]];
	sol1[\[FormalX]_]=solin1/.trait1->\[FormalX];
	VPrint[1,"sol1[\[FormalX]]=",sol1[\[FormalX]]]
];

If[trait1=!=trait2,
	Which[
		solin2==="FindEcoAttractor",
		delayinv=True;
		If[icsin=={},
			(* figure out number of species in guilds *)
			Set\[ScriptCapitalN][Append[fixed,trait2->trait2]];
			VPrint[3,"\[ScriptCapitalN]2=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
			ics=DefaultICs;
			VPrint[1,"ics=",ics];
		,
			ics=icsin
		];
		If[verbose,
			With[{tr=Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol2[(System`\[FormalX])_?NumberQ]:=Global`sol2[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
		]];
		sol2[\[FormalX]_?NumberQ]:=sol2[\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts]];
			If[printtrace,Print["EcoAttractor (",trait2,"=",\[FormalX],"): ",result]];
			If[result=={$Failed},Message[PlotMIP::feafail,trait2,\[FormalX]]];
			Return[result];
		];
	,
		TemporalRuleListQ[solin2],
		sol2[\[FormalX]_]=solin2/.(var_->if_)->(var->if[\[FormalX]]);
	,
		Else,
		If[verbose,PrintCall[Global`sol2[(System`\[FormalX])_]=solin2/.trait2->\[FormalX]]];
		sol2[\[FormalX]_]=solin2/.trait2->\[FormalX];
		VPrint[1,"sol2[\[FormalX]]=",sol2[\[FormalX]]]
	]
,
	sol2[\[FormalX]_]:=sol1[\[FormalX]];
	VPrint[1,"sol2[\[FormalX]]=sol1[\[FormalX]]"]
];

(* define inv21 & inv12 *)
If[delayinv,
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Defer[Global`sol1][\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts,trinv=Subscript[trait[gu2,tr2],0]},
			PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv21[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
		If[printtrace,Print["Inv (",trait2,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		Return[result]
	];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Defer[Global`sol2][\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv12[\[FormalX],\[FormalY]]=Module[{result},
			result=Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
			If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr2,0],"=",\[FormalY],"): ",result]];
			Return[result]
		];
	,
		(* if trait1=trait2, then re-use inv21 *)
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]]
	]
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Defer[Global`sol1][\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts},
			PrintCall[Global`inv21[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_,\[FormalY]_]=
		Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Global`sol2[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_,\[FormalY]_]=
			Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]]
	,
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]];
		VPrint[1,"inv12[\[FormalX],\[FormalY]]=inv21[\[FormalX],\[FormalY]]"]
	]
];


If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[trait1],TextCell["="],Dynamic[x]},
		{ExpressionCell[If[trait2===trait1,Subscript[tr1,sp1+1],trait2]],TextCell["="],Dynamic[y]}
		}],WindowTitle->"PlotMIP Progress...",WindowSize->All];
];


Which[
	plottype=="MIP",
	pip1=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv21[\[FormalX],\[FormalY]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv12[\[FormalY],\[FormalX]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1//AxisFlip
	];
	res=Show[Graphics[{invstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,Frame->True,FrameLabel->framelabel,
		Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionMIP",
	res=RegionPlot[{!Evaluate[(inv12[\[FormalY],\[FormalX]]>invthreshold&&inv21[\[FormalX],\[FormalY]]>invthreshold)],Evaluate[(inv12[\[FormalY],\[FormalX]]>invthreshold&&inv21[\[FormalX],\[FormalY]]>invthreshold)]},
		{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		PlotStyle->{noninvstyle,invstyle},BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="Outcome",
	pip1=ContourPlot[Evaluate[inv21[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[2]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[Evaluate[inv12[\[FormalY],\[FormalX]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[1]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1/.spcolors[[2]]->spcolors[[1]]//AxisFlip
	];
	res=Show[Graphics[{noninvstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,
		Frame->True,FrameLabel->framelabel,Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionOutcome",
	res=RegionPlot[Evaluate[{inv21[\[FormalX],\[FormalY]]>invthreshold,inv12[\[FormalY],\[FormalX]]>invthreshold}]
		,{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],BoundaryStyle->boundarystyle,
		PlotStyle->{Directive[spcolors[[1]],Opacity[0.4]],Directive[spcolors[[2]],Opacity[0.4]]},FrameLabel->framelabel],
	Else,
	Message[PlotMIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res];

]];


(* only one sol given *)
PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},
	{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
((*Print[1];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


(* only one sol given *)
PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},
	opts___?OptionQ]:=
((*Print[2];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait1,trait1min,trait1max},opts]);


(* no sol given *)
PlotMIP[{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},
	opts___?OptionQ]:=
((*Print[3];*)PlotMIP[{"FindEcoAttractor","FindEcoAttractor"},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


Options[PlotMIP]={Verbose->False,Verbosity->0,
PlotType->"MIP",DelayInv->False,FindEcoAttractorOpts->{},InvOpts->{},InvThreshold->0,
ICs->{},ZeroDiagonal->False,Fixed->{},
BoundaryStyle->Black,SpeciesColors->{Red,Blue},InvStyle->Gray,NonInvStyle->White,FrameLabel->Automatic,
PlotOpts->{MaxRecursion->3},
Monitor->False
};


PlotMIP::feafail="FindEcoAttractor failed at `1`=`2`.";
PlotMIP::badmtd="The PlotType option should be a built-in method name (\"MIP\", \"RegionMIP\", \"Outcome\", or \"RegionOutcome\").";


TraitEqns::usage=
"TraitEqns[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] sets up trait equations with ecological solution \!\(\*
StyleBox[\"sol\", \"TI\"]\) and trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


TraitEqns[solin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=
 
Module[{
(* options *)
verbose,verboseall,fixed,
logged,delaydinv,dinvopts,evoeqn,traitshiftrate,nsps,ics,time,ignorevar,momentbased,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedtraits,alltraits,Gs,
g,dtrait,pre,wt,sol,eqns},

Block[{\[ScriptCapitalN],verbosity,func="TraitEqns"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[TraitEqns]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[TraitEqns]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[TraitEqns]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[TraitEqns]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
VPrint[3,"fixedattributes=",fixedattributes];
fixedvariables=ExtractVariables[fixed];
VPrint[3,"fixedvariables=",fixedvariables];

nonfixedtraits=Evaluate[NonFixedTraits/.Flatten[{opts,Options[TraitEqns]}]];

logged=Evaluate[Logged/.Flatten[{opts,Options[TraitEqns]}]];
momentbased=Evaluate[MomentBased/.Flatten[{opts,Options[TraitEqns]}]];
If[momentbased==Automatic,If[moments==True,momentbased=True,momentbased=False]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[TraitEqns]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[TraitEqns]}]];
If[modelperiod=!=0,AppendTo[dinvopts,InvOpts->{Method->"Instantaneous"}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[TraitEqns]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[TraitEqns]}]];
nsps=Evaluate[\[ScriptCapitalN]s/.Flatten[{opts,Options[TraitEqns]}]];
time=Evaluate[Time/.Flatten[{opts,Options[TraitEqns]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[TraitEqns]}]];

(*Print["solin=",solin];*)
sol=FixVariables[solin];
VPrint[3,"sol=",sol];

(* figure out number of species in guilds *)
If[solin==="FindEcoAttractor"&&nsps=!={},
	Evaluate[Table[\[ScriptCapitalN][gu],{gu,guilds}]]=nsps,
	Set\[ScriptCapitalN][Join[sol,fixedvariables]]
];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(*Print["Gsin="Gsin];*)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(* determine nonfixedtraits = Complement[alltraits,fixedattributes] *)
alltraits=Flatten[Table[Table[Table[If[ngcomps[gu]==1,Subscript[gtrait, i],Table[Subscript[gtrait[gcomp], i],{gcomp,gcomps[gu]}]],{gtrait,gtraits[gu]}],{i,\[ScriptCapitalN][gu]}],{gu,guilds}]];
VPrint[3,"alltraits=",alltraits];
If[nonfixedtraits===Automatic,nonfixedtraits=OrderedComplement[alltraits,fixedattributes]];
VPrint[3,"nonfixedtraits=",nonfixedtraits];

(* shifting traits *)
Do[
	dtrait[gu,gtrait]=If[MemberQ[traitshiftrate[[All,1]],gtrait],gtrait/.traitshiftrate,0]
,{gu,guilds},{gtrait,gtraits[gu]}];
VPrint[3,"dtrait=",Table[dtrait[gu,gtrait],{gu,guilds},{gtrait,gtraits[gu]}]];


If[momentbased==False, (* DInv-based *)

(* set up G matrices *)
Do[
	Do[
		g[gu,sp]=If[MatrixQ[Subscript[G[gu], sp]/.Gs],
			(* if G-matrix is given, symmetrize it to be safe *)
			SymmetrizeMatrix[Subscript[G[gu], sp]/.Gs],
			(* otherwise make one based on given Var[] & Cov[], otherwise assume Var[]=1 & Cov[]=0 *)
			MakeGMatrix[Subscript[gu, sp]]/.Gs/.{Subscript[Var[_], sp]->1,Subscript[Cov[_,_], sp]->0}
		];
		VPrint[3,"g[",gu,",",sp,"]=",g[gu,sp]];
	,{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}]
,{gu,guilds}];

(* pre-factors for weighting population componnents in canonical equation *)
Which[
	evoeqn=="QG",
	Do[Do[pre[gu,sp]=1,{sp,0,\[ScriptCapitalN][gu]}],{gu,guilds}],
	evoeqn=="CE",
	Do[
		Do[
			If[comptype[gcomp]=="Extensive",wt[gu,gcomp]=1,wt[gu,gcomp]=0]
		,{gcomp,gcomps[gu]}];
		Do[
			pre[gu,sp]:=Sum[wt[gu,gcomp]*Subscript[gcomp,sp],{gcomp,gcomps[gu]}]
		,{sp,0,\[ScriptCapitalN][gu]}]
	,{gu,guilds}],
	Else,
	Message[TraitEqns::badte];
	Return[$Failed]
];

(*Print["setting eqns..."];*)

If[delaydinv==True,
	eqns=Flatten[Table[Table[Table[
		Subscript[gtrait,sp]'==(pre[gu,sp]/.ToUnks)*
		Sum[(g[gu,sp]/.ToUnks)[[index[gtrait],index[gtrait\[Prime]]]]NumDInv[BlankUnkTraits,sol,Subscript[gtrait\[Prime],0],Species->sp,Method->"NDInv",Evaluate[Sequence@@dinvopts]],{gtrait\[Prime],gtraits[gu]}]
		-dtrait[gu,gtrait]+If[modeltype=="DiscreteTime",Unk[Subscript[gtrait,sp]],0]
	,{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]]/.fixed
,
	If[sol==="FindEcoAttractor",sol=BlankVariables];
	eqns=Flatten[Table[Table[
		Thread[Table[Subscript[gtrait,sp]',{gtrait,gtraits[gu]}]==(
		pre[gu,sp]*g[gu,sp] . DInv[BlankTraits,sol,Guild->gu,Species->sp,Time->time,Fixed->fixed,Evaluate[Sequence@@dinvopts]]
		-Table[dtrait[gu,gtrait],{gtrait,gtraits[gu]}]
		+If[modeltype=="DiscreteTime",Table[Subscript[gtrait,sp],{gtrait,gtraits[gu]}],0]
		/.fixed)]
	,{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]](*/.FixVarCovts*)
];

VPrint[3,"eqns=",eqns];

eqns=DeleteCases[eqns,DT[var_]==_/;MemberQ[fixedvars,var]];

(*Print["AllVariables=",AllVariables];
Print["logged=",logged];
Print["ExpRule[AllVariables,logged]=",ExpRule[AllVariables,logged]];
Print["returning ",eqns/.ExpRule[AllVariables,logged]];*)

Return[eqns(*/.ExpRule[AllVariables,logged]*)];
,

(* moment-based *)

(*Print["Gs=",Gs];*)
If[ignorevar,
	Return[Table[var'==(dxdtnaive[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed/.Dispatch[ExpandGs[Gs,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]]),{var,nonfixedtraits}]],
	Return[Table[var'==(dxdt[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed/.Dispatch[ExpandGs[Gs,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]]),{var,nonfixedtraits}]]
]

]

]];


Options[TraitEqns]={Verbose->False,Verbosity->0,
Time->t,DelayDInv->False,DInvOpts->{},EvoEquation->"QG",TraitShiftRate->{},Fixed->{},\[ScriptCapitalN]s->{},Logged->False,
NonFixedTraits->Automatic,MomentBased->Automatic,IgnoreVar->False};


VarEqns::usage=
"VarEqns[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] sets up trait variance/covariance equations with traits in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological solution \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


VarEqns[attributesin:(_?AttributesQ):{},solin:(_?VariablesQ):{},opts___?OptionQ]:=
 
Module[{
func=FuncStyle["VarEqns"],
(* options *)
verbose,verboseall,fixed,time,nonfixedvarcovs,ignorevar,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,fixedvarcovs,
allvarcovs,sol,attributes},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[VarEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[VarEqns]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[VarEqns]}]];
(*Print["fixed=",fixed];*)
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
If[Global`debug,Print[func,": fixedattributes=",fixedattributes]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];
fixedvarcovs=ExtractVarCovs[fixed];
If[Global`debug,Print[func,": fixedvarcovs=",fixedvarcovs]];

time=Evaluate[Time/.Flatten[{opts,Options[VarEqns]}]];
nonfixedvarcovs=Evaluate[NonFixedVarCovs/.Flatten[{opts,Options[VarEqns]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[VarEqns]}]];

sol=FixVariables[solin];
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[sol,fixedvariables],attributes];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

allvarcovs=Flatten[Table[Table[Table[MakeGMatrix[Subscript[gcomp, i]],{gcomp,gcomps[gu]}],{i,\[ScriptCapitalN][gu]}],{gu,guilds}]];
If[Global`debug,Print[func,": allvarcovs=",allvarcovs]];
If[nonfixedvarcovs===Automatic,nonfixedvarcovs=OrderedComplement[allvarcovs,fixedvarcovs]];
If[Global`debug,Print["nonfixedvarcovs=",nonfixedvarcovs]];

If[ignorevar,
	Return[Table[var'==(dGdtnaive[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed),{var,nonfixedvarcovs}]],
	Return[Table[var'==(dGdt[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed),{var,nonfixedvarcovs}]]
];

]];


Options[VarEqns]={Verbose->False,Verbosity->0,
Time->t,Fixed->{},NonFixedVarCovs->Automatic,IgnoreVar->False};


PlotEvoStreams::usage=
"PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary streams.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


PlotEvoStreams[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoStreams"],
(* options *)
verbose,verboseall,monitor,printtrace,fixed,time,
evoeqn,fitnessgradient,dinvopts,delaydinv,findecoattractoropts,streamplotopts,framelabel,ecoattnumber,usesymmetry,zerodiagonal,
(* other variables *)
nb,evoeqns,dt,nsps,ics,sol,
gu1,tr1,sp1,gu2,tr2,sp2,res},

Block[{\[ScriptCapitalN],verbosity,func="PlotEvoStreams"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEvoStreams]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEvoStreams]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoStreams]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoStreams]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoStreams]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoStreams]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoStreams]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[fitnessgradient=="NDInv",AppendTo[dinvopts,Method->"NDInv"]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];

streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEvoStreams]}],Options[StreamPlot]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoStreams]}]];
ecoattnumber=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoStreams]}]];
usesymmetry=Evaluate[UseSymmetry/.Flatten[{opts,Options[PlotEvoStreams]}]];

If[modelperiod!=0&&time==t,delaydinv=True;AppendTo[dinvopts,InvOpts->{}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[tr2===tr1,
		framelabel={trait1,SubscriptAdd[trait1,1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	(* figure out number of species in guilds *)
	Set\[ScriptCapitalN][Join[fixed,{trait1->trait1,trait2->trait2}]];
	ics=DefaultICs;
	nsps=Table[\[ScriptCapitalN][gu],{gu,guilds}];
	If[Global`debug,Print[func,": \[ScriptCapitalN]=",nsps]];
,
	nsps={}
];

evoeqns=TraitEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,\[ScriptCapitalN]s->nsps];
If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_'->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
VPrint[1,"evoeqns=",evoeqns];

If[solin==="FindEcoAttractor",
	sol[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=sol[\[FormalX],\[FormalY]]=FindEcoAttractor[{trait1->\[FormalX],trait2->\[FormalY]},ics,Time->time,Evaluate[Sequence@@findecoattractoropts]]/.fixed;
	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];

res=MyStreamPlot[dt[trait1,trait2],{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@streamplotopts],Monitor->monitor];

Return[res]

]];


PlotEvoStreams[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoStreams[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts]


Options[PlotEvoStreams]={Verbose->False,Verbosity->0,
Fixed->{},Time->t,FindEcoAttractorOpts->{},DInvOpts->{},DelayDInv->False,
FrameLabel->Automatic,StreamColorFunction->None,StreamStyle->Gray,
UseSymmetry->False,FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,TraitShiftRate->{},
Monitor->True,PrintTrace->False};


PlotEvoIsoclines::usage=
"PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary isoclines.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


PlotEvoIsoclines[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,verboseall,fixed,time,
monitor,printtrace,dinvopts,findecoattractoropts,plotopts,framelabel,ics,ecoattnum,
estest,isoclinestyle,delaydinv,delaydinv2,dinv2opts,excludediagonal,
(* other variables *)
evoeqns,
ics1,nsps,color1,color1es,color1nes,color2,color2es,color2nes,style1,style1es,style1nes,style2,style2es,style2nes,
sol,dt,dinv21,dinv22,gu1,tr1,sp1,gu2,tr2,sp2,pre1,pre2,iso1,iso2},

Block[{\[ScriptCapitalN],verbosity,func="PlotEvoIsoclines"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ecoattnum=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
estest=Evaluate[ESTest/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv2=Evaluate[DelayDInv2/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinv2opts=Evaluate[DInv2Opts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
excludediagonal=Evaluate[ExcludeDiagonal/.Flatten[{opts,Options[PlotEvoIsoclines]}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[excludediagonal&&{gu1,tr1}=={gu2,tr2},AppendTo[plotopts,Exclusions->{\[FormalX]==\[FormalY]}]];

If[isoclinestyle===Automatic,
	If[{gu1,tr1}==={gu2,tr2},
		color1es=color1nes=color1=Color[trait1][0];
		color2es=color2nes=color2=Color[trait2][1];
	,
		color1es=color1nes=color1=Color[trait1][0.5];
		color2es=color2nes=color2=Color[trait2][0.5];
	];
	style1es=Thickness[0.008];style1nes=Thickness[0.003];style1=Thickness[0.005];
	style2es=Thickness[0.008];style2nes=Thickness[0.003];style2=Thickness[0.005];
,
	If[ListQ[isoclinestyle[[1]]],
		color1es=ExtractColors[isoclinestyle[[1,1]]];
		color1nes=ExtractColors[isoclinestyle[[1,2]]];
		style1es=Complement[isoclinestyle[[1,1]],color1es];
		style1nes=Complement[isoclinestyle[[1,2]],color1nes];
	,
		color1=ExtractColors[isoclinestyle[[1]]];
		style1=Complement[isoclinestyle[[1,1]],color1];
	];
	If[ListQ[isoclinestyle[[2]]],
		color2es=ExtractColors[isoclinestyle[[2,1]]];
		color2nes=ExtractColors[isoclinestyle[[2,2]]];
		style2es=Complement[isoclinestyle[[2,1]],color2es];
		style2nes=Complement[isoclinestyle[[2,2]],color2nes];
	,
		color2=ExtractColors[isoclinestyle[[2]]];
		style2=Complement[isoclinestyle[[2,1]],color2];
	];
];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	delaydinv2=True;
	If[ics=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Join[fixed,{trait1->trait1}]];
		ics1=DefaultICs;
		Set\[ScriptCapitalN][Join[fixed,{trait1->trait1,trait2->trait2}]];
		nsps=Table[\[ScriptCapitalN][gu],{gu,guilds}];
		If[Global`debug,Print[func,": \[ScriptCapitalN]=",nsps]];
		ics=DefaultICs;
	];
	(* handle diagonal *)
	If[{gu1,tr1}=={gu2,tr2},
		sol[\[FormalX]_?NumberQ,\[FormalX]_?NumberQ]:=sol[\[FormalX],\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX]}],ics1,Time->time,Evaluate[Sequence@@findecoattractoropts]];
			Return[Join[result,Table[Subscript[gcomp,sp2]->0,{gcomp,gcomps[gu1]}]]]
		]
	];
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics=ics,time=time,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[System`\[FormalX],System`\[FormalY]]=
			FindEcoAttractor[tr,ics,Time->time,op]]]
	];
	sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
		result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics,Time->time,Evaluate[Sequence@@findecoattractoropts]];
		If[printtrace,Print["FindEcoAttractor ",{trait1->\[FormalX],trait2->\[FormalY]},"=",result]];
		If[ArrayDepth[result]<2,Return[result],Print[result," ",ArrayDepth[result]];Return[result[[ecoattnum]]]]
	];
, (* sol given *)
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]]
];

evoeqns=TraitEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,\[ScriptCapitalN]s->nsps];

If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_[t+1]->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
If[verbose,Print[func,": evoeqns=",evoeqns]];

If[solin==="FindEcoAttractor",
	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];

(*Print[dt[Global`x,Global`y]];*)

If[monitor,Monitor[
	iso1=ContourPlot[dt[x,y][[1]],{x,trait1min,trait1max},{y,trait2min,trait2max},Contours->{0},ContourShading->False,
		Evaluate[Sequence@@plotopts],ContourStyle->{Flatten[{color1,style1,Opacity[1]}]},ContourLabels->{None,Tooltip[Null,trait1]&}],
		ToString[trait1,StandardForm]<>" isocline: "<>ToString[{trait1,trait2},StandardForm]<>"="<>ToString[{x,y}]
	],
	iso1=ContourPlot[dt[x,y][[1]],{x,trait1min,trait1max},{y,trait2min,trait2max},Contours->{0},ContourShading->False,
		Evaluate[Sequence@@plotopts],ContourStyle->{Flatten[{color1,style1,Opacity[1]}]},ContourLabels->{None,Tooltip[Null,trait1]&}]
];
VPrint[3,iso1];

(* TODO: add flip option to save 50% time *)

If[monitor,Monitor[
	iso2=ContourPlot[dt[x,y][[2]],{x,trait1min,trait1max},{y,trait2min,trait2max},Contours->{0},ContourShading->False,
		Evaluate[Sequence@@plotopts],ContourStyle->{Flatten[{color2,style2,Opacity[1]}]},ContourLabels->{None,Tooltip[Null,trait2]&}],
		ToString[trait2,StandardForm]<>" isocline: "<>ToString[{trait1,trait2},StandardForm]<>"="<>ToString[{x,y}]
	],
	iso2=ContourPlot[dt[x,y][[2]],{x,trait1min,trait1max},{y,trait2min,trait2max},Contours->{0},ContourShading->False,
		Evaluate[Sequence@@plotopts],ContourStyle->{Flatten[{color2,style2,Opacity[1]}]},ContourLabels->{None,Tooltip[Null,trait2]&}]
];
VPrint[3,iso2];

If[estest==False,Return[Show[iso1,iso2,FrameLabel->framelabel]]];

(* ESTest\[Equal]True *)

If[delaydinv2,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv21[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv1,ts1,Method->"NDInv",Time->time,op]];
			PrintCall[Global`dinv22[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv22[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv2,ts2,Method->"NDInv",Time->time,op]]
	]];		
	dinv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv21[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts]];
	dinv22[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv22[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts]];
,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},sp1=sp1,sp2=sp2,
			time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv1,Species->sp1,Time->time,op]];
			PrintCall[Global`dinv22[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv2,Species->sp2,Time->time,op]]
	]];
	dinv21[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Time->time,Evaluate[Sequence@@dinv2opts]];
	dinv22[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Time->time,Evaluate[Sequence@@dinv2opts]];
	If[verbose,
		Print[func,": dinv21[\[FormalX],\[FormalY]]=",dinv21[\[FormalX],\[FormalY]]];
		Print[func,": dinv22[\[FormalX],\[FormalY]]=",dinv22[\[FormalX],\[FormalY]]]
	]
];

Return[Show[
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]>0,color1nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]<0,color1es,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]>0,color2nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]<0,color2es,{Opacity[0]}]]&)],
	Frame->True,Axes->False,AspectRatio->1,FrameLabel->framelabel,PlotRange->{{trait1min,trait1max},{trait2min,trait2max}}
]]

]];


PlotEvoIsoclines[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoIsoclines[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts];


Options[PlotEvoIsoclines]={Fixed->{},Time->t,
	FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,ExcludeDiagonal->True,TraitShiftRate->{},
	FindEcoAttractorOpts->{},DelayDInv->False,DInvOpts->{},PlotOpts->{},FrameLabel->Automatic,
	ESTest->True,DelayDInv2->False,DInv2Opts->{},IsoclineStyle->Automatic,
	Verbose->False,Monitor->True,PrintTrace->False};


PlotEvoPhasePlane::usage=
"PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] combines PlotMIP, PlotEvoStreams and PlotEvoIsoclines.
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq1\", \"TI\"]\), \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses one-species ecological equilibrium \!\(\*
StyleBox[\"eq1\", \"TI\"]\) and two-species ecological equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) for improved speed (2 species).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits (within or between guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses one-species ecological equilibria \!\(\*
StyleBox[\"eq11\", \"TI\"]\) and \!\(\*
StyleBox[\"eq12\", \"TI\"]\) and two-species ecological equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) (2 guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq0\", \"TI\"]\), \!\(\*
StyleBox[\"eq1\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] combines PlotZIP, PlotEvoStreams and PlotEvoIsoclines (2 traits)";


(* two guilds *)
PlotEvoPhasePlane[{eq11:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq12:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Gu)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[{eq11,eq12},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two species *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Sp)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[eq1,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two traits *)
PlotEvoPhasePlane[eq0:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Tr)"],
(* options *)
plotzipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
invader,pes,pei,zip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotzipopts=FilterRules[Flatten[{Evaluate[PlotZIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotZIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

invader=(Guild->LookUp[trait1][[2]]);

pes=PlotEvoStreams[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
zip=PlotZIP[eq0,{(trait1/.Subscript[x_,_]->Subscript[x,0]),trait1min,trait1max},{(trait2/.Subscript[x_,_]->Subscript[x,0]),trait2min,trait2max},
invader,InvStyle->Opacity[0],NonInvStyle->White,Evaluate[Sequence@@plotzipopts]];
If[Global`debug,Print[zip]];

Return[Show[pes,pei,zip]]
];


(* two traits - no eq0 alias *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
PlotEvoPhasePlane["FindEcoAttractor",eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts];


Options[PlotEvoPhasePlane]={PlotMIPOpts->{},PlotZIPOpts->{},PlotEvoIsoclinesOpts->{},PlotEvoStreamsOpts->{}};


EcoEvoSim::usage=
"EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoSim[traitsin_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},tmax_?NumericQ,opts___?OptionQ]:=
Module[{
(* options *)
verbose,
logged,boundarydetection,ndsolveopts,wheneventopts,delaydinv,fixed,tmin,outputtmin,output,freezetraits,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvars,
Gs,traits,tic,ecoeqns,evoeqns,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{\[ScriptCapitalN],verbosity,func="EcoEvoSim"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoSim]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoSim]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoSim]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEvoSim]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EcoEvoSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoEvoSim]}]];
If[outputtmin===Automatic,outputtmin=tmin];
output=Evaluate[Output/.Flatten[{opts,Options[EcoEvoSim]}]];
freezetraits=Evaluate[FreezeTraits/.Flatten[{opts,Options[EcoEvoSim]}]];

If[logged&&delaydinv,Message[EcoEvoSim::notimp];Return[$Failed]];

If[Max[Table[ngcomps[gu],{gu,guilds}]]>1&&modelperiod!=0,Message[EcoEvoSim::susmtd]];

(* expand traits *)
traits=ExpandTraits[traitsin];

fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits];
(*Print["nonfixedvars=",nonfixedvars];*)
(*nonfixedvars=Join[traits\[LeftDoubleBracket]All,1\[RightDoubleBracket],variables\[LeftDoubleBracket]All,1\[RightDoubleBracket]];*)
VPrint[3,"fixedvars=",fixedvars];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* set up ics *)
ics=Table[
	If[logged===True&&comptype[var]==="Extensive",
		log[var][tic]==Log[var/.variables],
		var[tic]==(var/.traits/.variables)]
,{var,nonfixedvars}];

(* insert unks[] for delaydinv *)
If[delaydinv,ics=ics/.ToUnks];

(* expand Gs *)
VPrint[3,"Gsin=",Gsin];
If[Gsin==={},
	Gs=Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}],
	Gs=Gsin];
Gs=ExpandGs[Gs,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(* set up ecoeqns & evoeqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVars->nonfixedvariables,opts]/.Gs;
evoeqns=TraitEqns[BlankVariables,Gs,NonFixedTraits->nonfixedtraits,opts]/.ExpRule[nonfixedvariables,logged];
VPrint[3,"ecoeqns=",ecoeqns];
VPrint[3,"evoeqns=",evoeqns];

(* insert Unks[] for delaydinv *)
If[delaydinv,
	VPrint[3,"processing DelayDInv..."];
	ecoeqns=ecoeqns/.ToUnks;
	evoeqns=evoeqns/.ToUnkRules/.ExpRule[AllVariables,logged];
	evoeqns=ReplaceLHS[evoeqns,ToUnks];
	VPrint[3,"ecoeqns=",ecoeqns];
	VPrint[3,"evoeqns=",evoeqns];
];

VPrint[3,"adding [t]'s..."];
ecoeqns=ecoeqns/.AddVariablets/.AddTraitts;
evoeqns=evoeqns/.AddVariablets/.AddTraitts;
If[delaydinv,evoeqns=ReplaceRHS[evoeqns,{(var1_[t]->var2_)->(var1->var2),Subscript[var_, 0][t]->Subscript[var, 0]}]];
VPrint[3,"ecoeqns=",ecoeqns];
VPrint[3,"evoeqns=",evoeqns];


(* boundary detection *)
If[boundarydetection==True,
	Which[
		modeltype=="ContinuousTime",
		bdwhens=Flatten[WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.(evoeqns/.(var_'[t]==rhs_):>{
			{event->var[t]>Max[range[var/.FromUnks]],action->in[var][t]->0},
			{event->var[t]<Min[range[var/.FromUnks]],action->in[var][t]->0},
			{event->rhs>0&&var[t]==Min[range[var/.FromUnks]],action->in[var][t]->1},
			{event->rhs<0&&var[t]==Max[range[var/.FromUnks]],action->in[var][t]->1}
		}),1];
		(*Print[func,": bdwhens="];Print[bdwhens];*)
		discretevars=evoeqns/.(var_'[t]==rhs_)->in[var];
		(*Print["discretevars=",discretevars];*)
		ics=Flatten[Join[ics,evoeqns/.(var_'[t]==rhs_)->in[var][0]==1]];
		(*Print["ics=",ics];*)
		evoeqns=evoeqns/.(var_'[t]==rhs_)->var'[t]==rhs*in[var][t]
	,
		modeltype=="DiscreteTime",
		evoeqns=evoeqns/.(var_[t+1]==rhs_):>var[t+1]==Clip[rhs,{Min[range[var]],Max[range[var]]}];
	];
,
	bdwhens={};
	discretevars={};
];


VPrint[3,"joining eqns..."];
eqns=Join[ecoeqns,evoeqns];
VPrint[3,"eqns=",eqns];

If[freezetraits,
	VPrint[3,"freezing traits..."];
	eqns=ReplaceRHS[ReplaceRHS[eqns,RemoveTraitts],traits];
	VPrint[3,"eqns=",eqns];
];

(*Print["doing something (?) with Unk..."];
eqns=ReplaceLHS[eqns,{log[Unk[var_]]'->log[Unk[var]]'[t],Unk[var_]'->Unk[var]'[t]}];
eqns=ReplaceRHS[eqns,{log[Unk[var_]]->log[Unk[var]][t],Unk[var_]->Unk[var][t]}];
Print["eqns=",eqns];*)

(* set up unks *)
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};

VPrint[1,"eqns=",eqns];
VPrint[1,"ics=",ics];
VPrint[1,"unks=",unks];
If[bdwhens!={},VPrint[1,"bdwhens=",bdwhens]];
VPrint[3,"discretevars=",discretevars];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens,modelwhenevents]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	sol=Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TimeSeries[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
	sol=Join[sol,Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[delaydinv,sol=sol/.FromUnks];

If[logged===True,
	res=Table[
		If[Head[var]===log,
			var[[1]]->Reinterpolation[E^var/.sol],
			var->(var/.sol)]
	,{var,Keys[sol]}]
,
	res=sol
];
	
If[output=="FinalSlice",Return[SortRuleList[Chop[Join[FinalSlice[res],fixed]],Join[AllVariables,AllTraits]]]];

Return[SortRuleList[res,Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoSim]={Verbose->False,Verbosity->0,
Fixed->{},Logged->False,BoundaryDetection->False,FreezeTraits->False,
NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
TMin->0,OutputTMin->Automatic,Output->"Dynamics"};


(* split traitsandvariables *)
EcoEvoSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],tmax,opts];
EcoEvoSim[sol_?AttributesAndVariablesQ,Gs:(_?RuleListQ):{},tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],Gs,tmax,opts];


EcoEvoSim::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

EcoEvoSim::susmtd=
"Warning: EcoEvoSim is likely to be inappropriate when there are multiple components and non-equilibrium dynamics.";

EcoEvoSim::notimp="Combining Logged and DelayDInv not currently implemented.";


FindEcoEvoEq::usage =
"FindEcoEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an eco-evolutionary equilibrium with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).";


FindEcoEvoEq[traitsin_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,method,boundarydetection,percapita,delaydinv,fixed,findrootopts,chop,
(* other variables *)
traits,Gs,fixedvars,fixedattributes,fixedvariables,ecoeqns,evoeqns,eqns,unks,newunk,unksics,sol},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoEvoEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[FindEcoEvoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoEq]}]];

(* expand traits *)
traits=ExpandTraits[traitsin];

fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
Gs=ExpandGs[Join[Gsin,Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]],Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],opts,PerCapita->percapita];
VPrint[3,"ecoeqns=",ecoeqns];
evoeqns=TraitEqns[BlankVariables,Gs,opts];
VPrint[3,"evoeqns=",evoeqns];
eqns=If[delaydinv,
	Join[ecoeqns/.Eq/.Gs/.ToUnks,evoeqns/.Eq/.ToUnkRules],
	Join[ecoeqns,evoeqns]/.Eq/.Gs
];

(* set up unksics *)
unks=Join[ecoeqns,evoeqns]/.LHS/.{var_'->var,var_[t+1]/var_[t]->var,var_[t+1]-var_[t]->var,var_[t+1]->var};
unksics={};
Do[
	newunk=If[delaydinv,{var/.ToUnks,var/.traits/.variables},{var,var/.traits/.variables}];
	If[method=="Secant",AppendTo[newunk,var+0.001/.traits/.variables]];
	If[boundarydetection,
		newunk=Join[newunk,{Min[range[var]],Max[range[var]]}];
		If[((var/.traits/.variables)<Min[range[var]])||((var/.traits/.variables)>Max[range[var]]),
			Message[FindEcoEvoEq::streg,var,var/.traits/.variables,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
			Abort[];
		];
	];
	AppendTo[unksics,newunk];
,{var,unks}];

VPrint[1,"eqns=",eqns];
VPrint[1,"unksics=",unksics];

(* solve it *)
sol=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]];
VPrint[3,"sol=",sol];
If[Length[$MessageList]>0&&$MessageList[[-1]]===HoldForm[FindRoot::reged],Message[FindEcoEvoEq::reged]];

If[chop,
	Return[SortRuleList[Chop[Join[sol,fixed]/.FromUnks],Join[AllVariables,AllTraits]]],
	Return[SortRuleList[Join[sol,fixed]/.FromUnks,Join[AllVariables,AllTraits]]]
];

]];


Options[FindEcoEvoEq]={Fixed->{},PerCapita->True,FindRootOpts->{},DelayDInv->False,Chop->True,Verbose->False,Verbosity->0};


(* split traitsandvariables *)
FindEcoEvoEq[sol_?AttributesAndVariablesQ,Gs_:{},opts___?OptionQ]:=
	FindEcoEvoEq[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


FindEcoEvoEq::badfg="Bad FitnessGradient method (should be either DInv or NDInv).";

FindEcoEvoEq::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

FindEcoEvoEq::streg="Initial value of `1` = `2` is outside the range `3` < `1` < `4`. Either fix it or set BoundaryDetection\[Rule]False.";

FindEcoEvoEq::reged="Warning: FindRoot reached boundary, don't trust result (maybe try again using Fixed to fix variables on the boundary).";


TrackEcoEvoEq::usage=
"TrackEcoEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\), \!\(\*
StyleBox[\"dpar\", \"TI\"]\)}] tracks an eco-evolutionary equilibrium, with initial guess \!\(\*
StyleBox[\"sol\", \"TI\"]\), over parameter \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\), with initial step size \!\(\*
StyleBox[\"dpar\", \"TI\"]\).";


TrackEcoEvoEq[init_?AttributesAndVariablesQ,{parname_,parmin_?NumericQ,parmax_?NumericQ,dparin_:Automatic},opts___?OptionQ]:=

Module[{
func=FuncStyle["TrackEcoEvoEq"],
(* options *)
verbose,monitor,printtrace,
tests,
minstepsize,maxstepsize,maxsteps,mindist,maxbend,maxchange,
findecoevoeqopts,interpolationopts,
(* other variables *)
par,dpar,tmp,ics,unks,count,sol,
m0,m1,list
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[Global`debug,verbose=True];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[TrackEcoEvoEq]}]];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[dparin===Automatic,dpar=Sign[parmax-parmin],dpar=dparin];
minstepsize=Evaluate[MinStepSize/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[minstepsize===Automatic,minstepsize=dpar*2^-10];
maxstepsize=Evaluate[MaxStepSize/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[maxstepsize===Automatic,maxstepsize=dpar*2^3];
maxsteps=Evaluate[MaxSteps/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
mindist=Evaluate[MinDistance/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
maxbend=Evaluate[MaxBend/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
maxchange=Evaluate[MaxChange/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
tests=Evaluate[Tests/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
findecoevoeqopts=Evaluate[FindEcoEvoEqOpts/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
interpolationopts=Evaluate[InterpolationOpts/.Flatten[{opts,Options[TrackEcoEvoEq]}]];

If[monitor,PrintTemporary[Dynamic[count]," ",parname,"=",Dynamic[par]," d",parname,"=",Dynamic[dpar]]];

Evaluate[parname]:=par;

unks=Keys[init];
tmp={};
par=parmin;
dpar=dpar/2;
ics=init;
count=0;

While[count<maxsteps,
	count++;
	sol=Check[Quiet[FindEcoEvoEq[ics,Evaluate[Sequence@@findecoevoeqopts]],FindRoot::lstol],"err"];
	If[printtrace&&sol=!="err",Print[Defer@parname,"=",NumberForm@par," sol=",sol]];
	(*Print[Flatten[Table[PartsAboveDiagonal[TraitDistance[sol,gu]],{gu,guilds}]]];*)
	(*Print[Table[{
				m1=((unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])-(unk/.tmp\[LeftDoubleBracket]-2,2\[RightDoubleBracket]))/(tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]-tmp\[LeftDoubleBracket]-2,1\[RightDoubleBracket]);
				m0=((unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket]))/(par-tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]);
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]],
				Abs[(unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])]/(Differences@MinMax[Table[unk/.ent\[LeftDoubleBracket]2\[RightDoubleBracket],{ent,tmp}]])\[LeftDoubleBracket]1\[RightDoubleBracket]}
			,{unk,unks}]];*)
	Which[
		sol==="err",
		If[par==parmin,Message[TrackEcoEvoEq::ferr,Defer@parname,NumberForm@par];Return[$Aborted]];
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," FindEcoEvoEq error"]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::err,Defer@parname,NumberForm@par];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"CSS"]&&Max[Re[EcoEvoEigenvalues[sol]]]>0,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-CSS, EcoEvoEigenvalues[sol]=",EcoEvoEigenvalues[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::noncss,Defer@parname,NumberForm@par,EcoEvoEigenvalues[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"LocalESS"]&&!CompoundAnd[Flatten[LocalESSQ[sol]]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-local ESS, LocalESSQ[sol]=",LocalESSQ[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::nonless,Defer@parname,NumberForm@par,LocalESSQ[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"GlobalESS"]&&!CompoundAnd[GlobalESSQ[sol][[1]]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-global ESS, GlobalESSQ[sol]=",GlobalESSQ[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::nongess,Defer@parname,NumberForm@par,GlobalESSQ[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"Extinction"]&&Cases[ExtinctSpecies[sol],_Subscript]!={},
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," extinction, sol=",sol]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::extinct,Defer@parname,NumberForm@par,sol];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"Convergence"]&&Min[Flatten[Table[PartsAboveDiagonal[TraitDistance[sol,gu]],{gu,guilds}]]]<mindist,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," traits converged, sol=",sol]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::converged,Defer@parname,NumberForm@par,sol];Break[]];
		par=par-dpar;
	,
		MemberQ[tests,"MaxBend"]&&Length[tmp]>=2&&CompoundOr[Table[
				m1=((unk/.tmp[[-1,2]])-(unk/.tmp[[-2,2]]))/(tmp[[-1,1]]-tmp[[-2,1]]);
				m0=((unk/.sol)-(unk/.tmp[[-1,2]]))/(par-tmp[[-1,1]]);
				list=Table[unk/.ent[[2]],{ent,tmp}];
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]]>maxbend
				&&
				Abs[(unk/.sol)-(unk/.tmp[[-1,2]])]/(10^-10+Differences[{Min[list],Max[list]}][[1]])>maxchange
			,{unk,unks}]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," MaxBend exceeded"]];
		If[dpar>0,dpar=Max[minstepsize,dpar/2],dpar=Min[minstepsize,dpar/2]];
		par=par-dpar;			
	,
		True,
		AppendTo[tmp,{par,sol}];
		If[par==parmax,Break[]]; (* reached end *)
		If[dpar>0,
			dpar=Min[maxstepsize,2dpar];
			par=Min[parmax,par+dpar];
		,
			dpar=Max[maxstepsize,2dpar];
			par=Max[parmax,par+dpar];
		];
	];
	ics=Quiet[Slice[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]],par],{Interpolation::inhr,InterpolatingFunction::dmval}];
];

If[count==maxsteps,Message[TrackEcoEvoEq::mxst,maxsteps,Defer@parname,NumberForm@par]];

Clear[parname];

Return[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]]]
]];


Options[TrackEcoEvoEq]={
	Verbose->False,PrintTrace->False,Monitor->True,
	MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->200,
	Tests->{"CSS","LocalESS","GlobalESS","Extinction","Convergence","MaxBend"},
	FindEcoEvoEqOpts->{},InterpolationOpts->{},
	MinDistance->10^-10,MaxBend->3,MaxChange->0.01
};


TrackEcoEvoEq::err="FindEcoEvoEq failed at `1`=`2`.";
TrackEcoEvoEq::ferr="FindEcoEvoEq failed at initial parameter value,`1`=`2`, can not continue.";
TrackEcoEvoEq::noncss="Non-convergence stable EcoEvoEq at `1`=`2`, eigenvalues=`3`).";
TrackEcoEvoEq::nonless="Not a local ESS at `1`=`2`, LocalESSQ=`3`.";
TrackEcoEvoEq::nongess="Not a global ESS at `1`=`2`, GlobalESSQ=`3`.";
TrackEcoEvoEq::extinct="Extinction at `1`=`2`, sol=`3`.";
TrackEcoEvoEq::converged="Traits converged at `1`=`2`, sol=`3`.";
TrackEcoEvoEq::mxst="Maximum number of `1` steps reached at `2`=`3`";


FindEcoEvoCycle::usage=
"FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an eco-evolutionary cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

FindEcoCycleEvoEq::usage=
"FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an evolutionary equilibrium with an ecological cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varscovars\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


(* Periodic system *)
FindEcoEvoCycle[traitsin_?TraitsQ,Gs:(_?GsQ):{},variablesin_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoCycle (Periodic)"],
(* options *)
verbose,verboseall,
method,fitnessgradient,evoeq,
ecosimopts,ndinvopts,ecoevosimopts,findrootopts,monitor,printtrace,fixed,traitshiftrate,
maxiterations,rulelistdistanceopts,
accuracygoal,traitaccuracygoal,variableaccuracygoal,
precisiongoal,traitprecisiongoal,variableprecisiongoal,
(* other variables *)
traits,variables,
fixedvars,fixedtraits,fixedvariables,nonfixedtraits,nonfixedvars,nonfixedvariables,
thing,fw,sol,unks,unksics,res,dtrait,v,nb},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
evoeq=Evaluate[EvoEq/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[fitnessgradient===Automatic,
	If[evoeq==False||Max[Table[ngcomps[gu],{gu,guilds}]]==1,fitnessgradient="EcoEvoSim",fitnessgradient="NDInv"]];
If[Max[Table[ngcomps[gu],{gu,guilds}]]>1&&fitnessgradient=="EcoEvoSim",Message[FindEcoEvoCycle::susmtd]];
If[verbose,Print[func,": FitnessGradient=",fitnessgradient]];
ndinvopts=Evaluate[NDInvOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecoevosimopts=Evaluate[EcoEvoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[evoeq==True,AppendTo[ecoevosimopts,FreezeTraits->True]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
maxiterations=Evaluate[MaxIterations/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
accuracygoal=Evaluate[AccuracyGoal/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[ListQ[accuracygoal],
	{variableaccuracygoal,traitaccuracygoal}=accuracygoal[[1;;2]],
	variableaccuracygoal=traitaccuracygoal=accuracygoal];
precisiongoal=Evaluate[PrecisionGoal/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[ListQ[precisiongoal],
	{variableprecisiongoal,traitprecisiongoal}=precisiongoal[[1;;2]],
	variableprecisiongoal=traitprecisiongoal=precisiongoal];
rulelistdistanceopts=Evaluate[RuleListDistanceOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];

(* drop fixed variables from traits and variables *)
traits=RuleListComplement[traitsin,fixed];
variables=RuleListComplement[variablesin,fixed];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedtraits=traits[[All,1]];
nonfixedvariables=variables[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedtraits],Join[variables,fixedvariables]];

Which[
	fitnessgradient=="EcoEvoSim",
	thing[varsandtraits_?NumericRuleListQ]:=Module[{},
		$FindEcoEvoCycleSteps++;
		sol=EcoEvoSim[varsandtraits,Gs,modelperiod,Fixed->fixed,TraitShiftRate->traitshiftrate,
			Evaluate[Sequence@@ecoevosimopts]];
		If[printtrace,Print[$FindEcoEvoCycleSteps," ",FinalSlice[sol]]];
		Return[Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&]]
	]
,	
	fitnessgradient=="NDInv",
	(* shifting traits *)
	Do[dtrait[tr]=If[MemberQ[traitshiftrate[[All,1]],tr[[1]]],tr[[1]]/.traitshiftrate,0],{tr,nonfixedtraits}];
	(* set up vs *)
	Do[v[tr]=V[DeleteSubscripts@tr]/.Gs/.V[DeleteSubscripts@tr]->1,{tr,nonfixedtraits}];

	thing[varsandtraits_?NumericRuleListQ]:=Module[{fg},
		$FindEcoEvoCycleSteps++;
		sol=EcoSim[varsandtraits,modelperiod,Fixed->fixed,Evaluate[Sequence@@ecosimopts]];
		fg=Flatten[Table[tr->
			v[tr]*NDInv[Join[varsandtraits,fixed]//ExtractTraits,sol,tr//ZeroSubscripts,{(tr//ZeroSubscripts)->(tr/.varsandtraits)},
			Evaluate[Sequence@@ndinvopts]]-dtrait[tr]
		,{tr,nonfixedtraits}]];
		If[printtrace,Print[$FindEcoEvoCycleSteps," ",FinalSlice[sol]," ",RuleListAdd[ExtractTraits[varsandtraits],fg]]];
		Return[Join[
			Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&],
			RuleListAdd[ExtractTraits[varsandtraits],fg]
		]]
	],
	Else,
	Message[FindEcoEvoCycle::badmtd];Return[$Failed]
];

If[monitor,
	nb=CreateDialog[{
		TextCell["evaluation: "],
		Dynamic[$FindEcoEvoCycleSteps],
		TextCell["vars:"],
		Dynamic[FinalSlice[sol]]
	},
	WindowTitle->"FindEcoEvoCycle Progress...",WindowSize->All];
];

(* solve it *)
$FindEcoEvoCycleSteps=0;
Which[
	method=="FindRoot",
	If[verbose,Print[func,": Method FindRoot"]];
	unks=nonfixedvars/.ToUnks;
	unksics=Table[{var/.ToUnks,var/.traits/.variables},{var,nonfixedvars}];
	fw[l_?NumericListQ]:=nonfixedvars/.thing[Thread[nonfixedvars->l]];
	res=FindRoot[fw[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]];
	If[monitor,NotebookClose[nb]];
	If[evoeq==True,
		Return[SortRuleList[Join[ExtractTraits[res/.FromUnks],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]],
		Return[SortRuleList[Join[sol,fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]]
	]
,
	method=="FixedPoint",
	If[verbose,Print[func,": Method FixedPoint"]];
	(*res=FixedPoint[thing[#]&,Join[variables,traits],maxiterations,SameTest\[Rule](RuleListDistance[#1,#2,Evaluate[Sequence@@rulelistdistanceopts]]<10^-accuracygoal&)];*)
	res=FixedPoint[thing[#]&,Join[variables,traits],maxiterations,SameTest->(
		RuleListDistance[ExtractTraits[#1],ExtractTraits[#2],Evaluate[Sequence@@rulelistdistanceopts]]<10^-traitaccuracygoal
			+RuleListDistance[ExtractTraits[#1],Evaluate[Sequence@@rulelistdistanceopts]]*10^-traitprecisiongoal &&
		RuleListDistance[ExtractVariables[#1],ExtractVariables[#2],Evaluate[Sequence@@rulelistdistanceopts]]<10^-variableaccuracygoal
			+RuleListDistance[ExtractVariables[#1],Evaluate[Sequence@@rulelistdistanceopts]]*10^-variableprecisiongoal
	&)];
	If[monitor,NotebookClose[nb]];
	If[$FindEcoEvoCycleSteps==maxiterations,Message[FindEcoEvoCycle::cvmit,maxiterations]];
	If[evoeq==True,
		Return[SortRuleList[Join[ExtractTraits[res],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]],	
		Return[SortRuleList[Join[sol,fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]]
	]
,
	Else,
	Message[FindEcoEvoCycle::badmtd];Return[$Failed]
];

]]/;modelperiod=!=0;


Options[FindEcoEvoCycle]={
	Method->"FindRoot",FitnessGradient->Automatic,EvoEq->False,
	RuleListDistanceOpts->{},
	BoundaryDetection->False,TraitShiftRate->{},
	FindRootOpts->{},Fixed->{},EcoSimOpts->{},EcoEvoSimOpts->{},NDInvOpts->{},
	Chop->True,MaxIterations->100,AccuracyGoal->4,PrecisionGoal->{4,\[Infinity]},
	PrintTrace->False,Monitor->False,
	Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
FindEcoEvoCycle[traitsandvariables_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
FindEcoEvoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],Gs,opts];
FindEcoCycleEvoEq[stuff___]:=FindEcoEvoCycle[stuff,EvoEq->True];


FindEcoCycleEvoEq::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoEvoCycle::susmtd=
"Warning: FitnessGradient\[Rule]\"EcoEvoSim\" is likely to be inappropriate when there are multiple components. Try EvoEq\[Rule]True and FitnessGradient\[Rule]\"EcoEvoSim\".";


EvoEq::usage = 
"EvoEq contains SolveEvoEq, NSolveEvoEq, and FindEvoEq. Use them instead.";

SolveEvoEq::usage = 
"SolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

NSolveEvoEq::usage = 
"NSolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] numerically solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

FindEvoEq::usage = 
"FindEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
FindEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\), with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\).";


EvoEq[traits:(_?AttributesQ):{},sol:(_?VariablesQ):{},Gs_List:{},opts___?OptionQ] :=
 
Module[{
func=FuncStyle["EvoEq"],
(* options *)
verbose,verboseall,method,fixed,delaydinv,solveopts,nsolveopts,findrootopts,findinstanceopts,boundarydetection,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,tounks,fromunks,evoeqns,eqns,unks,unksics,newunk,res},
   
Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts, Options[EvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts, Options[EvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoEq]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EvoEq]}]];
solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EvoEq]}]];
If[$VersionNumber>=12.2,AppendTo[solveopts,Assumptions->{}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EvoEq]}]];
findinstanceopts=Evaluate[FindInstanceOpts/.Flatten[{opts,Options[EvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EvoEq]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[sol,fixedvariables]];
(*Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];*)

evoeqns=TraitEqns[sol,Gs,opts];
(*Print["evoeqns=",evoeqns];*)
eqns=evoeqns/.Eq;
(*Print["eqns=",eqns];*)

(* set up unksics *)
unks=evoeqns/.LHS/.{var_'->var(*,var_[t+1]/var_[t]\[Rule]var,var_[t+1]-var_[t]\[Rule]var,var_[t+1]\[Rule]var*)};
(*Print["unks=",unks];*)
If[method=="FindRoot",
	unksics={};
	Do[
		newunk={var,var/.traits};
		If[boundarydetection,
			If[((var/.traits)<Min[range[var]])||((var/.traits)>Max[range[var]]),
				Message[FindEvoEq::streg,var,var/.traits,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
				Abort[];
			];
			newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]
		];
		AppendTo[unksics,newunk];
	,{var,unks}]
];

(* solve it *)
Which[
	method=="Solve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@solveopts},
		PrintCall[Global`res=Solve[eqns,unks,op]]]];
	res=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@nsolveopts},
		PrintCall[Global`res=NSolve[eqns,unks,op]]]];
	res=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[delaydinv,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,op]/.FromUnks]]];
		res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,Evaluate[Sequence@@findrootopts]]/.FromUnks
	,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns,unksics,op]]]];
		res=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]]
	],
	method=="FindInstance",
	If[delaydinv,
		Message[FindEvoEq::needic];Return[$Failed]
	,
		If[verbose,
			With[{eqns=eqns,unks=unks,op=Sequence@findinstanceopts},
			PrintCall[Global`res=FindInstance[eqns,unks,op][[1]]]]];
		res=FindInstance[eqns,unks,Evaluate[Sequence@@findinstanceopts]][[1]]
	],
	Else, (* else *)
	Message[EvoEq::badmtd];Return[$Failed]
];

If[MemberQ[{Solve,NSolve},Head[res]],
	Message[EvoEq::nosol];Return[$Failed],
	Return[SortRuleList[EqSort[Chop[res]],AllTraits]]
];

]];


SolveEvoEq[args___]:=EvoEq[args,Method->"Solve"];
NSolveEvoEq[args___]:=EvoEq[args,Method->"NSolve"];
FindEvoEq[sol:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=EvoEq[sol,Gs,opts,Method->"FindInstance"];
FindEvoEq[args___]:=EvoEq[args,Method->"FindRoot"];


Options[EvoEq]={
Method->"None",
DelayDInv->False,DInvOpts->{},SolveOpts->{Reals},NSolveOpts->{Reals},FindRootOpts->{},FindInstanceOpts->{Reals},
BoundaryDetection->False,Fixed->{},
Verbose->False,VerboseAll->False};


EvoEq::nosol="Solve/NSolve couldn't find a solution.  Try FindEcoEq instead.";

EvoEq::badmtd="The Method option should be \"Solve\", \"NSolve\", \"FindRoot\", or \"FindInstance\".";

FindEvoEq::needic="Method FindInstance doesn't work with DelayDInv.  Give an initial guess to use Method FindRoot instead.";

FindEvoEq::streg="Initial value of `1` = `2` is outside the range `3` < `1` < `4`. Either fix it or set BoundaryDetection\[Rule]False.";


EcoEvoJacobian::usage= 
"EcoEvoJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoJacobian[attributesin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed *)
fixedvars,fixedattributes,fixedvariables,
(* other variables *)
attributes,Gs,variables,interactions,ecoeqns,evoeqns,eqns,unks,jmat},

Block[{\[ScriptCapitalN],verbosity,func="EcoEvoJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoJacobian]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoJacobian]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
VPrint[3,"fixedvars=",fixedvars];

(* handle blanks & figure out number of species in guilds *)
attributes=FixAttributes[attributesin];
variables=FixVariables[variablesin];
VPrint[3,"attributes=",attributes];
VPrint[3,"variables=",variables];

(*interactions=ExtractInteractions[attributesin];*)
interactions=ExtractInteractions[attributes];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[attributes,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
(*Gs=ExpandGs[Join[Gsin,Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]],Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];*)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[1,"Gs=",Gs];

(* set up eqns & unks *)
ecoeqns=EcoEqns[Join[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],interactions,fixedattributes],opts];
evoeqns=TraitEqns[Join[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],fixedvariables],opts,Fixed->interactions];
VPrint[1,"ecoeqns=",ecoeqns];
VPrint[1,"evoeqns=",evoeqns];

eqns=Join[ecoeqns,evoeqns]/.Gs;
unks=eqns/.LHS/.var_'->var;
eqns=eqns/.RHS;

VPrint[1,"eqns=",eqns];
VPrint[1,"unks=",unks];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
VPrint[1,"jmat=",jmat];

If[chop,
	Return[Chop[jmat/.variables/.attributes]],
	Return[jmat/.variables/.attributes]
];

]];


Options[EcoEvoJacobian]={Verbose->False,Verbosity->0,
EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,IgnoreVar->False};


(* split traitsandvariables *)
EcoEvoJacobian[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
	EcoEvoJacobian[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];
EcoEvoJacobian[sol_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
	EcoEvoJacobian[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EcoEvoJacobian[___]:=Message[EcoEvoJacobian::noper]/;modelperiod=!=0;


EcoEvoJacobian::noper="EcoEvoJacobian can't handle periodic models yet.";


EcoEvoEigenvalues::usage= 
"EcoEvoEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoEigenvalues[attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoEigenvalues]}],Options[EcoEvoJacobian]];

	res=Eigenvalues[EcoEvoJacobian[attributes,variables,Gs,Evaluate[Sequence@@eejopts]]];
	
	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoEigenvalues]={(*EvoEquation\[Rule]"QG",Fixed\[Rule]{},TraitShiftRate\[Rule]{},*)
Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoEigenvalues[sol_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
	EcoEvoEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];


EcoEvoEigenvalues::noper="EcoEvoEigenvalues can't handle periodic models yet.";


EvoJacobian::usage = 
"EvoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EvoJacobian[traitsin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed vars *)
fixedvars,fixedtraits,fixedvariables,
(* other variables *)
traits,variables,eqns,unks,jmat},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=FixAttributes[traitsin];
variables=FixVariables[variablesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedtraits],Join[variables,fixedvariables]];

(* set up eqns & unks *)
eqns=TraitEqns[BlankVariables,Gs,opts];
unks=eqns/.LHS/.{var_'->var(*,var_[t+1]/var_[t]\[Rule]var,var_[t+1]\[Rule]var*)};
eqns=eqns/.RHS(*/.RemoveTraitts/.RemoveVariablets*);

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unks="];Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[Global`debug,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.variables/.traits]],
	Return[jmat/.variables/.traits]
];

]];


(* split traitsandvariables *)
EvoJacobian[sol_?AttributesAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=
EvoJacobian[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EvoJacobian[___]:=Message[EvoJacobian::noper]/;modelperiod=!=0;


Options[EvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoJacobian::noper="EvoJacobian can't handle periodic models yet.";


EvoEigenvalues::usage = 
"EvoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EvoEigenvalues[traits:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,ejopts,res},

	If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

	chop=Evaluate[Chop/.Flatten[{opts,Options[EvoEigenvalues]}]];
	ejopts=FilterRules[Flatten[{opts,Options[EvoEigenvalues]}],Options[EvoJacobian]];

	res=Eigenvalues[EvoJacobian[traits,variables,Gs,ejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


(* split traitsandvariables *)
EvoEigenvalues[sol_?AttributesAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=
EvoEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EvoEigenvalues[___]:=Message[EvoEigenvalues::noper]/;modelperiod=!=0;


Options[EvoEigenvalues]={EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoEigenvalues::noper="EvoEigenvalues can't handle periodic models yet.";


EcoEvoVarSim::usage=
"EcoEvoVarSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
EcoEvoVarSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarSim[traitsin_?AttributesQ,variables_?VariablesQ,Gsin_?GsQ,tmax_?NumericQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,logged,boundarydetection,ndsolveopts,wheneventopts,delaydinv,fixed,tmin,outputtmin,output,freezetraits,ignorevar,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvarcovs,nonfixedvars,
traits,Gs,
tic,ecoeqns,evoeqns,vareqns,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{\[ScriptCapitalN],verbosity,func="EcoEvoVarSim"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEvoVarSim]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoVarSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoVarSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoVarSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoVarSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoVarSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoEvoVarSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoEvoVarSim]}]];
freezetraits=Evaluate[FreezeTraits/.Flatten[{opts,Options[EcoEvoVarSim]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEvoVarSim]}]];

(* expand traits *)
traits=ExpandTraits[traitsin];
VPrint[3,"traits=",traits];

fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
(*Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]\[Rule]\[ScriptCapitalN][gu],{gu,guilds}]];*)
Gs=ExpandGs[Gsin];
VPrint[3,"Gs=",Gs];

nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvarcovs=Gs[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits,nonfixedvarcovs];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* set up ics *)
ics=Table[
	If[logged===True&&comptype[var]==="Extensive",
		log[var][tic]==Log[var/.variables],
		var[tic]==(var/.traits/.variables/.Gs)]
,{var,nonfixedvars}];

(* insert unks[] for delaydinv *)
If[delaydinv,ics=ics/.ToUnks];


(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVars->nonfixedvariables,opts];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedTraits->nonfixedtraits,opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVarCovs->nonfixedvarcovs,opts];

VPrint[2,"ecoeqns=",ecoeqns];
VPrint[2,"evoeqns=",evoeqns];
VPrint[2,"vareqns=",vareqns];

(* boundary detection *)
If[boundarydetection==True,
	Which[
		modeltype=="ContinuousTime",
		bdwhens=Flatten[WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.(evoeqns/.(var_'[t]==rhs_):>{
			{event->var[t]>Max[range[var/.FromUnks]],action->in[var][t]->0},
			{event->var[t]<Min[range[var]/.FromUnks],action->in[var][t]->0},
			{event->rhs>0&&var[t]==Min[range[var/.FromUnks]],action->in[var][t]->1},
			{event->rhs<0&&var[t]==Max[range[var/.FromUnks]],action->in[var][t]->1}
		}),1];
		(*Print[func,": bdwhens="];Print[bdwhens];*)
		discretevars=evoeqns/.(var_'[t]==rhs_)->in[var];
		(*Print["discretevars=",discretevars];*)
		ics=Flatten[Join[ics,evoeqns/.(var_'[t]==rhs_)->in[var][0]==1]];
		(*Print["ics=",ics];*)
		evoeqns=evoeqns/.(var_'[t]==rhs_)->var'[t]==rhs*in[var][t]
	,
		modeltype=="DiscreteTime",
		evoeqns=evoeqns/.(var_[t+1]==rhs_):>var[t+1]==Clip[rhs,{Min[range[var]],Max[range[var]]}];
	];
,
	bdwhens={};
	discretevars={};
];
(*Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns];*)

If[freezetraits,
	ecoeqns=ReplaceRHS[ecoeqns,{RemoveTraitts,traits}];
	evoeqns=ReplaceRHS[evoeqns,{RemoveTraitts,traits}];
];

eqns=Join[ecoeqns,evoeqns,vareqns]/.AddVariablets/.AddTraitts/.AddVarCovts;

(* set up unks *)
unks=eqns/.LHS/.var_'[t]->var;

VPrint[1,"eqns=",eqns];
VPrint[1,"ics=",ics];
VPrint[1,"unks=",unks];
If[bdwhens!={},VPrint[1,"bdwhens=",bdwhens]];
VPrint[3,"discretevars=",discretevars];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens,modelwhenevents]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	sol=Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TimeSeries[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
	sol=Join[sol,Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[delaydinv,sol=sol/.FromUnks];

If[logged===True,
	res=Table[
		If[Head[var]===log,
			var[[1]]->Reinterpolation[E^var/.sol],
			var->(var/.sol)]
	,{var,Keys[sol]}]
,
	res=sol
];
	
If[output=="FinalSlice",Return[SortRuleList[Chop[Join[FinalSlice[res],fixed]],Join[AllVariables,AllTraits]]]];

Return[SortRuleList[res,Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoVarSim]={Verbose->False,Verbosity->0,
Fixed->{},Logged->False,BoundaryDetection->False,FreezeTraits->False,
NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
TMin->0,OutputTMin->0,Output->"Dynamics"};


(* split traitsandvariables *)
EcoEvoVarSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoVarSim[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],tmax,opts];


FindEcoEvoVarEq::usage=
"FindEcoEvoVarEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] finds an eco-evolutionary equilibrium (abundance, traits, variances) with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), and \!\(\*
StyleBox[\"varscovs\", \"TI\"]\).";


FindEcoEvoVarEq[traitsin_?AttributesQ,variables_?VariablesQ,Gsin_?GsQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,method,boundarydetection,percapita,fixed,findrootopts,chop,
(* other variables *)
Gs,traits,fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvarcovs,nonfixedvars,
ecoeqns,evoeqns,vareqns,eqns,unks,newunk,unksics,sol},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoEvoVarEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoVarEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoVarEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];

(* expand traits *)
traits=ExpandTraits[traitsin];
VPrint[3,"traits=",traits];

fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvarcovs=Gs[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits,nonfixedvarcovs];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVars->nonfixedvariables,opts,PerCapita->percapita];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedTraits->nonfixedtraits,opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVarCovs->nonfixedvarcovs,opts];

VPrint[2,"ecoeqns=",ecoeqns];
VPrint[2,"evoeqns=",evoeqns];
VPrint[2,"vareqns=",vareqns];

eqns=Join[ecoeqns,evoeqns,vareqns]/.Eq;

(* set up unks *)
unks=Join[ecoeqns,evoeqns,vareqns]/.LHS/.var_'->var;
unksics={};
Do[
	newunk={var,var/.traits/.variables/.Gs};
	If[method=="Secant",AppendTo[newunk,var+0.001/.traits/.variables/.Gs]];
	If[boundarydetection,
		newunk=Join[newunk,{Min[range[var]],Max[range[var]]}];
		If[((var/.traits/.variables)<Min[range[var]])||((var/.traits/.variables)>Max[range[var]]),
			Message[FindEcoEvoEq::streg,var,var/.traits/.variables,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
			Abort[];
		];
	];
	AppendTo[unksics,newunk];
,{var,unks}];

VPrint[1,"eqns=",eqns];
VPrint[1,"unksics=",unksics];

(* solve it *)
sol=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]];
VPrint[3,"sol=",sol];

If[Length[$MessageList]>0&&$MessageList[[-1]]===HoldForm[FindRoot::reged],Message[FindEcoEvoEq::reged]];

If[chop,
	Return[SortRuleList[Chop[Join[sol,fixed]/.FromUnks],Join[AllVariables,AllTraits]]],
	Return[SortRuleList[Join[sol,fixed]/.FromUnks,Join[AllVariables,AllTraits]]]
];

]]


Options[FindEcoEvoVarEq]={Verbose->False,Verbosity->0,
PerCapita->True,FindRootOpts->{},Chop->True,Fixed->{}};


(* split traitsandvariables *)
FindEcoEvoVarEq[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
FindEcoEvoVarEq[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];


EcoEvoVarJacobian::usage= 
"EcoEvoVarJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarJacobian[traitsin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=
(*EcoEvoVarJacobian[traitsin_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=*)

Module[{
(* options *)
verbose,fixed,chop,
(* rules *)
removets,
(* fixed *)
fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvarcovs,nonfixedvars,
(* other variables *)
Gs,traits,variables,interactions,ecoeqns,evoeqns,vareqns,eqns,unks,jmat},

Block[{\[ScriptCapitalN],verbosity,func="EcoEvoVarJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoVarJacobian]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoVarJacobian]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoVarJacobian]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];

(* handle blanks & figure out number of species in guilds *)
traits=FixAttributes[traitsin];
variables=FixVariables[variablesin];
VPrint[3,"traits=",traits];
VPrint[3,"variables=",variables];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(*nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvarcovs=Gs[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits,nonfixedvarcovs];
VPrint[3,"nonfixedvars=",nonfixedvars];*)

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,(*NonFixedVars\[Rule]nonfixedvariables,*)opts,PerCapita->percapita];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,(*NonFixedTraits->nonfixedtraits,*)opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,(*NonFixedVarCovs->nonfixedvarcovs,*)opts];

VPrint[2,"ecoeqns=",ecoeqns];
VPrint[2,"evoeqns=",evoeqns];
VPrint[2,"vareqns=",vareqns];

eqns=Join[ecoeqns,evoeqns,vareqns]/.RHS;
unks=Join[ecoeqns,evoeqns,vareqns]/.LHS/.var_'->var;

VPrint[1,"eqns=",eqns];
VPrint[1,"unks=",unks];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
VPrint[1,"jmat=",jmat];

(*If[Global`debug,
	Print["variables=",variables];
	Print["traits=",traits];
	Print["Gs=",Gs];
];*)

If[chop,
	Return[Chop[jmat/.variables/.traits/.Gs]],
	Return[jmat/.variables/.traits/.Gs]
];

]];


Options[EcoEvoVarJacobian]=
{Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoVarJacobian[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
EcoEvoVarJacobian[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];





EcoEvoVarEigenvalues::usage= 
"EcoEvoVarEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarEigenvalues[attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoVarEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoVarEigenvalues]}],Options[EcoEvoVarJacobian]];

	res=Eigenvalues[EcoEvoVarJacobian[attributes,variables,Gs,Evaluate[Sequence@@eejopts]]];

	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoVarEigenvalues]={(*EvoEquation\[Rule]"QG",Fixed\[Rule]{},TraitShiftRate\[Rule]{},*)
Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoVarEigenvalues[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
	EcoEvoVarEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];



