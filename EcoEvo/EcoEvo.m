(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* hack to address <https://mathematica.stackexchange.com/questions/167143/setdelayedwrsym-on-first-use-of-formalx> *)
Plot[0,{x,0,1}];
ContourPlot[0,{x,0,1},{y,0,1}];


BeginPackage["EcoEvo`"];


Unprotect@@Names["EcoEvo`*"];
ClearAll@@Names["EcoEvo`*"];


EcoEvoGeneral::nomodel="No model loaded. Use SetModel first.";
$EcoEvoVersion::usage="$EcoEvoVersion gives the version of the loaded EcoEvo package.";


$InvCount;$FindEcoCycleSteps;$FindEcoEvoCycleSteps;


\[IGrave]::usage="\[IGrave] is a placeholder index in RuleList.";
Var::usage="Var indicates Variance in output of TemporalVariance and TraitVariance.";
Cov::usage="Cov indicates Covariance in output of TemporalCovariance and TraitCovariance.";


CheckAssumptions;DeleteNulls;RuleListSet;InequalityToInterval;
SymmetrizeMatrix;
NMin;NMax;
Reinterpolation;MakeInterpolatingFunctionPeriodic;
SimplifyLogE;SortRuleList;OrderedComplement;RuleListComplement;EqSort;
RHS;LHS;ReplaceRHS;ReplaceLHS;Eq;ZeroLHS;
ZeroVector;ZeroMatrix;
SubscriptAdd;DeleteSubscripts;ZeroSubscripts;AddSubscripts;
HighlightChanges;
ExtractColors;AxisFlip;
FuncStyle;PrintCall;
MakeRuleList;ArrayToRuleList;
RuleListQ;RuleListListQ;NumericRuleListQ;TemporalRuleListQ;
RuleListDistance;RuleListTweak;RuleListAdd;RuleListSubtract;RuleListMultiply;NumericRuleListToNumericList;RuleListInterpolation;
ClearCache;
InterpolatingFunctionFunctionQ;TemporalDataFunctionQ;
TemporalMean;TemporalVariance;TemporalCovariance;
ExtractPlotPoints;GetPlotRange;
Else;SpFrac;ModPart;
FindMaxima;FindMinima;FindExtrema;
MaximumValues;MinimumValues;ExtremumValues;
FindPeriod;
NumberedGridForm;MyStreamPlot;RealSimplify;TD;CompoundAnd;CompoundOr;
NumericListQ;NumericFlattenedListQ;
InterpolatingFunctionTake;Slice;InitialSlice;FinalSlice;FinalDerivatives;InitialTime;FinalTime;
SortedEigensystem;ListMultiplier;RunFile;RouthHurwitzCriteria;
JoinFirst;
PlotDynamics;PlotInterpolatingFunction;MyListLinePlot3D;RuleListPlot;
TrackRoot;
PartsAboveDiagonal;PrintMessage;
GrayScale;
DoubleDotProduct;HessianMatrix;
UnfactorSums;GaussianIntegral;GaussianIntegralApproximation;
VPrint;
CreateBlock;NEqual;(*MaxEigenvalue;MaxEigenvector;MaxEigensystem;*)
FindRoots;VarRangeQ;
VectorPlot1D;PlotVector;


Set\[ScriptCapitalN];


EcoEvoDocs;
ExtractInteractions;ExtractTraits;ExtractAttributes;
ExtractPops;ExtractAuxs;ExtractGuilds;ExtractVariables;ExtractSpecies;ExtractVarCovs;
ExpandTraits;ExpandGs;
TraitsQ;InteractionsQ;AttributesQ;VariablesQ;ListOfVariablesQ;AttributesAndVariablesQ;AttributesVariablesAndGsQ;AttributesAndGsQ;
InvaderQ;NotInvaderTraitsQ;GsQ;
ExtractInvaders;DeleteInvaders;
ValidQ;SelectValid;
SplitSpecies;


SetModel;UnsetModel;ModelInfo;
ClearParameters;ParameterValues;
MatrixToPopComponents;MatrixToGuildComponents;
WeightedAbundance;TotalAbundance;
TraitMean;TraitVariance;TraitDistance;FunctionalDistinctiveness;
ExtantSpecies;ExtinctSpecies;
MakeGMatrix;MakeTraitVector;
ZeroGs;


LookUp::usage =
"LookUp[\!\(\*
StyleBox[\"var\", \"TI\"]\)] finds the indices of a variable or trait.";

t::usage="Reserved for time.";
log::usage="Indicates a log-transformed variable.";

ModelType::usage="Type of model (\"ContinuousTime\" or \"DiscreteTime\").";
ModelName::usage="Model name.";
ModelPeriod::usage="Model period (0=unforced, \[Infinity]=aperiodic).";

Component::usage="Defines a Component of a Pop or Guild in SetModel.";
Equation::usage="Defines the equation of a Pop or Guild Component in SetModel.";
Aux::usage="Defines an Aux variable in SetModel.";
Pop::usage="Defines a Pop in SetModel.";
Guild::usage="Defines a Guild in SetModel. Also an option for various EcoEvo functions.";
Trait::usage="Defines a trait in SetModel.";
Interaction::usage="Defines an interaction in SetModel.";
Type::usage="Defines a Component type in SetModel.";
Guilds::usage="Guilds are used in defining Interactions in SetModel.";
Components::usage="A list of components in a guild in SetModel.";
Auxs::usage="A list of Aux variables in SetModel.";
Traits::usage="A list of traits in a guild in SetModel.";
Transitions::usage="A list of components in SetModel.";
Parameters::usage="A list of parameters in SetModel.";

\[ScriptCapitalN]::usage="\!\(\*SubscriptBox[\(\[ScriptCapitalN]\), 
StyleBox[\"gu\", \"TI\"]]\) is a reserved symbol that denotes the number of species in guild \!\(\*
StyleBox[\"gu\", \"TI\"]\).  Do not set directly.";
\[FormalCapitalN]::usage="\[FormalCapitalN] is used for a placeholder for \[ScriptCapitalN].";

Color::usage="Color gives the color for a model part.";
Colors::usage="Colors is a list of default colors for model parts.";

LineStyle::usage="LineStyle gives the line style for a model part.";
LineStyles::usage="LineStyles is a list of default line styles for model parts.";

PlotMarker::usage="PlotMarker gives the plot marker for a model part.";

Unk::usage="An internal header for unknown variables.";

Mutated::usage="Mutated[\!\(\*
StyleBox[\"rate\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] represents a mutation at rate \!\(\*
StyleBox[\"rate\", \"TI\"]\) with variance/covariance \!\(\*
StyleBox[\"var\", \"TI\"]\).";


EcoEqns;EcoSim;
EcoEq;SolveEcoEq;NSolveEcoEq;FindEcoEq;FindEcoCycle;
EcoJacobian;EcoEigenvalues;EcoStableQ;SelectEcoStable;FindEcoAttractor;
PlotEcoIsoclines;PlotEcoStreams;PlotEcoPhasePlane;
PrestonPlot;WhittakerPlot;PlotGuild;
ImpactVector;PlotImpactVector;
PlotEcoEq;


InvSPS;Inv;StablePopulationStructure;ReproductiveValues;
DInv;NDInv;NumDInv;
MaximizeInv;GlobalESSQ;LocalESSQ;
PlotInv;PlotZIP;PlotZNGI;PlotPIP;PlotMIP;


TraitEqns;VarEqns;
PlotEvoIsoclines;PlotEvoStreams;PlotEvoPhasePlane;
EcoEvoSim;
FindEcoEvoEq;FindEcoEvoCycle;FindEcoCycleEvoEq;
TrackEcoEvoEq;
EvoEq;SolveEvoEq;NSolveEvoEq;FindEvoEq;
EcoEvoJacobian;EcoEvoEigenvalues;EvoJacobian;EvoEigenvalues;
EcoEvoVarSim;FindEcoEvoVarEq;EcoEvoVarJacobian;EcoEvoVarEigenvalues;


AbsoluteStepSize::usage = "AbsoluteStepSize is an option for NDInv that sets the absolute step size.";
ApproximationOrder::usage = "ApproximationOrder is an option for SetModel that sets the approximation order.";
ArrayPlotOpts::usage = "ArrayPlotOpts is an option for PlotGuild that passes options to ArrayPlot.";
Averaged::usage = "Averaged is an option for Inv that averages growth if True, gives instantaneous growth if False.";
TemporalMeanOpts::usage = "TemporalMeanOpts is an option for TemporalVariance and TemporalCovariance that passes options to TemporalMean.";
Bandwidth::usage = "Bandwidth is an option for PrestonPlot that sets the bandwidth in SmoothKernelDistribution.";
Base::usage = "Base is an option for PrestonPlot that sets the logarithm base.";
BasePeriod::usage = "BasePeriod is an option for FindPeriod that gives the period to look at multiples of.";
BoundaryDetection::usage = "BoundaryDetection is an option for various EcoEvo functions to enforce variable/trait bounds.";
Constraints::usage = "Constraints is an option for various EcoEvo functions that add extra constraints.";
CoreSatellite::usage = "CoreSatellite is an option for PlotGuild to split core and satellite species.";
DelayDInv::usage = "DelayDInv is an option for various EcoEvo functions that delays the evaluation of DInv.";
DelayDInv2::usage = "DelayDInv2 is an option for PlotEvoIsoclines whether to delay evaluation of DInv in ESS-test.";
DelayInv::usage = "DelayInv is an option for various EcoEvo functions that delays the evaluation of Inv.";
DEq::usage = "DEq is an option for FindRoots that specifies which equation to not plot.";
DInv2Opts::usage = "DInvOpts is an option for PlotEvoIsoclines that passed options to DInv in ESS-test.";
DInvOpts::usage = "DInvOpts is an option for various EcoEvo functions that passes options to DInv.";
dTMaxPower::usage = "dTMaxPower is an option for FindEcoCycle that sets the stepsize base-10 power of tmax.";
EcoAttractorNumber::usage = "EcoAttractorNumber specifies which EcoAttractor to choose in the case of multiple attractors.";
EcoEigenvaluesOpts::usage = "EcoEigenvaluesOpts is an option for various EcoEvo functions that passes options to EcoEigenvalues.";
EcoEvoSimOpts::usage = "EcoEvoSimOpts is an option for various EcoEvo functions that passes options to EcoEvoSim.";
EcoSimOpts::usage = "EcoSimOpts is an option for various EcoEvo functions that passes options to EcoSim.";
EcoStableQOpts::usage = "EcoStableQOpts is an option for various EcoEvo functions that passes options to EcoStableQ.";
EigensystemOpts::usage = "EigenvaluesOpts is an option for various EcoEvo functions that passes options to Eigenvalues.";
EigenvaluesOpts::usage = "EigenvaluesOpts passes options to Eigenvalues.";
EqStop::usage = "EqStop is an option for various EcoEvo simulation functions that stops upon reaching an equilibrium.";
EqThreshold::usage = "EqThreshold is an option for various EcoEvo simulation functions that sets the sensitivity for EqStop.";
EqTolerance::usage = "EqTolerance is an option for FindEcoAttractor that sets the minimum distance to consider two equilibria distinct.";
EqualInvTraits::usage = "EqualInvTraits is an option for Inv that forces invader traits to be equal across components.";
ESColor::usage = "ESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";
ESTest::usage = "ESTest is an option for PlotEvoIsoclines that colors isoclines according to (local) evolutionary stability.";
EvoEquation::usage = "EvoEquation is an option for EcoEvoSim that sets whether to use the breeders' equation (\"QG\" -- default) or the canonical equation (\"CE\").";
ExcludeDiagonal::usage = "ExcludeDiagonal is an option for PlotEvoIsoclines that excludes the diagonal.";
ExcludeFocalSpecies::usage = "ExcludeFocalSpecies is an option for FunctionalDistinctiveness to exclude the focal species in the total abundance in the denominator.";
FinalTMax::usage = "FinalTMax is an option for FindEcoAttractor that sets the length of an aperiodic solution.";
FindEcoAttractorOpts::usage = "FindEcoAttractorOpts is an option for various EcoEvo functions that passes options to FindEcoAttractor.";
FindEcoCycleOpts::usage = "FindEcoCycleOpts is an option for various EcoEvo functions that passes options to FindEcoCycle.";
FindEcoEqOpts::usage = "FindEcoEqOpts is an option for various EcoEvo functions that passes options to FindEcoEq.";
FindEcoEvoEqOpts::usage = "FindEcoEvoEqOpts is an option for TrackEcoEvoEq that passes options to FindEcoEvoEq.";
FindInstanceOpts::usage = "FindInstanceOpts in an option for various EcoEvo functions that passes options to FindInstance.";
FindRootOpts::usage = "FindRootOpts is an option for various EcoEvo functions that passes options to FindRoot.";
FindRootsOpts::usage = "FindRootsOpts is an option for various EcoEvo functions that passes options to FindRoots.";
FitnessGradient::usage = "FitnessGradient is an option for various EcoEvo functions that chooses which method to use to calculate fitness gradients.";
Fixed::usage = "Fixed is an option for various EcoEvo functions that find equilibria, that fixes the values of certain species/traits.";
FreezeTraits::usage = "FreezeTraits is an option for EcoEvoSim that freezes traits at their initial conditions.";
FromInv::usage = "FromInv is an option for InvSPS when called from Inv.";
G::usage = "G is an option to set genetic variance/covariance matrix in various EcoEvo functions.";
GaussianIntegralOpts::usage = "GaussianIntegralOpts is an option for SetModel that passes options to GaussianIntegral.";
GlobalESSQOpts::usage = "GlobalESSQOpts is an option for TrackEcoEvoEq that passes options to GlobalESSQ.";
Gradients::usage = "Gradients is an option for SetModel that provides a list of base Colorradients for guilds.";
Guild::usage = "Guild is an option for various EcoEvo functions that sets which guild to use.";
HistogramOpacity::usage = "HistogramOpacity is an option for PlotDynamics that sets the opacity in a marginal Histogram.";
HistogramOpts::usage = "HistogramOpts is an option for various EcoEvo functions that passes options to Histogram.";
HistogramPoints::usage = "HistogramPoints is an option for PlotDynamics that sets the number of points to use in making a marginal Histogram.";
HistogramPosition::usage = "HistogramPosition is an option for PlotDynamics that controls the position of a marginal Histogram.";
HistogramScale::usage = "HistogramScale is an option for PlotDynamics that controls the scale of a marginal Histogram.";
ICs::usage = "ICs is an option for PlotPIP and PlotMIP that supplies initial guesses for FindEcoAttractor.";
IgnoreVar::usage = "IgnoreVar is an option for various EcoEvo functions that neglects Var/Cov terms in calculating per capita growth rate.";
IndeterminateMarker::usage = "IndeterminateMarker is an option for RuleListPlot that defines the marker style for indeterminate equilibria.";
IntegrateOpts::usage = "IntegrateOpts is an option for various EcoEvo functions that passes options to Integrate.";
InterpolationOpts::usage = "InterpolationOpts is an option for various EcoEvo functions that passes options to Interpolation.";
InvOpts::usage = "InvOpts is an option for various EcoEvo functions that passes options to Inv.";
InvStyle::usage = "InvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for successful invasion.";
InvThreshold::usage = "InvThreshold is an option for PlotMIP that sets the threshold for successful invasion.";
IsoclineStyle::usage = "IsoclineStyle is an option for PlotEcoIsoclines and PlotEvoIsoclines that defines the style for isoclines.";
Kernel::usage = "Kernel is an option for PrestonPlot that sets the kernel used in SmoothKernelDistribution.";
ListLinePlot3DOpts::usage = "ListLinePlot3DOpts is an option for PlotGuild that passes options to ListLinePlot3D.";
ListPlotOpts::usage = "ListPlotOpts is an option for PlotGuild that passes options to ListPlot.";
ListPlot3DOpts::usage = "ListPlotOpts is an option for PlotGuild that passes options to ListPlot3D.";
Logged::usage = "Logged is an option for EcoSim that logs population variables.";
MarkerStyle::usage = "MarkerStyle is an option for PrestonPlot that styles species markers.";
MaximizeInvOpts::usage = "MaximizeInvOpts is an option for GlobalESSQ that passes options to MaximizeInv.";
MaximizeOpts::usage = "MaximizeOpts is an option for various EcoEvo functions that passes options to Maximize.";
MaxBend::usage = "MaxBend is an option for TrackEcoEvoEq that sets the minimum angle to trigger refinement.";
MaxChange::usage = "MaxChange is an option for TrackEcoEvoEq that sets the minimum change to trigger refinement.";
MaxPeriod::usage = "MaxPeriod is an option for FindEcoAttactor that sets the largest discrete-time period to look for a cycle.";
MaxPeriodMultiplier::usage = "MaxPeriodMultiplier is an option for FindEcoAttractor that sets how many multiples of the Period to try.";
MinDistance::usage = "MinDistance is an option for TrackEcoEvoEq that sets the threshold for calling two species converged.";
MinPop::usage = "MinPop is an option for various EcoEvo functions that defines a minimum population size.";
MinStepSize::usage = "MinStepSize is an option for various EcoEvo functions that specifies the minimum size of a single step used in generating a result.";
MomentBased::usage = "MomentBased is an option for TraitEqns that specifies to use moment equations.";
MomentMethod::usage = "MomentMethod is an option for SetModel that specifies how to set up moment equations.";
Multipliers::usage = "Multipliers is an option for EcoEigenvalues that chooses Floquet multipliers (True) or exponents (False).";
NDInvOpts::usage = "NDInvOpts is an option for various EcoEvo functions that passes options to NDInv.";
NDOpts::usage = "NDOpts is an option for various EcoEvo functions that passes options to ND.";
NDSolveOpts::usage = "NDSolveOpts is an option for various EcoEvo functions that passes options to NDSolve.";
NIntegrateOpts::usage = "NIntegrateOpts is an option for various EcoEvo functions that passes options to NIntegrate.";
NInvOpts::usage = "NInvOpts is an option for various EcoEvo functions that passes options to NInv.";
NMaximizeOpts::usage = "NMaximizeOpts is an option for GlobalESSQ that passes options to NMaximize.";
NonESColor::usage = "NonESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";
NonFixedVars::usage = "NonFixedVars is an option for EcoEqns that lists variables that need equations.";
NonFixedTraits::usage = "NonFixedTraits is an option for TraitEqns that lists traits that need equations.";
NonFixedVarCovs::usage = "NonFixedVarCovs is an option for VarEqns that lists traits that need equations.";
NonInvStyle::usage = "NonInvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for unsuccessful invasion.";
NormalizeDistance::usage = "NormalizeDistance is an option for FunctionalDistinctiveness whether to normalize distances to one.";
NSolveEcoEqOpts::usage = "NSolveEcoEqOpts is an option for various EcoEvo functions that passes options to NSolveEcoEq.";
NSolveOpts::usage = "NSolveOpts is an option for various EcoEvo functions that passes options to NSolve.";
\[ScriptCapitalN]s::usage = "\[ScriptCapitalN]s is an option for TraitEqns that sets the number of species in each Guild.";
NumSeeds::usage = "NumSeeds is an option for FindRoots that defines the number of seeds.";
NumTries::usage = "NumTries is an option for FindEcoAttractor's method \"FindRoot\" that says how many initial guesses to try.";
Output::usage = "Output is an option for various EcoEvo functions that determines the type of output.";
OutputTMin::usage = "OutputTMin is an option for EcoSim and EcoEvoSim that that sets the length of the results (default=0).";
PerCapita::usage = "PerCapita is an option for various EcoEvo functions that divides by population size.";
Period::usage = "Period is an option for EcoEvoModel that defines its period.";
PlotEcoIsoclinesOpts::usage = "PlotEcoIsoclinesOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoIsoclines.";
PlotEcoStreamsOpts::usage = "PlotEcoStreamsOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoStreams.";
PlotEvoIsoclinesOpts::usage = "";
PlotEvoStreamsOpts::usage = "PlotEvoStreamsOpts is an option for PlotEvoPhasePlane that passes options to PlotEvoStreams.";
PlotMin::usage = "PlotMin is an option for PrestonPlot that sets where to start the histogram.";
PlotMIPOpts::usage = "PlotMIPOpts is an option for PlotEvoPhasePlane that passes options to PlotMIP.";
PlotOpts::usage = "PlotOpts is an option for various EcoEvo functions that passes options to plotting functions.";
PlotGuildOpts::usage = "PlotGuildOpts is an option for PlotInv that passes options to PlotGuild.";
PlotType::usage = "PlotType is an option for PlotPIP that chooses plot type (ZeroContourPlot [default], ContourPlot, Plot3D).";
PlotVariance::usage = "PlotVariance is an option for PlotDynamics that shows variance around means.";
PlotZIPOpts::usage = "PlotZIPOpts is an option for PlotEvoPhasePlane that passes options to PlotZIP.";
PointStyle::usage = "PointStyle is an option for PlotInv that determines the style of points for species.";
Pop::usage = "Pop is an option for various EcoEvo functions that sets which population to use.";
PrintTrace::usage = "PrintTrace is an option for various EcoEvo functions to leave a trace of iterations.";
QSS::usage = "QSS is an option for *EcoEq that indicates that nonspecified variables should be treated as unknowns.";
QSSICs::usage = "QSSICs is an option for Inv that sets initial conditions for solving for qualitative structure of the invader.";
QSSMethod::usage = "QSSMethod is an option for Inv that selects how to solve for qualitative structure of the invader.";
RelativeStepSize::usage = "RelativeStepSize is an option for NDInv that sets the relative step size.";
RidgelinePlot3DOpts::usage = "RidgelinePlot3DOpts is an option for PlotGuild that passes options for a 3D ridgeline plot.";
RuleListDistanceOpts::usage = "RuleListDistanceOpts is an option for various EcoEvo functions that passes options to RuleListDistance.";
RuleListPlotOpts::usage = "RuleListPlotOpts is an option for various EcoEvo functions that passes options to RuleListPlot.";
RV::usage = "RV is an option for InvSPS when called from ReproductiveValues.";
SameThreshold::usage = "SameThreshold is an option for various EcoEvo functions that is the threshold to consider two numbers the same.";
ShowSpecies::usage = "ShowSpecies is an option for various EcoEvo functions that specifies how to show species markers.";
SimplifyOpts::usage = "SimplifyOpts is an option for various EcoEvo functions that passes options to Simplify.";
SimplifyResult::usage = "SimplifyResult is an option for various EcoEvo functions that applies Simplify before returning results.";
Slope::usage = "Slope is an option for NMin and NMax that sets the steepness of the approximation.";
SMax::usage = "SMax is an option for TrackRoot that sets the maximum value of the pseudo-arclength.";
SMin::usage = "SMin is an option for TrackRoot that sets the minumum value of the pseudo-arclength.";
SolveEcoEqOpts::usage = "SolveEcoEqOpts is an option for various EcoEvo functions that passes options to SolveEcoEq.";
SolveOpts::usage = "SolveOpts is an option for various EcoEvo functions that passes options to Solve.";
Species::usage = "Species is an option for various EcoEvo functions that sets which species to use.";
SpeciesColors::usage = "SpeciesColors is an option for PlotMIP (PlotType->Outcome) that defines colors for each species.";
StableMarker::usage = "StableMarker is an option for RuleListPlot that defines the marker style for stable equilibria.";
StableStyle::usage = "StableStyle is an option for PlotEcoEq that defines the plot style for stable equilibria.";
SubtractDiagonal::usage = "SubtractDiagonal is an option for PlotPIP that subtracts the diagonal from all invasion rates.";
Switches::usage = "Switches is an option for EcoSimSSD that says when external mode switches occur.";
TADVerticalScale::usage = "TADVerticalScale is an option for PlotInv that sets the vertical extent of the TAD. Should be between zero and one.";
TestStability::usage = "TestStability is an option for FindEcoAttractor that determines whether to test for stable equilibria.";
TestValidity::usage = "TestValidity is an option for FindEcoAttractor that determines whether to test for valid equilibria.";
Tests::usage = "Tests is an option for TrackEcoEvoEq that gives which bifurcations/errors to look for.";
Time::usage = "Time is an option for various EcoEvo functions that specifies when to evaluation the model.";
TimeScale::usage = "TimeScale is an option for EcoSim that sets the overall timescale (default=1).";
TMax::usage = "TMax is an option for FindEcoAttractor that sets the maximum time for EcoSim.";
TMax2::usage = "TMax2 is an option for FindEcoAttractor that sets the maximum time for EcoSim.";
TMaxPowerMax::usage = "TMaxPowerMax is an option for FindEcoCycle that sets the maximum base-10 power of tmax to try.";
TMaxPowerMin::usage = "TMaxPowerMin is an option for FindEcoCycle that sets the minimum base-10 power of tmax to try.";
TMin::usage = "TMin specifies the starting time for EcoSim and EcoEvoSim.";
TraitDistanceOpts::usage = "TraitDistanceOpts is an option for various EcoEvo functions that passes options to TraitDistance.";
TraitRange::usage = "TraitRange is an option for PlotGuild that sets the range of the y-axis.";
TraitShiftRate::usage = "TraitShiftRate is an option for various evolutionary EcoEvo functions that changes into a moving frame of reference for an constantly changing environment.";
TriggerVariable::usage = "TriggerVariable is an option for FindEcoCycle that sets which variable to focus on.";
UnstableMarker::usage = "UnstableMarker is an option for RuleListPlot that defines the marker style for unstable equilibria.";
UnstableStyle::usage = "UnstableStyle is an option for PlotEcoEq that defines the plot style for unstable equilibria.";
UseSymmetry::usage = "UseSymmetry is an option for PlotEvoStreams & PlotEvoIsoclines that assumes fitness gradients are symmetric.";
V::usage = "V is an option to set genetic variance in various EcoEvo functions.";
Verbosity::usage = "Verbosity is an option for various EcoEvo functions that sets level of verbosity (0\[Dash]3).";
WarmUp::usage =  "WarmUp is an option for various EcoEvo functions that numerical solves a model before refining.";
WarmUp2::usage = "WarmUp2 is an option for various EcoEvo functions that numerical solves a model before refining.";
WarmUp3::usage = "WarmUp3 is an option for various EcoEvo functions that numerical solves a model before refining.";
WeightFunction::usage = "WeightFunction is an option for PlotGuild that defines abundance in structured populations.";
WeightedAbundanceOpts::usage = "WeightedAbundanceOpts is an option for various EcoEvo functions that passes options to WeightedAbundance.";
WhenEventOpts::usage = "WhenEventOpts is an option for various EcoEvo functions that passes options to WhenEvent.";
WhenEvents::usage = "WhenEvents is an option for various EcoEvo simulation functions that adds WhenEvents to NDSolve.";
ZeroDiagonal::usage =  "ZeroDiagonal is an option for PlotPIP that forces Inv=0 along the diagonal.";
ZeroGrowthBy::usage = "ZeroGrowthBy is an option for various EcoEvo functions that prevents growth relative to a component.";


Begin["`Private`"];


$EcoEvoVersion="1.7.1 (December 22, 2022)";
(* orange & pink = changed in 1.7.1 *)


modelloaded=False;


NewFunction::usage=
"NewFunction[\!\(\*
StyleBox[\"args\", \"TI\"]\)] is a new function.";


NewFunction[args_,opts___?OptionQ]:=

Module[{
func=FuncStyle["NewFunction"],
(* options *)
verbose
(* other variables *)
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[NewFunction]}]];
If[Global`debug,verbose=True];
method=Evaluate[Method/.Flatten[{opts,Options[NewFunction]}]];
plotopts=FilterRules[Flatten[{opts,Options[NewFunction]}],Options[Plot]];

Return[ret]
]];


Options[NewFunction]={
};








SetOptions[NDSolve,MaxSteps->Infinity];
If[$VersionNumber>=12.2,SetOptions[Solve,Assumptions->{}]]; (* <https://mathematica.stackexchange.com/questions/270045> *)
(*SetOptions[NIntegrate,MaxRecursion\[Rule]30];*)


CheckAssumptions::usage="CheckAssumptions checks if any $Assumptions are False.";


(* see <https://mathematica.stackexchange.com/questions/270045/simplify-with-false-assumptions-gives-wrong-answers> *)
CheckAssumptions:=If[Cases[$Assumptions,False]!={},
	Message[CheckAssumptions::fas,Extract[assumptionstrings,Position[$Assumptions,False]]]];


CheckAssumptions::fas="Warning: one or more $Assumptions evaluated to False. Check `1` in SetModel Parameters to avoid problems with Simplify.";


DeleteNulls::usage="DeleteNulls[\!\(\*
StyleBox[\"list\", \"TI\"]\)] deletes all Null elements in \!\(\*
StyleBox[\"list\", \"TI\"]\).";


DeleteNulls[list_List]:=DeleteCases[list,Null];


RuleListSet::usage="RuleListSet[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] assigns variables according to \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* by J.M. <https://mathematica.stackexchange.com/questions/238689/> *)
SetAttributes[RuleListSet,HoldAll];
RuleListSet[rulelist:{__Rule}]:=(Set@@@Unevaluated[rulelist];)


InequalityToInterval::usage="InequalityToInterval[\!\(\*
StyleBox[\"ineq\", \"TI\"]\)] converts inequality \!\(\*
StyleBox[\"ineq\", \"TI\"]\) to an Interval.";


(* based on <https://mathematica.stackexchange.com/a/271537/> by Somnium *)
InequalityToInterval[ineq_]:=ineq/.{
	Greater[max_:\[Infinity],var:Except[_?NumericQ],min_:-\[Infinity]]->var\[Element]Interval[{min,max}],
	GreaterEqual[max_:\[Infinity],var:Except[_?NumericQ],min_:-\[Infinity]]->var\[Element]Interval[{min,max}],
	Less[min_:-\[Infinity],var:Except[_?NumericQ],max_:\[Infinity]]->var\[Element]Interval[{min,max}],
	LessEqual[min_:-\[Infinity],var:Except[_?NumericQ],max_:\[Infinity]]->var\[Element]Interval[{min,max}],
	var_->var\[Element]Interval[{-\[Infinity],\[Infinity]}]
};


SetAttributes[InequalityToInterval,Listable];


SymmetrizeMatrix::usage="";


SymmetrizeMatrix[mat_?MatrixQ]:=UpperTriangularize[mat]+Transpose[UpperTriangularize[mat,1]];


NMin::usage="NMin[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)] is a numerical approximation to Min[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)].";
NMax::usage="NMax[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)] is a numerical approximation to Max[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)].";


NMin[x_,y_,opts___]:=Module[{slope},
	slope=Evaluate[Slope/.Flatten[{opts,Options[NMin]}]];
	(\[Pi](x+y)-2.(x-y)ArcTan[slope(x-y)])/(2\[Pi])
];


NMax[x_,y_,opts___]:=Module[{slope},
	slope=Evaluate[Slope/.Flatten[{opts,Options[NMax]}]];
	(\[Pi](x+y)+2.(y-x)ArcTan[slope(y-x)])/(2\[Pi])
];


NMin[list_List,opts___]:=If[Length[list]==2,NMin[list[[1]],list[[2]],opts],Message[NMin::nottwo]];
NMax[list_List,opts___]:=If[Length[list]==2,NMax[list[[1]],list[[2]],opts],Message[NMax::nottwo]];


Options[NMin]={Slope->10000};
Options[NMax]={Slope->10000};


NMin::nottwo="NMin only works on lists of two values.";
NMax::nottwo="NMax only works on lists of two values.";


Reinterpolation::usage="Reinterpolation[\!\(\*
StyleBox[\"f\", \"TI\"]\)] reinterpolates a function containing one or more InterpolatingFunctions.";


Reinterpolation[f_,opts___?OptionQ]:=Module[{
(* options *)
interpolationopts,interpolationpoints,
(* other variables *)
xmin,xmax,ifs,grid,tmp},
	
(* handle options *)
interpolationopts=FilterRules[Flatten[{opts,Options[Reinterpolation]}],Options[Interpolation]];
interpolationpoints=Evaluate[InterpolationPoints/.Flatten[{opts,Options[Reinterpolation]}]];

ifs=Cases[f,_InterpolatingFunction,{0,\[Infinity]}];
If[ifs=={},Return[f]];

If[interpolationpoints===Automatic,
	grid=Union[Flatten[Through[ifs["Grid"]],1]],
(* using ifs\[LeftDoubleBracket]1,1\[RightDoubleBracket] because ifs\[LeftDoubleBracket]1\[RightDoubleBracket]["Domain"] fails sometimes?! - see "wtf domain.nb" *)
	(*grid=Flatten[Subdivide[Sequence@@#,interpolationpoints]&/@ifs\[LeftDoubleBracket]1,1\[RightDoubleBracket]]*)
	{xmin,xmax}=ifs[[1,1,1]];
	grid=Table[x,{x,xmin,xmax,(xmax-xmin)/(interpolationpoints-1)}];
];
(*Print["grid=",grid];*)

Quiet[
	tmp=Interpolation[Table[{Sequence@@val,f/.(if_InterpolatingFunction->if[Sequence@@val])},{val,grid}],Evaluate[Sequence@@interpolationopts]],
	{InterpolatingFunction::dmval}];

tmp[[1]]=ifs[[1,1]]; (* fix domain *)

Return[tmp]
];


Options[Reinterpolation]={InterpolationPoints->Automatic};


MakeInterpolatingFunctionPeriodic::usage="MakeInterpolatingFunctionPeriodic[\!\(\*
StyleBox[\"if\", \"TI\"]\)] makes InterpolatingFunction \!\(\*
StyleBox[\"if\", \"TI\"]\) periodic.";


MakeInterpolatingFunctionPeriodic[if_InterpolatingFunction]:=Module[{
	dorder=if[[2,3]],
	ngrid=if[[2,4]]},
	Which[
		if[[4,1]]===Developer`PackedArrayForm,
		ReplacePart[if,{
			{2,7}->{1}, (* set periodic flag *)
			{2,4}->ngrid-1 ,(* decrease ngrid by 1 *)
			{4,2}->Drop[if[[4,2]],-1], (* remove last abscissa *)
			{4,3}->Drop[if[[4,3]],-dorder-1] (* remove last dorder+1 values *)
		}]
	,
		ListQ[if[[4,1]]],
		ReplacePart[if,{
			{2,7}->{1}, (* set periodic flag *)
			{2,4}->ngrid-1, (* decrease ngrid by 1 *)
			{4}->Drop[if[[4]],-1] (* remove last point *)
		}]
	]
];


(*(* modified from <https://mathematica.stackexchange.com/a/235451/6358> by MichaelE2 *)
MakeInterpolatingFunctionPeriodic[if_InterpolatingFunction]:=Module[{periodify},
	periodify[list_List]:=Append[list,First@list];
	Interpolation[
		Transpose@{if["Grid"],
		periodify@Most@if["ValuesOnGrid"],
		periodify@Most@Derivative[1][if]["ValuesOnGrid"],
		periodify@Most@Derivative[2][if]["ValuesOnGrid"]},
		PeriodicInterpolation\[Rule]True]
];*)


SimplifyLogE::usage=
"SimplifyLogE is a replacement rule that simplifies Log[\!\(\*
StyleBox[\"a\", \"TI\"]\) \!\(\*SuperscriptBox[\(E\), 
StyleBox[\"x\", \"TI\"]]\)] to Log[\!\(\*
StyleBox[\"a\", \"TI\"]\)]+\!\(\*
StyleBox[\"x\", \"TI\"]\).";


SimplifyLogE=Log[(a_:1) E^x_]:>x+Log[a];


SortRuleList::usage=
"SortRuleList[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] sorts \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) in order of \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


SortRuleList[eq_?RuleListQ,vars_List]:=SortBy[eq,Position[vars,#[[1]]]&];


(* make Listable *)
SortRuleList[eqs_?RuleListListQ,vars_List]:=SortRuleList[#,vars]&/@eqs;


OrderedComplement::usage=
"OrderedComplement[\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"all\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)] gives the elements in \!\(\*
StyleBox[SubscriptBox[\"e\", \"all\"], \"TI\"]\) that are not in any of the \!\(\*
StyleBox[SubscriptBox[\"e\", \"i\"], \"TI\"]\), without sorting the result.";


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/30434/6358> *)
OrderedComplement[all_List, i__List]:=DeleteDuplicates[Join@##]~Drop~Length[#]&[Union@i,DeleteDuplicates@all];


RuleListComplement::usage=
"RuleListComplement[\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"all\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)] gives the elements in \!\(\*
StyleBox[SubscriptBox[\"e\", \"all\"], \"TI\"]\) whose variables don't match any of the \!\(\*
StyleBox[SubscriptBox[\"e\", \"i\"], \"TI\"]\).";


RuleListComplement[all_?RuleListQ,i__?RuleListQ]:=Complement[all,i,SameTest->(First[#1]===First[#2]&)];


EqSort::usage=
"EqSort[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] sorts \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) in order of increasing number of non-zero entries.";


(*EqSort[x_?RuleListListQ]:=SortBy[x,Reverse[Map[If[Abs[#]<$MachineEpsilon,0,1]&,#\[LeftDoubleBracket]All,2\[RightDoubleBracket]]]&];*)
EqSort[x_?RuleListListQ]:=Module[{ind},ind[y_]:=Reverse[Map[If[Abs[#[[2]]]<$MachineEpsilon,0,1,1]&,y]];SortBy[x,{Total[ind[#]]&,ind[#]&}]];


EqSort[x_?RuleListQ]:=x;


RHS::usage=
"RHS is a replacement rule that returns the right-hand side of equations.";

LHS::usage=
"LHS is a replacement rule that returns the left-hand side of equations.";


RHS=(_==rhs_->rhs);
LHS=(lhs_==_->lhs);


ReplaceRHS::usage="ReplaceRHS[\!\(\*
StyleBox[\"eqn\", \"TI\"]\), \!\(\*
StyleBox[\"rule\", \"TI\"]\)] applies replacement rule \!\(\*
StyleBox[\"rule\", \"TI\"]\) to the right-hand side of \!\(\*
StyleBox[\"eqn\", \"TI\"]\).";
ReplaceLHS::usage="ReplaceLHS[\!\(\*
StyleBox[\"eqn\", \"TI\"]\), \!\(\*
StyleBox[\"rule\", \"TI\"]\)] applies replacement rule \!\(\*
StyleBox[\"rule\", \"TI\"]\) to the left-hand side of \!\(\*
StyleBox[\"eqn\", \"TI\"]\).";


ReplaceRHS[eqn_,rules_]:=eqn/.(Equal[lhs_,rhs_]:>Equal[lhs,rhs/.Flatten@rules]);
ReplaceLHS[eqn_,rules_]:=eqn/.(Equal[lhs_,rhs_]:>Equal[lhs/.Flatten@rules,rhs]);

(* make Listable over eqns *)
ReplaceRHS[eqns_List,rules_]:=ReplaceRHS[#,rules]&/@eqns;
ReplaceLHS[eqns_List,rules_]:=ReplaceLHS[#,rules]&/@eqns;


Eq::usage="Eq is a replacement rule that sets time derivatives to zero and next timesteps equal to current timesteps.";


Eq:=Which[modeltype=="ContinuousTime",var_'->0,modeltype=="DiscreteTime",var_'->var];


ZeroLHS::usage="ZeroLHS is a replacement rule that sets the left hand side of equations equal to zero.";


ZeroLHS=(lhs_==rhs_->0==rhs);


ZeroVector::usage="ZeroVector[\!\(\*
StyleBox[\"d\", \"TI\"]\)] returns a \!\(\*
StyleBox[\"d\", \"TI\"]\)-dimensional zero vector.";


ZeroVector[dim_Integer]:=Table[0,{i,dim}];


ZeroMatrix::usage="ZeroMatrix[\!\(\*
StyleBox[\"d\", \"TI\"]\)] returns a \!\(\*
StyleBox[\"d\", \"TI\"]\)\!\(\*
StyleBox[\"*\", \"TI\"]\)\!\(\*
StyleBox[\"d\", \"TI\"]\)-dimensional zero matrix.";


ZeroMatrix[dim_Integer]:=Table[0,{dim},{dim}];


SubscriptAdd::usage="SubscriptAdd[\!\(\*
StyleBox[\"expr\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] adds \!\(\*
StyleBox[\"val\", \"TI\"]\) (default=1) to all subscripts in \!\(\*
StyleBox[\"expr\", \"TI\"]\).";


SubscriptAdd[x_Subscript,add_Integer:1]:=x/.Subscript[var_,sub_]->Subscript[var,sub+add];


AddSubscripts::usage="AddSubscripts[\!\(\*
StyleBox[\"array\", \"TI\"]\), \!\(\*
StyleBox[\"sub\", \"TI\"]\)] adds subscript \!\(\*
StyleBox[\"sub\", \"TI\"]\) to all elements of list/matrix \!\(\*
StyleBox[\"array\", \"TI\"]\).";


AddSubscripts[array_?VectorQ,sub_]:=Replace[array,sym_->Subscript[sym, sub],{1}];
AddSubscripts[array_?MatrixQ,sub_]:=Replace[array,sym_->Subscript[sym, sub],{2}];


DeleteSubscripts::usage="DeleteSubscripts[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] removes all subscripts from \!\(\*
StyleBox[\"expr\", \"TI\"]\).";


DeleteSubscripts[x_]:=x/.Subscript[var_,_]->var;


ZeroSubscripts::usage="ZeroSubscripts[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] sets the subscript in \!\(\*
StyleBox[\"expr\", \"TI\"]\) to zero.";


ZeroSubscripts[x_]:=x/.Subscript[var_,sub_]->Subscript[var,0];


HighlightChanges::usage=
"HighlightChanges[True] turns on change highlighting. HighlightChanges[False] turns it off.";


HighlightChanges[bool_]:=If[bool==True,
	SetOptions[EvaluationNotebook[],{
	CellProlog:>(
		SelectionMove[EvaluationCell[],All,GeneratedCell];
		$oldoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&]
	),
	CellEpilog:>(
	SelectionMove[EvaluationCell[],All,GeneratedCell];
	$newoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&];
	If[($oldoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"])=!=($newoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"]),
	Print[Style["Output change:",Red],"\nold=",$oldoutput]];
	If[Length[$newoutput]!=0,SelectionMove[EvaluationCell[],After,CellGroup,2],SelectionMove[EvaluationCell[],After,Cell]]
	)
	}],
	SetOptions[EvaluationNotebook[],{CellProlog->{},CellEpilog->{}}]
];


ExtractColors::usage="ExtractColor[\!\(\*
StyleBox[\"list\", \"TI\"]\)] extracts colors from \!\(\*
StyleBox[\"list\", \"TI\"]\).";


ExtractColors[list_List]:=Select[list,ColorQ[#]||Head[#]==Opacity&]


AxisFlip::usage="AxisFlip exchanges axes on a Graphics object.";


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/18669/6358> *)
AxisFlip=#/.{x_Line|x_GraphicsComplex:>MapAt[#~Reverse~2&,x,1],x:(PlotRange->_):>x~Reverse~2}&;


FuncStyle::usage="FuncStyle[\!\(\*
StyleBox[\"string\", \"TI\"]\)] formats \!\(\*
StyleBox[\"string\", \"TI\"]\) for use in debugging output.";


FuncStyle[func_]:=Style[func,Underlined];


PrintCall::usage="PrintCall[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] prints \!\(\*
StyleBox[\"expr\", \"TI\"]\) unevaluated.";


(* based on <https://mathematica.stackexchange.com/a/158902/6358> by Szabolcs and <https://mathematica.stackexchange.com/a/161310/6358> by Carl Woll *)
SetAttributes[PrintCall,HoldAll]
(*PrintCall[expr_]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]"Running:"]*)
(*PrintCall[expr_]:=Print[Defer[expr]];*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=With[{expr2=Defer[expr/.Sequence[]\[Rule]Null]},
	CellPrint@ExpressionCell[Defer[expr2],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
];*)
(*PrintCall[expr_,dingbat_:""]:=
CellPrint@ExpressionCell[Defer[expr]/.Sequence[]\[Rule]Nothing,CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]],
CellBaseline\[Rule]Scaled[0.005],CellMargins\[Rule]{{66,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
*)
(*PrintCall[expr_]:=Print@DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]];*)
PrintCall[expr_,dingbat_:""]:=Print[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]]];


ColorData[1]; (* load ColorData *)

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.083,0.4,1],Hue[0.083,0.7,1],Hue[0.083,1,1],Hue[0,1,1],Hue[0.917,1,1],Hue[0.917,1,0.7],Hue[0.917,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.25,0.4,1],Hue[0.25,0.7,1],Hue[0.25,1,1],Hue[0.333,1,1],Hue[0.417,1,1],Hue[0.417,1,0.7],Hue[0.417,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.567,0.4,1],Hue[0.583,0.7,1],Hue[0.583,1,1],Hue[0.667,1,1],Hue[0.75,1,1],Hue[0.75,1,0.7],Hue[0.75,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBrowns","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Lighter[Brown,0.5],Lighter[Blend[{Brown,Orange},0.5],0.5],Blend[{Brown,Orange},0.5],Darker[Blend[{Brown,Orange},0.5],0.5],Darker[Brown,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBrowns"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGrays","",{}},{"Gradients"},1,{0,1},
	{LightGray,Black}
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGrays"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"Black","",{}},{"Gradients"},1,{0,1},
	{Black,Black}
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"Black"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"Gray","",{}},{"Gradients"},1,{0,1},
	{Gray,Gray}
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"Gray"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"DarkerRainbow","darkerrainbow",{}},{"Gradients"},1,{0,1},{RGBColor[0.3142746666666667, 0.07251066666666667, 0.35134400000000005`],RGBColor[0.20737333333333335`, 0.07838666666666667, 0.44297933333333334`],RGBColor[0.16715200000000002`, 0.15025733333333335`, 0.512768],RGBColor[0.16272, 0.24082800000000001`, 0.5440560000000001],RGBColor[0.1774146666666667, 0.32444266666666666`, 0.5350193333333334],RGBColor[0.20394600000000002`, 0.3903833333333333, 0.4931106666666667],RGBColor[0.24032000000000003`, 0.43717266666666665`, 0.43046133333333336`],RGBColor[0.28656133333333333`, 0.46789933333333333`, 0.36021400000000003`],RGBColor[0.342278, 0.48661333333333334`, 0.29378800000000005`],RGBColor[0.4051006666666667, 0.49581200000000003`, 0.2390586666666667],RGBColor[0.4700253333333334, 0.4950606666666667, 0.1994446666666667],RGBColor[0.5296993333333333, 0.480772, 0.17388599999999999`],RGBColor[0.5756746666666667, 0.44718066666666667`, 0.15770933333333334`],RGBColor[0.600676, 0.38855066666666666`, 0.14436133333333334`],RGBColor[0.601902, 0.30264266666666667`, 0.12800933333333334`],RGBColor[0.5854046666666667, 0.19547200000000003`, 0.10698733333333335`],RGBColor[0.5715726666666667, 0.08740400000000001, 0.08808533333333333]},""}
];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"DarkerRainbow"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"LighterRainbow","lighterrainbow",{}},{"Gradients"},1,{0,1},{RGBColor[0.647608, 0.405844, 0.6846773333333334],RGBColor[0.5407066666666667, 0.41172, 0.7763126666666667],RGBColor[0.5004853333333333, 0.4835906666666666, 0.8461013333333333],RGBColor[0.49605333333333335`, 0.5741613333333333, 0.8773893333333334],RGBColor[0.510748, 0.6577759999999999, 0.8683526666666667],RGBColor[0.5372793333333333, 0.7237166666666666, 0.8264440000000001],RGBColor[0.5736533333333333, 0.770506, 0.7637946666666667],RGBColor[0.6198946666666667, 0.8012326666666666, 0.6935473333333333],RGBColor[0.6756113333333333, 0.8199466666666667, 0.6271213333333333],RGBColor[0.738434, 0.8291453333333333, 0.572392],RGBColor[0.8033586666666667, 0.828394, 0.532778],RGBColor[0.8630326666666667, 0.8141053333333333, 0.5072193333333332],RGBColor[0.9090079999999999, 0.780514, 0.4910426666666666],RGBColor[0.9340093333333334, 0.721884, 0.47769466666666666`],RGBColor[0.9352353333333333, 0.635976, 0.4613426666666667],RGBColor[0.9187379999999999, 0.5288053333333333, 0.4403206666666667],RGBColor[0.904906, 0.42073733333333335`, 0.4214186666666666]},""}
];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"LighterRainbow"];

GrayScale[x_]:=GrayLevel[1-x];


ClearCache::usage="ClearCache[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), ...] removes memoized DownValues of \!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), etc.";


(* mostly by Simon - see <http://stackoverflow.com/questions/5086749/mathematica-how-to-clear-the-cache-for-a-symbol-i-e-unset-pattern-free-downva> *)
ClearCache[f_]:=(DownValues[f]=DeleteCases[DownValues[f],_?(FreeQ[First[#],Pattern]&)];);

(* make work on multiple arguments *)
ClearCache[f__]:=(Map[ClearCache,{f}];);


InterpolatingFunctionFunctionQ::usage=
"InterpolatingFunctionFunctionQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] is True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a InterpolatingFunction function.";


InterpolatingFunctionFunctionQ[x_]:=If[Length[Cases[x,_InterpolatingFunction,\[Infinity],Heads->True]]!=0,True,False];
(*InterpolatingFunctionFunctionQ[x_]:=If[Head[Head[x]]===InterpolatingFunction,True,False];*) (* why did I write this? <- breaks (c[t]/.sol)^2 *)


TemporalDataFunctionQ::usage="TemporalDataFunctionQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] is True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a TemporalData function.";


TemporalDataFunctionQ[x_]:=If[Length[Cases[x,_TemporalData,\[Infinity],Heads->True]]!=0,True,False];


TemporalMean::usage=
"TemporalMean[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the average of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
TemporalMean[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] ranges from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
TemporalMean[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* thread over RuleLists *)
TemporalMean[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(x->TemporalMean[val,opts]));
TemporalMean[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["rulelist2"];*)
f/.(x_->val_):>(x->TemporalMean[val,{var,varmin,varmax},opts]));


(* thread over Lists *)
(*TemporalMean[list_List,rest___]:=TemporalMean[#,rest]&/@list;*)


(* main *)
TemporalMean[f_,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,method},
(*Print["main"];*)
	method=Evaluate[Method/.Flatten[{opts,Options[TemporalMean]}]];
	If[InterpolatingFunctionFunctionQ[f]==True,method="NIntegrate"];
	If[TemporalDataFunctionQ[f]==True,method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[TemporalMean]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalMean]}]];
	Which[
		method=="Integrate",
		Return[Integrate[f,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[f,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[f,{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Message[General::badmtd];Return[$Failed]
	];
];


(* InterpolatingFunctionFunctions *)
TemporalMean[f_?InterpolatingFunctionFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{nintegrateopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalMean]}]];
	
	ifdomains=Map[#["Domain"][[1]]&,Cases[f,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Message[TemporalMean::norange],
		numifdomains>1,
		Message[TemporalMean::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[TemporalMean[f,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


(* InterpolatingFunctions *)
TemporalMean[f_InterpolatingFunction,opts___?OptionQ]:=((*Print["IF"];*)TemporalMean[f[t],opts]);
TemporalMean[f_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)TemporalMean[f[t],{var,varmin,varmax},opts]);


(* TemporalData *)
TemporalMean[f_TemporalData,opts___?OptionQ]:=((*Print["td"];*)Mean[f]);
TemporalMean[f_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["td2"];*)
Mean[TimeSeriesWindow[f,{varmin,varmax}]]);


(* TemporalDataFunctions *)
TemporalMean[f_?TemporalDataFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{domains,numdomains,varmin,varmax},
	
	domains=Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f,_TemporalData,\[Infinity],Heads->True]];
	numdomains=Length[Union[domains]];
	
	Which[
		numdomains==0,
		Message[TemporalMean::norange],
		numdomains>1,
		Message[TemporalMean::unkrange],
		Else,
		{varmin,varmax}=domains[[1]];
		Return[TemporalMean[f,{var,varmin,varmax},opts]]
	];
];


(* fallthrough *)
TemporalMean[f_?((!RuleListQ[#]&&!InterpolatingFunctionFunctionQ[#])&),opts___?OptionQ]:=((*Print["otherwise"];*)f);


Options[TemporalMean]={Method->"Integrate",IntegrateOpts->{},NIntegrateOpts->{}};


TemporalVariance::usage=
"TemporalVariance[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the variance of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=\!\(\*
StyleBox[\"t\", \"TI\"]\)).
TemporalVariance[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] ranges from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
TemporalVariance[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* main *)
TemporalVariance[f_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg},
	method=Evaluate[Method/.Flatten[{opts,Options[TemporalVariance]}]];
	If[InterpolatingFunctionFunctionQ[f]==True,method="NIntegrate"];
	If[TemporalDataFunctionQ[f]==True,method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avg=TemporalMean[f,{var,varmin,varmax},Method->method];
	Which[
		method=="Integrate",
		Return[Integrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[(f-avg)^2,{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Message[General::badmtd];Return[$Failed];
	];
];


(* thread over RuleLists *)
TemporalVariance[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(Var[x]->TemporalVariance[val,opts]));
TemporalVariance[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["rulelist2"];*)
f/.(x_->val_):>(Var[x]->TemporalVariance[val,{var,varmin,varmax},opts]));


(* InterpolatingFunctionFunctions *)
TemporalVariance[if_?InterpolatingFunctionFunctionQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalVariance]}]];
		
	ifdomains=Map[#["Domain"][[1]]&,Cases[if,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Message[TemporalVariance::norange],
		numifdomains>1,
		Message[TemporalVariance::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[TemporalVariance[if,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


(* InterpolatingFunctions *)
TemporalVariance[f_InterpolatingFunction,opts___?OptionQ]:=((*Print["raw IF"];*)TemporalVariance[f[t],opts]);
TemporalVariance[f_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)TemporalVariance[f[t],{var,varmin,varmax},opts]);


(* TemporalData *)
TemporalVariance[f_TemporalData,opts___?OptionQ]:=Module[{n},
(*Print["td"];*)
	n=(f["LastTimes"]-f["FirstTimes"])[[1]]+1;
	Variance[f]*(n-1)/n
];

TemporalVariance[f_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{n},
(*Print["td2"];*)
	n=varmax-varmin+1;
	Variance[TimeSeriesWindow[f,{varmin,varmax}]]*(n-1)/n
];


(* TemporalDataFunctions *)
TemporalVariance[f_?TemporalDataFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{domains,numdomains,varmin,varmax},
	
	domains=Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f,_TemporalData,\[Infinity],Heads->True]];
	numdomains=Length[Union[domains]];

	Which[
		numdomains==0,
		Message[TemporalVariance::norange],
		numdomains>1,
		Message[TemporalVariance::unkrange],
		Else,
		{varmin,varmax}=domains[[1]];
		Return[TemporalVariance[f,{var,varmin,varmax},opts]]
	];
];


(* fallthrough *)
TemporalVariance[f_?NumericQ,opts___?OptionQ]:=((*Print["otherwise"];*)0);


Options[TemporalVariance]={IntegrateOpts->{},NIntegrateOpts->{},TemporalMeanOpts->{},Method->"Integrate"};


TemporalCovariance::usage=
"TemporalCovariance[\!\(\*
StyleBox[\"f1\", \"TI\"]\), \!\(\*
StyleBox[\"f2\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the covariance of \!\(\*
StyleBox[\"f1\", \"TI\"]\) and \!\(\*
StyleBox[\"f2\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=\!\(\*
StyleBox[\"t\", \"TI\"]\)).
TemporalCovariance[\!\(\*
StyleBox[\"f1\", \"TI\"]\), \!\(\*
StyleBox[\"f2\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] ranges from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
TemporalCovariance[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) to give variances and covariances.";


(* main *)
TemporalCovariance[f1_,f2_,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg1,avg2},
	method=Evaluate[Method/.Flatten[{opts,Options[TemporalCovariance]}]];
	If[(InterpolatingFunctionFunctionQ[f1]==True)||(InterpolatingFunctionFunctionQ[f2]==True),method="NIntegrate"];
	If[(TemporalDataFunctionQ[f1]==True)||(TemporalDataFunctionQ[f2]==True),method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	
	avg1=TemporalMean[f1,{var,varmin,varmax},Method->method];
	avg2=TemporalMean[f2,{var,varmin,varmax},Method->method];
	
	Which[
		method=="Integrate",
		Return[Integrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[(f1-avg1)(f2-avg2),{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Message[General::badmtd];Return[$Failed];
	];
];


(* thread over rule lists *)
TemporalCovariance[f_?RuleListQ,opts___?OptionQ]:=Module[{vars,pairs},
(*Print["threading 1"];*)
	vars=Keys[f];
	pairs=Subsets[vars,{2}];
	Return[Join[
		Table[Var[var]->TemporalVariance[var/.f,opts],{var,vars}],
		Table[Cov[Evaluate@@Sequence[pair]]->TemporalCovariance[Evaluate@@Sequence[pair/.f],opts]
	,{pair,pairs}]]]
];

TemporalCovariance[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{vars,pairs},
(*Print["threading 2"];*)
	vars=Keys[f];
	pairs=Subsets[vars,{2}];
	Return[Join[
		Table[Var[var]->TemporalVariance[var/.f,{var,varmin,varmax},opts],{var,vars}],
		Table[Cov[Evaluate@@Sequence[pair]]->TemporalCovariance[Evaluate@@Sequence[pair/.f],{var,varmin,varmax},opts]
	,{pair,pairs}]]]
];


(* InterpolatingFunctionFunctions *)
TemporalCovariance[if1_,if2_?InterpolatingFunctionFunctionQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalCovariance]}]];

	ifdomains=Map[#["Domain"][[1]]&,Cases[{if1,if2},_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Message[TemporalCovariance::norange],
		numifdomains>1,
		Message[TemporalCovariance::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[TemporalCovariance[if1,if2,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];

TemporalCovariance[if1_?InterpolatingFunctionFunctionQ,if2_,var_:t,opts___?OptionQ]:=TemporalCovariance[if2,if1,var,opts];


(* InterpolatingFunctions *)
TemporalCovariance[f1_InterpolatingFunction,f2_InterpolatingFunction,opts___?OptionQ]:=((*Print["raw IF"];*)TemporalCovariance[f1[t],f2[t],opts]);
TemporalCovariance[f1_InterpolatingFunction,f2_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)TemporalCovariance[f1[t],f2[t],{var,varmin,varmax},opts]);


(* TemporalData *)
TemporalCovariance[f1_TemporalData,f2_TemporalData,opts___?OptionQ]:=Module[{n},
(*Print["td"];*)
	n=(f1["LastTimes"]-f1["FirstTimes"])[[1]]+1;
	Covariance[f1["Values"],f2["Values"]]*(n-1)/n
];

TemporalCovariance[f1_TemporalData,f2_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{n},
	n=varmax-varmin+1;
	(*Print["td2"];*)
	Covariance[TimeSeriesWindow[f1,{varmin,varmax}]["Values"],TimeSeriesWindow[f2,{varmin,varmax}]["Values"]]*(n-1)/n
];


(* TemporalDataFunctions *)
TemporalCovariance[f1_,f2_?TemporalDataFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{domains,numdomains,varmin,varmax},
	(*Print["tdf2"];*)
	
	domains=Join[
		Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f1,_TemporalData,\[Infinity],Heads->True]],
		Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f2,_TemporalData,\[Infinity],Heads->True]]
	];
	numdomains=Length[Union[domains]];
	
	Which[
		numdomains==0,
		Message[TemporalCovariance::norange],
		numdomains>1,
		Message[TemporalCovariance::unkrange],
		Else,
		{varmin,varmax}=domains[[1]];
		Return[TemporalCovariance[f1,f2,{var,varmin,varmax},opts]]
	];
];

TemporalCovariance[f1_?TemporalDataFunctionQ,f2_,var_:t,opts___?OptionQ]:=((*Print["tdf1"];*)TemporalCovariance[f2,f1,var,opts]);


Options[TemporalCovariance]={IntegrateOpts->{},NIntegrateOpts->{},TemporalMeanOpts->{},Method->"Integrate"};


ExtractPlotPoints::usage="ExtractPlotPoints[\!\(\*
StyleBox[\"plot\", \"TI\"]\)] extracts lists of points from lines in \!\(\*
StyleBox[\"plot\", \"TI\"]\).";


(* by Jens <http://mathematica.stackexchange.com/a/20282/6358> *)
ExtractPlotPoints[plot:(_Graphics|_Graphics3D)]:=Cases[Normal@plot,Line[x_]:>x,\[Infinity]];


(* prF2 by kglr <https://mathematica.stackexchange.com/a/156783/6358> *)
GetPlotRange=Through[{Min,Max}@#]&/@Transpose[Join@@Cases[#//ToBoxes,RectangleBox[x_,y_,___]:>{x,y},\[Infinity]]/.NCache[_,vals_]->vals]&;


Else::usage="Else is an alias for True.";


Else=True;


SpFrac::usage="\!\(\*
StyleBox[\"SpFrac\", \"InlineCode\"]\)\!\(\*
StyleBox[\"[\", \"InlineCode\"]\)\!\(\*
StyleBox[\"sp\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"InlineCode\"]\)\!\(\*
StyleBox[\" \", \"InlineCode\"]\)\!\(\*
StyleBox[\"nsp\", \"TI\"]\)] gives \!\(\*
StyleBox[\"sp\", \"TI\"]\)/(\!\(\*
StyleBox[\"nsp\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\",\nFontSlant->\"Plain\"]\)1).";


SpFrac[sp_Integer,nsp_Integer]:=sp/(nsp+1.);
(*SpFrac[sp_Integer,nsp_Integer]:=(sp-1)/(nsp-0.99999);*)


ModPart::usage="ModPart[\!\(\*
StyleBox[\"list\", \"TI\"]\), \!\(\*
StyleBox[\"part\", \"TI\"]\)] returns part number \!\(\*
StyleBox[\"part\", \"TI\"]\) of \!\(\*
StyleBox[\"list\", \"TI\"]\) like Part, but wraps around.";


ModPart[list_List,part_Integer]:=Part[list,Mod[part,Length[list],1]];


NumberedGridForm::usage="NumberedGridForm[\!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*
StyleBox[SubscriptBox[\"list\", \"2\"], \"TI\"]\), \[Ellipsis]] formats \!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*
StyleBox[SubscriptBox[\"list\", \"2\"], \"TI\"]\), \[Ellipsis] in a table with numbers.";


(*NumberedGridForm[list_List]:=Grid[Transpose[{Range[Length[list]],list}],Alignment\[Rule]Left];*)
NumberedGridForm[lists__List,opts___?OptionQ]:=
	Grid[Transpose[{Range[Length[{lists}[[1]]]],lists}],Sequence@@Flatten[Join[{opts},Options[NumberedGridForm]]]];


Options[NumberedGridForm]={Alignment->Left};


FindMinima::usage=
"FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local minima of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358>
& a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


(* InterpolatingFunction *)
FindMinima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]>0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindMinima[if_InterpolatingFunction]:=FindMinima[if,if["Domain"][[1]]];


(* TemporalData *)
FindMinima[td_TemporalData]:=Normal[TimeSeriesMap[Minus,FindPeaks[TimeSeriesMap[Minus,td]]]];
FindMinima[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMinima[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindMinima[f_?RuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->FindMinima[val,opts]);
FindMinima[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindMinima[val,{tmin,tmax},opts]);


(* List *)
FindMinima[l_List]:=FindMinima[TimeSeries[l]];
FindMinima[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMinima[TimeSeries[l],{tmin,tmax}];


FindMaxima::usage=
"FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local maxima of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358>
& a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


(* InterpolatingFunction *)
FindMaxima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]<0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindMaxima[if_InterpolatingFunction]:=FindMaxima[if,if["Domain"][[1]]];


(* TemporalData *)
FindMaxima[td_TemporalData]:=Normal[FindPeaks[td]];
FindMaxima[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMaxima[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindMaxima[f_?RuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->FindMaxima[val,opts]);
FindMaxima[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindMaxima[val,{tmin,tmax},opts]);


(* List *)
FindMaxima[l_List]:=FindMaxima[TimeSeries[l]];
FindMaxima[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMaxima[TimeSeries[l],{tmin,tmax}];


FindExtrema::usage=
"FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local extrema of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358>
& a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


(* InterpolatingFunction *)
FindExtrema[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]==0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindExtrema[if_InterpolatingFunction]:=FindExtrema[if,if["Domain"][[1]]];


(* TemporalData *)
FindExtrema[td_TemporalData]:=Sort[Join[FindMinima[td],FindMaxima[td]]];
FindExtrema[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindExtrema[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindExtrema[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(x->FindExtrema[val,opts]));
FindExtrema[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindExtrema[val,{tmin,tmax},opts]);


(* List *)
FindExtrema[l_List]:=FindExtrema[TimeSeries[l]];
FindExtrema[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindExtrema[TimeSeries[l],{tmin,tmax}];


MaximumValues::usage=
"MaximumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local maximum values of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
MaximumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
MaximumValues[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


MaximumValues[x:(_InterpolatingFunction|_TemporalData),opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MaximumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMaxima[x][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMaxima[x][[All,2]]]]
	];
];


MaximumValues[x:(_InterpolatingFunction|_TemporalData),{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MaximumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMaxima[x,{tmin,tmax}][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMaxima[x,{tmin,tmax}][[All,2]]]]
	];
];


(* thread over RuleLists *)
MaximumValues[f_?TemporalRuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->MaximumValues[val,opts]);
MaximumValues[f_?TemporalRuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=
	f/.(x_->val_):>(x->MaximumValues[val,{tmin,tmax},opts]);


(* non-TemporalRuleLists *)
MaximumValues[f_?RuleListQ]:=f/.(x_->val_):>(x->{val});


(* Lists *)
MaximumValues[l_List]:=MaximumValues[TimeSeries[l]];
MaximumValues[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=MaximumValues[TimeSeries[l],{tmin,tmax}];


(* Numeric *)
MaximumValues[x_?NumericQ]:={x};
MaximumValues[x_?NumericQ,{tmin_?NumericQ,tmax_?NumericQ}]:={x};


Options[MaximumValues]={SameThreshold->10^-4};


MinimumValues::usage=
"MinimumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local minimum values of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
MinimumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
MinimumValues[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


MinimumValues[x:(_InterpolatingFunction|_TemporalData),opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MinimumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMinima[x][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMinima[x][[All,2]]]]
	];
];


MinimumValues[x:(_InterpolatingFunction|_TemporalData),{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MinimumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMinima[x,{tmin,tmax}][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMinima[x,{tmin,tmax}][[All,2]]]]
	];
];


(* thread over RuleLists *)
MinimumValues[f_?TemporalRuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->MinimumValues[val,opts]);
MinimumValues[f_?TemporalRuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=
	f/.(x_->val_):>(x->MinimumValues[val,{tmin,tmax},opts]);


(* non-TemporalRuleLists *)
MinimumValues[f_?RuleListQ]:=f/.(x_->val_):>(x->{val});


(* Lists *)
MinimumValues[l_List]:=MinimumValues[TimeSeries[l]];
MinimumValues[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=MinimumValues[TimeSeries[l],{tmin,tmax}];


(* Numeric *)
MinimumValues[x_?NumericQ]:={x};
MinimumValues[x_?NumericQ,{tmin_?NumericQ,tmax_?NumericQ}]:={x};


Options[MinimumValues]={SameThreshold->10^-4};


ExtremumValues::usage=
"ExtremumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local extremum values of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
ExtremumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
ExtremumValues[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


ExtremumValues[x:(_InterpolatingFunction|_TemporalData),opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[ExtremumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindExtrema[x][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindExtrema[x][[All,2]]]]
	];
];


ExtremumValues[x:(_InterpolatingFunction|_TemporalData),{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[ExtremumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindExtrema[x,{tmin,tmax}][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindExtrema[x,{tmin,tmax}][[All,2]]]]
	];
];


(* thread over TemporalRuleLists *)
ExtremumValues[f_?TemporalRuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->ExtremumValues[val,opts]);
ExtremumValues[f_?TemporalRuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=
	f/.(x_->val_):>(x->ExtremumValues[val,{tmin,tmax},opts]);


(* non-TemporalRuleLists *)
ExtremumValues[f_?RuleListQ]:=f/.(x_->val_):>(x->{val});


(* Lists *)
ExtremumValues[l_List]:=ExtremumValues[TimeSeries[l]];
ExtremumValues[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=ExtremumValues[TimeSeries[l],{tmin,tmax}];


(* Numeric *)
ExtremumValues[x_?NumericQ]:={x};
ExtremumValues[x_?NumericQ,{tmin_?NumericQ,tmax_?NumericQ}]:={x};


Options[ExtremumValues]={SameThreshold->10^-4};


FindPeriod::usage=
"FindPeriod[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the period of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


FindPeriod[sol_,opts:OptionsPattern[]]:=Module[{var1,res,tmp},

Which[
	Head[sol[[1,2]]]===TemporalData,
	(* based on idea from bbgodfrey, http://mathematica.stackexchange.com/a/107741/6358 *)
	res=Length[DeleteDuplicates[Transpose[
		Map[(#/.sol)["Values"][[Max[-sol[[1,2]]["PathLength"],-OptionValue[MaxPeriod]];;]]&,sol[[All,1]]]],
		Norm[#1-#2]<10^-OptionValue[AccuracyGoal]+Norm[(#1-#2)/#1]*10^-OptionValue[PrecisionGoal]&]]
,
	Head[sol[[1,2]]]===InterpolatingFunction&&OptionValue[BasePeriod]=!=None,
	var1=sol[[1,1]];
	tmp={var1->TimeSeries[Table[{t,var1/.Slice[sol,t]},{t,InitialTime[sol],FinalTime[sol],OptionValue[BasePeriod]}]]};
	res=FindPeriod[tmp]*OptionValue[BasePeriod]
,
	True, (* else *)
	Return[];
];

Return[res]

];


Options[FindPeriod]={MaxPeriod->4,AccuracyGoal->5,PrecisionGoal->5,BasePeriod->None};


MyStreamPlot::usage=
"MyStreamPlot[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"xmin\", \"TI\"]\), \!\(\*
StyleBox[\"xmax\", \"TI\"]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\), \!\(\*
StyleBox[\"ymin\", \"TI\"]\), \!\(\*
StyleBox[\"ymax\", \"TI\"]\)}] is like StreamPlot, but with better arrow spacing.";


(* originally by Rahul <http://mathematica.stackexchange.com/a/42770/6358>,
tweaked by me <https://mathematica.stackexchange.com/a/157613/6358>,
RegionFunction fixed by kglr <https://mathematica.stackexchange.com/a/193304/6358> *)

MyStreamPlot[f_,{x_,x0_,x1_},{y_,y0_,y1_},opts___?OptionQ]:=

Module[{
(* options *)
a,rf,
(* other variables *)
u,v,res,opts2},

a=Evaluate[AspectRatio/.Flatten[{opts,Options[StreamPlot]}]];
rf=Evaluate[RegionFunction/.Flatten[{opts,Options[StreamPlot]}]];

(* hack to fix visible region introduced in v12.1,
see <https://mathematica.stackexchange.com/questions/216865/blue-background-in-streamplot-output> *)
If[$VersionNumber>=12.1,opts2=Join[{opts},{RegionBoundaryStyle->None,RegionFillingStyle->None}],opts2={opts}];

res=Show[StreamPlot[
	({EcoEvo`Private`xmon,EcoEvo`Private`ymon}={Rescale[u,{0,1},{x0,x1}],Rescale[v,{0,a},{y0,y1}]};
	{1/(x1-x0),a/(y1-y0)} (f/.{x->Rescale[u,{0,1},{x0,x1}],y->Rescale[v,{0,a},{y0,y1}]})),{u,0,1},{v,0,a},
	RegionFunction->(rf[Rescale[#,{0,1},{x0,x1}],Rescale[#2,{0,a},{y0,y1}],##3]&),Evaluate[Sequence@@opts2]]
	/.Arrow[pts_]:>Arrow[Transpose[{Rescale[#,{0,1},{x0,x1}],Rescale[#2,{0,a},{y0,y1}]}&@@Transpose[pts]]],
	PlotRange->{{x0,x1},{y0,y1}}];
	
	Return[res]
];


RealSimplify::usage=
"RealSimplify[\!\(\*
StyleBox[\"expression\", \"TI\"]\)] Simplifies \!\(\*
StyleBox[\"expression\", \"TI\"]\) assuming everything is Real.";


(*RealSimplify[foo_]:=Simplify[foo,_\[Element]Reals];*)
(*RealSimplify[foo_,opts___]:=Simplify[foo,Evaluate[Sequence@@Flatten[Join[{_\[Element]Reals},{opts}]]]];*)
RealSimplify[foo_,opts___]:=Simplify[foo,Flatten[Join[{_\[Element]Reals},{opts}]]];


CompoundAnd::usage="CompoundAnd[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if all \!\(\*
StyleBox[\"conds\", \"TI\"]\) are True.";


CompoundAnd[list_]:=Module[{},And[Evaluate[Sequence@@list]]];


CompoundOr::usage="CompoundOr[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if any of \!\(\*FormBox[
StyleBox[\"conds\", \"TI\"],
TraditionalForm]\) are True.";


CompoundOr[list_]:=Module[{},Or[Evaluate[Sequence@@list]]];


NumericListQ::usage="NumericListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers, False otherwise.";


NumericListQ[x_]:=VectorQ[x,NumericQ[#]&];


NumericFlattenedListQ::usage =
"NumericFlattenedListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers when Flattened, False otherwise.";


NumericFlattenedListQ[x_]:=If[ListQ[x],NumericListQ[Flatten[x]],False];


NumericRuleListQ::usage=
"NumericRuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a RuleList with numeric values, False otherwise.";


NumericRuleListQ[x_]:=If[RuleListQ[x],VectorQ[x,NumericQ[#[[2]]]&],False];


MakeRuleList::usage=
"MakeRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
MakeRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), {\!\(\*
StyleBox[\"min\", \"TI\"]\), \!\(\*
StyleBox[\"max\", \"TI\"]\)}] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) ranges from \!\(\*
StyleBox[\"min\", \"TI\"]\) to \!\(\*
StyleBox[\"max\", \"TI\"]\).
MakeRuleList[\!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"vals\", \"TI\"]\)] makes a list of rules between corresponding elements of the lists \!\(\*
StyleBox[\"vars\", \"TI\"]\) and \!\(\*
StyleBox[\"vals\", \"TI\"]\).
MakeRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ns\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
MakeRuleList[{\!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(1\)]\), \[Ellipsis], \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(nv\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(1\)]\), \[Ellipsis] , \!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(nv\)]\)}, {{\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(1\)]\)}, \[Ellipsis] , {\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(nv\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(nv\)]\)}}] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(i\)]\) ranges from \!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(i\)]\) to \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(i\)]\).";


MakeRuleList[vars_List,n_,vals_List]:=Flatten[Table[Subscript[vars[[j]],i]->vals[[j]],{i,n},{j,Length[vars]}]];


MakeRuleList[vars_List,ns_List,vals_List]:=Module[{n,min,max},
	Thread[
		Flatten[Table[Map[Subscript[#,i]&,vars],{i,Times[Sequence@@ns]}]]
		->
		Flatten[Outer[List,Sequence@@Table[
			n=ns[[j]];
			If[ListQ[vals[[j]]],{min,max}=vals[[j]],min=max=vals[[j]]];
			Table[min+(max-min)*(i-1)/(n-1),{i,n}]
		,{j,Length[ns]}]]]
		]
	]


MakeRuleList[var_,n_,val_]:=Table[Subscript[var,i]->val/.\[IGrave]->i,{i,n}];


MakeRuleList[var_,n_,{min_?NumericQ,max_?NumericQ}]:=Table[Subscript[var,i]->min+(max-min)*(i-1)/(n-1),{i,n}];


MakeRuleList[var_,ns_List,val_]:=
	Thread[
		Table[Subscript[var,i],{i,Times[Sequence@@ns]}]->
		Table[val,{i,Times[Sequence@@ns]}]
	]


SetAttributes[MakeRuleList,HoldAll];


ArrayToRuleList::usage="ArrayToRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"arr\", \"TI\"]\)] makes an indexed rule list from \!\(\*
StyleBox[\"arr\", \"TI\"]\).";


ArrayToRuleList[var_Symbol,arr_List]:=Flatten[MapIndexed[Subscript[var, Sequence@@#2]->#1&,arr,{-1}]];


RuleListQ::usage=
"RuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of replacement rules, False otherwise.";


RuleListQ[x_]:=VectorQ[x,(#[[0]]==Rule||#[[0]]==RuleDelayed)&];


TemporalRuleListQ::usage="TemporalRuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a RuleList with temporal values, False otherwise.";


TemporalRuleListQ[x_]:=If[RuleListQ[x],VectorQ[x,MatchQ[#,_->_InterpolatingFunction|_TemporalData]&],False];


RuleListListQ::usage=
"RuleListListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of RuleLists, False otherwise.";


RuleListListQ[x_]:=VectorQ[x,RuleListQ[#]&];


RuleListDistance::usage=
"RuleListDistance[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] gives the distance between two rule lists.
RuleListDistance[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] gives the distance between a rule list and the origin.";


RuleListDistance[in1_?NumericRuleListQ,in2:(_?NumericRuleListQ):{},opts___?OptionQ]:=

Module[{
(* options *)
distancefunction=Evaluate[DistanceFunction/.Flatten[{opts,Options[RuleListDistance]}]],
weights=Evaluate[Weights/.Flatten[{opts,Options[RuleListDistance]}]],
(* other variables *)
list1,list2},

list1=RuleListMultiply[in1,weights];
If[in2!={},
	list2=RuleListMultiply[in2,weights],
	list2=RuleListMultiply[in1,0]
];

Return[distancefunction[Sort[list1][[All,2]],Sort[list2][[All,2]]]]
];


Options[RuleListDistance]={DistanceFunction->EuclideanDistance,Weights->{}};


RuleListTweak::usage=
"RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variable \!\(\*
StyleBox[\"var\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).
RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).";


RuleListTweak[point_?RuleListQ,var_Symbol,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_Subscript,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_List,h_List]:=Join[Select[point,!MemberQ[var,#[[1]]]&],#->((#/.point)+h[[Position[var,#][[1,1]]]])&/@var];


RuleListAdd::usage=
"RuleListAdd[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] adds corresponding elements of two rulelists.
RuleListAdd[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"x\", \"TI\"]\)] or RuleListAdd[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] adds number \!\(\*
StyleBox[\"x\", \"TI\"]\) to all elements of rulelist \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


RuleListAdd[a_?RuleListQ,b_?RuleListQ]:=Normal[Merge[{a,b},Total]];
RuleListAdd[a_?RuleListQ,x_?NumericQ]:=Normal[Merge[a,x+#[[1]]&]];
RuleListAdd[x_?NumericQ,a_?RuleListQ]:=Normal[Merge[a,x+#[[1]]&]];


RuleListSubtract::usage=
"RuleListSubtract[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] subtracts corresponding elements of \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\) from \!\(\*
StyleBox[\"rulelist1\", \"TI\"]\).";


RuleListSubtract[a_?RuleListQ,b_?RuleListQ]:=RuleListAdd[a,RuleListMultiply[b,-1]];


RuleListMultiply::usage=
"RuleListMultiply[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] multiplies corresponding elements of rulelists.
RuleListMultiply[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"x\", \"TI\"]\)] or RuleListMultiply[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] multiplies elements of rulelist \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) by number \!\(\*
StyleBox[\"x\", \"TI\"]\).";


RuleListMultiply[a_?RuleListQ,x_?NumericQ]:=Normal[Merge[a,x*#[[1]]&]];
RuleListMultiply[x_?NumericQ,a_?RuleListQ]:=Normal[Merge[a,x*#[[1]]&]];
RuleListMultiply[a_?RuleListQ,b_?RuleListQ]:=Normal[Merge[{a,b},Apply[Times]]];


NumericRuleListToNumericList::usage=
"NumericRuleListToNumericList[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] converts numeric rulelist \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) to a numeric list, in order of \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


NumericRuleListToNumericList[rl_?NumericRuleListQ,vars_List]:=vars/.rl;


RuleListInterpolation::usage=
"RuleListInterpolation[\!\(\*
StyleBox[\"list\", \"TI\"]\)] converts a list of the form {{\!\(\*
StyleBox[SubscriptBox[\"x\", \"1\"], \"TI\"]\),\!\(\*
StyleBox[SubscriptBox[\"rulelist\", \"1\"], \"TI\"]\)},{\!\(\*
StyleBox[SubscriptBox[\"x\", \"2\"], \"TI\"]\),\!\(\*
StyleBox[SubscriptBox[\"rulelist\", \"2\"], \"TI\"]\)},...} to a rule list of InterpolatingFunctions.";


RuleListInterpolation[list_List,opts___?OptionQ]:=Module[{interpolationopts},
	interpolationopts=FilterRules[Flatten[{opts,Options[RuleListInterpolation]}],Options[Interpolation]];
	
	Normal@Merge[Map[ReplaceAll[#[[2]],(var_->val_?NumericQ)->(var->{#[[1]],val})]&,list],Interpolation[#,Evaluate[Sequence@@interpolationopts]]&]
];


Options[RuleListInterpolation]={};


InterpolatingFunctionTake::usage=
"InterpolatingFunctionTake[\!\(\*
StyleBox[\"if\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] takes part of an InterpolatingFunction from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";


(* based on code by MichaelE2 <https://mathematica.stackexchange.com/a/152861/6358> *)

ClearAll[ifnPart];
ifnPart["Domain"]=Sequence[1];(*bounding box for domain*)
ifnPart["X1"]=Sequence[1,1];(*lower bound for first coordinate*)
ifnPart["X2"]=Sequence[1,2];(*upper bound for first coordinate*)
ifnPart["Version"]=Sequence[2,1];
ifnPart["Flags"]=Sequence[2,2];(*flags indicating properties:bit field positions-inferred,perhaps mistaken $extrapolation=0;whether to warn about extrapolation $fullArrayBit=1;interpolation data is a full array (not ragged) $packed=2;packed array form (???) $repeatedBit=4;whether repeated abscissae are permitted*)
ifnPart["DerivativeOrder"]=Sequence[2,3];(*max derivative order*)
ifnPart["NGrid"]=Sequence[2,4];(*number of points in each coordinate grid*)
ifnPart["InterpolationOrder"]=Sequence[2,5];(*interpolation order*)
ifnPart["Derivative"]=Sequence[2,6];(*derivative to evaluate:0-->f[x],1-->f'[x],...*)
ifnPart["Periodic"]=Sequence[2,7];
ifnPart["ExtrapolationHandler"]=Sequence[2,10];
ifnPart["Coordinates"]=Sequence[3];(*list of lists,abscissae of interpolation grid*)
ifnPart["InterpolationData"]=Sequence[4];(*interpolation data (values or coefficients)*)
ifnPart["Offsets"]=Sequence[4,2];(*offsets in function/derivative array (PackedArrayForm)*)
ifnPart["FlatData"]=Sequence[4,3];(*flattened function/derivative values (PackedArrayForm)*)
ifnPart["InterpolationStructure"]=Sequence[5];(*{Automatic},or dense output interpolation structure:list of types for each unit/subinterval*)ifnPart["UnitIndices"]=Sequence[5,1,1];(*dense output:Indices (to grid) for corresponding coefficients*)
ifnPart["UnitTypes"]=Sequence[5,1,2];(*dense output types:Automatic|NDSolve`CubicHermite|NDSolve`LocalSeries|ChebyshevT*)
ifnPart["Properties"]=Cases[DownValues[ifnPart],Verbatim[ifnPart][prop_]:>prop,Infinity];

ifnPart["ValidPartQ","Chebyshev"|"Local Taylor Series","UnitIndices"|"UnitTypes",_]:=True;
ifnPart["ValidPartQ",_,"UnitIndices"|"UnitTypes",_]:=False;
ifnPart["ValidPartQ","Hermite","Offsets"|"FlatData",Developer`PackedArrayForm]:=True;
ifnPart["ValidPartQ",_,"Offsets"|"FlatData",_]:=False;
ifnPart["ValidPartQ",method_String,part_String,_]/;MemberQ[method,"Chebyshev"|"Local Taylor Series"|"Hermite"]&&MemberQ[part,ifnPart["Properties"]]:=True;
ifnPart["ValidPartQ",_,_,_]:=False;
ifnPart[if_InterpolatingFunction,part_String]/;ifnPart["ValidPartQ",if["InterpolationMethod"],part,if[[4,1]]]:=if~Part~ifnPart[part];


dupeLast[list_]:=Append[list,Last@list];

iDataTake["Local Taylor series"|"Chebyshev",data_,span_]:=Join[{data[[First@span,1;;2]]},data[[First@span+1;;Last@span]]];
iDataTake["Hermite",data:{Developer`PackedArrayForm,_,_},span:{s1_,s2_}]:=
	ReplacePart[data,{Rest@{ifnPart["Offsets"]}->data[[2,s1;;s2+1]]-data[[2,s1]],Rest@{ifnPart["FlatData"]}->data[[3,data[[2,s1]]+1;;data[[2,s2+1]]]]}];
iDataTake["Hermite",data:{__List},span_]:=data[[Span@@span]];

iStructureTake["Local Taylor series"|"Chebyshev",structure_,span_]:=
	ReplacePart[structure,{Rest@{ifnPart["UnitIndices"]}->Join[{{1}},1+structure[[##2&@ifnPart["UnitIndices"],First@span+1;;Last@span]]-structure[[##2&@ifnPart["UnitIndices"],First@span,-1]]//dupeLast],Rest@{ifnPart["UnitTypes"]}->Join[{Automatic},structure[[##2&@ifnPart["UnitTypes"],First@span+1;;Last@span]]//dupeLast]}];
iStructureTake["Hermite",structure_,span_]:=structure;

InterpolatingFunctionTake[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]/;Length@if["Domain"]==1:=Module[
{coords,newif=Hold@@if,span,method},

method=if["InterpolationMethod"];
coords=First@if["Coordinates"];
span=Clip[SparseArray[UnitStep[coords-tmin] UnitStep[tmax-coords]]["AdjacencyLists"][[{1,-1}]]+{-1,1},{1,Length@coords}];
newif[[ifnPart["Domain"]]]={{tmin,tmax}};
newif[[ifnPart["NGrid"]]]=1+Differences@span;
newif[[ifnPart["Coordinates"]]]=Developer`ToPackedArray@{coords[[Span@@span]]};
newif[[ifnPart["InterpolationData"]]]=iDataTake[method,if[[ifnPart["InterpolationData"]]],span];
newif[[ifnPart["InterpolationStructure"]]]=iStructureTake[method,if[[ifnPart["InterpolationStructure"]]],span];
InterpolatingFunction@@newif
];


Slice::usage=
"Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"t\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with its values at \!\(\*
StyleBox[\"t\", \"TI\"]\).
Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] extracts values from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";


Slice[sol_?(*Temporal*)RuleListQ,t:(_?NumericQ|_DirectedInfinity)]:=
Which[
	MemberQ[{InterpolatingFunction,TemporalData},Head[#[[2]]]],
	ReplacePart[#,2->(#[[1]][t]/.#)]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],#[[1]]==t&,1][[1,2]]]
,
	Else,#
]&/@sol;

Slice[sol_?(*Temporal*)RuleListQ,{t1_?NumericQ,t2_?NumericQ}]:=
Which[
	Head[#[[2]]]===InterpolatingFunction,
	ReplacePart[#,2->InterpolatingFunctionTake[#[[2]],{t1,t2}]]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],t1<=#[[1]]<=t2&]]
,
	Head[#[[2]]]===TemporalData,
	ReplacePart[#,2->TimeSeries[Transpose[{#[[2]]["Times"][[t1+1;;t2+1]],#[[2]]["Values"][[t1+1;;t2+1]]}]]]
,
	Else,#
]&/@sol

Slice[sol_?RuleListQ,___]:=sol;


InitialSlice::usage=
"InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the initial values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] extracts the initial values ending at \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";


InitialSlice[sol_?RuleListQ,n:(_?NumericQ):0]:=Module[{x},
	x=If[modeltype=="ContinuousTime",10.^-100,0];
	If[n==0,
		Return[Slice[sol,InitialTime[sol]+x]],
		Return[Slice[sol,{InitialTime[sol]x,InitialTime[sol]+n}]]
	]
];


(*InitialSlice[sol_?RuleListQ,___]:=sol;*)


FinalSlice::usage=
"FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the final values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmin\", \"TI\"]\)] extracts the final values starting at \!\(\*
StyleBox[\"tmin\", \"TI\"]\).";


FinalSlice[sol_?RuleListQ,n:(_?NumericQ):0]:=
	If[n==0,
		Return[Slice[sol,FinalTime[sol]]],
		Return[Slice[sol,{FinalTime[sol]-n,FinalTime[sol]}]]
	];


(*FinalSlice[sol_?RuleListQ,___]:=sol;*)


FinalDerivatives::usage=
"FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with their final derivatives.
FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\)] averages over the final values starting at \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\).";


FinalDerivatives[sol_?TemporalRuleListQ,dt:(_?NumericQ):0]:=Module[{res},
	If[dt==0,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]]'[#[[2,1,1,2]]]/.#)}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket]'[#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]/.#)}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-2,2]])/(#[[2,-1,1]]-#[[2,-2,1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-2]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-2]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-2\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]][#[[2,1,1,2]]]-#[[1]][#[[2,1,1,2]]-dt])/dt/.#}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]-#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]-dt])/dt/.#}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-(1+dt),2]])/(#[[2,-1,1]]-#[[2,-(1+dt),1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-(1+dt)]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-(1+dt)]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	];
	Return[res]
]


FinalDerivatives[sol_?NumericRuleListQ,___]:=ReplacePart[#,{1->#[[1]]',2->0}]&/@sol


InitialTime::usage=
"InitialTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the initial time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(*InitialTime[sol_]:=Which[
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===InterpolatingFunction,sol\[LeftDoubleBracket]1,2,1,1,1\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===List,sol\[LeftDoubleBracket]1,2,1,1\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===TemporalData,sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]["FirstTime"]
];*)


InitialTime[sol_?RuleListQ]:=Module[{tmp,numtmp},
	tmp=Which[
		Head[#[[2]]]===InterpolatingFunction,#[[2,1,1,1]],
		Head[#[[2]]]===List,#[[2,1,1]],
		Head[#[[2]]]===TemporalData,#[[2]]["FirstTime"],
		Else,-\[Infinity]
	]&/@sol;
	numtmp=Select[tmp,NumericQ];
	(*If[Length[Union[numtmp]]>1,Message[InitialTime::notime,numtmp];Return[$Failed]];*)
	Return[Max[tmp]];
];


InitialTime::notime="No common final time among `1`.";


FinalTime::usage=
"FinalTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the final time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(*FinalTime[sol_]:=Which[
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===InterpolatingFunction,sol\[LeftDoubleBracket]1,2,1,1,2\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===List,sol\[LeftDoubleBracket]1,2,-1,1\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===TemporalData,sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]["LastTime"]
];*)


FinalTime[sol_?RuleListQ]:=Module[{tmp,numtmp},
	tmp=Which[
		Head[#[[2]]]===InterpolatingFunction,#[[2,1,1,2]],
		Head[#[[2]]]===List,#[[2,-1,1]],
		Head[#[[2]]]===TemporalData,#[[2]]["LastTime"],
		Else,\[Infinity]
	]&/@sol;
	numtmp=Select[tmp,NumericQ];
	(*If[Length[Union[numtmp,SameTest\[Rule](Abs[#1-#2]<$MachinePrecision&)]]>1,Message[FinalTime::notime,numtmp];Return[$Failed]];*)
	Return[Min[tmp]];
];


FinalTime::notime="No common final time among `1`.";


SortedEigensystem::usage=
"SortedEigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] is Eigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)], sorted from largest to smallest Re[eigenvalue].";


(* by Jens <http://mathematica.stackexchange.com/questions/59172/should-eigenvalues-be-ordered> *)
SortedEigensystem[matrix_?MatrixQ,opts___]:=
(Eigensystem[matrix+# IdentityMatrix[Dimensions[matrix]],opts]-{#,0})&@Norm[Flatten[matrix]];


ListMultiplier::usage="ListMultiplier[\!\(\*
StyleBox[\"list\", \"TI\"]\)] multiplies a list of matrices.";


(* by Joel Wallman <http://mathematica.stackexchange.com/a/113113/6358> *)
ListMultiplier[list_,partitionwidth_:5]:=NestWhile[Dot@@@Partition[#,partitionwidth,partitionwidth,1,{}]&,list,Dimensions[#][[1]]>1&][[1]];


RouthHurwitzCriteria::usage=
"RouthHurwitzCriteria[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] gives the modified Routh-Hurwitz stability criteria (up to 3x3).";


RouthHurwitzCriteria[a_?MatrixQ]:=Module[{c3},
	If[!SquareMatrixQ[a],Message[RouthHurwitzCriteria::nonsq];Return[a]];
	Which[
		Length[a]==1,
		Return[Piecewise[{{True,a[[1,1]]<0},{False,a[[1,1]]>0}},Indeterminate]],
		Length[a]==2,
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]>0},{False,Tr[a]>0||Det[a]<0}},Indeterminate]],
		Length[a]==3,
		c3=Det[{{a[[1,1]]+a[[2,2]],a[[2,3]],-a[[1,3]]},{a[[3,2]],a[[1,1]]+a[[3,3]],a[[1,2]]},{-a[[3,1]],a[[2,1]],a[[2,2]]+a[[3,3]]}}];
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]<0&&c3<0},{False,Tr[a]>0||Det[a]>0||c3>0}},Indeterminate]],
		Length[a]>3,
		Message[RouthHurwitzCriteria::toobig];Return[a]
	]
];


JoinFirst::usage="JoinFirst[\!\(\*
StyleBox[\"l1\", \"TI\"]\), \!\(\*
StyleBox[\"l2\", \"TI\"]\)] joins two rulelists, taking the first definition in case of multiple.";


JoinFirst[l1_List,l2_List]:=If[l1!={}||l2!={},Normal@Merge[{l1,l2},First],{}];


MyListLinePlot3D::usage="MyListLinePlot3D[{{\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\)},{\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\)},\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)}] generates a 3D line plot of points with coordinates {\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)}.
MyListLinePlot3D[{\!\(\*SubscriptBox[
StyleBox[\"data\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"data\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)}] plots several collections of points, by default in different colors.";


(* based on user37744 <https://mathematica.stackexchange.com/a/107450/> *)
MyListLinePlot3D[arg_,opts___?OptionQ]:=Module[{listpointplot3dopts},
If[$VersionNumber>=12.3,(* use builtin ListLinePlot3D if available *)
	ListLinePlot3D[arg,opts],
	(* otherwise use homemade version *)
	(*Print["{opts}=",{opts}];*)
	listpointplot3dopts=FilterRules[{opts},Options[ListPointPlot3D]];
	(*Print["listpointplot3dopts=",listpointplot3dopts];*)
	If[Evaluate[Joined/.Flatten[{opts,Options[MyListLinePlot3D]}]]===False,
		ListPointPlot3D[arg,Sequence@@listpointplot3dopts],
		ListPointPlot3D[arg,Sequence@@listpointplot3dopts]/.Point[a___]:>{Thick,Line[a]}
	]
]
];


Options[MyListLinePlot3D]={Joined->True};


(*Options[MyListLinePlot3D]=If[$VersionNumber>=12.3,(* use builtin ListLinePlot3D if available *)
	Options[ListLinePlot3D],
	(* otherwise use homemade version *)
	(*FilterRules[Join[Options[ListPointPlot3D],{Joined\[Rule]True}],Except[ColorFunction]]*)
	(*Join[FilterRules[Options[ListPointPlot3D],Except[ColorFunction]],{Joined\[Rule]True}]*)
];*)


PlotDynamics::usage=
"PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots the functions in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.
PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\) in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.";

PlotInterpolatingFunction::usage=
"PlotInterpolatingFunction[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots the InterpolatingFunctions in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.
PlotInterpolatingFunction[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\) in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.";


Options[PlotDynamics]=
{Logged->False,PlotStyle->{},PlotMarkers->{},AxesLabel->Automatic,LineStyles->{},PlotType->"Plot",Joined->True,PlotVariance->True,PlotRangePadding->Scaled[0.02],
Histogram->False,HistogramPoints->10^5,HistogramScale->0.1,HistogramPosition->0.08,HistogramOpts->{},HistogramOpacity->0.6,Exclusions->Automatic};

Options[PlotInterpolatingFunction]=
{Logged->False,PlotStyle->{},PlotMarkers->{},AxesLabel->Automatic,LineStyles->{},PlotType->"Plot",Joined->True,PlotRangePadding->Scaled[0.02],
Histogram->False,HistogramPoints->10^5,HistogramScale->0.1,HistogramPosition->0.08,HistogramOpts->{},HistogramOpacity->0.6,Exclusions->Automatic};

notPlotDynamicsOpts=Except[Alternatives@@Replace[Options[PlotDynamics],h_[a_,_]:>h[a,_],1]];


PlotDynamics[sol_?RuleListQ,plotvarsin_List,opts___?OptionQ]:=

Module[{
(* options *)
logged,plotstyle,plotmarkers,axeslabel,plotopts,plotrange,linestyles,plottype,plotvariance,
histogram,histogrampoints,histogramscale,histogramposition,histogramopts,histogramopacity,exclusions,
(* other variables *)
lookup,gu,sp,vars,varvar,plotvars,plotcolor,ls,i,yaxislabel,xinit,xfinal,ifvars,tdvars,cvars,funcs,tdsol,
ifplot,tdplot,cplot,varplots,var,varvars,funcplots,if,
xrange,hmax,histo,hplot},
	
Block[{\[ScriptCapitalN]},

(*If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];*)

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[PlotDynamics]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotDynamics]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[PlotDynamics]}]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotDynamics]}]];
linestyles=Flatten[{Evaluate[LineStyles/.Flatten[{opts,Options[PlotDynamics]}]]}];
histogram=Evaluate[Histogram/.Flatten[{opts,Options[PlotDynamics]}]];
histogrampoints=Evaluate[HistogramPoints/.Flatten[{opts,Options[PlotDynamics]}]];
histogramscale=Evaluate[HistogramScale/.Flatten[{opts,Options[PlotDynamics]}]];
histogramposition=Evaluate[HistogramPosition/.Flatten[{opts,Options[PlotDynamics]}]];
histogramopts=Evaluate[HistogramOpts/.Flatten[{opts,Options[PlotDynamics]}]];
histogramopacity=Evaluate[HistogramOpacity/.Flatten[{opts,Options[PlotDynamics]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotDynamics]}]];
plotvariance=Evaluate[PlotVariance/.Flatten[{opts,Options[PlotDynamics]}]];
exclusions=Evaluate[Exclusions/.Flatten[{opts,Options[PlotDynamics]}]];

vars=sol[[All,1]];
(*Print["vars=",vars];*)

(* figure out number of species in guilds *)
If[modelloaded,
	Do[
		\[ScriptCapitalN][gu]=Max[
			Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==gcomp)&][[All,2]]],{gcomp,gcomps[gu]}],
			Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==gtrait)&][[All,2]]],{gtrait,gtraits[gu]}]
		];
		If[\[ScriptCapitalN][gu]==-\[Infinity],\[ScriptCapitalN][gu]=0];
		If[Global`debug,Print["\[ScriptCapitalN][",gu,"]=",\[ScriptCapitalN][gu]]];
	,{gu,guilds}]
];

(*Print["plotvarsin=",plotvarsin];*)
If[plotvarsin==={All},
	plotvars=vars,
	plotvars={};
	Do[
		lookup=LookUp[var];
		If[MemberQ[{"gcomp","gtrait"},lookup[[1]]]&&Length[lookup]==3&&\[ScriptCapitalN][lookup[[2]]]!=0,
			Do[AppendTo[plotvars,Subscript[var,sp]],{sp,\[ScriptCapitalN][lookup[[2]]]}],
			AppendTo[plotvars,var]
		];
	,{var,plotvarsin}]
];
(*Print["plotvars=",plotvars];*)

If[axeslabel===Automatic,
	yaxislabel=Sort[Union[Replace[plotvars,{Subscript[v_,sp_]->Subscript[v,"i"]},1]]];
	axeslabel={t,Row[yaxislabel,","]}
];
(*Print["axeslabel=",axeslabel];*)

(* split into InterpolatingFunctions, TemporalData, and constants *)
ifvars=Select[plotvars,Head[#/.sol]==InterpolatingFunction&];
(*Print["ifvars=",ifvars];*)
tdvars=Select[plotvars,Head[#/.sol]==TemporalData||Head[#/.sol]==List&];
(*Print["tdvars=",tdvars];*)
cvars=Select[plotvars,NumericQ[#/.sol]&];
(*Print["cvars=",cvars];*)
funcs=Complement[plotvars,ifvars,tdvars,cvars];
(*Print["funcs=",funcs];*)

If[plotstyle==={},
	i=0;
	Do[
		i++;
		If[linestyles==={},ls=LineStyle[var],ls=ModPart[linestyles,i]];
		lookup=LookUp[var];
		Which[
			(lookup[[1]]==="gcomp"||lookup[[1]]==="gtrait"||lookup[[1]]==="var")&&Length[lookup]==4,
			plotcolor[var]=Color[var][SpFrac[lookup[[4]],\[ScriptCapitalN][lookup[[2]]]]]
		,
			(lookup[[1]]==="gcomp"||lookup[[1]]==="gtrait")&&Length[lookup]==3,
			plotcolor[var]=Color[var]
		,
			lookup[[1]]==="pcomp"||lookup[[1]]==="aux",
			plotcolor[var]=Color[var]
		,
			Else,
			plotcolor[var]=ColorData[97][i];
		];
		AppendTo[plotstyle,{plotcolor[var],ls}]
	,{var,plotvars}]
];

If[CompoundAnd[Table[comptype[var]==="Extensive",{var,plotvars}]],
	If[logged==True,
		plotrange=All,
		plotrange={0,All}
	],
	(*plotrange=(IntervalUnion[Sequence@@Table[range[var],{var,plotvars}]]/.{-\[Infinity]\[Rule]All,\[Infinity]\[Rule]All})\[LeftDoubleBracket]1\[RightDoubleBracket]*)
	plotrange=All
];

varplots={};

If[ifvars!={},
	(*Print["ifvars=",ifvars];*)
	{xinit,xfinal}=(ifvars[[1]]/.sol)["Domain"][[1]]; (* extract domain *)
	(*Print["{xinit,xfinal}=",{xinit,xfinal}];*)
	If[logged==True,
		Which[
			plottype=="ListPlot",
			plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[ListPlot]];
			ifplot=ListLogPlot[ifvars/.sol,Evaluate[Sequence@@plotopts],PlotRange->plotrange]
		,
			Else,
			plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[LogPlot]];
			ifplot=LogPlot[Evaluate[Table[var[x],{var,ifvars}]/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange];
			varplots={};
		]
	,
		Which[
			plottype=="ListPlot",
			plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[ListPlot]];
			ifplot=ListPlot[ifvars/.sol,Evaluate[Sequence@@plotopts],PlotRange->plotrange],
			Else,
			plotopts=FilterRules[Flatten[{Exclusions->exclusions,opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[Plot]];
			If[exclusions===Automatic,exclusions=Union@Select[Split[Flatten@Table[(var/.sol)["Coordinates"][[1]],{var,ifvars}]],Length[#]>1&][[All,1]]];
			(*Print["exclusions=",exclusions];*)
			ifplot=Plot[Evaluate[Table[Tooltip[var[x],ToString[var]],{var,ifvars}]/.sol],{x,xinit,xfinal},Exclusions->exclusions,Evaluate[Sequence@@plotopts],PlotRange->plotrange];
			If[plotvariance==True,
				varplots=DeleteNulls@Table[
					varvar=var/.{Subscript[x_, i_]->Subscript[Var[x], i],Subscript[x_[n_], i_]->Subscript[Var[x][n], i],x_->Var[x],x_[n_]->Var[x][n]};
					(*Print[var," ",varvar];*)
					If[KeyExistsQ[sol,varvar],
						Plot[Evaluate[{var[x]+Sqrt[varvar[x]],var[x]-Sqrt[varvar[x]]}/.sol],{x,xinit,xfinal},
							Filling->{1->{{2},Directive[Opacity[0.2],plotcolor[var]]}},PlotStyle->None,PlotRange->All]
					]
				,{var,ifvars}]
			]
		]
	]
,
	ifplot={};
];
(*Print[ifplot];*)

If[tdvars!={},
	If[plotmarkers==={}&&(Joined/.{opts})===False,
		plotmarkers=Table[PlotMarker[var],{var,tdvars}]
	];

	If[plotmarkers=={},plotmarkers=None];
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,PlotMarkers->plotmarkers,Options[PlotDynamics]}],Options[ListPlot]];
	tdsol=Select[sol,MemberQ[tdvars,#[[1]]]&];
	{xinit,xfinal}={InitialTime[tdsol],FinalTime[tdsol]};
	If[logged==True,
		tdplot=ListLogPlot[Normal[tdvars/.sol],Evaluate[Sequence@@plotopts],PlotRange->plotrange]
	,
		tdplot=ListPlot[Normal[tdvars/.sol],Evaluate[Sequence@@plotopts],AxesOrigin->{xinit,0},PlotRange->plotrange];
	]
,
	tdplot={};
];

If[cvars!={},
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[Plot]];
	cplot=Plot[Evaluate[cvars/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange]
,
	cplot={}
];

If[funcs!={},
	funcplots=Table[
		func=funcs[[f]];
		(*Print[func/.sol];*)
		if=Reinterpolation[func/.sol];
		{xinit,xfinal}=if["Domain"][[1]]; (* extract domain *)
		(*Print["{xinit,xfinal}=",{xinit,xfinal}];*)
		plotopts=FilterRules[Flatten[{Exclusions->exclusions,opts,AxesLabel->axeslabel,Options[PlotDynamics]}],Options[Plot]];
		If[ListQ[plotstyle],ps=plotstyle[[f]],ps=plotstyle];
		If[exclusions===Automatic,exclusions=Union@Select[Split[Flatten@Table[(var/.sol)["Coordinates"][[1]],{var,ifvars}]],Length[#]>1&][[All,1]]];
		Plot[Evaluate[Tooltip[if[x],ToString[func]]],{x,xinit,xfinal},Exclusions->exclusions,PlotStyle->ps,Evaluate[Sequence@@plotopts]]
	,{f,Length[funcs]}]
,
	funcplots={};
];

If[histogram,
	xrange=(xfinal-xinit);
	hmax=Max[Table[
		histo[ifvar]=Histogram[Table[ifvar[t]/.sol,{t,xinit,xfinal,xrange/histogrampoints}],Automatic,"PDF",Evaluate[Sequence@@histogramopts]];
		GetPlotRange[histo[ifvar]][[2,2]]
	,{ifvar,ifvars}]];
	hplot=Graphics[
		Flatten[
		Table[{
			{Directive[EdgeForm[Directive[Thickness[Small],Opacity[histogramopacity]]],plotcolor[ifvar],Opacity[histogramopacity]]},
			Cases[histo[ifvar]/.NCache[_,vals_]->vals
			/.(Rectangle[List[x1_,y1_],List[x2_,y2_],optz___]->Rectangle[List[y1+xfinal+xrange*histogramposition,x1],List[y2*xrange/hmax*histogramscale+xfinal+xrange*histogramposition,x2],optz])
			/.(RectangleBox[List[x1_,y1_],List[x2_,y2_],optz___]->Rectangle[List[y1+xfinal+xrange*histogramposition,x1],List[y2*xrange/hmax*histogramscale+xfinal+xrange*histogramposition,x2],optz]),
			Rectangle[List[_,_],List[_,_],___],\[Infinity]]
		},{ifvar,ifvars}]]
		]
,
	hplot={}
];
(*Print[hplot];*)

If[histogram,
	Return[Show[ifplot,tdplot,cplot,hplot,funcplots,PlotRange->{{xinit,xfinal},All},PlotRangeClipping->False,ImagePadding->All(*{{20,400*histogramposition+250*histogramscale},{20,20}}*)]],
	Return[Show[ifplot,varplots,tdplot,cplot,funcplots]]
];
]];


(* if only one plotvar given, doesn't need to be in a list *)
PlotDynamics[sol_?RuleListQ,plotvarin:notPlotDynamicsOpts:All,opts___?OptionQ]:=(*(Print[1];*)PlotDynamics[sol,{plotvarin},opts];

(* if only a rule given, doesn't need to be in a list *)
PlotDynamics[sol_Rule,plotvarsin_List,opts___?OptionQ]:=PlotDynamics[{sol},plotvarsin,opts];
PlotDynamics[sol_Rule,plotvarin_Symbol,opts___?OptionQ]:=PlotDynamics[{sol},{plotvarin},opts];
PlotDynamics[sol_Rule,opts___?OptionQ]:=PlotDynamics[{sol},All,opts];

(* thread over sols *)
PlotDynamics[list_?RuleListListQ,rest___]:=Show[PlotDynamics[#,rest]&/@list];

PlotInterpolatingFunction[sol_,plotvarsin___,opts___?OptionQ]:=PlotDynamics[sol,plotvarsin,opts,AxesLabel->None];


RuleListPlot::usage=
"RuleListPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots a two- or three-dimensional rule list.
RuleListPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\).
RuleListPlot[{\!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(2\)]\), \[Ellipsis]}] plots multiple rule lists.";


RuleListPlot[solsin_?RuleListListQ,varsin_List:{All},opts___?OptionQ]:=

Module[{
func=FuncStyle["RuleListPlot"],
(* options *)
plotstyle,plotmarkers,axeslabel,plotrange,
stablemarker,unstablemarker,indeterminatemarker,
parametricplotopts,parametricplot3dopts,listplotopts,listlineplotopts,listpointplot3dopts,listlineplot3dopts,
(* other variables *)
sol,sols,lookup,vars},
	
Block[{\[ScriptCapitalN]},

(*If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];*)
If[Global`debug,Print["In ",func]];

(* handle options *)

plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[RuleListPlot]}]];
If[plotstyle===Automatic,plotstyle=ColorData[97,"ColorList"]];
If[!ListQ[plotstyle],plotstyle={plotstyle}];

stablemarker=Evaluate[StableMarker/.Flatten[{opts,Options[RuleListPlot]}]];
unstablemarker=Evaluate[UnstableMarker/.Flatten[{opts,Options[RuleListPlot]}]];
indeterminatemarker=Evaluate[IndeterminateMarker/.Flatten[{opts,Options[RuleListPlot]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[RuleListPlot]}]]/.
	{True->stablemarker,False->unstablemarker,Indeterminate->indeterminatemarker};
Which[
	plotmarkers===Automatic,
	plotmarkers={"\[FilledCircle]","\[FilledSquare]","\[FilledDiamond]","\[FilledUpTriangle]","\[FilledDownTriangle]","\[EmptyCircle]","\[EmptySquare]","\[EmptyDiamond]","\[EmptyUpTriangle]","\[EmptyDownTriangle]"},
	plotmarkers==="OpenMarkers",
	plotmarkers={"\[EmptyCircle]","\[EmptySquare]","\[EmptyDiamond]","\[EmptyUpTriangle]","\[EmptyDownTriangle]"},
	plotmarkers==="FilledMarkers",
	plotmarkers={"\[FilledCircle]","\[FilledSquare]","\[FilledDiamond]","\[FilledUpTriangle]","\[FilledDownTriangle]"}
];
(*Print[plotmarkers];*)

axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[RuleListPlot]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[RuleListPlot]}]];

parametricplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ParametricPlot]];
parametricplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ParametricPlot3D]];
listplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListPlot]];
listlineplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListLinePlot]];
listpointplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListPointPlot3D]];
listlineplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[MyListLinePlot3D]];

(* figure out number of species in guilds *)
(*Set\[ScriptCapitalN][ExtractTraits[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]],ExtractVariables[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];*)

(* find vars for plotting *)
If[varsin==={All},
	vars=solsin[[1,All,1]],
	vars=varsin
];
(*Print["vars=",vars];*)
If[Length[vars]!=2&&Length[vars]!=3,Message[RuleListPlot::baddim,Length[vars]];Return[$Failed]];

(* split up subscripted variables (gcomps & gtraits) *)
lookup=LookUp[vars[[1]]];
If[MemberQ[{"gcomp","gtrait"},lookup[[1]]]&&Length[lookup]==3,
	sols=Flatten[GatherBy[#,#[[1,2]]&]&/@solsin,1]/.Replace[vars,var_->(Subscript[var, _]->var),1],
	sols=solsin
];
(*Print[sols];*)

If[axeslabel===Automatic,axeslabel=vars];
(*Print["axeslabel=",axeslabel];*)

Which[
	Length[vars]==2,
	If[plotrange===Automatic,
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],If[comptype[vars[[2]]]==="Extensive",{0,All},All]}
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			(*Print["parametricplotopts=",parametricplotopts];*)
			ParametricPlot[{vars[[1]][t],vars[[2]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplotopts]],
			Head[sol[[1,2]]]===List,
			ListLinePlot[Transpose[(vars/.sol)[[All,All,2]]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]],
			Head[sol[[1,2]]]===TemporalData,
			ListLinePlot[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]],
			Else,
			(*Print["listplotopts=",listplotopts];*)
			ListPlot[{vars/.sol},PlotStyle->ModPart[plotstyle,i],PlotMarkers->ModPart[plotmarkers,i],
				PlotRange->plotrange,Evaluate[Sequence@@listplotopts]]
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,FrameLabel->axeslabel,PlotRange->plotrange]],
	Length[vars]==3,
	If[plotrange===Automatic,
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],
			If[comptype[vars[[2]]]==="Extensive",{0,All},All],
			If[comptype[vars[[3]]]==="Extensive",{0,All},All]}
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			ParametricPlot3D[{vars[[1]][t],vars[[2]][t],vars[[3]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplot3dopts]],
			Head[sol[[1,2]]]===List,
			MyListLinePlot3D[Transpose[vars/.sol],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]],
			Head[sol[[1,2]]]===TemporalData,
			MyListLinePlot3D[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]],
			Else,
			ListPointPlot3D[{vars/.sol},PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@listpointplot3dopts]]
				(*/.Point[a___]\[RuleDelayed]Text[ModPart[plotmarkers,i],a]*)
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,PlotRange->plotrange]]
];

]];


RuleListPlot[sol_?RuleListQ,rest___]:=RuleListPlot[{sol},rest];


Options[RuleListPlot]={
	PlotStyle->Automatic,AxesLabel->Automatic,PlotRange->Automatic,
	PlotMarkers->{Graphics[{Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	StableMarker->{Graphics[{Black,Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	UnstableMarker->{Graphics[{EdgeForm[{Black}],FaceForm[White],Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	IndeterminateMarker->{Graphics[{EdgeForm[{Black}],FaceForm[Gray],Disk[]},ImageSize->8,AlignmentPoint->{0,0},ImagePadding->1]},
	PlotRangeClipping->False,BoxRatios->1,AspectRatio->1/GoldenRatio
};


RuleListPlot::baddim="RuleListPlot requires two- or three-dimensional data (# of dimensions=`1`).";


TrackRoot::usage=
"TrackRoot[\!\(\*
StyleBox[\"eqns\", \"TI\"]\), {{\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\), \!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], \(0\)]\)},...}, {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"initpar\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] tracks a root of \!\(\*
StyleBox[\"eqns\", \"TI\"]\), varying \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\), starting at \!\(\*
StyleBox[\"initpar\", \"TI\"]\).";


TrackRoot::badmtd="The Method option should be a built-in method name (\"Direct\" or \"PseudoArcLength\")";


TrackRoot[eqns_List,unksnics_List,{par_Symbol,ipar_?NumericQ,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=Module[{
(* options *)
method,findrootopts,ndsolveopts,smin,smax,
(* other variables *)
whenevents,unks,subrule,breaks,isol,ics,deqns,j,sol,s1,s2,res,respart,pts},

(* handle options *)
method=Evaluate[Method/.Flatten[{opts,Options[TrackRoot]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[TrackRoot]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[TrackRoot]}]];
smin=Evaluate[SMin/.Flatten[{opts,Options[TrackRoot]}]];
smax=Evaluate[SMax/.Flatten[{opts,Options[TrackRoot]}]];

(* jacobian *)
j:=D[eqns,{unks}]/.subrule;

unks=unksnics[[All,1]];
(*Print["unks=",unks];*)

(* use FindRoot to improve initial guess *)
isol=FindRoot[eqns/.par->ipar,unksnics,Evaluate[Sequence@@findrootopts]];
If[Global`debug,Print["isol=",isol]];

whenevents={};

Which[
	method=="Direct",
	subrule=Table[unk->unk[par],{unk,unks}];
	ics=Table[unk[ipar]==(unk/.isol),{unk,unks}];
	deqns=Map[#==0&,D[eqns/.subrule,par]];
	maxev[param_?NumericQ]:=Module[{jac},jac=D[eqns,{unks}]/.subrule;Print[jac];Max[Re[Eigenvalues[jac]]]];
	whenevents=Join[whenevents,{
		WhenEvent[Evaluate[Max[Re[Eigenvalues[j]]]==0],"StopIntegration"](*,
		WhenEvent[maxev[par]==0,"StopIntegration"]*)
	}];
	Print["whenevents="];Print[whenevents];
	(* track root with NDSolve *)
	sol=NDSolve[Join[deqns,ics,whenevents],unks,{par,parmin,parmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	Return[sol]
	,
	method=="PseudoArcLength",
	subrule=Append[Table[unk->unk[s],{unk,unks}],par->par[s]];
	ics=Join[Table[unk[0]==(unk/.isol),{unk,unks}],{par[0]==ipar}];
	whenevents=Join[whenevents,{
		WhenEvent[par'[s]==0,AppendTo[breaks,s]],
		WhenEvent[par[s]==parmax,"StopIntegration"],
		WhenEvent[par[s]==parmin,"StopIntegration"](*,
		WhenEvent[Evaluate[Max[Re[Eigenvalues[j]]]==0],"StopIntegration"]*)
	}];
	(*Print["whenevents="];Print[whenevents];*)
	deqns=Join[
		Map[#==0&,eqns/.subrule],
		{Total[D[unks/.subrule,s]]^2+D[par[s],s]^2==1},
		Table[unk'[0]==0,{unk,unks}],
		{par'[0]==1}
	];
	If[Global`debug,Print["deqns="];Print[deqns]];
	(* track root with NDSolve *)
	breaks={}; (* capture turning points *)
	sol=NDSolve[Join[deqns,ics,whenevents],Append[unks,par],{s,smin,smax},Evaluate[Sequence@@ndsolveopts]][[1]];
	(* beginning and ending s *)
	{s1,s2}=(par/.sol)["Domain"][[1]];
	(* add endpoints to breaks *)
	breaks=Sort[Join[{s1,s2},breaks]];
	(* construct interpolatingfunctions (unk vs par) for each segment (between breaks) *)
	res={};
	Do[
		respart={};
		Do[
			pts=Transpose[{(par/.sol)["Coordinates"][[1]],(par/.sol)["ValuesOnGrid"],(unk/.sol)["ValuesOnGrid"]}];
			AppendTo[respart,unk->Interpolation[Select[pts,breaks[[i]]<=#[[1]]<=breaks[[i+1]]&][[All,2;;3]],"ExtrapolationHandler"->{Indeterminate&,"WarningMessage"->False}]];
		,{unk,unks}];
		AppendTo[res,respart];
	,{i,Length[breaks]-1}];
	Return[res]
	,
	Else,
	Message[TrackRoot::badmtd];Return[$Failed]
];

]


(* no initpar - assume initpar=parmin *)
TrackRoot[eqns_List,unksnics_List,{par_Symbol,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=
TrackRoot[eqns,unksnics,{par,parmin,parmin,parmax},opts,SMin->0];

(* one equation, one unknown, no {} *)
TrackRoot[eqns_,unksnics_List,{par_Symbol,ipar_?NumericQ,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=
TrackRoot[{eqns},{unksnics},{par,ipar,parmin,parmax},opts];


Options[TrackRoot]={FindRootOpts->{},NDSolveOpts->{},Method->"PseudoArcLength",SMin->-100,SMax->100};


PartsAboveDiagonal[arr_?MatrixQ]:=Module[{dim},
	dim=Dimensions[arr];
	Flatten@Table[arr[[i,j]],{i,1,dim[[1]]},{j,i+1,dim[[2]]}]
]


(* by xzczd <https://mathematica.stackexchange.com/a/233122/6358> *)
PrintMessage[mess_, val__] := Print@StringForm[mess, val];


DoubleDotProduct::usage="DoubleDotProduct[\!\(\*
StyleBox[\"A\", \"TI\"]\), \!\(\*
StyleBox[\"B\", \"TI\"]\)] calculates the double dot product of matrices \!\(\*
StyleBox[\"A\", \"TI\"]\) and \!\(\*
StyleBox[\"B\", \"TI\"]\).";


DoubleDotProduct[A_?MatrixQ,B_?MatrixQ]:=Flatten[A] . Flatten[B];


HessianMatrix::usage="HessianMatrix[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] calculates the Hessian matrix of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


HessianMatrix[f_,vars_]:=Table[D[f,var1,var2],{var1,vars},{var2,vars}]


UnfactorSums::usage="UnfactorSums is a replacement rule that moves external multiplicative terms inside Sums.";


UnfactorSums:=pre_. Sum[func_,range_,opts___]:>Sum[pre func,range,opts];


GaussianIntegral::usage="GaussianIntegral[\!\(\*
StyleBox[\"func\", \"TI\"]\), {\!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"mean\", \"TI\"]\), \!\(\*
StyleBox[\"varcov\", \"TI\"]\)}] calculates the Gaussian integral with respect to \!\(\*
StyleBox[\"vars\", \"TI\"]\) of \!\(\*
StyleBox[\"func\", \"TI\"]\) multiplied by a multinormal distibution with \!\(\*
StyleBox[\"mean\", \"TI\"]\) and \!\(\*
StyleBox[\"varcov\", \"TI\"]\).";


GaussianIntegral[func_,{x_List,mean_List,var_List},opts___?OptionQ]:=Module[{method,timeconstraint,res},
	method=Evaluate[Method/.Flatten[{opts,Options[GaussianIntegral]}]];
	timeconstraint=Evaluate[TimeConstraint/.Flatten[{opts,Options[GaussianIntegral]}]];
	res=TimeConstrained[
		Expectation[func,x\[Distributed]MultinormalDistribution[mean,var],Method->method],
		timeconstraint,Message[GaussianIntegral::time,timeconstraint];Return[$Failed]];
	If[Head[res]===Expectation,Message[GaussianIntegral::failed];Return[$Failed]];
	RealSimplify[res]
];

GaussianIntegral[func_,{x1_List,mean1_List,var1_List},{x2_List,mean2_List,var2_List},opts___?OptionQ]:=Module[{method,timeconstraint},
	method=Evaluate[Method/.Flatten[{opts,Options[GaussianIntegral]}]];
	RealSimplify[Expectation[Expectation[func,x1\[Distributed]MultinormalDistribution[mean1,var1],Method->method],x2\[Distributed]MultinormalDistribution[mean2,var2],Method->method],(#>=0)&/@Flatten[{var1,var2}]]
];


GaussianIntegral[func_,{x_,mean_,var_},opts___?OptionQ]:=GaussianIntegral[func,{{x},{mean},{{var}}},opts];
GaussianIntegral[func_,{x1_,mean1_,var1_},{x2_,mean2_,var2_},opts___?OptionQ]:=GaussianIntegral[func,{{x1},{mean1},{{var1}}},{{x2},{mean2},{{var2}}},opts];


Options[GaussianIntegral]={Method->Automatic,TimeConstraint->5};


GaussianIntegral::time = "Time spent on GaussianIntegral exceeded `1` seconds, so it was aborted. Increasing the value of TimeConstraint may result in an answer.";
GaussianIntegral::failed = "Expectation failed to calculate GaussianIntegral.";


GaussianIntegralApproximation::usage="GaussianIntegralApproximation[\!\(\*
StyleBox[\"func\", \"TI\"]\),{\!\(\*
StyleBox[\"vars\", \"TI\"]\),\!\(\*
StyleBox[\"mean\", \"TI\"]\),\!\(\*
StyleBox[\"varcov\", \"TI\"]\)}] gives a second-order approximation to the Gaussian integral with respect to \!\(\*
StyleBox[\"vars\", \"TI\"]\) of \!\(\*
StyleBox[\"func\", \"TI\"]\) multiplied by a multinormal distibution with \!\(\*
StyleBox[\"mean\", \"TI\"]\) and \!\(\*
StyleBox[\"varcov\", \"TI\"]\).";


GaussianIntegralApproximation[func_?MatrixQ,{x_List,mean_List,var_List},opts___?OptionQ]:={{GaussianIntegralApproximation[func[[1,1]],{x,mean,var},opts]}};
GaussianIntegralApproximation[func_?MatrixQ,{x_,mean_,var_},opts___?OptionQ]:={{GaussianIntegralApproximation[func[[1,1]],{{x},{mean},{{var}}},opts]}};


GaussianIntegralApproximation[func_,{x_List,mean_List,var_List}]:=(func+1/2DoubleDotProduct[HessianMatrix[func,x],var])/.x->mean;


GaussianIntegralApproximation[func_,{x_,mean_,var_},opts___?OptionQ]:=GaussianIntegralApproximation[func,{{x},{mean},{{var}}},opts];
GaussianIntegralApproximation[func_,{x_,xmean_,xvar_},{y_,ymean_,yvar_},opts___?OptionQ]:=GaussianIntegralApproximation[GaussianIntegralApproximation[func,{x,xmean,xvar},opts],{y,ymean,yvar},opts];


VPrint::usage = "VPrint[\!\(\*
StyleBox[\"lvl\", \"TI\"]\), \!\(\*
StyleBox[\"msg\", \"TI\"]\)] prints \!\(\*
StyleBox[\"msg\", \"TI\"]\) if Verbosity level >= \!\(\*
StyleBox[\"lvl\", \"TI\"]\).";


VPrint[lvl_Integer:1,msg___]:=
	If[lvl<=verbosity,If[StringQ[func],Print[FuncStyle[func],": ",msg],Print[msg]]];


CreateBlock::usage="CreateBlock[lvals, rvals, expr] makes a Block with lvals equal to rvals.";


(* by Daniel Huber <http://forums.wolfram.com/mathgroup/archive/2010/Nov/msg00217.html> *)
SetAttributes[CreateBlock, HoldAll];
CreateBlock[lvals_, rvals_, expr_] :=
Module[{v, myBlock, mySet, vals},
    v = Thread[mySet[lvals, rvals]];
    SetAttributes[myBlock, HoldAll];
    myBlock[vals, expr] /. vals -> v /. mySet -> Set /. myBlock -> Block
];


NEqual::usage="NEqual[\!\(\*
StyleBox[\"x1\", \"TI\"]\), \!\(\*
StyleBox[\"x2\", \"TI\"]\)] tests if \!\(\*
StyleBox[\"x1\", \"TI\"]\) approximately equals \!\(\*
StyleBox[\"x2\", \"TI\"]\).";


NEqual[x1_,x2_,opts___?OptionQ]:=Module[{samethreshold},
	samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[NEqual]}]];
	If[
		Dimensions[x1,AllowedHeads->"ListLike"]==Dimensions[x2,AllowedHeads->"ListLike"],
		Return[If[Norm[x1-x2]<samethreshold,True,False,False]],
		Message[NEqual::nedd];
		Return[False]
	];
];


Options[NEqual]={SameThreshold->10^-8};


NEqual::nedd="Arguments of NEqual have different dimensions.";


VarRangeQ::usage="VarRangeQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] tests if \!\(\*
StyleBox[\"x\", \"TI\"]\) has the form {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"min\", \"TI\"]\), \!\(\*
StyleBox[\"max\", \"TI\"]\)}.";


VarRangeQ[x_]:=If[ListQ[x]&&Length[x]==3&&NumericQ[x[[2]]]&&NumericQ[x[[3]]],True,False,False];


FindRoots::usage="FindRoots[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}] finds all roots of \!\(\*
StyleBox[\"f\", \"TI\"]\) in the range \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\) <= \!\(\*
StyleBox[\"x\", \"TI\"]\) <= \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\).
FindRoots[{\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), \[Ellipsis]}, {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}, \[Ellipsis]] finds all roots of {\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), \[Ellipsis]}.";


(* based on:
FindAllCrossings2D by Stan Wagon,
findAllRoots by Jens <https://mathematica.stackexchange.com/a/16444/>,
FindRoots2D by Mr. Wizard <https://mathematica.stackexchange.com/a/770/>,
FindAllCrossings3D by J.M. <https://mathematica.stackexchange.com/a/11365/> *)


FindRoots[eqnsin_List,ranges__?VarRangeQ,opts___?OptionQ]:=

Module[{
(* options *)
numseeds,method,pad,plotopts,findrootopts,deq,
verbose,
(* other variables *)
eqns,dim,roots,seeds,peqns,var,min,max,dvar,vars,plot,f},

Block[{verbosity},

(* set verbosity *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindRoots]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindRoots]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindRoots]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[FindRoots]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindRoots]}]];
method=Evaluate[Method/.Flatten[{opts,Options[FindRoots]}]];
numseeds=Evaluate[NumSeeds/.Flatten[{opts,Options[FindRoots]}]];
pad=Evaluate[Padding/.Flatten[{opts,Options[FindRoots]}]];
deq=Evaluate[DEq/.Flatten[{opts,Options[FindRoots]}]];

eqns=eqnsin/.(lhs_==rhs_)->rhs-lhs; (* convert equations into functions *)
dim=Length[eqns];
If[dim!=Length[{ranges}],Message[FindRoots::baddim];Abort[]];

Do[
	{var[i],min[i],max[i]}={ranges}[[i]];
	dvar[i]=(max[i]-min[i]);
	(*Print[i," ",{var[i],min[i],max[i],dvar[i]}];*)
,{i,dim}];
vars=Table[var[i],{i,dim}];

(* set seeds *)
If[
	method===Automatic,
	Which[
		dim==1,
		plot=Plot[Evaluate[eqns/.{var[1]->x}],{x,min[1]-pad*dvar[1],max[1]+pad*dvar[1]}];
		VPrint[3,plot];
		seeds=Mean/@Map[First,Select[Split[ExtractPlotPoints[plot][[1]],Sign[Last[#2]]==-Sign[Last[#1]]&],Length[#1]==2&],{2}]/.{x_?NumericQ->{x}};
		seeds=Join[seeds,{{min[1]},{max[1]}}]
	,
		dim==2,
		peqns=Drop[eqns,{deq}];
		plot=ContourPlot[Evaluate[peqns/.{var[1]->x,var[2]->y}],
			{x,min[1]-1.1*pad*dvar[1],max[1]+pad*dvar[1]},{y,min[2]-pad*dvar[2],max[2]+1.1*pad*dvar[2]},
			Contours->{0},ContourShading->False,Evaluate[Sequence@@plotopts]];
		VPrint[3,plot];
		f=Compile[{x,y},Evaluate[eqns[[deq]]/.{var[1]->x,var[2]->y}]];
		seeds=Flatten[Pick[Rest@#,Rest[#]Most[#]&@Sign@Apply[f,#,2],-1]&/@ExtractPlotPoints[plot],1];
		seeds=Join[seeds,Tuples[Table[{min[i],max[i]},{i,dim}]]]
	,
		dim==3,
		peqns=Drop[eqns,{deq}];
		plot=ContourPlot3D[Evaluate[peqns/.{var[1]->x,var[2]->y,var[3]->z}],
			{x,min[1]-1.1*pad*dvar[1],max[1]+pad*dvar[1]},{y,min[2]-pad*dvar[2],max[2]+1.1*pad*dvar[2]},{z,min[3]-1.05*pad*dvar[3],max[3]+1.05*pad*dvar[3]},
			BoundaryStyle->{1->None,2->None,{1,2}->{}},ContourStyle->None,Mesh->None,
			Evaluate[Sequence@@plotopts]];
		VPrint[3,plot];
		f=Compile[{x,y,z},Evaluate[eqns[[deq]]/.{var[1]->x,var[2]->y,var[3]->z}]];
		seeds=Flatten[Pick[Rest[#],Most[#] Rest[#]&@Sign@Apply[f,#,2],-1]&/@ExtractPlotPoints[plot],1];
		seeds=Join[seeds,Tuples[Table[{min[i],max[i]},{i,dim}]]]
	,
		Else,
		method=Grid
	];
];
Which[
	method===Grid,
	If[numseeds==Automatic,numseeds=5];
	If[IntegerQ[numseeds],numseeds=Table[numseeds,{dim}]];
	seeds=Tuples[Table[Range[min[i],max[i],(max[i]-min[i])/(numseeds[[i]]-1)],{i,dim}]]
,
	method===Random,
	If[numseeds==Automatic,numseeds=10];
	seeds=RandomVariate[UniformDistribution[Table[{min[i],max[i]},{i,dim}]],numseeds]	
];
VPrint[1,"seeds=",seeds];

If[seeds!={},
	roots=Union[
		Chop[Map[Quiet@Check[
			FindRoot[eqns,Evaluate[Transpose[{vars,#}]],Evaluate[Sequence@@findrootopts]],Null,{FindRoot::jsing}]&,seeds]]//DeleteNulls,
		SameTest->(RuleListDistance[#1,#2]<10^-8&)
		];
	VPrint[1,"roots=",roots];
	Return[Select[roots,And@@Table[min[i]-$MachineEpsilon<=#[[i,2]]<=max[i]+$MachineEpsilon,{i,dim}]&]],
	Return[{}]
];

]];


Options[FindRoots]={Method->Automatic,NumSeeds->Automatic,FindRootOpts->{},PlotOpts->{},Padding->10^-3,DEq->-1,
Verbose->False,Verbosity->0};


FindRoots::baddim="Number of functions does not match number of unknowns.";


(* handle one-function case *)
FindRoots[func_,range_?VarRangeQ,opts___?OptionQ]:=FindRoots[{func},range,opts];


VectorPlot1D::usage="VectorPlot1D[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}] plots arrows in the direction of \!\(\*
StyleBox[\"f\", \"TI\"]\) from \!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\) to \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\).";


VectorPlot1D[func_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{
vectorpoints,markerwidth,markeraspectratio,markerspacing,
rt,lt,varrange,w,h},

(* handle options *)
vectorpoints=Evaluate[VectorPoints/.Flatten[{opts,Options[VectorPlot1D]}]];
markerwidth=Evaluate[MarkerWidth/.Flatten[{opts,Options[VectorPlot1D]}]];
If[markerwidth==Automatic,markerwidth=varrange/vectorpoints];
markeraspectratio=Evaluate[MarkerAspectRatio/.Flatten[{opts,Options[VectorPlot1D]}]];
markerspacing=Evaluate[MarkerSpacing/.Flatten[{opts,Options[VectorPlot1D]}]];

varrange=varmax-varmin;
w=(1-markerspacing)markerwidth;
h=w*markeraspectratio;

(*Print[{w,h}];*)

rt[x_]:=Triangle[{{x+w/2,0},{x-w/2,(h/2)Sqrt[3]/2},{x-w/2,-(h/2)Sqrt[3]/2}}];
lt[x_]:=Triangle[{{x-w/2,0},{x+w/2,(h/2)Sqrt[3]/2},{x+w/2,-(h/2)Sqrt[3]/2}}];
	
Show[Graphics[Table[
	Which[
		(func/.var->x)<0&&(func/.var->x-w/2)<0&&(func/.var->x+w/2)<0,lt[x],
		(func/.var->x)>0&&(func/.var->x-w/2)>0&&(func/.var->x+w/2)>0,rt[x]
	]
	,{x,varmin,varmax,varrange/vectorpoints}]],Axes->{True,False}]
];


Options[VectorPlot1D]={VectorPoints->21,MarkerWidth->Automatic,MarkerAspectRatio->0.5,MarkerSpacing->0.5};


PlotVector::usage="PlotVector[\!\(\*
StyleBox[\"vec\", \"TI\"]\)] plots a vector from the origin.
PlotVector[\!\(\*
StyleBox[\"vec\", \"TI\"]\), \!\(\*
StyleBox[\"pt\", \"TI\"]\)] plots a vector starting at \!\(\*
StyleBox[\"pt\", \"TI\"]\).";


PlotVector[vec_,ptin_List:{},opts___?OptionQ]:=Module[{plotstyle,dim,pt},

(* handle options *)
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotVector]}]];
dim=Length[vec];

If[ptin==={},pt=ZeroVector[dim],pt=ptin];

Which[
	dim==2,
	Graphics[Join[Flatten[{plotstyle}],{Arrow[{pt,pt+vec}]}]],
	dim==3,
	Graphics3D[Join[Flatten[{plotstyle}],{Arrow[{pt,pt+vec}]}]]
]
]


Options[PlotVector]={PlotStyle->Black};


Set\[ScriptCapitalN][attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{}]:=Module[{tmp,interxns,tnsp,pnsp,insp},

If[ninteractions!=0,interxns=ExtractInteractions[attributes]];

Do[
	If[IntegerQ[\[FormalCapitalN][gu]/.attributes], (* if \[FormalCapitalN] passed, just use that *)
		tnsp[gu]=insp[gu]=(\[FormalCapitalN][gu]/.attributes),
		(*If[attributes\[NotEqual]{},*)
			(* tnsp = nsp determined from traits *)
			If[ngtraits[gu]!=0,
				(*tmp=Table[Max[Select[Select[attributes,#\[LeftDoubleBracket]1,0\[RightDoubleBracket]\[Equal]Subscript&],#\[LeftDoubleBracket]1,1\[RightDoubleBracket]\[Equal]gtrait&]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket]],{gtrait,gtraits[gu]}];*)
				tmp=Table[Max[Select[
					Select[Select[attributes,#[[1,0]]==Subscript&],(#[[1,1]]==gtrait||#[[1,1,0]]==gtrait)&][[All,1,2]],NumericQ]],{gtrait,gtraits[gu]}];
(*Print[ExtractTraits[attributes,gu]];
Print[ExtractTraits[attributes,gu]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket]];
				tmp=ExtractTraits[attributes,gu]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket];*)
				If[Length[Union[tmp]]==1,
					tnsp[gu]=tmp[[1]],
					Message[Set\[ScriptCapitalN]::badtrait,gu,tmp];
					Abort[]
				];
(*Print["tnsp[gu]=",tnsp[gu]];*)
				If[tnsp[gu]==-\[Infinity],tnsp[gu]=0];
			,
				tnsp[gu]=None
			];
			(* insp = nsp determined from interactions *)
			If[Length[interactionpos[gu]]!=0,
				tmp=Table[Max[Select[interxns,#[[1,1]]==pos[[1]]&][[All,1,pos[[2]]+1]]],{pos,interactionpos[gu]}];
				(*Print[tmp];*)
				If[Length[Union[tmp]]==1,
					insp[gu]=tmp[[1]],
					Message[Set\[ScriptCapitalN]::badinterxn,gu,tmp];
					Abort[]
				];
			,
				insp[gu]=None
			]
		(*];*)
	];
	If[IntegerQ[\[FormalCapitalN][gu]/.variables], (* if \[FormalCapitalN] passed, just use that *)
		pnsp[gu]=(\[FormalCapitalN][gu]/.variables),
		(*If[variables\[NotEqual]{},*)
			(* pnsp = nsp determined from variables *)
			tmp=Table[Max[Select[Select[Select[variables,#[[1,0]]==Subscript&],#[[1,1]]==gcomp&][[All,1,2]],NumericQ]],{gcomp,gcomps[gu]}];
			If[Length[Union[tmp]]==1,
				pnsp[gu]=tmp[[1]],
				Message[Set\[ScriptCapitalN]::badcomm,gu,tmp];
				Abort[]
			];(*,
			pnsp[gu]=None
		];*)
(*Print["pnsp[gu]=",pnsp[gu]];*)
		If[pnsp[gu]==-\[Infinity],pnsp[gu]=0];
	];

	If[Global`debug,Print["Set\[ScriptCapitalN]: (",gu," tnsp=",tnsp[gu]," insp=",insp[gu]," pnsp=",pnsp[gu],")"]];
	
	Which[
		(* no traits given *)
		attributes=={},
		\[ScriptCapitalN][gu]=pnsp[gu],
		(* gu has traits & interactions *)
		ngtraits[gu]!=0&&Length[interactionpos[gu]]!=0,
		If[pnsp[gu]==tnsp[gu]==insp[gu]||(variables=={}&&tnsp[gu]==insp[gu]),
			\[ScriptCapitalN][gu]=tnsp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],tnsp[gu],insp[gu]}];
			Abort[]
		],
		(* gu has only interactions *)
		ngtraits[gu]==0&&Length[interactionpos[gu]]!=0,
		If[pnsp[gu]==insp[gu]||variables=={},
			\[ScriptCapitalN][gu]=insp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],None,insp[gu]}];
			Abort[]
		],
		(* gu has only traits *)
		ngtraits[gu]!=0&&Length[interactionpos[gu]]==0,
		If[pnsp[gu]==tnsp[gu]||variables=={},
			\[ScriptCapitalN][gu]=tnsp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],insp[gu],None}];
			Abort[]
		]
	]
,{gu,guilds}]

]/;(nguilds!=0);


Set\[ScriptCapitalN]::badnsp=
"Number of species in guild `1` inconsistent: {pnsp,tnsp,insp}= `2`.";

Set\[ScriptCapitalN]::badtrait=
"Number of traits in guild `1` inconsistent: `2`.";

Set\[ScriptCapitalN]::badcomm=
"Number of components in guild `1` inconsistent: `2`.";

Set\[ScriptCapitalN]::badinterxn=
"Number of interactions in guild `1` inconsistent: `2`.";


FromUnks::usage="Internal usage only ;)";
ToUnks::usage="Internal usage only ;)";
ToUnkRules::usage="Internal usage only ;)";


FromUnks:=Unk[stuff___]->stuff


ToUnks:=Flatten[{
	Table[Table[Subscript[gcomp,\[FormalS]_]->Unk[Subscript[gcomp,\[FormalS]]],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}],
	Table[Table[Subscript[gtrait,\[FormalS]_]->Unk[Subscript[gtrait,\[FormalS]]],{gtrait,gtraits[gu]}],{gu,guilds}]
}]


(*ToUnks:=Flatten[Table[Table[Subscript[gtrait,\[FormalS]_]\[Rule]Unk[Subscript[gtrait,\[FormalS]]],{gtrait,gtraits[gu]}],{gu,guilds}]];*)


ToUnkRules:=Flatten[Join[
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_][t])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]][t])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[(pcomp->pcomp)->(pcomp->Unk[pcomp]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[(pcomp->pcomp[t])->(pcomp->Unk[pcomp][t]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[(aux->aux)->(aux->Unk[aux]),{aux,auxs}],
	Table[(aux->aux[t])->(aux->Unk[aux][t]),{aux,auxs}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]])
	,{gtrait,gtraits[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_][t])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]][t])
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]]


AllTraits::usage="Internal usage only ;)";
AllVariables::usage="Internal usage only ;)";
AllPopsAndAuxs::usage="Internal usage only ;)";


AllTraits:=Flatten[Table[Table[Table[
	{Subscript[gtrait,sp],Table[Subscript[gtrait[gcomp],sp],{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


AllVariables:=Flatten[Join[
	Table[Table[Table[Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


AllPopsAndAuxs:=Flatten[Join[
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


BlankTraits::usage="Internal usage only ;)";
BlankUnkTraits::usage="Internal usage only ;)";
BlankVariables::usage="Internal usage only ;)";
BlankUnkVariables::usage="Internal usage only ;)";


BlankTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Subscript[gtrait,sp],{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


BlankUnkTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Unk[Subscript[gtrait,sp]],{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


BlankVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->aux,{aux,auxs}]
]];


BlankUnkVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Unk[Subscript[gcomp,sp]],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}]
]];


FixAttributes::usage="Internal usage only ;)";
FixVariables::usage="Internal usage only ;)";


FixAttributes[attributes_]:=attributes/.(var_->arr_?ArrayQ):>Sequence@@ArrayToRuleList[var,arr]/.{Subscript[\[ScriptCapitalN], gu_]->Subscript[\[FormalCapitalN], gu],\[ScriptCapitalN][gu_]->\[FormalCapitalN][gu]};


FixVariables[variables_]:=variables/.{Subscript[\[ScriptCapitalN], gu_]->Subscript[\[FormalCapitalN], gu],\[ScriptCapitalN][gu_]->\[FormalCapitalN][gu]};


ExpRule::usage="Internal: make rule list var[t]\[Rule]E^log[var][t] for all logged vars.";


(*ExpRule[vars_List,logged_]:=DeleteCases[Table[If[logged===True&&comptype[var]==="Extensive",var[t]\[Rule]E^log[var][t]],{var,vars}],Null];*)
(*ExpRule[vars_List,logged_]:=DeleteNulls@Flatten@Table[If[logged===True&&comptype[var]==="Extensive",{var[t]\[Rule]E^log[var][t],(var\[Rule]Unk[var][t])\[Rule](var\[Rule]E^log[Unk[var]][t])}],{var,vars}];*)
ExpRule[vars_List,logged_]:=DeleteNulls@Flatten@Table[If[logged===True&&comptype[var]==="Extensive",{log[var]->log[var],var->E^log[var],(var->Unk[var])->(var->E^log[Unk[var]])}],{var,vars}];


AddUnkts::usage="Internal usage only ;)";
AddVariablets::usage="Internal usage only ;)";
AddTraitts::usage="Internal usage only ;)";
AddVarCovts::usage="Internal usage only ;)";
FixVarCovts::usage="Internal usage only ;)";
RemoveVariablets::usage="Internal usage only ;)";
RemoveTraitts::usage="Internal usage only ;)";
RemoveVarCovts::usage="Internal usage only ;)";


AddUnkts:=(var_->Unk[stuff___])->(var->Unk[stuff][t]);


AddVariablets:=Which[
	modeltype=="ContinuousTime",
	DeleteDuplicates[Flatten[Join[
		Table[Table[{
			Subscript[gcomp,\[FormalS]_]'->Subscript[gcomp,\[FormalS]]'[t],Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]][t],
			log[Subscript[gcomp,\[FormalS]_]]'->log[Subscript[gcomp,\[FormalS]]]'[t],log[Subscript[gcomp,\[FormalS]_]]->log[Subscript[gcomp,\[FormalS]]][t],
			Unk[Subscript[gcomp, \[FormalS]_]]'->Unk[Subscript[gcomp, \[FormalS]]]'[t],Unk[Subscript[gcomp, \[FormalS]_]]->Unk[Subscript[gcomp, \[FormalS]]][t]}
		,{gcomp,gcomps[gu]}],{gu,guilds}],
		Table[Table[{
			pcomp'->pcomp'[t],pcomp->pcomp[t],
			log[pcomp]'->log[pcomp]'[t],log[pcomp]->log[pcomp][t],
			Unk[pcomp]'->Unk[pcomp]'[t],Unk[pcomp]->Unk[pcomp][t]}
		,{pcomp,pcomps[pop]}],{pop,pops}],
		Table[{
			aux'->aux'[t],aux->aux[t],
			Unk[aux]'->Unk[aux]'[t],Unk[aux]->Unk[aux][t]}
		,{aux,auxs}]
	]]],
	modeltype=="DiscreteTime",
	DeleteDuplicates[Flatten[Join[
		Table[Table[{
			Subscript[gcomp,\[FormalS]_]'->Subscript[gcomp,\[FormalS]][t+1],Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]][t],
			Unk[Subscript[gcomp, \[FormalS]_]]'->Unk[Subscript[gcomp, \[FormalS]]][t+1],Unk[Subscript[gcomp, \[FormalS]_]]->Unk[Subscript[gcomp, \[FormalS]]][t]}
		,{gcomp,gcomps[gu]}],{gu,guilds}],
		Table[Table[{
			pcomp'->pcomp[t+1],pcomp->pcomp[t],
			log[pcomp]'->log[pcomp][t+1],log[pcomp]->log[pcomp][t],
			Unk[pcomp]'->Unk[pcomp][t+1],Unk[pcomp]->Unk[pcomp][t]}
		,{pcomp,pcomps[pop]}],{pop,pops}],
		Table[{
			aux'->aux[t+1],aux->aux[t],
			Unk[aux]'->Unk[aux][t+1],Unk[aux]->Unk[aux][t]}
		,{aux,auxs}]
	]]]
];


AddTraitts:=Which[
	modeltype=="ContinuousTime",
	DeleteDuplicates[Flatten[
		Table[Table[{
			Unk[Subscript[gtrait, \[FormalS]_]]'->Unk[Subscript[gtrait, \[FormalS]]]'[t],Unk[Subscript[gtrait, \[FormalS]_]]->Unk[Subscript[gtrait, \[FormalS]]][t],
			Subscript[gtrait, \[FormalS]_]'->Subscript[gtrait, \[FormalS]]'[t],Subscript[gtrait, \[FormalS]_]->Subscript[gtrait, \[FormalS]][t],
			Table[{Subscript[gtrait[gcomp], \[FormalS]_]'->Subscript[gtrait[gcomp], \[FormalS]]'[t],Subscript[gtrait[gcomp], \[FormalS]_]->Subscript[gtrait[gcomp], \[FormalS]][t]},{gcomp,gcomps[gu]}]}
	,{gtrait,gtraits[gu]}],{gu,guilds}]]],
	modeltype=="DiscreteTime",
	DeleteDuplicates[Flatten[
	Table[Table[{
		Unk[Subscript[gtrait, \[FormalS]_]]'->Unk[Subscript[gtrait, \[FormalS]]][t+1],Unk[Subscript[gtrait, \[FormalS]_]]->Unk[Subscript[gtrait, \[FormalS]]][t],
		Subscript[gtrait, \[FormalS]_]'->Subscript[gtrait, \[FormalS]][t+1],Subscript[gtrait, \[FormalS]_]->Subscript[gtrait, \[FormalS]][t],
		Table[{Subscript[gtrait[gcomp], \[FormalS]_]'->Subscript[gtrait[gcomp], \[FormalS]][t+1],Subscript[gtrait[gcomp], \[FormalS]_]->Subscript[gtrait[gcomp], \[FormalS]][t]},{gcomp,gcomps[gu]}]}
	,{gtrait,gtraits[gu]}],{gu,guilds}]]]
];


AddVarCovts:=Flatten[
	Table[Table[{
		Table[{
			{Subscript[Var[gtrait][gcomp],\[FormalS]_]'->Subscript[Var[gtrait][gcomp],\[FormalS]]'[t],Subscript[Var[gtrait][gcomp],\[FormalS]_]->Subscript[Var[gtrait][gcomp],\[FormalS]][t]},
			Table[
				{Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]'->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]]'[t],
				Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]][t]}
			,{gtrait\[Prime],gtraits[gu]}]
			}
		,{gcomp,gcomps[gu]}],
		{Subscript[Var[gtrait],\[FormalS]_]'->Subscript[Var[gtrait],\[FormalS]]'[t],Subscript[Var[gtrait],\[FormalS]_]->Subscript[Var[gtrait],\[FormalS]][t]},
		Table[
			{Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]'->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]]'[t],
			Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]][t]}
		,{gtrait\[Prime],gtraits[gu]}]
		}
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]


FixVarCovts:={Var[Subscript[\[FormalT]_,\[FormalS]_][t]]->Var[Subscript[\[FormalT],\[FormalS]]][t],Cov[Subscript[\[FormalT]_,\[FormalS]_][t],Subscript[\[FormalCapitalT]_,\[FormalS]_][t]]->Cov[Subscript[\[FormalT],\[FormalS]],Subscript[\[FormalCapitalT],\[FormalS]]][t]};


RemoveVariablets:=DeleteDuplicates[Flatten[Join[
	Table[Table[
		Subscript[gcomp,\[FormalS]_][t]->Subscript[gcomp,\[FormalS]]
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp[t]->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux[t]->aux,{aux,auxs}]
]]];


RemoveTraitts:=Flatten[Table[Table[{
	Subscript[gtrait,\[FormalS]_][t]->Subscript[gtrait,\[FormalS]],
	Table[Subscript[gtrait[gcomp],\[FormalS]_][t]->Subscript[gtrait[gcomp],\[FormalS]],{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{gu,guilds}]];


(* ::Code::Initialization:: *)
RemoveVarCovts:=Flatten[Table[Table[{
	Subscript[Var[gtrait],\[FormalS]_][t]->Subscript[Var[gtrait],\[FormalS]],
	Table[Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}],
	Table[{
		Subscript[Var[gtrait][gcomp],\[FormalS]_][t]->Subscript[Var[gtrait][gcomp],\[FormalS]],
		Table[Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}]}
	,{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{gu,guilds}]];


DefaultICs::usage="Internal usage only ;)";


DefaultICs:=Quiet[Flatten[{
	Table[Table[Table[Subscript[gcomp,sp]->Min[(Min[range[gcomp]]+Max[range[gcomp]])/2,Min[range[gcomp]]+1],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->Min[(Min[range[pcomp]]+Max[range[pcomp]])/2,Min[range[pcomp]]+1],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Min[(Min[range[aux]]+Max[range[aux]])/2,Min[range[aux]]+1],{aux,auxs}]
}]/.Indeterminate->0,{Infinity::indet}];


SetAttributes[DoubleRightArrow,HoldAllComplete];


InterpretTransitions::usage="";


InterpretTransitions[DoubleRightArrow[Times[c1_,var1_],Times[c2_,var2_]]]:={c1,var1,c2,var2};
InterpretTransitions[DoubleRightArrow[var1_,Times[c2_,var2_]]]:={1,var1,c2,var2};
InterpretTransitions[DoubleRightArrow[Times[c1_,var1_],var2_]]:={c1,var1,1,var2};
InterpretTransitions[DoubleRightArrow[var1_,var2_]]:={1,var1,1,var2};

InterpretTransitions[Rule[var_,Plus[c_,var_]]]:={0,Global`\[EmptySet],c,var};


DoubleRightArrowsToTrans:={
DoubleRightArrow[Times[c1_,var1_],Times[c2_,var2_]]->{var1->var1-c1,var2->var2+c2},
DoubleRightArrow[var1_,Times[c2_,var2_]]->{var1->var1-1,var2->var2+c2},
DoubleRightArrow[Times[c1_,var1_],var2_]->{var1->var1-c1,var2->var2+1},
DoubleRightArrow[var1_,var2_]->{var1->var1-1,var2->var2+1}
}


AddProceduralToSum::usage="Add Method->\"Procedural\" to Sum[\!\(\*
StyleBox[\"stuff\", \"TI\"]\), {\!\(\*
StyleBox[\"ind\", \"TI\"]\), \[ScriptCapitalN][\!\(\*
StyleBox[\"gu\", \"TI\"]\)]}]'s.";


AddProceduralToSum[expr_]:=
Inactivate[expr,Sum]/.Inactive[Sum][stuff___,{ind_,\[ScriptCapitalN][gu_]},sumopts___]:>Sum[stuff,{ind,\[ScriptCapitalN][gu]},Method->"Procedural",sumopts]


ZeroGs::usage = "ZeroGs is a replacement rule to remove G-matrix entries (Var and Cov).";


ZeroGs:={Subscript[Var[_], _]->0,Subscript[Var[_][_], _]->0,Subscript[Cov[_,_], _]->0,Subscript[Cov[_][_,_], _]->0};


EcoEvoDocs::usage="EcoEvoDocs opens the main EcoEvo guide.";


EcoEvoDocs:=(NotebookOpen["paclet:EcoEvo/guide/EcoEvo"];Null);


ExtractInteractions::usage=
"ExtractInteractions[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts interactions from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractTraits::usage=
"ExtractTraits[x] extracts traits from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).
ExtractTraits[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] extracts only traits from guild or species \!\(\*
StyleBox[\"target\", \"TI\"]\).";

ExtractAttributes::usage=
"ExtractAttributes[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts traits and interactions from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractGuilds::usage=
"ExtractGuilds[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts guilds from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).
ExtractGuilds[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] extracts only guilds from guild or species \!\(\*
StyleBox[\"target\", \"TI\"]\).";

ExtractPops::usage=
"ExtractPops[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractAuxs::usage=
"ExtractAuxs[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts auxs from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractVariables::usage=
"ExtractVariables[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops, guilds, and auxs from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractSpecies::usage=
"ExtractSpecies[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops and guilds from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractVarCovs::usage=
"ExtractVarCovs[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts trait variances and covariances from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";


ExtractInteractions[in_?RuleListQ]:=Module[{pattern},
	pattern=Join[
		interactions,
		Table[Subscript[interaction, _,_],{interaction,interactions}],
		Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
		Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}]
	];
	Return[FilterRules[in,pattern]]
];


ExtractTraits[in_?RuleListQ,target_:All]:=Module[{res,pattern,gu,sp},
	Which[
		target===All,
		pattern=Join[
			Flatten[Table[Table[Subscript[gtrait, _],{gtrait,gtraits[gu]}],{gu,guilds}]],
			Flatten[Table[Table[Table[Subscript[gtrait[gcomp], _],{gcomp,gcomps[gu]}],{gtrait,gtraits[gu]}],{gu,guilds}]],
			Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
			Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}]
		],
		Head[target]===Subscript,
		gu=target[[1]];sp=target[[2]];
		pattern=Table[Subscript[gtrait, sp],{gtrait,gtraits[gu]}],
		Else,
		gu=target;
		pattern=Join[
			Table[Subscript[gtrait, _],{gtrait,gtraits[gu]}],
			Flatten[Table[Table[Subscript[gtrait[gcomp], _],{gcomp,gcomps[gu]}],{gtrait,gtraits[gu]}]],
			{Subscript[\[ScriptCapitalN], gu],Subscript[\[FormalCapitalN], gu]}]
	];
	(*Print["pattern=",pattern];*)
	res=FilterRules[in,pattern];
	Return[res]
];


ExtractAttributes[in_?RuleListQ]:=Union[ExtractTraits[in],ExtractInteractions[in]];


ExtractGuilds[in_?RuleListQ,target_:All]:=Module[{res,pattern,gu,sp},
	Which[
		target===All,
		pattern=Join[
			Flatten[Table[Table[Subscript[gcomp, _],{gcomp,gcomps[gu]}],{gu,guilds}]],
			Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
			Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}],
			Table[Subscript[gu, _],{gu,guilds}]
		],
		Head[target]===Subscript,
		gu=target[[1]];sp=target[[2]];
		pattern=Join[Table[Subscript[gcomp, sp],{gcomp,gcomps[gu]}],{Subscript[gu, sp]}],
		Else,
		gu=target;
		pattern=Join[Table[Subscript[gcomp, _],{gcomp,gcomps[gu]}],{Subscript[gu, _],Subscript[\[ScriptCapitalN], gu]}]
	];
	(*Print["pattern=",pattern];*)
	res=FilterRules[in,pattern];
	Return[res]
];


ExtractAuxs[in_?RuleListQ]:=FilterRules[in,auxs];


ExtractPops[in_?RuleListQ]:=FilterRules[in,Flatten[Table[pcomps[pop],{pop,pops}]]];


ExtractVariables[in_?RuleListQ]:=Union[ExtractAuxs[in],ExtractPops[in],ExtractGuilds[in]];


ExtractSpecies[in_?RuleListQ]:=Union[ExtractPops[in],ExtractGuilds[in]];


ExtractVarCovs[in_?RuleListQ,target_:All]:=Module[{res,pattern,gu,sp},
	Which[
		target===All,
		pattern=Join[
			Flatten[Table[Table[
				{Var[gtrait],Subscript[Var[gtrait], _],
				Table[{Var[gtrait][gcomp],Subscript[Var[gtrait][gcomp], _]},{gcomp,gcomps[gu]}],
				Table[
					{Cov[gtrait,gtrait\[Prime]],Subscript[Cov[gtrait,gtrait\[Prime]], _],
					Table[{Cov[gtrait,gtrait\[Prime]][gcomp],Subscript[Cov[gtrait,gtrait\[Prime]][gcomp], _]},{gcomp,gcomps[gu]}]}
				,{gtrait\[Prime],gtraits[gu]}]}
				,{gtrait,gtraits[gu]}],{gu,guilds}]],
			Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
			Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}]
		]
	];
	(*Print["pattern=",pattern];*)
	res=FilterRules[in,pattern];
	Return[res]
];


(* make Listable *)
ExtractTraits[in_?RuleListListQ,target___]:=ExtractTraits[#,target]&/@in;
ExtractTraits[in_?RuleListQ,target_List]:=Flatten[Union[ExtractTraits[in,#]&/@target]];
ExtractInteractions[in_?RuleListListQ]:=ExtractInteractions/@in;
ExtractAttributes[in_?RuleListListQ]:=ExtractAttributes/@in;
ExtractGuilds[in_?RuleListListQ,target___]:=ExtractGuilds[#,target]&/@in;
ExtractGuilds[in_?RuleListQ,target_List]:=Flatten[Union[ExtractGuilds[in,#]&/@target]];
ExtractAuxs[in_?RuleListListQ]:=ExtractAuxs/@in;
ExtractPops[in_?RuleListListQ]:=ExtractPops/@in;
ExtractVariables[in_?RuleListListQ]:=ExtractVariables/@in;
ExtractSpecies[in_?RuleListListQ]:=ExtractSpecies/@in;


ExpandTraits::usage="Expand traits across components.";


(*ExpandTraits[rulelist_]:=If[transitionbased,
	rulelist/.Flatten[Table[Table[{
		(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Join[{Subscript[trait, i]->val},Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}]],
		(trait\[Rule]val_)\[Rule]Sequence@@Join[{trait->val},Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]]}
	,{trait,gtraits[gu]}],{gu,guilds}]],
	rulelist];*)


(*ExpandTraits[rulelist_]:=rulelist/.DeleteNulls@Flatten@Table[
	If[ngcomps[gu]>1,
		Table[{
			(*(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Join[{Subscript[trait, i]->val},Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}]],
			(trait\[Rule]val_)\[Rule]Sequence@@Join[{trait->val},Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]]}*)
			(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}],
			(trait\[Rule]val_)\[Rule]Sequence@@Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]}
		,{trait,gtraits[gu]}]
	]
,{gu,guilds}]*)


ExpandTraits[rulelist_]:=Module[{},
	If[moments==True,
		rulelist/.DeleteNulls@Flatten@Table[
			If[ngcomps[gu]>1,
				Table[{
				(*(Subscript[trait, i_]\[Rule]val_)\[Rule]Sequence@@Join[{Subscript[trait, i]->val},Table[Subscript[trait[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}]],
				(trait\[Rule]val_)\[Rule]Sequence@@Join[{trait->val},Table[trait[gcomp]\[Rule]val,{gcomp,gcomps[gu]}]]}*)
					(Subscript[trait, i_]->val_)->Sequence@@Table[Subscript[trait[gcomp], i]->val,{gcomp,gcomps[gu]}],
					(trait->val_)->Sequence@@Table[trait[gcomp]->val,{gcomp,gcomps[gu]}]}
				,{trait,gtraits[gu]}]
			]
		,{gu,guilds}]
	,
		rulelist
	]
];


ExpandGs::usage="Expand variance/covariances across species and components.";


(* \[ScriptCapitalN]s not given *)
ExpandGs[rulelist_]:=rulelist/.Flatten@Table[Table[
	If[ngcomps[gu]>1,
		(Subscript[entry, i_]->val_)->Sequence@@Table[Subscript[entry[gcomp], i]->val,{gcomp,gcomps[gu]}],
		{}]
	,{entry,Flatten@MakeGMatrix[gu]}]
,{gu,guilds}];


(*(* \[ScriptCapitalN]s given *)
ExpandGs[in_,nsps_]:=Module[{trsub,tmp},
tmp=Flatten[in/.(G[gu_]->vals_):>(Thread[Flatten[MakeGMatrix[gu]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
tmp=Flatten[tmp/.(Subscript[G[gu_], sp_]->vals_):>(Thread[Flatten[MakeGMatrix[Subscript[gu, sp]]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
(*tmp=tmp/.Flatten@Table[Table[
	If[ngcomps[gu]>1,
		(Subscript[entry, i_]\[Rule]val_)\[Rule]Sequence@@Table[Subscript[entry[gcomp], i]\[Rule]val,{gcomp,gcomps[gu]}],
		{}]
	,{entry,Flatten@MakeGMatrix[gu]}]
,{gu,guilds}];
Print["tmp=",tmp];*)
Flatten@Table[
	Table[
		Table[
			(*Print[entry," ",Subscript[entry, i]," ",Replace[Subscript[entry, i],tmp]];*)
			Which[
				(*Print["species-defined"];*)
				Replace[Subscript[entry, i],tmp]=!=Subscript[entry, i],
				Subscript[entry, i]->(Subscript[entry, i]/.tmp),
				(*Print["guild-defined"];*)
				Replace[entry,tmp]=!=entry,
				trsub=Table[gtrait->Subscript[gtrait, i],{gtrait,gtraits[gu]}];
				(*Print["trsub=",trsub];*)
				Subscript[entry, i]->(entry/.tmp/.trsub),
				Else,(*Print["undefined"];*){}
			]
		,{i,\[FormalCapitalN][gu]/.nsps}]
	,{entry,Flatten@MakeGMatrix[gu]}]
,{gu,guilds}]
]*)


(* \[ScriptCapitalN]s given *)
ExpandGs[in_,nsps_]:=Module[{trsub,tmp},
tmp=Flatten[in/.(G[gu_]->vals_):>(Thread[Flatten[MakeGMatrix[gu]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
tmp=Flatten[tmp/.(Subscript[G[gu_], sp_]->vals_):>(Thread[Flatten[MakeGMatrix[Subscript[gu, sp]]]->Flatten[vals]])];
(*Print["tmp=",tmp];*)
If[moments,
	tmp=tmp/.Flatten@Table[Table[
		If[ngcomps[gu]>1,{
			(Subscript[entry, i_]->val_)->Sequence@@Table[Subscript[entry[gcomp], i]->val,{gcomp,gcomps[gu]}],
			(entry->val_)->Sequence@@Table[entry[gcomp]->val,{gcomp,gcomps[gu]}]
			},{}]
		,{entry,Flatten@MakeGMatrix[gu]}]
	,{gu,guilds}]
];
(*Print["tmp=",tmp];*)
If[moments,
	Flatten@Table[
		Table[
			Table[
				Table[
					(*Print[entry," ",Subscript[entry, i]," ",Replace[Subscript[entry, i],tmp]];*)
					Which[
						(*Print["species-defined"];*)
						Replace[Subscript[entry, i],tmp]=!=Subscript[entry, i],
						Subscript[entry, i]->(Subscript[entry, i]/.tmp),
						(*Print["guild-defined"];*)
						Replace[entry,tmp]=!=entry,
						trsub=Table[gtrait->Subscript[gtrait, i],{gtrait,gtraits[gu]}];
						(*Print["trsub=",trsub];*)
						Subscript[entry, i]->(entry/.tmp/.trsub),
						Else,(*Print["undefined"];*){}
					]
				,{i,\[FormalCapitalN][gu]/.nsps}]
			,{entry,Flatten@MakeGMatrix[gcomp]}]
		,{gcomp,gcomps[gu]}]
	,{gu,guilds}]
,
	Flatten@Table[
		Table[
			Table[
				(*Print[entry," ",Subscript[entry, i]," ",Replace[Subscript[entry, i],tmp]];*)
				Which[
					(*Print["species-defined"];*)
					Replace[Subscript[entry, i],tmp]=!=Subscript[entry, i],
					Subscript[entry, i]->(Subscript[entry, i]/.tmp),
					(*Print["guild-defined"];*)
					Replace[entry,tmp]=!=entry,
					trsub=Table[gtrait->Subscript[gtrait, i],{gtrait,gtraits[gu]}];
					(*Print["trsub=",trsub];*)
					Subscript[entry, i]->(entry/.tmp/.trsub),
					Else,(*Print["undefined"];*){}
				]
			,{i,\[FormalCapitalN][gu]/.nsps}]
		,{entry,Flatten@MakeGMatrix[gu]}]
	,{gu,guilds}]
]
]


TraitsQ::usage=
"TraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits.";

InteractionsQ::usage=
"InteractionsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of interactions.";

AttributesQ::usage=
"AttributesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits and/or interactions.";

VariablesQ::usage=
"VariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of variables.";

ListOfVariablesQ::usage=
"ListOfVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of rulelists of variables.";

AttributesAndVariablesQ::usage=
"AttributesAndVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of attributes (traits or interactions) and variables (auxs, pops, guilds).";

AttributesVariablesAndGsQ::usage=
"AttributesAndVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of attributes (traits or interactions), variables (auxs, pops, guilds), and trait variance/covariances.";

AttributesAndGsQ::usage=
"AttributesAndGsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of attributes (traits or interactions), and trait variance/covariances.";


TraitsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="gtrait"||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


InteractionsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="interaction"||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


AttributesQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="gtrait"||First@LookUp[#[[1]]]==="interaction"||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


VariablesQ[list_]:=list==="FindEcoAttractor"||VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(MemberQ[{"pcomp","gcomp","aux"},First@LookUp[#[[1]]]]||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


AttributesAndVariablesQ[list_]:=
If[RuleListQ[list]&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!=list&&
	FixVariables[ExtractVariables[list]]=!=list,
	True,False,False]


ListOfVariablesQ[x_]:=If[x==={},False,VectorQ[x,VariablesQ[#]&]];


AttributesVariablesAndGsQ[list_]:=
If[RuleListQ[list]&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!=list&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!={}&&
	FixVariables[ExtractVariables[list]]=!=list&&
	FixVariables[ExtractVariables[list]]=!={}&&
	ExtractVarCovs[list]=!=list&&
	ExtractVarCovs[list]=!={},
	True,False,False]


AttributesAndGsQ[list_]:=
If[RuleListQ[list]&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!=list&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!={}&&
	ExtractVariables[list]==={}&&
	ExtractVarCovs[list]=!=list&&
	ExtractVarCovs[list]=!={},
	True,False,False]


GsQ::usage=
"GsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of G matrices or V variances.";


GsQ[list_]:=Quiet[
	VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(
		MemberQ[{G,V},#[[1,0]]]||MemberQ[{G,V},#[[1,1,0]]]||
		MemberQ[{Var,Cov},#[[1,1,0,0]]]||MemberQ[{Var,Cov},#[[1,1,0]]]||MemberQ[{Var,Cov},#[[1,0]]])&]
	,{Part::partd}
];


InvaderQ::usage=
"InvaderQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a possible invader.";

NotInvaderTraitsQ::usage=
"NotInvaderTraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits with no invaders.";


InvaderQ[x_]:=If[
	x===Automatic ||
	MemberQ[Join[Flatten[Table[pcomps[pop],{pop,pops}]],pops],x]||
	(LookUp[x][[1]]==="gcomp"||LookUp[x][[1]]==="guild")||
	(x[[0]]===Rule&&Length[LookUp[x[[1]]]]>=4&&LookUp[x[[1]]][[{1,4}]]==={"gtrait",0})||
	VectorQ[x,#[[0]]===Rule&&Length[LookUp[#[[1]]]]>=4&&LookUp[#[[1]]][[{1,4}]]==={"gtrait",0}&]||
	(x[[0]]===Rule&&Length[LookUp[x[[1]]]]>=5&&LookUp[x[[1]]][[{1,5}]]==={"interaction",0})||
	VectorQ[x,#[[0]]===Rule&&Length[LookUp[#[[1]]]]>=5&&LookUp[#[[1]]][[{1,5}]]==={"interaction",0}&],
	True,False];


NotInvaderTraitsQ[list_]:=VectorQ[list,
	(#[[0]]===Rule||#[[0]]===RuleDelayed)&&
	((LookUp[#[[1]]][[1]]==="gtrait"&&LookUp[#[[1]]][[4]]=!=0)||
	(LookUp[#[[1]]][[1]]==="interaction"&&(Length[LookUp[#[[1]]]]==4||LookUp[#[[1]]][[5]]=!=0))||
	#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])
&];


ExtractInvaders::usage=
"ExtractInvaders[\!\(\*
StyleBox[\"list\", \"TI\"]\)] extracts invaders (with subscript 0) from \!\(\*
StyleBox[\"list\", \"TI\"]\).";

DeleteInvaders::usage=
"DeleteInvaders[\!\(\*
StyleBox[\"list\", \"TI\"]\)] removes invaders (with subscript 0) from \!\(\*
StyleBox[\"list\", \"TI\"]\).";


ExtractInvaders[list_?RuleListQ]:=FilterRules[list,Subscript[_, 0]->_];


DeleteInvaders[list_?RuleListQ]:=DeleteCases[list,Subscript[_,0,___]->_];


ValidQ::usage="ValidQ[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"sol\", \"TI\"]\) is within the allowed range of variables.";


ValidQ[eq_?RuleListQ,opts___?OptionQ]:=Module[{
(* options *)
verbose,simplifyresult,simplifyopts,
(* other variables *)
res},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

Block[{verbosity},

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoStableQ]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[ValidQ]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[ValidQ]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

simplifyresult=Evaluate[SimplifyResult/.Flatten[{opts,Options[ValidQ]}]];
simplifyopts=Evaluate[SimplifyOpts/.Flatten[{opts,Options[ValidQ]}]];

(*Print["simplifyresult=",simplifyresult];
Print["simplifyopts=",simplifyopts];*)

res=CompoundAnd[Flatten@Table[
	Which[
		Head[el[[2]]]===TemporalData,
		Map[IntervalMemberQ[range[el[[1]]],#]&,Normal[el[[2]]][[All,2]]],
		Else,
		If[Im[el[[2]]]==0&&Min[range[el[[1]]]]<=el[[2]]<=Max[range[el[[1]]]],True,False]
	]
,{el,eq}]];

VPrint[3,"res",res];

Which[
	simplifyresult===True,
	CheckAssumptions;
	Return[Simplify[res,Evaluate[Sequence@@simplifyopts]]],
	simplifyresult===Full,
	CheckAssumptions;
	Return[FullSimplify[res,Evaluate[Sequence@@simplifyopts]]],
	simplifyresult===Real,
	CheckAssumptions;
	Return[RealSimplify[res,Evaluate[Sequence@@simplifyopts]]],
	Else,
	Return[res]
];

]];


(* make listable across variables *)
ValidQ[eqs_?ListOfVariablesQ,opts___?OptionQ]:=(ValidQ[#,opts]&/@eqs);


Options[ValidQ]={Verbose->False,Verbosity->0,
SimplifyResult->Real,SimplifyOpts->{Assumptions:>DeleteCases[$Assumptions,False]}};


SelectValid::usage=
"SelectValid[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects valid solutions in list of rule lists \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


SelectValid[sol:(_?RuleListListQ):{},opts___?OptionQ]:=Module[{validqopts},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

validqopts=FilterRules[Flatten[{opts,Options[SelectValid]}],Options[ValidQ]];

Return[Select[sol,ValidQ[#,Evaluate[Sequence@@validqopts]]&]]

];


Options[SelectValid]={};


SplitSpecies::usage=
"SplitSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] splits \!\(\*
StyleBox[\"target\", \"TI\"]\) in two.
SplitSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"dtraits\", \"TI\"]\)] uses distance \!\(\*
StyleBox[\"dtraits\", \"TI\"]\).";


SplitSpecies[sol_(*?AttributesAndVariablesQ*),target_,dtraitsin_:Automatic,opts___?OptionQ]:=Module[{
func=FuncStyle["SplitSpecies"],
(* options *)
(* other variables *)
gu,sp,dtraits,ecomps,tmp(*,gs*)
},

Block[{\[ScriptCapitalN],verbosity,func="SplitSpecies"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

If[Evaluate[Verbose/.Flatten[{opts,Options[SplitSpecies]}]]===True,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[SplitSpecies]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[SplitSpecies]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* figure out target sp *)
{gu,sp}=LookUp[target][[{2,-1}]];
VPrint[3,"{gu,sp}=",{gu,sp}];

Which[
	dtraitsin===Automatic,
	dtraits=Join[
		Flatten[Table[trait[gcomp]->0,{trait,gtraits[gu]},{gcomp,gcomps[gu]}]],
		Table[trait->0,{trait,gtraits[gu]}]
	],
	NumericQ[dtraitsin],
	dtraits=Join[
		Flatten[Table[trait[gcomp]->dtraitsin,{trait,gtraits[gu]},{gcomp,gcomps[gu]}]],
		Table[trait->dtraitsin,{trait,gtraits[gu]}]
	],
	Else,
	dtraits=ExpandTraits[dtraitsin]
];
VPrint[3,"dtraits=",dtraits];

(*gs=ExpandGs[ExtractVarCovs[sol]];*)
(*Print["gs=",gs];*)

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractAttributes[sol],ExtractVariables[sol]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* split target species' extensive components *)
ecomps=Select[gcomps[gu],comptype[#]=="Extensive"&];
tmp=sol/.Table[(Subscript[var, sp]->val_)->(Subscript[var, sp]->val/2),{var,ecomps}];
(*Print[tmp];*)

(* add new species' components *)
tmp=Join[tmp,Table[Subscript[var, \[ScriptCapitalN][gu]+1]->(Subscript[var, sp]/.tmp),{var,gcomps[gu]}]];
(*Print[tmp];*)

(* add new species' traits *)
tmp=Join[tmp,
	Table[If[NumericQ[Subscript[trait, sp]/.tmp],Subscript[trait, \[ScriptCapitalN][gu]+1]->((Subscript[trait, sp]/.tmp)+(trait/.dtraits))],{trait,gtraits[gu]}],
	Flatten[Table[If[NumericQ[Subscript[trait[gcomp], sp]/.tmp],Subscript[trait[gcomp], \[ScriptCapitalN][gu]+1]->((Subscript[trait[gcomp], sp]/.tmp)+(trait[gcomp]/.dtraits))],{trait,gtraits[gu]},{gcomp,gcomps[gu]}]]
];
tmp=DeleteNulls[tmp];
(*Print[tmp];*)

(* add new species' Gs *)
tmp=Join[tmp,
	Table[If[NumericQ[Subscript[Var[trait], sp]/.tmp],Subscript[Var[trait], \[ScriptCapitalN][gu]+1]->(Subscript[Var[trait], sp]/.tmp)],{trait,gtraits[gu]}],
	Flatten[Table[If[NumericQ[Subscript[Var[trait][gcomp], sp]/.tmp],Subscript[Var[trait][gcomp], \[ScriptCapitalN][gu]+1]->(Subscript[Var[trait][gcomp], sp]/.tmp)],{trait,gtraits[gu]},{gcomp,gcomps[gu]}]]
];
tmp=DeleteNulls[tmp];
(*Print[tmp];*)

(* change target species' traits *)
If[NumericQ[Subscript[gtraits[gu][[1]], sp]/.tmp],
	tmp=RuleListSubtract[tmp,Table[Subscript[trait, sp]->(trait/.dtraits),{trait,gtraits[gu]}]],
	tmp=RuleListSubtract[tmp,Flatten[Table[Subscript[trait[gcomp], sp]->(trait[gcomp]/.dtraits),{trait,gtraits[gu]},{gcomp,gcomps[gu]}]]]
];
(*Print[tmp];*)

Return[Sort[tmp]];
]];


Options[SplitSpecies]={Verbose->False,Verbosity->0};


SetModel::usage=
"SetModel[\!\(\*
StyleBox[\"model\", \"TI\"]\)] sets an EcoEvo \!\(\*
StyleBox[\"model\", \"TI\"]\) for analysis.";


SetModel[model_?RuleListQ,opts___?OptionQ]:=Module[{
(* options *)
colors,linestyles,plotmarkers,assumptions,parametersin,momentmethod,gaussianintegralopts,
(* other *)
parameterstmp,parintervals,stylecount,basestyle,indexcount,in,gradients,gradient,
sourcec,source,destc,dest,protectedfuncs,
(* funcs *)
FixEqn,FixGuildEqn,AddBars,RemoveBars},

Block[{verbosity,func="SetModel"},

(* set verbosity *)

If[Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]]===True,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

colors=Evaluate[Colors/.Flatten[{opts,Options[SetModel]}]];
linestyles=Evaluate[LineStyles/.Flatten[{opts,Options[SetModel]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[SetModel]}]];
momentmethod=Evaluate[MomentMethod/.Flatten[{opts,Options[SetModel]}]];
assumptions=Evaluate[Assumptions/.Flatten[{model,Options[SetModel]}]];
gaussianintegralopts=Evaluate[GaussianIntegralOpts/.Flatten[{opts,Options[SetModel]}]];


FixEqn[f_]:=Module[{agent,gifs},
f/.Sum[fs_,{i_,\[ScriptCapitalN][gu\[Prime]_]},sumopts___]:>(
If[ngcomps[gu\[Prime]]==1,
	agent=comps[gu\[Prime]][[1]],
	agent=Cases[fs,Subscript[_[_], i],All][[1,1,1]];
];
VPrint[3,"agent=",agent];
gifs=momentmethod[fs,{MakeTraitVector[Subscript[agent, i]],MakeTraitVector[Subscript[agent, i]]/.AddBars,MakeGMatrix[Subscript[agent, i]]},Evaluate[Sequence@@gaussianintegralopts]];
VPrint[3,"gifs=",gifs];
Sum[FullSimplify[gifs/.RemoveBars],{i,\[ScriptCapitalN][gu\[Prime]]},sumopts]
)];

FixGuildEqn[f_,traits_,G_]:=Module[{tmp,tmp2},
VPrint[3,"f=",f];
tmp=Distribute[gi[f/.UnfactorSums,{traits,traits/.AddBars,G}]];
VPrint[3,"tmp=",tmp];
tmp2=tmp/.gi[Sum[fs_,{i_,\[ScriptCapitalN][gu\[Prime]_]},sumopts___],giopts___]:>
Sum[gi[fs,{MakeTraitVector[Subscript[gu\[Prime], i]],MakeTraitVector[Subscript[gu\[Prime], i]]/.AddBars,MakeGMatrix[Subscript[gu\[Prime], i]]},giopts],{i,\[ScriptCapitalN][gu\[Prime]]},sumopts];
VPrint[3,"tmp2=",tmp2];
FullSimplify[tmp2/.gi->momentmethod/.RemoveBars]
];

AddBars:=Subscript[var_, sp_]->Subscript[mean[var], sp];
RemoveBars:=Subscript[mean[var_], sp_]->Subscript[var, sp];

protectedfuncs={"Color","LineStyle","PlotMarker"};
Unprotect[Evaluate[protectedfuncs]];

ClearParameters;UnsetModel;

modelloaded=True;

If[momentmethod===None||momentmethod==="None",moments=False,moments=True];

(* model name - default="UnnamedModel"*)
modelname=ModelName/.Append[model,ModelName->"UnnamedModel"];

(* model type - default="ContinuousTime" *)
modeltype=(ModelType/.Append[model,ModelType->"ContinuousTime"]);
If[!MemberQ[{"ContinuousTime","DiscreteTime"},modeltype],Message[SetModel::unktype]];

(* model whenevents - default={} *)
modelwhenevents:=WhenEvents/.Append[model,WhenEvents->{}];

(* period - default=0 (unforced) *)
modelperiod:=Period/.Append[model,Period->0];

(* transition-based? *)
transitions=Transitions/.model;
If[transitions=!=Transitions,transitionbased=True,transitionbased=False];


(* Transitions *) (* placeholder for later *)

If[transitionbased,
	VPrint[3,"Processing Transitions..."];
];


(* Parameters *)

VPrint[2,"Processing Parameters..."];
parametersin=Evaluate[Parameters/.Flatten[{model,Options[SetModel]}]];
(*Print["parametersin=",parametersin];*)
If[parametersin=!={},
	{parameters,parintervals}=Transpose[InequalityToInterval[parametersin]/.Element->List]
];
(*Print["parameters=",parameters];
Print["parintervals=",parintervals];*)

(* parameter assumptions *)
$Assumptions=Select[parametersin,MemberQ[{Greater,GreaterEqual,Less,LessEqual},Head[#]]&];
parnames=ToString/@parameters;
Do[range[parameters[[i]]]=parintervals[[i]],{i,Length[parameters]}];
VPrint[2,"paramaters=",parameters];

(* Guilds *)

VPrint[2,"Processing Guilds..."];

stylecount=0;

If[(Guilds/.model)===Guilds,
	guilds=Select[model,#[[1,0]]==Guild&][[All,1,1]],
	guilds=Guilds/.model
];
VPrint[3,"guilds=",guilds];
nguilds=Length[guilds];

Do[
	VPrint[3,"Guild[",gu,"]=",Guild[gu]/.model];
	type[gu]="guild";
	LookUp[gu]={"guild",gu};
	LookUp[Subscript[gu,sp_]]=LookUp[_[Subscript[gu,sp_]]]={"guild",gu,sp};
	If[!transitionbased,
		(*Print["old comps"];*)
		comps[gu]=gcomps[gu]=Select[Guild[gu]/.model,#[[1,0]]==Component&][[All,1,1]]
	,
		(*Print["new comps"];*)
		comps[gu]=gcomps[gu]=Components/.(Guild[gu]/.model)
	];
	If[Length[gcomps[gu]]==0,comps[gu]=gcomps[gu]={Guild[gu][[1]]}];
	VPrint[3,"comps[",gu,"]=",comps[gu]];
	comps[Subscript[gu_,sp_]]:=Replace[comps[gu],var_->Subscript[var,sp],1];
	ncomps[gu]=ngcomps[gu]=Length[gcomps[gu]];
	
	If[(Traits/.(Guild[gu]/.model))===Traits,
		(*Print["old traits"];*)
		gtraits[gu]=Select[Guild[gu]/.model,#[[1,0]]==Trait&][[All,1,1]],
		(*Print["new traits"];*)
		gtraits[gu]=Cases[(Traits/.(Guild[gu]/.model)),_Symbol,\[Infinity]];
		(*Print["gtraits[gu]=",gtraits[gu]];*)
		ranges=(InequalityToInterval/@(Traits/.(Guild[gu]/.model)))[[All,2]];
		(*Print["ranges=",ranges];*)
		Do[
			range[gtraits[gu][[i]]]=ranges[[i]];
			range[Subscript[gtraits[gu][[i]],_]]=ranges[[i]];
		,{i,Length[gtraits[gu]]}];
	];
	ngtraits[gu]=Length[gtraits[gu]];
	VPrint[3,"{gcomps[",gu,"], gtraits[",gu,"]}=",{gcomps[gu],gtraits[gu]}];

	If[nguilds==1(*&&ngcomps[guilds\[LeftDoubleBracket]1\[RightDoubleBracket]]\[Equal]1&&ngtraits[guilds\[LeftDoubleBracket]1\[RightDoubleBracket]]\[Equal]1*),
		gradients={"Rainbow","DarkerRainbow","LighterRainbow"},
		gradients={"EEGreens","EEReds","EEBlues"}
	];
	indexcount=0;
	Do[
		VPrint[3,"gcomp=",gcomp];
		indexcount++;
		stylecount++;
		basestyle[gu]=stylecount;
		in=If[RuleListQ[Component[gcomp]/.(Guild[gu]/.model)],Component[gcomp]/.(Guild[gu]/.model),Guild[gu]/.model];
		type[Subscript[gcomp,_]]="gcomp";
		index[Subscript[gcomp,_]]=index[gcomp]=indexcount;
		comptype[Subscript[gcomp,_]]=comptype[gcomp]=Type/.Append[in,Type->"Extensive"];
		range[Subscript[gcomp,_]]=range[gcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		gradient=Color/.Append[in,Color->ModPart[gradients,stylecount]];
		Color[Subscript[gcomp,_]]=Color[_[Subscript[gcomp,_]]]=With[{cd=ColorData[gradient]},cd[#]&];
		Color[gcomp]=Color[_[gcomp]]=With[{cd=ColorData[gradient]},cd[0.5]];
		LineStyle[Subscript[gcomp,_]]=LineStyle[gcomp]=LineStyle[_[gcomp]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		PlotMarker[Subscript[gcomp,_]]=PlotMarker[gcomp]=PlotMarker[_[gcomp]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[gcomp]=LookUp[_[gcomp]]=LookUp[gcomp[_]]={"gcomp",gu,gcomp};
		LookUp[Subscript[gcomp,sp_]]=LookUp[_[Subscript[gcomp,sp_]]]=LookUp[Subscript[gcomp,sp_][_]]={"gcomp",gu,gcomp,sp};
	,{gcomp,gcomps[gu]}];
	
	Color[gu]=Color[_[gu]]=With[{cd=ColorData[gradient]},cd[0.5]];

	indexcount=0;
	Do[
		VPrint[3,"gtrait=",gtrait];
		indexcount++;
		stylecount=basestyle[gu];
		If[(Traits/.(Guild[gu]/.model))===Traits,
			in=Trait[gtrait]/.(Guild[gu]/.model),
			in={}
		];
		type[Subscript[gtrait,_]]="gtrait";
		index[Subscript[gtrait,_]]=index[gtrait]=indexcount;
		If[(Traits/.(Guild[gu]/.model))===Traits,
			range[Subscript[gtrait,_]]=range[gtrait]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]]
		];
		gradient=Color/.Join[in,Guild[gu]/.model,{Color->ModPart[gradients,stylecount]}];
		Color[Subscript[gtrait,_]]=Color[_[Subscript[gtrait,_]]]=With[{cd=ColorData[gradient]},cd[#]&];
		(*Color[Subscript[gtrait[gcomp_],sp_]]=Color[Subscript[_[gtrait][gcomp_],sp_]]=Color[Subscript[gcomp, sp]];*)
		Color[gtrait]=Color[_[gtrait]]=With[{cd=ColorData[gradient]},cd[0.5]];
		LineStyle[Subscript[gtrait,_]]=LineStyle[gtrait]=LineStyle[_[gtrait]]=LineStyle/.Join[in,Guild[gu]/.model,{LineStyle->ModPart[linestyles,stylecount]}];
		PlotMarker[Subscript[gtrait,_]]=PlotMarker[gtrait]=PlotMarker/.Join[in,Guild[gu]/.model,{PlotMarker->ModPart[plotmarkers,stylecount]}];
		LookUp[gtrait]=LookUp[_[gtrait]]={"gtrait",gu,gtrait};
		LookUp[Subscript[gtrait,sp_]]=LookUp[_[Subscript[gtrait,sp_]]]={"gtrait",gu,gtrait,sp};
		Do[
			Color[Subscript[gtrait[gcomp],sp_]]=Color[Subscript[_[gtrait][gcomp],sp_]]=Color[Subscript[gcomp, sp]];
			LookUp[Subscript[gtrait[gcomp],sp_]]=LookUp[_[Subscript[gtrait[gcomp],sp_]]]={"gtrait",gu,gtrait[gcomp],sp};
			LookUp[Subscript[Var[gtrait][gcomp],sp_]]=LookUp[_[Subscript[Var[gtrait][gcomp],sp_]]]={"var",gu,gtrait[gcomp],sp};
		,{gcomp,gcomps[gu]}];
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];


(* Auxs *)

VPrint[2,"Processing Auxs..."];

auxs=Select[model,#[[1,0]]==Aux&][[All,1,1]];
VPrint[3,"auxs=",auxs];
nauxs=Length[auxs];

If[nauxs!=0,
	Do[
		raweqn=Equation/.(Aux[aux]/.model);
		VPrint[3,"raweqn=",raweqn];
		If[!moments,
			Unprotect[Equation];Equation[aux]:=Evaluate[raweqn];Protect[Equation]
		,
			f=AddProceduralToSum[raweqn];
			VPrint[3,"f=",f];
			f\[Prime]=FixEqn[f];
			VPrint[3,"f\[Prime]=",f\[Prime]];
			dndtnaive[aux]=f;
			dndt[aux]=f\[Prime];
			Unprotect[Equation];Equation[aux]=f\[Prime];Protect[Equation];
		];	
		stylecount++;
		type[aux]="aux";
		in=Aux[aux]/.model;
		range[aux]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
		Color[aux]=Color[_[aux]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
		LineStyle[aux]=LineStyle[_[aux]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		PlotMarker[aux]=PlotMarker[_[aux]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[aux]=LookUp[_[aux]]=LookUp[aux[_]]={"aux",aux};
	,{aux,auxs}];
];


(* Pops *)

VPrint[2,"Processing Pops..."];
pops=Select[model,#[[1,0]]==Pop&][[All,1,1]];
VPrint[3,"pops=",pops];
npops=Length[pops];

Do[
	in=Pop[pop]/.model;
	type[pop]="pop";
	LookUp[pop]={"pop",pop};
	comps[pop]=pcomps[pop]=Select[in,#[[1,0]]==Component&][[All,1,1]];
	If[pcomps[pop]=={},comps[pop]=pcomps[pop]={pop}];
	VPrint[3,"pcomps["<>ToString@pop<>"]=",pcomps[pop]];
	ncomps[pop]=npcomps[pop]=Length[pcomps[pop]];
	Do[
		in=If[RuleListQ[Component[pcomp]/.(Pop[pop]/.model)],Component[pcomp]/.(Pop[pop]/.model),Pop[pop]/.model];
		raweqn=Equation/.If[RuleListQ[Component[pcomp]/.in],Component[pcomp]/.in,in];
		VPrint[3,"raweqn=",raweqn];
		If[!moments,
			Unprotect[Equation];Equation[pcomp]:=Evaluate[raweqn];Protect[Equation]
		,
			f=AddProceduralToSum[raweqn];
			VPrint[3,"f=",f];
			f\[Prime]=FixEqn[f];
			VPrint[3,"f\[Prime]=",f\[Prime]];
			dndtnaive[pcomp]=f;
			dndt[pcomp]=f\[Prime];
			Unprotect[Equation];Equation[pcomp]=f\[Prime];Protect[Equation];
		];
		stylecount++;
		type[pcomp]="pcomp";
		comptype[pcomp]=Type/.Append[in,Type->"Extensive"];
		range[pcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		Color[pcomp]=Color[_[pcomp]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
		LineStyle[pcomp]=LineStyle[_[pcomp]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		PlotMarker[pcomp]=PlotMarker[_[pcomp]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[pcomp]=LookUp[_[pcomp]]=LookUp[pcomp[_]]={"pcomp",pop,pcomp};
	,{pcomp,pcomps[pop]}];
,{pop,pops}];


(* build moment eqns *)

VPrint[2,"Setting Guild Equations..."];

Do[Do[
	VPrint[3,"gcomp=",gcomp];
	raweqn=Evaluate[Equation/.If[RuleListQ[Component[gcomp]/.(Guild[gu]/.model)],Component[gcomp]/.(Guild[gu]/.model),Guild[gu]/.model]];
	If[!moments,
		Unprotect[Equation];Equation[Subscript[gcomp, i_]]:=Evaluate[raweqn/.\[FormalI]->i/.Mutated[rate_,M_]:>rate];Protect[Equation]
		,
		VPrint[3,"raweqn=",raweqn];
		desttraits=MakeTraitVector[Subscript[gcomp, \[FormalI]]];
		VPrint[3,"desttraits=",desttraits];
		destG=MakeGMatrix[Subscript[gcomp, \[FormalI]]];
		VPrint[3,"destG=",destG];
		Thread[{dndtnaive[gcomp],dxdtnaive[gcomp],dGdtnaive[gcomp],dndt[gcomp],dxdt[gcomp],dGdt[gcomp]}=Sum[
			VPrint[3,"adding contributions from ",source];
			sourcetraits=MakeTraitVector[Subscript[source, \[FormalI]]];
			VPrint[3,"sourcetraits=",sourcetraits];
			(*sourceG=MakeGMatrix[Subscript[gcomp, \[FormalI]]];*)
			sourceG=MakeGMatrix[Subscript[source, \[FormalI]]];
			VPrint[3,"sourceG=",sourceG];
			f=AddProceduralToSum[Coefficient[(raweqn/.Mutated[Subscript[source, \[FormalI]] stuff___,M_]:>Subscript[source, \[FormalI]] Mutated[stuff,M]),Subscript[source, \[FormalI]],1]];
			VPrint[3,"f=",f];
			mut=Total[Cases[f,Mutated[_,_:Except[_List]]]/.Mutated[rate_,var_]->rate*{{var}}]+
				Total[Cases[f,Mutated[_,_List]]/.Mutated[rate_,var_]->rate*var];
			VPrint[3,"mut=",mut];
			mut\[Prime]=FixGuildEqn[mut,desttraits,destG];
			VPrint[3,"mut\[Prime]=",mut\[Prime]];
			f=f/.Mutated[rate_,_]->rate; (* remove Mutated *)
			f\[Prime]=FixGuildEqn[f,desttraits,destG];
			VPrint[3,"f\[Prime]=",f\[Prime]];
			df=Simplify@D[f,{sourcetraits,1}];
			VPrint[3,"df=",df];
			d2f=Simplify@HessianMatrix[f,sourcetraits];
			VPrint[3,"d2f=",d2f];
			df\[Prime]=Simplify@D[f\[Prime],{sourcetraits,1}];
			VPrint[3,"df\[Prime]=",df\[Prime]];
			d2f\[Prime]=Simplify@HessianMatrix[f\[Prime],sourcetraits];
			VPrint[3,"d2f\[Prime]=",d2f\[Prime]];
			{Subscript[source, \[FormalI]]f,
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]]*(f(sourcetraits-desttraits)+sourceG . df),
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]](mut+f(sourceG-destG+(sourcetraits-desttraits)^2)+sourceG . d2f . sourceG
				+df*sourceG . Transpose[sourcetraits-desttraits]+(sourcetraits-desttraits) . Transpose[sourceG . df]),
			Subscript[source, \[FormalI]]f\[Prime],
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]]*(f\[Prime](sourcetraits-desttraits)+sourceG . df\[Prime]),
			Subscript[source, \[FormalI]]/Subscript[gcomp, \[FormalI]](mut\[Prime]+f\[Prime](sourceG-destG+(sourcetraits-desttraits)^2)+sourceG . d2f\[Prime] . sourceG
				+df\[Prime]*sourceG . Transpose[sourcetraits-desttraits]+(sourcetraits-desttraits) . Transpose[sourceG . df\[Prime]])
			}
		,{source,gcomps[gu]}]];
		Unprotect[Equation];Equation[Subscript[gcomp, i_]]:=Evaluate[dndt[gcomp]/.\[FormalI]->i];Protect[Equation];
		VPrint[3,"Equation[",Subscript[gcomp, \[FormalI]],"]=",Equation[Subscript[gcomp, \[FormalI]]]];
		If[ngcomps[gu]==1,
			Do[
				dxdt[gtraits[gu][[i]]]=dxdt[gcomp][[i]];
				dxdtnaive[gtraits[gu][[i]]]=dxdtnaive[gcomp][[i]];
				dGdt[Var[gtraits[gu][[i]]]]=dGdt[gcomp][[i,i]];
				dGdtnaive[Var[gtraits[gu][[i]]]]=dGdtnaive[gcomp][[i,i]];
				Do[
					dGdt[Cov[gtraits[gu][[i]],gtraits[gu][[j]]]]=dGdt[gcomp][[i,j]];
					dGdtnaive[Cov[gtraits[gu][[i]],gtraits[gu][[j]]]]=dGdtnaive[gcomp][[i,j]];
				,{j,ngtraits[gu]}];
			,{i,ngtraits[gu]}];
		,
			Do[
				dxdt[gtraits[gu][[i]][gcomp]]=dxdt[gcomp][[i]];
				dxdtnaive[gtraits[gu][[i]][gcomp]]=dxdtnaive[gcomp][[i]];
				dGdt[Var[gtraits[gu][[i]]][gcomp]]=dGdt[gcomp][[i,i]];
				dGdtnaive[Var[gtraits[gu][[i]]][gcomp]]=dGdtnaive[gcomp][[i,i]];
				Do[
					dGdt[Cov[gtraits[gu][[i]],gtraits[gu][[j]]][gcomp]]=dGdt[gcomp][[i,j]];
					dGdtnaive[Cov[gtraits[gu][[i]],gtraits[gu][[j]]][gcomp]]=dGdtnaive[gcomp][[i,j]];
				,{j,ngtraits[gu]}];
			,{i,ngtraits[gu]}];
		];
	];
,{gcomp,gcomps[gu]}],{gu,guilds}];


(* Interactions *)

VPrint[2,"Processing Interactions..."];

interactions=Select[model,#[[1,0]]==Interaction&][[All,1,1]];
VPrint[3,"interactions=",interactions];
ninteractions=Length[interactions];

Do[interactionpos[gu]={},{gu,guilds}];

Do[
	VPrint[3,"interaction=",interaction];
	in=Interaction[interaction]/.model;
	type[Subscript[interaction,_]]=(*index[gtrait]=*)"interaction";
	index[Subscript[interaction,_]]=index[interaction]=indexcount;
	range[Subscript[interaction,_]]=range[interaction]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
	{guild1[interaction],guild2[interaction]}=Guilds/.in;
	AppendTo[interactionpos[guild1[interaction]],{interaction,1}];
	AppendTo[interactionpos[guild2[interaction]],{interaction,2}];
	LookUp[interaction]=LookUp[_[interaction]]={"interaction",guild1[interaction],guild2[interaction],interaction};
	LookUp[Subscript[interaction,sp1_,sp2_]]=LookUp[_[Subscript[interaction,sp1_,sp2_]]]=
		{"interaction",guild1[interaction],guild2[interaction],interaction,sp1,sp2};
,{interaction,interactions}];


(* model assumptions - default={} *)

VPrint[2,"Processing Assumptions..."];

$Assumptions=Flatten[assumptions/.Automatic->Join[
	Select[parametersin,MemberQ[{Greater,GreaterEqual,Less,LessEqual},Head[#]]&],
	(*Table[Region`SpecialRegionProperty[range[aux],{aux},"ImplicitDescription"],{aux,auxs}],*)
	Table[Table[Region`SpecialRegionProperty[range[pcomp],{pcomp},"ImplicitDescription"],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gcomp],{Subscript[gcomp,sp]},"ImplicitDescription"],{sp,0,2}],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gtrait],{Subscript[gtrait,sp]},"ImplicitDescription"],{sp,0,2}],{gtrait,gtraits[gu]}],{gu,guilds}]
]];
VPrint[2,"$Assumptions=",$Assumptions];

assumptionstrings=ToString/@$Assumptions;

(* get rid of this? *)
Which[
	modeltype=="ContinuousTime",
	DT[var_]:=var'(*[t]*)
,
	modeltype=="DiscreteTime",
	DT[var_]:=var'
];

Protect[Evaluate[protectedfuncs]];

]]


Options[SetModel]={
	LineStyles->{{}},PlotMarkers->Graphics`PlotMarkers[],
	Colors->ColorData[97,"ColorList"],
	Assumptions->{Automatic},
	Parameters->{},
	ApproximationOrder->3,
	GaussianIntegralOpts->{},
	MomentMethod->None
};


SetModel::unktype=
"Unknown ModelType (\"ContinuousTime\", \"DiscreteTime\" currently supported).";
SetModel::badpar=
"One or more Parameters already defined. Clear them before running SetModel.";
SetModel::badmut=
"Bad mutation kernel `1`.";


UnsetModel::usage=
"UnsetModel clears the currently set EcoEvo model.";


UnsetModel:=Module[{dvs},
	modelloaded=False;
	Quiet[Clear[LookUp,type,range,comptype,DT,
	modeltype,modelwhenevents,modelperiod,moments,
	pops,npops,npcomps,pcomps,pcompeqn,
	auxs,nauxs,auxeqn,
	guilds,nguilds,gcomps,ngcomps,gtraits,ngtraits,
	eqns,
	dndt,dxdt,dGdt,assumptionstrings,
	parameters],{Clear::wrsym}];
	dvs={Color,LineStyle,PlotMarker};
	Unprotect[dvs];
	Do[DownValues[func]={},{func,dvs}];
	Protect[dvs];
	$Assumptions={};
];


ModelInfo::usage=
"ModelInfo gives a summary of the currently loaded EcoEvo model.";


ModelInfo:=(

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[]];

(* model name *)
Print["modelname=",modelname];

(* model type *)
Print["modeltype=",modeltype,", modelperiod=",modelperiod];

(* aux vars *)
Print["auxs=",auxs," (nauxs=",nauxs,")"];
Do[
	Print["  ",FuncStyle[aux]];
	Print["  Equation[",aux,"]=",Equation[aux]];
	Print["  range[",aux,"]=",range[aux]];
,{aux,auxs}];

(* pops *)

Print["pops=",pops," (npops=",npops,")"];
Do[
	Print["  pcomps[",pop,"]=",pcomps[pop]," (npcomps[",pop,"]=",npcomps[pop],")"];
	Do[
		Print["    ",FuncStyle[pcomp]];
		Print["    Equation[",pcomp,"]=",Equation[pcomp]];
		Print["    comptype[",pcomp,"]=",comptype[pcomp]];
		Print["    range[",pcomp,"]=",range[pcomp]];
	,{pcomp,pcomps[pop]}];
,{pop,pops}];

(* guilds *)

Print["guilds=",guilds," (nguilds=",nguilds,")"];
Do[
	Print["  gcomps[",gu,"]=",gcomps[gu]," (ngcomps[",gu,"]=",ngcomps[gu],")"];
	Do[
		Print["    ",FuncStyle[gcomp]];
		Print["    Equation[",Subscript[gcomp,Global`i],"]=",Equation[Subscript[gcomp,Global`i]]];
		Print["    comptype[",gcomp,"]=",comptype[gcomp]];
		Print["    range[",gcomp,"]=",range[gcomp]];
	,{gcomp,gcomps[gu]}];
	Print["  gtraits[",gu,"]=",gtraits[gu]," (ngtraits[",gu,"]=",ngtraits[gu],")"];
	Do[
		Print["    ",FuncStyle[gtrait]];
		Print["    range[",gtrait,"]=",range[gtrait]];
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];

);


MatrixToPopComponents::usage=
"MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";

MatrixToGuildComponents::usage=
"MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";


MatrixToPopComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[(Sum[a[[c,c\[Prime]]]var[c\[Prime]],{c\[Prime],ncomps}])]},{c,ncomps}];
	On[Part::partd];
	Return[res]
];


MatrixToGuildComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[Sum[a[[c,c\[Prime]]]var[c\[Prime]],{c\[Prime],ncomps}]]/.{var[c_]->Subscript[var[c],\[FormalI]]}},{c,ncomps}];
	On[Part::partd];
	Return[res/.{(Equation:>eqn_)->(Equation:>(eqn))}]
];


WeightedAbundance::usage = 
"WeightedAbundance[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] totals components in all guilds and pops.";


WeightedAbundance[sol_?RuleListQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WeightedAbundance"],
(* options *)
weightfunction,minpop,
(* other variables *)
f,gu,sp
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WeightedAbundance]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[WeightedAbundance]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractAttributes[sol],ExtractVariables[sol]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Which[
	weightfunction==="Total",
	f[var_]:=Total[Select[comps[var],comptype[#]==="Extensive"&]],
	weightfunction==="Components",
	f[var_]:=Select[comps[var],comptype[#]==="Extensive"&],
	weightfunction==="PresenceAbsence",
	f[var_]:=If[Total[Select[comps[var],comptype[#]==="Extensive"&]]>minpop,1,0],
	Else,
	f[Subscript[gu_,sp_]]:=weightfunction/.(#->Subscript[#,sp]&/@comps[gu]);
	f[pop_]:=weightfunction;
];

Return[Flatten@Join[
	Table[Table[Subscript[gu, sp]->Reinterpolation[f[Subscript[gu, sp]]/.sol],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[pop->Reinterpolation[f[pop]/.sol],{pop,pops}],
	ExtractAuxs[sol],
	ExtractAttributes[sol]
]]
]];


Options[WeightedAbundance]={WeightFunction->"Total",MinPop->10^-10};


TotalAbundance::usage = 
"TotalAbundance[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the total abundance in guilds.";


TotalAbundance[solin_,opts___?OptionQ]:=
Module[{
func=FuncStyle["TotalAbundance"],
(* options *)
weightfunction,
(* other variables *)
sol,wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TotalAbundance]}]];

sol=ExtractVariables[solin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][{},sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];
Return[Table[gu->Reinterpolation[Sum[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]/.wa],{gu,guilds}]]

]];


Options[TotalAbundance]={WeightFunction->"Total"};


TraitMean::usage = 
"TraitMean[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the mean traits in guilds.";


TraitMean[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["TraitMean"],
(* options *)
weightfunction,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TraitMean]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];

Return[
	Flatten@Table[Table[
		gtrait->Reinterpolation[Moment[WeightedData[Table[Subscript[gtrait, i],{i,\[ScriptCapitalN][gu]}]/.traits,Chop[Table[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]]],1]/.wa]
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]

]];


Options[TraitMean]={
	WeightFunction->"Total"
};


(* split traitsandvariables *)
TraitMean[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
TraitMean[ExtractTraits[eesol],ExtractVariables[eesol],opts];


TraitVariance::usage = 
"TraitVariance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the variance of traits in guilds.";


TraitVariance[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["TraitVariance"],
(* options *)
weightfunction,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TraitVariance]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];

Return[
	Flatten@Table[Table[
		Var[gtrait]->Reinterpolation[CentralMoment[WeightedData[Table[Subscript[gtrait, i],{i,\[ScriptCapitalN][gu]}]/.traits,Chop[Table[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]/.wa]],2]]
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]

]];


Options[TraitVariance]={
	WeightFunction->"Total"
};


(* split traitsandvariables *)
TraitVariance[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
TraitVariance[ExtractTraits[eesol],ExtractVariables[eesol],opts];


TraitDistance::usage =
"TraitDistance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sp1\", \"TI\"]\), \!\(\*
StyleBox[\"sp2\", \"TI\"]\)] returns the trait distance between two species.
TraitDistance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"guild\", \"TI\"]\)] returns a trait distance matrix between all species in a guild (default=first).";


TraitDistance[traits_?RuleListQ,sp1_Subscript,sp2_Subscript,opts___?OptionQ]:=

Module[{
func=FuncStyle["TraitDistance (2sp)"],
(* options *)
rulelistdistanceopts
},

Block[{},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
rulelistdistanceopts=FilterRules[Flatten[{opts,Options[TraitDistance]}],Options[RuleListDistance]];

(*Print[DeleteSubscripts@ExtractTraits[traits,sp1]];
Print[DeleteSubscripts@ExtractTraits[traits,sp2]];
Print[Evaluate[Sequence@@rulelistdistanceopts]];*)

Return[Reinterpolation[RuleListDistance[DeleteSubscripts@ExtractTraits[traits,sp1],DeleteSubscripts@ExtractTraits[traits,sp2],
	Evaluate[Sequence@@rulelistdistanceopts]]]];

]];


TraitDistance[traits_?RuleListQ,gu:(_Symbol|_Integer):Automatic,opts___?OptionQ]:=

Module[{
func=FuncStyle["TraitDistance (guild)"]
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

If[gu==="Automatic",gu=guilds[[1]]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractTraits@traits,{}];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Return[Table[TraitDistance[traits,Subscript[gu, i],Subscript[gu, j],opts],{i,\[ScriptCapitalN][gu]},{j,\[ScriptCapitalN][gu]}]];

]];


Options[TraitDistance]={};


TraitDistance[traits_?RuleListQ,sp1_Subscript,sp1_Subscript,opts___?OptionQ]:=0;


FunctionalDistinctiveness::usage =
"FunctionalDistinctiveness[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] calculates the functional distinctiveness of \!\(\*
StyleBox[\"target\", \"TI\"]\).";


FunctionalDistinctiveness[traits_?TraitsQ,sol:(_?VariablesQ):{},target:(_Symbol|_Integer|_Subscript):Automatic,opts___?OptionQ]:=
Module[{
func=FuncStyle["FunctionalDistinctiveness"],
(* options *)
verbose,method,weightfunction,traitdistanceopts,normalizedistance,excludefocalspecies,
(* other variables *)
gu,sp,dists,distnorm,denom,abunds,totalabundance
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
If[sol==={},method="Species",method=Evaluate[Method/.Flatten[{opts,Options[FunctionalDistinctiveness]}]]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
traitdistanceopts=Evaluate[TraitDistanceOpts/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
normalizedistance=Evaluate[NormalizeDistance/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
excludefocalspecies=Evaluate[ExcludeFocalSpecies/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,{}];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Which[
	(* species target *)
	Head[target]===Subscript,
	gu=target[[1]];sp=target[[2]],
	(* automatic *)
	target===Automatic,
	gu=guilds[[1]];sp="All",
	(* guild target *)
	Head[target]===Integer||Head[target]==Symbol,
	gu=target;sp="All",
	Else,
	Message[FunctionalDistinctiveness::badtgt];
	Return[$Aborted];
];

dists=TraitDistance[traits,gu,Evaluate[Sequence@@traitdistanceopts]];
If[verbose,Print[func,": dists=",dists]];
distnorm=If[normalizedistance==True,Max[Flatten[dists]],1];
If[verbose,Print[func,": distnorm=",distnorm]];

Which[
	method==="Species",
	If[excludefocalspecies==True,denom=Subscript[\[ScriptCapitalN], gu]-1,denom=Subscript[\[ScriptCapitalN], gu]];
	If[sp==="All",
		Return[Table[FunctionalDistinctiveness[Subscript[gu, sp]]->Reinterpolation[Sum[dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)],{sp,Subscript[\[ScriptCapitalN], gu]}]],
		Return[Reinterpolation[Sum[dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]]
	],
	method==="AbundanceWeighted",
	abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];
	If[verbose,Print[func,": abunds=",abunds]];
	totalabundance=gu/.TotalAbundance[sol,WeightFunction->weightfunction];
	If[verbose,Print[func,": totalabundance=",totalabundance]];
	If[sp==="All",
		Return[Table[
			If[excludefocalspecies==True,denom=totalabundance-(Subscript[gu, sp]/.abunds),denom=totalabundance];
			FunctionalDistinctiveness[Subscript[gu, sp]]->Reinterpolation[Sum[(Subscript[gu, sp\[Prime]]/.abunds)*dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]
		,{sp,Subscript[\[ScriptCapitalN], gu]}]],
		If[excludefocalspecies==True,denom=totalabundance-(Subscript[gu, sp]/.abunds),denom=totalabundance];
		Return[Reinterpolation[Sum[(Subscript[gu, sp]/.abunds)*dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]]
	],
	Else,
	Message[FunctionalDistinctiveness::badmtd];Return[$Failed]
];

]]


Options[FunctionalDistinctiveness]={
	Verbose->False,
	Method->"Species",WeightFunction->"Total",TraitDistanceOpts->{},NormalizeDistance->True,ExcludeFocalSpecies->True
};


(* break up combned traitsandpops *)
FunctionalDistinctiveness[traitsandpops_?AttributesAndVariablesQ,target:(_Symbol|_Integer|_Subscript):Automatic,opts___?OptionQ]:=
FunctionalDistinctiveness[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],target,opts];


FunctionalDistinctiveness::badmtd="The Method option should be a built-in method name (\"Species\" or \"AbundanceWeighted\").";
FunctionalDistinctiveness::badtgt="The target should be a guild, a species, or Automatic.";


ExtinctSpecies::usage=
"ExtinctSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives a list of extinct species in \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


ExtinctSpecies[sol_?RuleListQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["ExtinctSpecies"],
(* options *)
verbose,weightfunction,time,minpop,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[ExtinctSpecies]}]];
If[Global`debug,verbose=True];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[ExtinctSpecies]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[ExtinctSpecies]}]];
time=Evaluate[Time/.Flatten[{opts,Options[ExtinctSpecies]}]];

wa=ExtractSpecies[WeightedAbundance[sol,WeightFunction->weightfunction]];
(*If[verbose,Print[func,": wa=",wa]];*)

If[time===t,
	Which[
		modelperiod==0,
		wa=FinalSlice[wa],
		modelperiod<\[Infinity],
		wa=TemporalMean[FinalSlice[wa,modelperiod]],
		Else,
		wa=TemporalMean[wa]
	]
,
	wa=Slice[wa,time]
];
If[verbose,Print[func,": WeightedAbundance=",wa]];

Return[Keys[Select[Association[wa],#<=minpop&]]]
]];


Options[ExtinctSpecies]={Verbose->False,MinPop->10^-10,WeightFunction->"Total",Time->t};


ExtantSpecies::usage=
"ExtantSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives a list of extant species in \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


ExtantSpecies[sol_?RuleListQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["ExtantSpecies"],
(* options *)
verbose,weightfunction,time,minpop,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[ExtantSpecies]}]];
If[Global`debug,verbose=True];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[ExtantSpecies]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[ExtantSpecies]}]];
time=Evaluate[Time/.Flatten[{opts,Options[ExtantSpecies]}]];

wa=ExtractSpecies[WeightedAbundance[sol,WeightFunction->weightfunction]];
(*If[verbose,Print[func,": wa=",wa]];*)

If[time===t,
	Which[
		modelperiod==0,
		wa=FinalSlice[wa],
		modelperiod<\[Infinity],
		wa=TemporalMean[FinalSlice[wa,modelperiod]],
		Else,
		wa=TemporalMean[wa]
	]
,
	wa=Slice[wa,time]
];
If[verbose,Print[func,": WeightedAbundance=",wa]];

Return[Keys[Select[Association[wa],#>minpop&]]]
]];


Options[ExtantSpecies]={Verbose->False,MinPop->10^-10,WeightFunction->"Total",Time->t};


Subscript[\[ScriptCapitalN], gu_]:=\[ScriptCapitalN][gu];
Subscript[\[FormalCapitalN], gu_]:=\[FormalCapitalN][gu];


ClearParameters::usage="ClearParameters clears all model parameters.";


ClearParameters:=Quiet[Clear[Evaluate[Sequence@@EcoEvo`Private`parnames]],{Clear::wrsym}];


ParameterValues::usage="ParameterValues returns a rulelist of current definitions of model parameters.";


ParameterValues:=Thread[EcoEvo`Private`parnames->EcoEvo`Private`parameters];


MakeGMatrix::usage="MakeGMatrix[\!\(\*
StyleBox[\"var\", \"TI\"]\)] makes a G-matrix of Var and Cov for guild/gcomp \!\(\*
StyleBox[\"var\", \"TI\"]\).";


MakeGMatrix[var_]:=Module[{type,gu},
	{type,gu}=LookUp[var][[1;;2]];
	(*Print[{type,gu}];*)
	Which[
		type=="guild"||ngcomps[gu]==1,
		Table[Table[
			Which[
				i<j,Cov[gtraits[gu][[i]],gtraits[gu][[j]]],
				i==j,Var[gtraits[gu][[i]]],
				i>j,Cov[gtraits[gu][[j]],gtraits[gu][[i]]]
			]
		,{j,ngtraits[gu]}],{i,ngtraits[gu]}]
		,
		type=="gcomp",
		Table[Table[
			Which[
				i<j,Cov[gtraits[gu][[i]],gtraits[gu][[j]]][var],
				i==j,Var[gtraits[gu][[i]]][var],
				i>j,Cov[gtraits[gu][[j]],gtraits[gu][[i]]][var]
			]
		,{j,ngtraits[gu]}],{i,ngtraits[gu]}]
	]
];


MakeGMatrix[Subscript[var_,sp_]]:=Replace[MakeGMatrix[var],x_->Subscript[x, sp],{2}];


MakeTraitVector::usage="MakeTraitVector[\!\(\*
StyleBox[\"var\", \"TI\"]\)] makes a trait vector for guild/gcomp \!\(\*
StyleBox[\"var\", \"TI\"]\)."


MakeTraitVector[var_]:=Module[{type,gu},
	{type,gu}=LookUp[var][[1;;2]];
	(*Print[{type,gu}];*)
	Which[
		type=="guild"||ngcomps[gu]==1,
		gtraits[gu],
		type=="gcomp",
		Table[gtrait[var],{gtrait,gtraits[gu]}]
	]
];


MakeTraitVector[Subscript[var_,sp_]]:=Replace[MakeTraitVector[var],x_->Subscript[x, sp],{1}];


EcoEqns::usage=
"EcoEqns[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] sets up ecological equations using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoEqns[attributesin:(_?AttributesQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,logged,fixed,fixedvars,fixedvariables,timescale,percapita,zerogrowthby,ignorevar,
(* other variables *)
attributes,zeroedvars,nonfixedvars,fixed2,eqn,eqns,gco,sp},

Block[{\[ScriptCapitalN],verbosity,func="EcoEqns"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEqns]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEqns]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEqns]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEqns]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoEqns]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[EcoEqns]}]];
nonfixedvars=Evaluate[NonFixedVars/.Flatten[{opts,Options[EcoEqns]}]];
zerogrowthby=Evaluate[ZeroGrowthBy/.Flatten[{opts,Options[EcoEqns]}]];
If[zerogrowthby===None,
	zeroedvars={},
	zeroedvars=Which[
		LookUp[zerogrowthby][[1]]=="gcomp",
		Table[Subscript[gcomp, LookUp[zerogrowthby][[4]]],{gcomp,gcomps[LookUp[zerogrowthby][[2]]]}],
		LookUp[zerogrowthby][[1]]=="pcomp",
		pcomps[LookUp[zerogrowthby][[2]]]
	]
];
(*Print["zeroedvars=",zeroedvars];*)
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEqns]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEqns]}]];
fixedvars=fixed[[All,1]];
fixedvariables=ExtractVariables[fixed];
VPrint[3,"fixedvars=",fixedvars];

(* fix attributes *)
attributes=FixAttributes[attributesin];
(*Print["attributes=",attributes];*)

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[nonfixedvars===Automatic,nonfixedvars=OrderedComplement[AllVariables,fixedvars]];
VPrint[3,"nonfixedvars=",nonfixedvars];

(*Print["making eqns"];*)
eqns=Table[
	If[ignorevar,eqn=Simplify[Equation[var]/.ZeroGs],eqn=Equation[var]];
	Which[
		logged===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			log[var]'==log[var]+RealSimplify[timescale*Log[eqn/var]],
			modeltype=="ContinuousTime",
			log[var]'==timescale*(eqn/var)
		]
	,
		percapita===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			var'==var+RealSimplify[timescale*Log[eqn/var]],
			modeltype=="ContinuousTime",
			var'==timescale*eqn/var
		]
	,
		Else,
		Which[
			modeltype=="DiscreteTime",
			var'==timescale*eqn,
			modeltype=="ContinuousTime",
			If[MemberQ[zeroedvars,var],
				var'==timescale*(eqn-Equation[zerogrowthby]*var/zerogrowthby),
				var'==timescale*eqn
			]
		]
	]
,{var,nonfixedvars}];
(*Print["eqns=",eqns];
Print["ExpandTraits[attributes]=",ExpandTraits[attributes]];
Print["nonfixedvars=",nonfixedvars];
Print["logged=",logged];*)
Return[DeleteDuplicates[eqns/.ExpRule[nonfixedvars,logged]/.Dispatch[ExpandTraits[attributes]]/.fixed]]

]];


Options[EcoEqns]={Verbose->False,Verbosity->0,
Fixed->{},TimeScale->1,Logged->False,PerCapita->False,NonFixedVars->Automatic,ZeroGrowthBy->None,IgnoreVar->False};


EcoSim::usage=
"EcoSim[\!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates ecological dynamics, with initial densities in \!\(\*
StyleBox[\"init\", \"TI\"]\), from time \!\(\*
StyleBox[\"t\", \"TI\"]\)=0 to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
EcoSim[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoSim[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},initin:(_?VariablesQ):{},tmax_?NumericQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,method,
ndsolveopts,logged,interpolationpoints,interpolationopts,fixed,fixedvars,whenevents,timescale,outputtmin,randomseeding,
output,tmin,minpop,wheneventopts,
(* other variables *)
attributes,nonfixedvars,Gs,luv,sp,eqns,unks,ics,tic,exprule,sol,res,fixedres,minwhens,minvar,minval,
init,delayedics,icwhens,var,t0,var0},

Block[{\[ScriptCapitalN],verbosity,func="EcoSim"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoSim]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[EcoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoSim]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[EcoSim]}]];
whenevents=Evaluate[WhenEvents/.Flatten[{opts,Options[EcoSim]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoSim]}]];
If[output=="FinalSlice",outputtmin=tmax];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoSim]}]];
If[outputtmin===Automatic,outputtmin=tmin];
randomseeding=Evaluate[RandomSeeding/.Flatten[{opts,Options[EcoSim]}]];
If[IntegerQ[randomseeding],SeedRandom[randomseeding]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[EcoSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoSim]}]];

interpolationopts=FilterRules[Flatten[{opts,Options[EcoSim]}],Options[Interpolation]];
interpolationpoints=Evaluate[InterpolationPoints/.Flatten[{opts,Options[EcoSim]}]];


init=initin/.{(va_[tmin]->vl_)->(va->vl),(va_[_?NumericQ]->_)->(va->0)};
VPrint[3,"init=",init];

(* process fixed variables *)
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoSim]}]];
fixedvars=fixed[[All,1]];
nonfixedvars=init[[All,1]]; (* nonfixedvars are those given ICs *)
(*Print["nonfixedvars=",nonfixedvars];*)

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],
		AppendTo[fixed,var->0];
		AppendTo[fixedvars,var];
	]
,{var,AllPopsAndAuxs}];

(* set up MinPop WhenEvents *)
Which[
	NumberQ[minpop],
	minwhens=Table[
		If[comptype[var]==="Extensive",
			If[logged===False,
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->var[t]<minpop,action->var[t]->0},
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->log[var][t]<Log[minpop],action->log[var][t]->-10^10}
			]]
	,{var,nonfixedvars}]//DeleteNulls,
	RuleListQ[minpop],
	minwhens=Table[
		{minvar,minval}={rule[[1]],rule[[2]]};
		If[logged===False,
			WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->minvar[t]<minval,action->minvar[t]->0},
			WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->log[minvar][t]<Log[minval],action->log[minvar][t]->-10^10}
		]
	,{rule,minpop}]//DeleteNulls,
	minpop===Automatic,
	minwhens=Table[
		If[comptype[var]==="Extensive"&&Min[range[var]]>0,
			If[logged===False,
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->var[t]<Min[range[var]],action->var[t]->0},
				WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->log[var][t]<Log[Min[range[var]]],action->log[var][t]->-10^10}
			]]
	,{var,nonfixedvars}]//DeleteNulls,
	Else,
	minwhens={}
];
VPrint[3,"minwhens=",minwhens];

(* setup delayed IC WhenEvents *)

(*Print["initin=",initin];*)
delayedics=FilterRules[initin,_[_?NumericQ]];
VPrint[3,"delayedics=",delayedics];
icwhens=Table[
	{var,t0,var0}={dic[[1,0]],dic[[1,1]],dic[[2]]};
	If[tmin<t0<tmax,WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.{event->t==t0,action->var[t]->var0}]
,{dic,delayedics}]//DeleteNulls;
VPrint[3,"icwhens=",icwhens];

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes,Join[init,fixed]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-10^-15]; (* hack to ensure that events are triggered at t=tmin *)

(* set eqns, unks and ics *)
(*Print["calling EcoEqns..."];*)
eqns=EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,opts]/.AddVariablets/.Gs/.ZeroGs;
unks=Table[If[logged===True&&comptype[var]==="Extensive",log[var],var],{var,nonfixedvars}];
ics=Table[If[logged===True&&comptype[var]==="Extensive",log[var][tic]==Log[var/.init],var[tic]==(var/.init)],{var,nonfixedvars}];

VPrint[3,"eqns=",eqns];
VPrint[3,"unks=",unks];
VPrint[3,"ics=",ics];

(* solve it *)
(*Print["calling NDSolve..."];*)
Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	If[verbosity>=1,
		With[{ndsolveeqns=Join[eqns,ics,modelwhenevents,whenevents,minwhens,icwhens],unks=unks,outputtmin=outputtmin,options=Sequence@@ndsolveopts},
			PrintCall[Global`sol=NDSolve[ndsolveeqns,unks,{t,outputtmin,tmax},options][[1]]]
	]];
	sol=NDSolve[Join[eqns,ics,modelwhenevents,whenevents,minwhens,icwhens],unks,{t,outputtmin,tmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	If[logged===True,
		If[output=="FinalSlice",Return[SortRuleList[FinalSlice[sol]/.(log[var_]->val_)->(var->E^val),AllVariables]]];
		res=Table[If[comptype[var]==="Extensive",
			var->Reinterpolation[E^log[var]/.sol,InterpolationPoints->interpolationpoints,Evaluate[Sequence@@interpolationopts]],
			var->(var/.sol)]
		,{var,nonfixedvars}]
	,
		(*res=sol*)
		res=FilterRules[sol,nonfixedvars]
	];
	res=Join[res,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
	,
	modeltype=="DiscreteTime",
	If[verbosity>=1,
		With[{rteqns=Join[eqns,ics],unks=unks,tmin=tmin},
			PrintCall[Global`res=RecurrenceTable[rteqns,unks,{t,tmin,tmax}]]
	]];
	sol=Transpose[Replace[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax},Method->{Compiled->True}],n_?NumericQ->{n},1]]; (* Replace to deal with weird RecurrenceTable bug <https://mathematica.stackexchange.com/questions/128371/> *)
	res=Join[Table[
		If[Head[unks[[i]]]===log,unks[[i,1]],unks[[i]]]->TimeSeries[Transpose[{Table[t,{t,outputtmin,tmax}],If[Head[unks[[i]]]===log,E^sol[[i]],sol[[i,outputtmin-tmin+1;;tmax-tmin+1]]]}]]
	,{i,Length[unks]}],
	Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

VPrint[3,"res=",res];

If[output=="FinalSlice",Return[SortRuleList[FinalSlice[res],AllVariables]]];

Return[SortRuleList[res,AllVariables]];

]];


Options[EcoSim]={Verbose->False,Verbosity->0,
Method->Automatic,NDSolveOpts->{},Logged->False,Fixed->{},WhenEvents->{},InterpolationOrder->7,InterpolationPoints->1000,
EqStop->False,EqThreshold->10^-8,TimeScale->1,TMin->0,OutputTMin->Automatic,Output->"Dynamics",TMin->0,RandomSeeding->None,
MinPop->None,WhenEventOpts->{}};


(* split traitsandvariables *)
EcoSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoSim[ExtractTraits[sol],ExtractVarCovs[sol],ExtractVariables[sol],tmax,opts];
EcoSim[sol_?AttributesAndVariablesQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoSim[ExtractTraits[sol],ExtractVariables[sol],tmax,opts];


EcoEq::usage = 
"EcoEq[] solves for ecological equilibria.
EcoEq[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).";

SolveEcoEq::usage = 
"SolveEcoEq[] solves for ecological equilibria.
SolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";

NSolveEcoEq::usage = 
"NSolveEcoEq[] numerically solves for ecological equilibria.
NSolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses traits/interactions \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";

FindEcoEq::usage = 
"FindEcoEq[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological equilibrium using initial guess / range \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and initial guess / range \!\(\*
StyleBox[\"init\", \"TI\"]\).";


EcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},init:(_?VariablesQ):{},vars:(__List|All):All,opts___?OptionQ]:=

Module[{
(* options *)
method,solveopts,nsolveopts,findrootopts,findrootsopts,
boundarydetection,time,fixed,chop,qss,percapita,verbose,ignorevar,
(* other variables *)
attributes,nonvars,nonfixedvars,fixedvars,Gs,removets,eqns,unks,newunk,sol,res},

Block[{\[ScriptCapitalN],verbosity,func="EcoEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[EcoEq]}]];
If[method===Automatic,If[init!={},method="FindRoot",method="Solve"]];
VPrint[3,"method=",method];

solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EcoEq]}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EcoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EcoEq]}]];
findrootsopts=Evaluate[FindRootsOpts/.Flatten[{opts,Options[EcoEq]}]];

boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEq]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEq]}]];
qss=Evaluate[QSS/.Flatten[{opts,Options[EcoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[EcoEq]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEq]}]];

(* EcoEq doesn't work on Periodic models *)
If[modelperiod=!=0&&time===t&&method=="FindRoot",Message[EcoEq::noneq];Return[]];

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
VPrint[3,"Gsin=",Gsin];
If[method=="FindRoot"||method=="FindRoots",
	If[moments,
		If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
		Gs={}]
	,
	Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
];
VPrint[3,"Gs=",Gs];

If[vars===All,
	nonvars={},
	nonvars=OrderedComplement[AllVariables,vars]
];
VPrint[3,"nonvars=",nonvars];

If[qss==False,
	fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->0),1]],
	fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->x),1]]
];
VPrint[3,"fixed=",fixed];

fixedvars=fixed[[All,1]];
nonfixedvars=OrderedComplement[AllVariables,fixedvars];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* set eqns *)
eqns=EcoEqns[attributes,Fixed->fixed,PerCapita->percapita,IgnoreVar->ignorevar]/.Eq/.t->time/.fixed/.attributes/.Gs;
VPrint[3,"eqns=",eqns];

(* solve it *)
Which[
	method=="Solve",
	unks=nonfixedvars;
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@solveopts},PrintCall[Global`sol=Solve[eqns,unks,options]]]];
	sol=Solve[eqns,unks,Evaluate[Sequence@@solveopts]];
	If[Head[sol]===Solve,sol=Solve[eqns,unks,Reals,Evaluate[Sequence@@solveopts]]]
	,

	method=="NSolve",
	unks=nonfixedvars;
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@nsolveopts},PrintCall[Global`sol=NSolve[eqns,unks,options]]]];
	sol=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]];
	If[Head[sol]===NSolve,sol=NSolve[eqns,unks,Reals,Evaluate[Sequence@@nsolveopts]]]
	,

	method=="FindRoot",
	unks=Table[
		newunk={var,(var/.Append[init,var->0])};
		If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
		newunk,{var,nonfixedvars}];
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@findrootopts},PrintCall[Global`sol=FindRoot[eqns,unks,options]]]];
	sol=FindRoot[eqns,unks,Evaluate[Sequence@@findrootopts]],

	method=="FindRoots",
	unks=vars;
	VPrint[3,"unks=",unks];
	If[verbosity>=1,
		With[{eqns=eqns,unks=unks,options=Sequence@@findrootsopts},PrintCall[Global`sol=FindRoots[eqns,unks,options]]]];
	sol=FindRoots[eqns,unks,Evaluate[Sequence@@findrootsopts]],
	Else,
	Message[EcoEq::badmtd];Return[$Failed];
];

VPrint[3,"sol=",sol];
If[MemberQ[{Solve,NSolve},Head[sol]],Message[EcoEq::nosol,Head[sol]];Return[$Failed]];

(* add in Fixed variables *)
Which[
	MemberQ[{"Solve","NSolve","FindRoots"},method],
	res=Join[DeleteCases[fixed,var_->var_],#]& /@ sol,
	method=="FindRoot",
	res=Join[DeleteCases[fixed,var_->var_],sol]
];

If[chop,
	Return[SortRuleList[EqSort[Chop[res]],AllVariables]],
	Return[SortRuleList[EqSort[res],AllVariables]]
];

]];


Options[EcoEq]={Method->Automatic,
SolveOpts->{},NSolveOpts->{Method->"EndomorphismMatrix"},FindRootOpts->{},FindRootsOpts->{},
PerCapita->False,Fixed->{},Chop->True,QSS->False,Time->t,Verbose->False,Verbosity->0,IgnoreVar->False};


(* break up combined traitsandpops *)
SolveEcoEq[sol_?AttributesAndGsQ,opts___?OptionQ]:=SolveEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],opts];
NSolveEcoEq[sol_?AttributesAndGsQ,opts___?OptionQ]:=NSolveEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],opts];
FindEcoEq[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=((*Print["breaking AVG"];*)FindEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],ExtractVariables[sol],opts]);
FindEcoEq[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=FindEcoEq[ExtractAttributes[sol],ExtractVariables[sol],opts];


SolveEcoEq[args___]:=EcoEq[args,Method->"Solve"];
NSolveEcoEq[args___]:=EcoEq[args,Method->"NSolve"];
FindEcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},init:(_?VariablesQ):{},opts___?OptionQ]:=
	EcoEq[attributesin,Gsin,init,opts,Method->"FindRoot"];
FindEcoEq[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},vars__List,opts___?OptionQ]:=
	EcoEq[attributesin,Gsin,vars,opts,Method->"FindRoots"];


EcoEq::noneq=
"Can't find equilibrium of periodically forced model with FindRoot.  Give Time option or try FindEcoCycle instead.";
EcoEq::nosol="`1` couldn't find a solution.  Try FindEcoEq instead.";
EcoEq::badmtd="Method is not known (\"Solve\",\"NSolve\",\"FindRoot\",\"FindRoots\").";


FindEcoCycle::usage = 
"FindEcoCycle[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological limit cycle using initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoCycle[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


FindEcoCycle[attributesin:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts:OptionsPattern[]]:=

Module[{
(* options *)
verbose,period,method,monitor,printtrace,
findrootopts,ecosimopts,maxiterations,accuracygoal,precisiongoal,logged,fixed,
triggervar,warmup1,warmup2,warmup3,wheneventopts,ignorevar,
(* other variables *)
attributes,Gs,nonfixedvars,fixedvars,extrema,triggerpos,triggerval,max,ics2,ics3,ics4,diff,tmax,eq,
ic,nb,thing,eqns,unks,logd,vars,unksics,ics,res,sol,per},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoCycle"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

monitor=OptionValue[Monitor];
printtrace=OptionValue[PrintTrace];
period=OptionValue[Period];
method=OptionValue[Method];
If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0,method="EcoSim",method="FixedPoint"]];
If[Global`debug,Print[func,": method=",method]];
findrootopts=OptionValue[FindRootOpts];
ecosimopts=OptionValue[EcoSimOpts];
maxiterations=OptionValue[MaxIterations];
accuracygoal=OptionValue[AccuracyGoal];
triggervar=OptionValue[TriggerVariable];
warmup1=OptionValue[WarmUp];
warmup2=OptionValue[WarmUp2];
warmup3=OptionValue[WarmUp3];
tmax=OptionValue[TMax];
wheneventopts=OptionValue[WhenEventOpts];
logged=OptionValue[Logged];
fixed=OptionValue[Fixed];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
ignorevar=OptionValue[IgnoreVar];

$FindEcoCycleSteps=0;

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* set up thing & unks *)
nonfixedvars=variables[[All,1]];
(*VPrint[3,"nonfixedvars=",nonfixedvars];*)

(* build various lists of vars *)
unks=Table[eq[var],{var,nonfixedvars}];
vars=Table[If[logged&&comptype[var]==="Extensive",Log[var],var],{var,nonfixedvars}];
ics=vars/.variables;
unksics=Transpose[{unks,ics}];
logd=Table[If[logged&&comptype[var]==="Extensive",True,False],{var,nonfixedvars}];

VPrint[3,"unks=",unks];
VPrint[3,"unksics=",unksics];
VPrint[3,"ics=",ics];
VPrint[3,"logd=",logd];
VPrint[3,"vars=",vars];


(* "EcoSim" method for unforced ContinuousTime models *)

If[method==="EcoSim",

	If[!(modeltype=="ContinuousTime"&&modelperiod==0),Message[FindEcoCycle::noecosim];Return[$Failed]];
	If[triggervar===Automatic,
		If[Length[Select[variables,#[[2]]!=0&]]!=0,
			triggervar=SelectFirst[variables,#[[2]]!=0&][[1]],
			Message[FindEcoCycle::notriggervar];Return[$Failed]
		];
		VPrint[1,"triggervar=",triggervar];
	];
	triggerpos=Position[nonfixedvars,triggervar][[1,1]];

	(* warmup #1 to get on limit cycle *)
	ics2=If[warmup1>0,
		FinalSlice[EcoSim[attributes,Gs,variables,warmup1,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]],
		variables];
	VPrint[1,"ics2=",ics2];
	
	(* warmup #2 to find maxima *)
	extrema={};
	EcoSim[attributes,Gs,ics2,warmup2,WhenEvents->{
		WhenEvent[event,AppendTo[extrema,Table[var[t],{var,nonfixedvars}]],Evaluate[Sequence@@wheneventopts]]
		/.event->(triggervar'[t]==0)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

	If[extrema=={},Message[FindEcoCycle::nomaxima];Return[$Failed]];

	max=Last@Sort[extrema,#1[[triggerpos]]<#2[[triggerpos]]&];
	ics3=Table[nonfixedvars[[i]]->max[[i]],{i,Length[nonfixedvars]}];
	VPrint[1,"ics3=",ics3];
	
	(* warmup #3 to move a wee bit beyond the maximum *)
	ics4=FinalSlice[EcoSim[attributes,Gs,ics3,warmup3,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]];

	VPrint[1,"ics4=",ics4];

	Do[
		triggerval=triggervar/.ics4;
		sol=EcoSim[attributes,Gs,ics4,tmax,WhenEvents->{
			WhenEvent[event,"StopIntegration",Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar[t]<triggerval)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

		diff=Sum[Abs[(var/.FinalSlice[sol])-(var/.ics4)],{var,nonfixedvars}];
		If[diff<10^-accuracygoal,Break[]];

		ics4=FinalSlice[sol];
	,{maxiterations}];

	If[diff>10^-accuracygoal,Message[FindEcoCycle::cvmit,maxiterations]];

	(* make InterpolatingFunctions Periodic *)
	sol=sol/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if];
	
	Return[Sort[sol]];
];

(* "FixedPoint" or "FindRoot" method *)

If[(modeltype=="ContinuousTime"&&modelperiod==0),
	AppendTo[unks,per];
	AppendTo[unksics,{per,period}];
	AppendTo[ics,period];
,
	If[period===Automatic,per=modelperiod,per=period];
];

VPrint[3,"unks=",unks];
VPrint[3,"unksics=",unksics];
VPrint[3,"ics=",ics];

If[monitor,
	nb=CreateDialog[{
		TextCell["evaluation: "],
		Dynamic[$FindEcoCycleSteps],
		TextCell["vars:"],
		Dynamic[FinalSlice[sol]]
	},
	WindowTitle->"FindEcoCycle Progress...",WindowSize->All];
];


(* function to advance model *)

thing[ps_?NumericListQ]:=Module[{popz,rez},
	$FindEcoCycleSteps++;
	If[(modeltype=="ContinuousTime"&&modelperiod==0),tmax=ps[[-1]],tmax=per];
	popz=Table[If[logd[[i]],nonfixedvars[[i]]->E^ps[[i]],nonfixedvars[[i]]->ps[[i]]],{i,Length[nonfixedvars]}];
	sol=EcoSim[attributes,Gs,popz,tmax,Fixed->fixed,Evaluate[Sequence@@ecosimopts],Logged->logged];
	rez=vars/.FinalSlice[sol];
	If[(modeltype=="ContinuousTime"&&modelperiod==0),AppendTo[rez,ps[[-1]]]];
	If[printtrace,Print[$FindEcoCycleSteps,": ",FinalSlice[sol]]];
	Return[rez];
];

Which[
	method=="FindRoot",
	VPrint[3,"Method FindRoot"];
	res=FindRoot[thing[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]]
,
	method=="FixedPoint",
	VPrint[3,"Method FixedPoint"];
	res=FixedPoint[thing[#]&,ics,maxiterations,SameTest->(Max[Abs[#1-#2]]<10^-accuracygoal&)];
	If[$FindEcoCycleSteps==maxiterations,Message[FindEcoCycle::cvmit,maxiterations];Return[$Failed]]
,
	Else,
	Message[FindEcoCycle::badmtd];Return[$Failed]
];

If[modeltype=="DiscreteTime",(* drop last point *)
	sol=ReplaceAll[sol,
		{(var_->td_List):>(var->Drop[td,-1]),(var_->td_TemporalData)->(var->TimeSeriesWindow[td,{0,per-1}])}]
];

(* make InterpolatingFunctions Periodic *)
sol=sol/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if];

(* return answer *)

If[monitor,NotebookClose[nb]];

Return[Sort[sol]];

]];


Options[FindEcoCycle]={Verbose->False,Verbosity->0,
Method->Automatic,Fixed->{},FindRootOpts->{},EcoSimOpts->{},MaxIterations->100,AccuracyGoal->6,Logged->False,
WarmUp->1000,WarmUp2->100,WarmUp3->0.1,TMax->1000,TriggerVariable->Automatic,
WhenEventOpts->{"DetectionMethod"->"Interpolation","LocationMethod"->{"Brent",MaxIterations->1000}},
Period->Automatic,
Monitor->False,PrintTrace->False,IgnoreVar->False
};


(* split traitsandvariables *)
FindEcoCycle[traitsandvariables_?AttributesAndVariablesQ,opts:OptionsPattern[]]:=
FindEcoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],opts];


FindEcoCycle::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoCycle::nomaxima=
"Found no maxima in warmup #3, probably not periodic solution.";

FindEcoCycle::badmtd=
"The Method option should be a built-in method name (\"FindRoot\", \"FixedPoint\", \"EcoSim\" or \"Automatic\")";

FindEcoCycle::noecosim=
"\"EcoSim\" Method only applicable to unforced ContinuousTime models.";

FindEcoCycle::notriggervar=
"Found no non-zero variable to set as trigger variable. Give one manually with option \"TriggerVar\".";


$FindEcoCycleSteps::usage="Counts the number of EcoSim calls in FindEcoCycle.";


EcoJacobian::usage = 
"EcoJacobian[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] returns the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"sol\", \"TI\"]\).
EcoJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


(* make listable across pops *)
EcoJacobian[attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=(EcoJacobian[attributes,Gsin,#,opts]&/@variables);


EcoJacobian[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,time,fixed,
(* other variables *)
attributes,fixedvars,Gs,eqns,unks,jmat},

Block[{\[ScriptCapitalN],verbosity,func="EcoJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoJacobian]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoJacobian]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoJacobian]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoJacobian]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoJacobian]}]];
verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoJacobian]}]];

fixedvars=fixed[[All,1]];

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Join[Gsin,ExtractVarCovs[attributesin]]==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}
];

(*Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]\[Rule]\[ScriptCapitalN][gu],{gu,guilds}]];*)
VPrint[3,"Gs=",Gs];

eqns=EcoEqns[attributes,opts]/.RHS/.Gs/.t->time;
VPrint[1,"eqns=",eqns];

unks=OrderedComplement[AllVariables,fixedvars];
VPrint[1,"unks=",unks];

(* set up jacobian *)
jmat=D[eqns,{unks}];
VPrint[3,"jmat=",jmat];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&(variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t,
	Return[TimeSeries[Table[{t\[Prime],jmat/.AddVariablets/.t->t\[Prime]},{t\[Prime],variables[[1,2]]["Times"]}]/.variables/.attributes]];
,
	(* ContinuousTime cycle *)
	variables!={}&&(variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinuousTime"&&modelperiod=!=0))&&time===t,
	Return[jmat/.AddVariablets/.variables/.attributes];
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	If[time===t,
		Return[jmat/.variables/.attributes],
		Return[jmat/.Slice[variables,time]/.attributes]
	];
];

]];


(* break up combined traitsandpops *)
EcoJacobian[traitsandpops_List,opts___?OptionQ]:=
EcoJacobian[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoJacobian]={Verbose->False,Verbosity->0,
Time->t,Fixed->{}};


EcoEigenvalues::usage = 
"EcoEigenvalues[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] returns the eigenvalues of the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"sol\", \"TI\"]\).
EcoEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


(* make listable across pops *)
EcoEigenvalues[attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=(EcoEigenvalues[attributes,Gsin,#,opts]&/@variables);


EcoEigenvalues[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,chop,time,ndsolveopts,multipliers,fixed,ignorevar,
(* other variables *)
attributes,j,dim,per,xsol,res},

Block[{\[ScriptCapitalN],verbosity,func="EcoJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEigenvalues]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEigenvalues]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEigenvalues]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEigenvalues]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEigenvalues]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEigenvalues]}]];
multipliers=Evaluate[Multipliers/.Flatten[{opts,Options[EcoEigenvalues]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEigenvalues]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEigenvalues]}]];

attributes=FixAttributes[attributesin];

j=EcoJacobian[attributes,Gsin,variables,Time->time,Fixed->fixed,IgnoreVar->ignorevar];
VPrint[1,"j=",j];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&((variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t),
	res=Eigenvalues[ListMultiplier[Table[j[t\[Prime]],{t\[Prime],j["Times"]}]]]
,
	(* ContinousTime cycle *)
	variables!={}&&((variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinousTime"&&modelperiod=!=0))&&time===t),
	dim=Length[j];
	per=FinalTime[variables];
	xsol=NDSolve[{x'[t]==j . x[t],x[0]==IdentityMatrix[dim]},x,{t,0,per},Sequence@@ndsolveopts][[1]];
	If[Global`debug,Print[func,": x[per]/.xsol=",x[per]/.xsol]];
	If[multipliers,
		res=Eigenvalues[x[per]/.xsol],
		res=Log[Chop[Eigenvalues[x[per]/.xsol]]]/per
	]
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	res=Eigenvalues[j/.t->time]
];

If[chop,Return[Chop[res]],Return[res]];

]];


EcoEigenvalues[traitsandpops_?AttributesAndVariablesQ,opts___?OptionQ]:=EcoEigenvalues[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoEigenvalues]={Verbose->False,Verbosity->0,
Chop->True,Time->t,NDSolveOpts->{},Multipliers->False,Fixed->{},IgnoreVar->False};


EcoStableQ::usage=
"EcoStableQ[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] reports the linear stability of ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) as True, False, or Indeterminate.
EcoStableQ[\!\(\*
StyleBox[\"attribues\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


(* make listable across variables *)
EcoStableQ[attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=(EcoStableQ[attributes,Gsin,#,opts]&/@variables);


EcoStableQ[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{
(* options *)
method,verbose,time,ecoeigenvaluesopts,tolerance,simplifyresult,simplifyopts,fixed,ignorevar,
(* other variables *)
attributes,j,evs,res},

Block[{\[ScriptCapitalN],verbosity,func="EcoJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoStableQ]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoStableQ]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoStableQ]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[EcoStableQ]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoStableQ]}]];
ecoeigenvaluesopts=Evaluate[EcoEigenvaluesOpts/.Flatten[{opts,Options[EcoStableQ]}]];
tolerance=Evaluate[Tolerance/.Flatten[{opts,Options[EcoStableQ]}]];
simplifyresult=Evaluate[SimplifyResult/.Flatten[{opts,Options[EcoStableQ]}]];
simplifyopts=Evaluate[SimplifyOpts/.Flatten[{opts,Options[EcoStableQ]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoStableQ]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoStableQ]}]];

(* fix attributes *)
attributes=FixAttributes[attributesin];

If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0&&InterpolatingFunctionFunctionQ[variables]==False&&Length[variables]<4,
		method="RouthHurwitz",
		method="Eigenvalues"
	];
	VPrint[3,"method=",method];
];

Which[
	method=="RouthHurwitz",
	j=EcoJacobian[attributes,Gsin,variables,Time->time,Fixed->fixed,IgnoreVar->ignorevar];
	res=RouthHurwitzCriteria[j];
,
	method=="Eigenvalues",
	evs=EcoEigenvalues[attributes,Gsin,variables,Time->time,Fixed->fixed,IgnoreVar->ignorevar,Evaluate[Sequence@@ecoeigenvaluesopts]];
	VPrint[1,"evs=",evs];
	If[tolerance===Automatic,If[NumericQ[Max[Re[evs]]],tolerance=10^-8,tolerance=0]];
	(*Print["tolerance=",tolerance];*)
	Which[
		modeltype=="DiscreteTime",
		res=Piecewise[{
			{True,Max[Abs[evs]]<1+tolerance},
			{False,Max[Abs[evs]]>1+tolerance}
		},Indeterminate],
		modeltype=="ContinuousTime",
		res=Piecewise[{
			{True,Max[Re[evs]]<tolerance},
			{False,Max[Re[evs]]>tolerance}
		},Indeterminate];
	];
];

VPrint[3,"res=",res];

Which[
	simplifyresult===True,
	CheckAssumptions;
	Return[Simplify[res,Evaluate[Sequence@@simplifyopts]]],
	simplifyresult===Full,
	CheckAssumptions;
	Return[FullSimplify[res,Evaluate[Sequence@@simplifyopts]]],
	simplifyresult===Real,
	CheckAssumptions;
	Return[RealSimplify[res,Evaluate[Sequence@@simplifyopts]]],
	Else,
	Return[res]
];


]];


(* break up combined traitsandpops *)
EcoStableQ[traitsandpops_?AttributesAndVariablesQ,opts___?OptionQ]:=
EcoStableQ[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoStableQ]={Verbose->False,Verbosity->0,
Method->Automatic,SimplifyResult->Real,SimplifyOpts->{Assumptions:>DeleteCases[$Assumptions,False]},
Time->t,EcoEigenvaluesOpts->{},Tolerance->Automatic,Fixed->{},IgnoreVar->False};


SelectEcoStable::usage=
"SelectEcoStable[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects stable equilibria from \!\(\*
StyleBox[\"sol\", \"TI\"]\).
SelectEcoStable[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


SelectEcoStable[attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},sol_?ListOfVariablesQ,opts___?OptionQ]:=
Module[{stableqopts},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

stableqopts=FilterRules[Flatten[{opts,Options[SelectEcoStable]}],Options[EcoStableQ]];

Return[Select[sol,EcoStableQ[attributes,Gsin,#,Evaluate[Sequence@@stableqopts]]&]]

];


SelectEcoStable[attributes:(_?AttributesQ):{},{},opts___?OptionQ]:={};


Options[SelectEcoStable]={};


FindEcoAttractor::usage=
"FindEcoAttractor[] tries to find an ecological attractor.
FindEcoAttractor[\!\(\*
StyleBox[\"init\", \"TI\"]\)] uses initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoAttractor[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
FindEcoAttractor[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and \!\(\*
StyleBox[\"init\", \"TI\"]\).";


FindEcoAttractor[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},variables:(_?VariablesQ):{},vars:(_List|All):All,opts___?OptionQ]:=

Module[{
(*options*)
verbose,method,chop,numtries,eqtolerance,
solveecoeqopts,nsolveecoeqopts,findecoeqopts,ecosimopts,findecocycleopts,
warmup,tmax,finaltmax,eqthreshold,time,period,maxperiod,maxperiodmultiplier,
testvalidity,teststability,fixed,ignorevar,
(*other variables*)
attributes,Gs,nonvars,eq,valideq,tmp,evs,ics,stableeq,res,essol,ddt,eqflag,per,ecosimflag},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoAttractor"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoAttractor]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoAttractor]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[!MemberQ[{Automatic,"SolveEcoEq","NSolveEcoEq","FindEcoEq","EcoSim","FindEcoCycle"},method],
	Message[FindEcoAttractor::badmtd];Return[$Failed]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoAttractor]}]];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqtolerance=Evaluate[EqTolerance/.Flatten[{opts,Options[FindEcoAttractor]}]];
solveecoeqopts=Evaluate[SolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
nsolveecoeqopts=Evaluate[NSolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecoeqopts=Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecocycleopts=Evaluate[FindEcoCycleOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
warmup=Evaluate[WarmUp/.Flatten[{opts,Options[FindEcoAttractor]}]];
tmax=Evaluate[TMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[tmax===Automatic,If[modelperiod==0||modelperiod==\[Infinity],tmax=1000,tmax=100*modelperiod]];
finaltmax=Evaluate[FinalTMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[finaltmax===Automatic,finaltmax=tmax];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqthreshold=Evaluate[EqThreshold/.Flatten[{opts,Options[FindEcoAttractor]}]];
time=Evaluate[Time/.Flatten[{opts,Options[FindEcoAttractor]}]];
period=Evaluate[Period/.Flatten[{opts,Options[FindEcoAttractor]}]];
maxperiod=Min[tmax-1,Evaluate[MaxPeriod/.Flatten[{opts,Options[FindEcoAttractor]}]]];
maxperiodmultiplier=Evaluate[MaxPeriodMultiplier/.Flatten[{opts,Options[FindEcoAttractor]}]];
testvalidity=Evaluate[TestValidity/.Flatten[{opts,Options[FindEcoAttractor]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[FindEcoAttractor]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoAttractor]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[FindEcoAttractor]}]];

ecosimflag=False;

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

If[vars===All,
	nonvars={},
	nonvars=OrderedComplement[AllVariables,vars]
];
(*Print["nonvars=",nonvars];*)

fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->0),1]];
(*Print["fixed=",fixed];*)

solveecoeqopts=Join[solveecoeqopts,{Fixed->fixed,IgnoreVar->ignorevar}];
nsolveecoeqopts=Join[nsolveecoeqopts,{Fixed->fixed,IgnoreVar->ignorevar}];
findecoeqopts=Join[findecoeqopts,{Fixed->fixed,IgnoreVar->ignorevar}];
ecosimopts=Join[ecosimopts,{Fixed->fixed,IgnoreVar->ignorevar}];
findecocycleopts=Join[findecocycleopts,{Fixed->fixed,IgnoreVar->ignorevar}];

If[method===Automatic,
	Which[
		modelperiod==\[Infinity]&&time===t,
		method="EcoSim",
		0<modelperiod<\[Infinity]&&time===t,
		method="FindEcoCycle",
		variables=={},
		method="NSolveEcoEq",
		Else,
		If[nauxs+npops+Sum[\[ScriptCapitalN][gu]*ngcomps[gu],{gu,guilds}]-Length[fixed]<=4,
			method="NSolveEcoEq",
			method="FindEcoEq"
		];
	];
];
VPrint[3,"method=",method];

Which[
	method=="EcoSim",Goto[ecosim],
	method=="FindEcoCycle",If[icsin=={},Message[FindEcoAttractor::novars,"FindEcoCycle"];Return[$Failed],ics=icsin];
	Goto[findecocycle]
];


(* method FindEcoEq *)

If[method=="FindEcoEq",
	VPrint[1,"FindEcoEq Mode"];
	If[variables=={},Message[FindEcoAttractor::novars,"FindEcoEq"];Return[$Failed]];
	If[warmup>0,
		VPrint[1,"Warming Up..."];
		If[verbosity>=1,
			With[{warmup=warmup,time=time,attributes=attributes,Gs=Gs,options=Sequence@@ecosimopts},
				PrintCall[Global`ics=FinalSlice[EcoSim[attributes,Gs,variables,warmup,Time->time,options]]]]
		];
		ics=FinalSlice[EcoSim[attributes,Gs,variables,warmup,Time->time,Evaluate[Sequence@@ecosimopts]]];
	, (* else *)
		ics=variables;
	];
	If[verbosity>=1,
		With[{ics=ics,time=time,attributes=attributes,Gs=Gs,options=Sequence@@findecoeqopts},
			PrintCall[Global`eq=FindEcoEq[attributes,Gs,ics,Time->time,options]]]
	];
	eq={FindEcoEq[attributes,Gs,ics,Time->time,Evaluate[Sequence@@findecoeqopts]]};

	(* try more initial conditions if required *)

	If[numtries>=2,
		Do[
			(* perturb ICs *)
			ics=ReplacePart[#,2->#[[2]]*10^RandomReal[{-1,1}]]& /@ variables;
			If[verbosity>=1,
				With[{ics=ics,time=time,attributes=attributes,Gs=Gs,options=Sequence@@findecoeqopts},
					PrintCall[Global`tmp=FindEcoEq[attributes,Gs,ics,Time->time,options]]]
			];
			tmp=FindEcoEq[attributes,Gs,ics,Time->time,Evaluate[Sequence@@findecoeqopts]];
			(* if distinct eq, add to tmp *)
			If[tmp!={},
				If[CompoundAnd[Table[RuleListDistance[tmp,bar,DistanceFunction->ChessboardDistance]>eqtolerance,{bar,eq}]],AppendTo[eq,tmp]];
			];
		,{numtries-1}];
	];	
];


(* method SolveEcoEq *)

If[method=="SolveEcoEq",
	VPrint[1,"SolveEcoEq Mode"];
	If[verbosity,
		With[{time=time,attributes=attributes,Gs=Gs,options=Sequence@@solveecoeqopts},
			PrintCall[Global`eq=SolveEcoEq[attributes,Gs,Time->time,options]]]
	];
	eq=SolveEcoEq[attributes,Gs,Time->time,Evaluate[Sequence@@solveecoeqopts]];
];


(* method NSolveEcoEq *)

If[method=="NSolveEcoEq",
	VPrint[1,"NSolveEcoEq Mode"];
	If[verbosity>=1,
		With[{time=time,attributes=attributes,Gs=Gs,options=Sequence@@nsolveecoeqopts},
			PrintCall[Global`eq=Union[NSolveEcoEq[attributes,Gs,Time->time,options]]]]
	];
	eq=Union[Flatten[{NSolveEcoEq[attributes,Gs,Time->time,Evaluate[Sequence@@nsolveecoeqopts]]},1]];
];


(* method FindEcoCycle *)

Label[findecocycle];
If[method=="FindEcoCycle",
	VPrint[1,"FindEcoCycle Mode"];
	If[variables=={},Message[FindEcoAttractor::novars,"FindEcoCycle"];Abort[]];

	(* figure out period to try *)
	If[period===Automatic,
		Which[
			modelperiod=!=0,
			per=modelperiod,
			modeltype=="DiscreteTime",
			per=1
		]
	,
		per=period
	];

	If[ecosimflag==False, (* if we haven't already been through ecosim *)
		If[warmup>0,
			VPrint[1,"Warming up..."];
			If[verbosity>=1,
				With[{warmup=warmup,per=per,time=time,attributes=attributes,Gs=Gs,options=Sequence@@ecosimopts},
					PrintCall[Global`ics=FinalSlice[EcoSim[attributes,Gs,variables,Floor[warmup,per],Time->time,options]]]]
			];
			ics=FinalSlice[EcoSim[attributes,Gs,variables,Floor[warmup,per],Time->time,Evaluate[Sequence@@ecosimopts]]];
		, (* else *)
			ics=variables;
		],
		ics=FinalSlice[essol] (* if we have been through ecosim *)
	];
	
	Which[
		modeltype=="DiscreteTime",
		If[verbosity>=1,
			With[{ics=ics,per=per,maxperiodmultiplier=maxperiodmultiplier,attributes=attributes,Gs=Gs,options=Sequence@@findecocycleopts},
				PrintCall[Global`eq=Table[FindEcoCycle[attributes,ics,Gs,options,Period->Global`permult*per],{Global`permult,maxperiodmultiplier}]]]
		];
		eq=Table[
			FindEcoCycle[attributes,ics,Gs,Evaluate[Sequence@@findecocycleopts],Period->permult*per]
		,{permult,maxperiodmultiplier}];
		(* remove $Failed & multiple period solutions *)
		eq=Select[eq,#=!=$Failed&&FindPeriod[#]==#[[1,2]]["PathLength"]&];
	,
		modeltype=="ContinuousTime",
		If[verbosity>=1,
			With[{ics=ics,attributes=attributes,Gs=Gs,options=Sequence@@findecocycleopts},
				PrintCall[Global`eq=FindEcoCycle[attributes,ics,Gs,options]]]
		];
		eq=Select[{FindEcoCycle[attributes,ics,Gs,Evaluate[Sequence@@findecocycleopts]]},#=!=$Failed&]
	];	
];

VPrint[1,"eq=",eq];


(* assess validity and stability of eq *)

If[testvalidity,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		valideq={}
	, 
		If[Head[eq[[1,1,2]]]=!=InterpolatingFunction,
			valideq=SelectValid[eq];
			VPrint[1,"valideq=",valideq];
		,
			valideq=eq (* SelectValid doesn't work on InterpolatingFunctions yet *)
		]
	];
	If[valideq=={},Message[FindEcoAttractor::novalideq]];
];

If[teststability,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		stableeq={}
	,
		stableeq=SelectEcoStable[attributes,Gs,valideq,Time->time,Fixed->fixed,IgnoreVar->ignorevar];
		VPrint[1,"stableeq=",stableeq];
	]
,
	stableeq=valideq
];

If[Length[stableeq]==0, (* no stable eq, try EcoSim once *)
	If[ecosimflag==False,
		Message[FindEcoAttractor::nosteq,attributes];
		method="EcoSim"
	,
		Message[FindEcoAttractor::giveup];
		(*Return[EcoSim[attributes,FinalSlice[essol],finaltmax,Time\[Rule]time,Evaluate[Sequence@@ecosimopts],VerboseAll\[Rule]verboseall]]*)
		Return[essol]
	]
];
If[Length[stableeq]==1,res=stableeq[[1]];Goto[done]]; (* successful *)
If[Length[stableeq]>=2,Message[FindEcoAttractor::musteq,Length[stableeq],attributes];method="EcoSim"(*;Goto[done]*)];


(* if we're still here, no stable equilibrium, so switch to EcoSim *)

(* method EcoSim *)

Label[ecosim];
If[method=="EcoSim",
	VPrint[1,"EcoSim Mode"];
	If[variables=={},Message[FindEcoAttractor::novars,"EcoSim"];Abort[]];
	
	If[Length[ics]==0,ics=variables];
	
	If[verbosity>=1,
		With[{ics=ics,tmax=tmax,time=time,attributes=attributes,Gs=Gs,options=Sequence@@ecosimopts},
			PrintCall[Global`essol=EcoSim[attributes,Gs,ics,tmax,Time->time,options]]]
	];

	Global`essol=essol=EcoSim[attributes,Gs,ics,tmax,Time->time,Evaluate[Sequence@@ecosimopts]];
	VPrint[1,PlotDynamics[essol]];
	
	(* if aperiodically forced, we're done *)
	If[modelperiod===\[Infinity],res=essol;Goto[done]];
	
	(* otherwise check for equilibrium (or modelperiod cycle) *)
	If[0<modelperiod,
		ddt=FinalDerivatives[essol,modelperiod][[All,2]],
		ddt=FinalDerivatives[essol][[All,2]]
	];
	VPrint[1,"d/dt=",ddt];
	If[Max[Abs[ddt]]<eqthreshold,
		VPrint[1,": Equilibrium found"];
		(* construct stableeq *)
		If[modelperiod=!=0,
			If[modeltype=="ContinuousTime",res=FinalSlice[essol,modelperiod]];
			If[modeltype=="DiscreteTime",res=FinalSlice[essol,modelperiod-1]]
		,
			res=FinalSlice[essol]
		];
		Goto[done];
	,
		(* steady state eq failed *)
		Message[FindEcoAttractor::nostst,ddt,tmax];
		If[SelectValid[{FinalSlice[essol]}]!={},
			(* attempt to find Period using FindEcoCycle approach *)
			ecosimflag=True; (* already been through ecosim *)
			method="FindEcoCycle";
			ics=FinalSlice[essol];
			period=FindPeriod[essol,MaxPeriod->maxperiod];
			Goto[findecocycle],
			Message[FindEcoAttractor::giveup2];
			Return[essol]
		];
	];
];

Label[done];

If[chop,
	Return[Chop[res]],
	Return[res]
];

]];


Options[FindEcoAttractor]={Verbose->False,Verbosity->0,
Method->Automatic,Chop->True,NumTries->1,EqTolerance->10^-10;
SolveEcoEqOpts->{},NSolveEcoEqOpts->{},FindEcoEqOpts->{},EcoSimOpts->{},FindEcoCycleOpts->{},
WarmUp->0,TMax->Automatic,EqThreshold->10^-5,Time->t,Period->Automatic,MaxPeriod->16,MaxPeriodMultiplier->2,
TestValidity->True,TestStability->True,FinalTMax->Automatic,Fixed->{},IgnoreVar->False};


FindEcoAttractor::badmtd=
"The Method option should be a built-in method name (\"SolveEcoEq\", \"NSolveEcoEq\", \"FindEcoEq\", or \"EcoSim\")";

FindEcoAttractor::novars=
"No initial population sizes given, cannot continue with `1`.";

FindEcoAttractor::nocycle=
"Warning: couldn't find a cycle with period less than MaxPeriod=`1`.";

FindEcoAttractor::novalideq=
"Couldn't find a valid equilibrium.";

FindEcoAttractor::giveup=
"Couldn't find an equilibrium or cycle, returing EcoSim.";

FindEcoAttractor::nosteq=
"Warning: couldn't find a stable equilibrium with attributes `1`. Trying EcoSim.";

FindEcoAttractor::musteq=
"Warning: found `1` stable equilibria with attributes `2`.";

FindEcoAttractor::nostst=
"Warning: EcoSim did not find a steady state (d/dt=`1` at t=`2`). Trying FindEcoCycle.";


PlotEcoIsoclines::usage =
"PlotEcoIsoclines[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoIsoclines[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)},{\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoIsoclines[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,fixed,time,percapita,isoclinestyle,framelabel,contourplotopts,ignorevar,
(* other variables *)
attributes,Gs,fixedvars,nonfixedvars,lookup1,lookup2,style1,style2,label1,label2,g,res1,res2},

Block[{\[ScriptCapitalN],verbosity,func="PlotEcoIsoclines"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoIsoclines]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoIsoclines]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];

time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
(*isoclinelabels=Evaluate[IsoclineLabels/.Flatten[{opts,Options[PlotEcoIsoclines]}]];*)
{label1,label2}={ToString[var1],ToString[var2]};

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* figure out what are the components on the x- and y-axes *)
lookup1=LookUp[var1];
lookup2=LookUp[var2];

(* set up isocline styles *)
Which[
	lookup1[[1]]=="gcomp",
	style1=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var1]}],{Thickness[0.005],Color[var1][0]}],isoclinestyle[[1]]],
	lookup1[[1]]=="pcomp"||lookup1[[1]]=="aux",
	style1=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var1]}],{Thickness[0.005],Color[var1]}],isoclinestyle[[1]]]
];

Which[
	lookup2[[1]]=="gcomp",
	style2=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var2]}],{Thickness[0.005],Color[var2][1]}],isoclinestyle[[2]]],
	lookup2[[1]]=="pcomp"||lookup2[[1]]=="aux",
	style2=If[isoclinestyle===Automatic,Join[Flatten[{LineStyle[var2]}],{Thickness[0.005],Color[var2]}],isoclinestyle[[2]]]
];

(*Print[{style1,style2}];*)

nonfixedvars={var1,var2};

(* look for aux and pcomps not in the vars, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

contourplotopts=FilterRules[Flatten[{opts,ContourShading->None,Options[PlotEcoIsoclines]}],Options[ContourPlot]];
(*Print["contourplotopts=",contourplotopts];*)

g=(EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,IgnoreVar->ignorevar,opts]/.RHS/.Gs/.{t->time})
	-Which[modeltype=="DiscreteTime"&&percapita==False,{var1,var2},modeltype=="DiscreteTime"&&percapita==True,{1,1},Else,{0,0}];
VPrint[1,"g=",g];

res1=ContourPlot[g[[1]]==0,{var1,var1min-10^-8(var1max-var1min),var1max},{var2,var2min-10^-8(var2max-var2min),var2max},
	ContourStyle->style1,Evaluate[Sequence@@contourplotopts],FrameLabel->framelabel,
	ContourLabels->{None,Tooltip[Null,DisplayForm[OverDot[var1]==0]]&}];
	
res2=ContourPlot[g[[2]]==0,{var1,var1min-10^-8(var1max-var1min),var1max},{var2,var2min-10^-8(var2max-var2min),var2max},
	ContourStyle->style2,Evaluate[Sequence@@contourplotopts],FrameLabel->framelabel,
	ContourLabels->{None,Tooltip[Null,DisplayForm[OverDot[var2]==0]]&}];

If[monitor,NotebookClose[nb]];

Return[Show[res1,res2]]

]];


Options[PlotEcoIsoclines]={Verbose->False,Verbosity->0,
Time->t,PerCapita->False,Fixed->{},IgnoreVar->False,IsoclineStyle->Automatic,FrameLabel->Automatic,MaxRecursion->5};


PlotEcoStreams::usage =
"PlotEcoStreams[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoStreams[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoStreams[attributesin:(_?AttributesQ):{},Gsin:(_?GsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoStreams"],
(* options *)
verbose,verboseall,fixed,time,framelabel,streamplotopts,ignorevar,
(* other variables *)
attributes,Gs,fixedvars,nonfixedvars,g,res},

Block[{\[ScriptCapitalN],verbosity,func="PlotEcoStreams"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoStreams]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoStreams]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoStreams]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];

time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoStreams]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[PlotEcoStreams]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEcoStreams]}],Options[StreamPlot]];

nonfixedvars={var1,var2};

(* fix attributes *)
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs - default = ZeroMatrix *)
VPrint[3,"Gsin=",Gsin];
If[moments,
	If[Gsin==={},Gs=ZeroGs,Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]],
	Gs={}];
VPrint[3,"Gs=",Gs];

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

g=(EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,IgnoreVar->ignorevar,opts]/.RHS/.Gs/.{t->time})
	-If[modeltype=="DiscreteTime",{var1,var2},{0,0}];
VPrint[1,"g=",g];

res=MyStreamPlot[g,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@streamplotopts],PlotRange->{{0,1},{0,1}},FrameLabel->framelabel];
		
If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotEcoStreams]={Verbose->False,Verbosity->0,
Fixed->{},Time->t,IgnoreVar->False,FrameLabel->Automatic,PlotRangePadding->Scaled[0.02],StreamStyle->Gray,StreamColorFunction->None};


PlotEcoPhasePlane::usage=
"PlotEcoPhasePlane[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams and isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoPhasePlane[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoPhasePlane[attributes:(_?AttributesQ):{},Gsin:(_?GsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{nonfixedvars,eq,Gs,
(* options *)
fixed,fixedvars,
findecoeqopts,plotecoisoclinesopts,plotecostreamsopts,ecostableqopts,rulelistplotopts,
verbose},

Block[{verbosity},

(* handle options *)

plotecoisoclinesopts=FilterRules[
	Flatten[{Evaluate[PlotEcoIsoclinesOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoIsoclines],Options[ContourPlot]]];
plotecostreamsopts=FilterRules[
	Flatten[{Evaluate[PlotEcoStreamsOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoStreams],Options[StreamPlot]]];
findecoeqopts=FilterRules[
	Flatten[{Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Options[EcoEq]];
ecostableqopts=FilterRules[
	Flatten[{Evaluate[EcoStableQOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Options[EcoStableQ]];
rulelistplotopts=Evaluate[RuleListPlotOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]];
	
(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoPhasePlane]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoPhasePlane]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoPhasePlane]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

eq=FindEcoEq[attributes,Gsin,{var1,var1min,var1max},{var2,var2min,var2max},findecoeqopts];
VPrint[1,"eq=",eq];

Return[Show[DeleteNulls[{
	PlotEcoStreams[attributes,Gsin,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecostreamsopts]],
	PlotEcoIsoclines[attributes,Gsin,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecoisoclinesopts]],
	If[eq!={},
		RuleListPlot[eq,{var1,var2},PlotMarkers->EcoStableQ[attributes,Gsin,eq,Evaluate[Sequence@@ecostableqopts]],
		Evaluate[Sequence@@rulelistplotopts]]
	]
}]]]

]];


Options[PlotEcoPhasePlane]={
Fixed->{},Time->t,FrameLabel->Automatic,
PlotEcoIsoclinesOpts->{},PlotEcoStreamsOpts->{},EcoStableQOpts->{},RuleListPlotOpts->{},FindEcoEqOpts->{},
Verbose->False,Verbosity->0};


PrestonPlot::usage =
"PrestonPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] makes a Preston species abundance distribution plot based on \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PrestonPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PrestonPlot"],
(* options *)
gu,minpop,bandwidth,kernel,scaled,showspecies,markerstyle,plotopts,listplotopts,plotrange,axesorigin,weightfunction,time,plotstyle,
coresatellite,plotmarkers,plotmin,
(* other variables *)
f,abunds,data,points,\[ScriptCapitalD],hist,stix
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[PrestonPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[PrestonPlot]}]];
bandwidth=Evaluate[Bandwidth/.Flatten[{opts,Options[PrestonPlot]}]];
kernel=Evaluate[Kernel/.Flatten[{opts,Options[PrestonPlot]}]];
scaled=Evaluate[Scaled/.Flatten[{opts,Options[PrestonPlot]}]];
showspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PrestonPlot]}]];
plotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[Plot]];
If[Evaluate[ListPlotOpts/.{opts}]=!=ListPlotOpts,
	listplotopts=Evaluate[Join[ListPlotOpts/.{opts},ListPlotOpts/.Options[PrestonPlot]]],
	listplotopts=Evaluate[ListPlotOpts/.Options[PrestonPlot]]
];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PrestonPlot]}]];
plotmin=Evaluate[PlotMin/.Flatten[{opts,Options[PrestonPlot]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[PrestonPlot]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PrestonPlot]}]];
axesorigin=Evaluate[AxesOrigin/.Flatten[{opts,Options[PrestonPlot]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PrestonPlot]}]];
coresatellite=Evaluate[CoreSatellite/.Flatten[{opts,Options[PrestonPlot]}]];

If[showspecies,
	plotmarkers=PlotMarkers/.listplotopts;
	If[plotmarkers==Automatic,
		If[coresatellite>0,
			plotmarkers={{"\[FilledSmallCircle]",9},{"\[SmallCircle]",12}},
			plotmarkers=Style["|",{Bold,12}]
		]
	]
];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][sol];

abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];

If[time===t,
	abunds=TemporalMean[abunds],
	abunds=Slice[abunds,time];
];

data=Select[abunds[[All,2]],#>minpop&];
If[plotmin===Automatic,plotmin=Min[data]];
If[coresatellite>0,
	Global`points=points={Select[data,#>=coresatellite&&#>=plotmin&],Select[data,plotmin<=#<coresatellite&]};
	\[ScriptCapitalD]1=SmoothKernelDistribution[Log[points[[1]]],0.01,{"Bounded",{Min[Log[data]],Max[Log[data]]},kernel}];
	\[ScriptCapitalD]2=SmoothKernelDistribution[Log[points[[2]]],bandwidth,{"Bounded",{Min[Log[data]],Max[Log[data]]},kernel}];
	\[ScriptCapitalD]=MixtureDistribution[{Length[points[[1]]],Length[points[[2]]]}/Length[Flatten@points],{\[ScriptCapitalD]1,\[ScriptCapitalD]2}];
,
	points=data;
	\[ScriptCapitalD]=SmoothKernelDistribution[Log[data],bandwidth,{"Bounded",{Min[Log[data]],Max[Log[data]]},kernel}];
];

If[scaled==True,f=1,f=Length[data]];

Which[
	axesorigin=="Left",axesorigin={Min[data],0},
	axesorigin=="Right",axesorigin={Max[data],0}
];
(*Print["axesorigin=",axesorigin];
Print["plotrange=",plotrange];*)

(*\[ScriptCapitalD]=SmoothKernelDistribution[data,bandwidth,{"Bounded",{Min[data],Max[data]},kernel}];*)
hist=LogLinearPlot[f*PDF[\[ScriptCapitalD],Log[x]],{x,plotmin,Max[data]},PlotStyle->plotstyle,PlotRange->plotrange,AxesOrigin->axesorigin];
(*Print[hist];*)
If[showspecies,
	stix=ListLogLinearPlot[
		points/.val_?NumericQ->{val,0},
		PlotMarkers->plotmarkers,
		Evaluate[Sequence@@listplotopts]
	],
	stix={}];
(*Print[stix];*)
Return[Show[hist,stix]];

]];


Options[PrestonPlot]={
Guild->Automatic,WeightFunction->"Total",Time->t,
MinPop->0,Bandwidth->"Scott",Kernel->"Gaussian",Scaled->True,
PlotStyle->Gray,
ShowSpecies->True,PlotRange->{0,All},AxesOrigin->{"Left","Bottom"},
ListPlotOpts->{PlotMarkers->Automatic,PlotStyle->Black},
CoreSatellite->0,PlotMin->Automatic};


WhittakerPlot::usage =
"WhittakerPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] makes a Whittaker rank-abundance plot based on \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


WhittakerPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WhittakerPlot"],
(* options *)
gu,minpop,listplotopts,weightfunction,time,coresatellite,scaled,
(* other variables *)
abunds,dat
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[WhittakerPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WhittakerPlot]}]];
listplotopts=FilterRules[Flatten[{opts,Options[WhittakerPlot]}],Options[ListLogPlot]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[WhittakerPlot]}]];
time=Evaluate[Time/.Flatten[{opts,Options[WhittakerPlot]}]];
coresatellite=Evaluate[CoreSatellite/.Flatten[{opts,Options[WhittakerPlot]}]];
scaled=Evaluate[Scaled/.Flatten[{opts,Options[WhittakerPlot]}]];


If[(PlotMarkers/.listplotopts)==Automatic,
	Which[
		(Filling/.listplotopts)===Axis,PrependTo[listplotopts,PlotMarkers->""],
		coresatellite>0,PrependTo[listplotopts,PlotMarkers->{{"\[FilledSmallCircle]",9},{"\[SmallCircle]",12}}],
		coresatellite==0,PrependTo[listplotopts,PlotMarkers->{"\[FilledSmallCircle]",9}]
	]
];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][sol];

abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];
If[time===t,
	abunds=TemporalMean[abunds],
	abunds=Slice[abunds,time];
];

abunds=Sort[Table[Subscript[gu,i],{i,Subscript[\[ScriptCapitalN], gu]}]/.abunds,Greater];
abunds=Select[abunds,#>minpop&];
If[scaled==True,
	dat=Transpose[{(Range[Length[abunds]]-1)/(Length[abunds]-1),abunds}],
	dat=Transpose[{Range[Length[abunds]],abunds}]
];

If[coresatellite>0,dat={Select[dat,#[[2]]>=coresatellite&],Select[dat,#[[2]]<coresatellite&]}];

Return[ListLogPlot[dat,Evaluate[Sequence@@listplotopts]]];

]];


Options[WhittakerPlot]={Guild->Automatic,MinPop->0,PlotRange->All,PlotMarkers->Automatic,WeightFunction->"Total",Time->t,CoreSatellite->0,Scaled->False};


PlotGuild::usage =
"PlotGuild[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots abundance vs trait/species for the species in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PlotGuild[attributesin:(_?AttributesQ):{},solin_?VariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=
Module[{
(* options *)
plottype,plotpoints,plotlayout,
listplotopts,arrayplotopts,listplot3dopts,listlineplot3dopts,plotopts,ridgelineplot3dopts,
logged,minpop,plotstyle,time,weightfunction,plotrange,
gu,tr,species,
coresatellite,plotmarkers,
(* other variables *)
traitrange,res,dat,tmin,tmax,framelabel,
sol,traits,abunds,pos,plotmin,xcoord,
plotrangemin,plotrangemax
},

Block[{\[ScriptCapitalN],verbosity,func="PlotGuild"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotGuild]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotGuild]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotGuild]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotGuild]}]];
plotlayout=Evaluate[PlotLayout/.Flatten[{opts,Options[PlotGuild]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotGuild]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[PlotGuild]}]];

listplotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ListPlot]],
	Evaluate[ListPlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
(*Print["listplotopts=",listplotopts];*)
arrayplotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ArrayPlot]],
	Evaluate[ArrayPlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
listplot3dopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ListPlot3D]],
	Evaluate[ListPlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]]];
listlineplot3dopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[MyListLinePlot3D]],
	Evaluate[ListLinePlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]]];
plotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[Plot]],
	Evaluate[PlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
(*Print["plotopts=",plotopts];*)
ridgelineplot3dopts=Evaluate[RidgelinePlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]];

plotpoints=Evaluate[PlotPoints/.Flatten[{opts,Options[PlotGuild]}]];
traitrange=Evaluate[TraitRange/.Flatten[{opts,Options[PlotGuild]}]];

gu=Evaluate[Guild/.Flatten[{opts,Options[PlotGuild]}]];
If[gu===Automatic,gu=guilds[[1]]];
tr=Evaluate[Trait/.Flatten[{opts,Options[PlotGuild]}]];
If[tr===Automatic,If[gtraits[gu]=!={},tr=gtraits[gu][[1]],tr=None]];
VPrint[3,"{gu,tr}=",{gu,tr}];

minpop=Evaluate[MinPop/.Flatten[{opts,Options[PlotGuild]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotGuild]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[PlotGuild]}]];
(*If[weightfunction==="Components",weightfunction=Select[gcomps[gu],comptype[#]==="Extensive"&]];*)
species=Evaluate[Species/.Flatten[{opts,Options[PlotGuild]}]];
coresatellite=Evaluate[CoreSatellite/.Flatten[{opts,Options[PlotGuild]}]];

(* expand traits *)
traits=ExpandTraits[attributesin];

If[ngcomps[gu]>1&&Gsin=={},
	sol=WeightedAbundance[ExtractGuilds[solin,gu],WeightFunction->weightfunction],
	sol=ExtractGuilds[solin,gu]
];
VPrint[3,"sol=",sol];


(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributesin,solin];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];


If[TemporalRuleListQ[sol]&&time===t, (* temporal dynamics *)
	{tmin,tmax}={InitialTime[sol],FinalTime[sol]};
	Which[
		plottype=="ArrayPlot",
		If[plotpoints===Automatic,plotpoints=200];
		If[tr=!=None,
			traitrange={Min[Table[Subscript[tr, sp],{sp,Subscript[\[ScriptCapitalN], gu]}]/.attributesin],Max[Table[Subscript[tr, sp],{sp,Subscript[\[ScriptCapitalN], gu]}]/.attributesin]};
			framelabel={tr,"t"},
			traitrange={1,Subscript[\[ScriptCapitalN], gu]};
			framelabel={"sp","t"}
		];
		If[InterpolatingFunctionFunctionQ[sol],
			dat=Table[Subscript[gu, sp][t]/.sol,{sp,Subscript[\[ScriptCapitalN], gu]},{t,tmin,tmax,(tmax-tmin)/plotpoints}],
			dat=Table[(Subscript[gu, sp]/.sol)["Values"],{sp,Subscript[\[ScriptCapitalN], gu]}]
		];		
		res=ArrayPlot[Reverse@dat,Evaluate[Sequence@@arrayplotopts],DataRange->{{tmin,tmax},traitrange},FrameLabel->framelabel]
	,
		plottype=="Plot3D",
		If[plotpoints===Automatic,plotpoints=100];
		If[InterpolatingFunctionFunctionQ[sol],
			dat=Flatten[Table[{t,Subscript[tr, sp]/.attributesin,Subscript[gu, sp][t]/.sol},{sp,Subscript[\[ScriptCapitalN], gu]},{t,tmin,tmax,(tmax-tmin)/plotpoints}],1],
			dat=Flatten[Table[Insert[Subscript[tr, sp]/.attributesin,2]/@(Subscript[gu, sp]/.sol)["Path"],{sp,Subscript[\[ScriptCapitalN], gu]}],1]
		];
		res=ListPlot3D[dat,Evaluate[Sequence@@listplot3dopts],AxesLabel->{"t",tr,gu}]
	,
		plottype=="LinePlot3D",
		If[plotstyle===Automatic,plotstyle=Table[Color[Subscript[tr,1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}]];
		If[InterpolatingFunctionFunctionQ[sol],
			res=ParametricPlot3D[Evaluate[Table[{t,Subscript[tr, sp]/.attributesin,Subscript[gu, sp][t]/.sol},{sp,Subscript[\[ScriptCapitalN], gu]}]],{t,tmin,tmax},
				PlotStyle->plotstyle,Evaluate[Sequence@@listlineplot3dopts],AxesLabel->{"t",tr,gu}]
		,
			dat=Table[Insert[Subscript[tr, sp]/.attributesin,2]/@(Subscript[gu, sp]/.sol)["Path"],{sp,Subscript[\[ScriptCapitalN], gu]}];
			res=MyListLinePlot3D[dat,PlotStyle->plotstyle,Evaluate[Sequence@@listlineplot3dopts],AxesLabel->{"t",tr,gu}]
		]
	,
		Else,
		Message[PlotGuild::badmtd];Return[$Failed]
	];
	Return[res]
];

(* non-temporal dynamics *)

sol=Slice[sol,time];
traits=Slice[traits,time];
(*Print["sol=",sol];
Print["traits=",traits];*)

If[plotstyle===Automatic,
	If[weightfunction==="Components",
		plotstyle=Reverse[Table[Directive[ColorData[97,i],Thick,Opacity[1]],{i,Length[Select[gcomps[gu],comptype[#]==="Extensive"&]]}]]
	,
		If[species=!=None,
			plotstyle=Table[If[i==species,
				Directive[Thick,Color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]],
				Directive[Thin,Color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]]
			],{i,Subscript[\[ScriptCapitalN], gu]}],
			plotstyle=Table[Color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}]
		];
	];
];

If[tr===None,
	xcoord=i;
	framelabel={"sp",Subscript[gu,Global`sp]},
	xcoord=Subscript[tr,i];
	framelabel={Subscript[tr,Global`i],Subscript[gu,Global`i]}
];

If[Gsin!={},  (* moment-based *)
	VPrint[3,"moment-based"];

	(* expand Gs *)
	Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
	VPrint[3,"Gs=",Gs];
	
	{plotrangemin,plotrangemax}=Visualization`Utilities`PlotRangeExpand[PlotRange/.plotopts][[1]]/.
		{{Automatic,Automatic}->{\[Infinity],-\[Infinity]},{min_,Automatic}->{min,-\[Infinity]},{Automatic,max_}->{\[Infinity],max},{All,All}->{\[Infinity],-\[Infinity]},{min_,All}->{min,-\[Infinity]},{All,max_}->{\[Infinity],max}};
	zrange=Visualization`Utilities`PlotRangeExpand[PlotRange/.plotopts][[2]];
	VPrint[3,"{{plotrangemin,plotrangemax},zrange}=",{{plotrangemin,plotrangemax},zrange}];
	{xmin,xmax}={
		Min[plotrangemin,If[ngcomps[gu]==1,Table[Subscript[tr, i]-3Sqrt[Subscript[Var[tr], i]],{i,Subscript[\[ScriptCapitalN], gu]}],Table[Subscript[tr[gcomp], i]-3Sqrt[Subscript[Var[tr][gcomp], i]],{i,Subscript[\[ScriptCapitalN], gu]},{gcomp,gcomps[gu]}]]],
		Max[plotrangemax,If[ngcomps[gu]==1,Table[Subscript[tr, i]+3Sqrt[Subscript[Var[tr], i]],{i,Subscript[\[ScriptCapitalN], gu]}],Table[Subscript[tr[gcomp], i]+3Sqrt[Subscript[Var[tr][gcomp], i]],{i,Subscript[\[ScriptCapitalN], gu]},{gcomp,gcomps[gu]}]]]
	}/.sol/.traits/.Gs;
	VPrint[3,"{xmin,xmax}=",{xmin,xmax}];
	If[ngcomps[gu]==1,
		res=Plot[Evaluate[Table[Subscript[gu, i]PDF[NormalDistribution[Subscript[tr, i],Sqrt[Subscript[Var[tr], i]]]][x],{i,Subscript[\[ScriptCapitalN], gu]}]/.sol/.traits/.Gs],{x,xmin,xmax},
				PlotStyle->plotstyle,Evaluate[Sequence@@plotopts],PlotRange->All,AxesLabel->{tr,gu}];
		Return[res]
	,
		If[plotstyle=="Ridgeline3D",
			res=ListLinePlot3D[Evaluate@Flatten[Table[Table[gcomp=gcomps[gu][[j]];
				Table[{x,j+0.002*i,Subscript[gcomp, i]PDF[NormalDistribution[Subscript[tr[gcomp], i],Sqrt[Subscript[Var[tr][gcomp], i]]]][x]}/.sol/.traits/.Gs,{x,xmin,xmax,(xmax-xmin)/plotpoints}]
			,{i,Subscript[\[ScriptCapitalN], gu]}],{j,ngcomps[gu]}],1],
			PlotRange->{{xmin,xmax},{0.9,Subscript[\[ScriptCapitalN], gu]+0.1},zrange},Evaluate[Sequence@@ridgelineplot3dopts],AxesOrigin->{xmin,0.9,0},Ticks->{Automatic,Table[{i,gcomps[gu][[i]]},{i,ngcomps[gu]}],Automatic},
			PlotStyle->Table[{Color[Subscript[gcomp, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]},{i,\[ScriptCapitalN][gu]}],AxesLabel->{tr,None,None}];
			Return[res]
		];
		res=Table[
			plotstyle=Table[Color[Subscript[gcomp, 1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}];
			Plot[Evaluate[Table[Subscript[gcomp, i]PDF[NormalDistribution[Subscript[tr[gcomp], i],Sqrt[Subscript[Var[tr][gcomp], i]]]][x],{i,Subscript[\[ScriptCapitalN], gu]}]/.sol/.traits/.Gs],{x,xmin,xmax},
				PlotStyle->plotstyle,Evaluate[Sequence@@plotopts],PlotRange->All,AxesLabel->{tr,gcomp}]
		,{gcomp,gcomps[gu]}];
		If[plotlayout===Automatic,plotlayout="Column"];
		Which[
			plotlayout=="Column",
			Return[GraphicsColumn[res]],
			plotlayout=="Row",
			Return[GraphicsRow[res]],
			Else,
			Return[res]
		];
	];
];

If[weightfunction==="Components",
		Return[ListPlot[
			Reverse[Transpose[{Table[xcoord,{i,Subscript[\[ScriptCapitalN], gu]}],#}/.traits]&/@Accumulate[Transpose[Table[Subscript[gu,i],{i,Subscript[\[ScriptCapitalN], gu]}]/.sol]]],
			Filling->Table[j->{Axis,ModPart[plotstyle,j]},{j,Length[Select[gcomps[gu],comptype[#]==="Extensive"&]]}],
			PlotStyle->None,
			Evaluate[Sequence@@listplotopts],
			PlotRange->All,AxesLabel->framelabel
		]]
];

If[(PlotMarkers/.listplotopts)==Automatic,
	Which[
		(Filling/.listplotopts)===Axis,PrependTo[listplotopts,PlotMarkers->""],
		coresatellite>0,PrependTo[listplotopts,PlotMarkers->{{"\[FilledSmallCircle]",9},{"\[SmallCircle]",12}}],
		coresatellite==0,PrependTo[listplotopts,PlotMarkers->{"\[FilledSmallCircle]",9}]
	]
];

If[logged==False,
	(* non-logged *)
	Return[ListPlot[
		Table[{{xcoord,0},{xcoord,Subscript[gu,i]}},{i,Subscript[\[ScriptCapitalN], gu]}]/.traits/.sol,
			PlotStyle->plotstyle,
			Evaluate[Sequence@@listplotopts],
			PlotRange->All,Joined->True,AxesLabel->framelabel
	]]
,
	(* logged *)
	sol=Select[sol,#[[2]]>minpop&];
	pos=sol[[All,1,2]]; (* positions *)
	{traitrange,{plotrangemin,plotrangemax}}=Visualization`Utilities`PlotRangeExpand[PlotRange/.listplotopts];
	If[plotrangemin===All,plotrangemin=Min[Table[Subscript[gu,i],{i,pos}]/.sol]];
	Which[
		coresatellite>0,
		dat=Table[{xcoord,Subscript[gu,i]},{i,pos}]/.traits/.sol;
		dat={Select[dat,#[[2]]>=coresatellite&],Select[dat,#[[2]]<coresatellite&]},
		(Joined/.listplotopts)===True||(Filling/.listplotopts)===None,
		dat=Table[{xcoord,Subscript[gu,i]},{i,pos}]/.traits/.sol,
		Else,
		dat=Table[{{xcoord,Subscript[gu,i]}},{i,pos}]/.traits/.sol
	];
	Return[ListLogPlot[dat,
		PlotStyle->plotstyle,
		PlotRange->{traitrange,{plotrangemin,plotrangemax}},
		Evaluate[Sequence@@listplotopts],
		AxesLabel->framelabel
	]]
];


]];


Options[PlotGuild]={Verbose->False,Verbosity->0,
PlotType->"ArrayPlot",PlotStyle->Automatic,PlotLayout->Automatic,PlotPoints->200,
ListPlotOpts->{PlotMarkers->Automatic,Filling->Axis,FillingStyle->Thickness[0.004],(*AxesOrigin->{Left,Bottom},*)PlotRange->{0,All}},
ListPlot3DOpts->{BoxRatios->{2,1,1},PlotRange->{0,All},ColorFunction->"ThermometerColors",Mesh->None},
ArrayPlotOpts->{AspectRatio->1/2,ImageSize->Large,ColorFunction->"ThermometerColors",Mesh->None,FrameTicks->{All,All,False,False},PlotRange->All},
ListLinePlot3DOpts->{BoxRatios->{2,1,1},PlotRange->{All,All,{0,All}}},
PlotOpts->{Filling->Axis,PlotRange->{0,All}},
RidgelinePlot3DOpts->{Boxed->False,BoxRatios->{1,0.6,0.4},Filling->Axis,ViewPoint->{0,-3,0.6},PlotRange->{0,All}},
Guild->Automatic,Trait->Automatic,Species->None,
WeightFunction->"Total",
Logged->False,MinPop->0,Time->t,CoreSatellite->0};


(* split combined traitsandpopsandGs *)
PlotGuild[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
PlotGuild[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];
(* split combined traitsandpops *)
PlotGuild[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=
PlotGuild[ExtractTraits[sol],ExtractVariables[sol],opts];


PlotGuild::badmtd="The Method option should be a built-in method name (\"ArrayPlot\", \"Plot3D\", or \"ListLinePlot3D\" for temporal dynamics).";


ImpactVector::usage=
"ImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\)] returns the impact of \!\(\*
StyleBox[\"sp\", \"TI\"]\) on {\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}.";


ImpactVector[{var1_,var2_},sp_]:=D[{Equation[var1],Equation[var2]}/.RemoveVariablets,sp];


PlotImpactVector::usage=
"PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] plots the impact vector of \!\(\*
StyleBox[\"sp\", \"TI\"]\) on {\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)} at \!\(\*
StyleBox[\"point\", \"TI\"]\).
PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, {\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"sp\", \"TI\"], \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"sp\", \"2\"], \"TI\"]\), \[Ellipsis]}, \!\(\*
StyleBox[\"point\", \"TI\"]\)] plots impact vectors of multiple species.
PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\), {\!\(\*
StyleBox[SubscriptBox[\"point\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"point\", \"2\"], \"TI\"]\), \[Ellipsis]}] plots at multiple points.";


(* make listable across points *)
PlotImpactVector[{var1_,var2_},sp_,points_?RuleListListQ,opts___?OptionQ]:=(PlotImpactVector[{var1,var2},sp,#,opts]&/@points);


(* make listable across sps *)
PlotImpactVector[{var1_,var2_},sps_List,point_?RuleListQ,opts___?OptionQ]:=Module[{plotstyles,nsp},
	plotstyles=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotImpactVector]}]];
	nsp=Length[sps];
	If[plotstyles===Automatic,plotstyles=Table[Automatic,{nsp}]];
	Table[
		PlotImpactVector[{var1,var2},sps[[i]],point,PlotStyle->ModPart[plotstyles,i],opts]
	,{i,nsp}]
];


PlotImpactVector[{var1_,var2_},sp_,ptin_?RuleListQ,opts___?OptionQ]:=Module[{
scale,scale1,scale2,plotstyle,plotstyle1,plotstyle2,
impactvector,pt},
(* handle options *)
scale=Evaluate[Scale/.Flatten[{opts,Options[PlotImpactVector]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotImpactVector]}]];

Which[
	Length[scale]==2,
	{scale1,scale2}=scale,
	NumericQ[scale],
	scale1=scale,
	Else,
	scale1=1;
];
(*Print[{scale1,scale2}];*)

Which[
	plotstyle===Automatic,
	{plotstyle1,plotstyle2}={Automatic,Automatic},
	Length[plotstyle]==2&&Length[scale]==2,
	{plotstyle1,plotstyle2}=plotstyle,
	Else,
	plotstyle1=plotstyle2=plotstyle
];
If[plotstyle1===Automatic,plotstyle1=Color[sp]];
If[plotstyle2===Automatic,plotstyle2={Color[sp],Dashed}];
(*Print[{plotstyle1,plotstyle2}];*)

pt={var1,var2}/.ptin;
impactvector=Normalize@ImpactVector[{var1,var2},sp]/.ptin;

{PlotVector[scale1*impactvector,pt,PlotStyle->plotstyle1],
If[NumericQ[scale2],Graphics[Join[Flatten[{plotstyle2}],{Line[{pt,pt+scale2*impactvector}]}]]]}//DeleteNulls
];


Options[PlotImpactVector]={Scale->1,PlotStyle->Automatic};


PlotEcoEq::usage=
"PlotEcoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] plots ecological equilibria \!\(\*
StyleBox[\"sol\", \"TI\"]\) as function of \!\(\*
StyleBox[\"par\", \"TI\"]\).
PlotEcoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] plots only \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


PlotEcoEq[eq_?RuleListQ,var_?(Not@*ListQ),{par_,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,
teststability,stablestyle,unstablestyle,
plotopts,plotrange,axeslabel,
(* other variables *)
yaxislabel,\[Lambda]
},

Block[{\[ScriptCapitalN],verbosity,func="PlotEcoEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotEcoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoEq]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[PlotEcoEq]}]];
stablestyle=Flatten[{Evaluate[StableStyle/.Flatten[{opts,Options[PlotEcoEq]}]]}];
unstablestyle=Flatten[{Evaluate[UnstableStyle/.Flatten[{opts,Options[PlotEcoEq]}]]}];
plotopts=FilterRules[Flatten[{opts,Options[PlotEcoEq]}],Options[Plot]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PlotEcoEq]}]];
If[plotrange===Automatic,
	If[comptype[var]=="Extensive",plotrange={0,All}]
];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotEcoEq]}]];
If[axeslabel===Automatic,axeslabel={par,var}];

(*Print["var=",var];*)

If[teststability,
	plotopts=Join[plotopts,
		{MeshStyle->Opacity[0],MeshFunctions->{\[Lambda][#1,eq]&},Mesh->{{0}},
		MeshShading->{Directive[Evaluate[Sequence@@stablestyle],Color[var]],Directive[Evaluate[Sequence@@unstablestyle],Color[var]]}}]
];


\[Lambda][parval_?NumericQ,pt_]:=Which[
	modeltype=="ContinuousTime",CreateBlock[{par},{parval},Max[Re[EcoEigenvalues[pt]]]],
	modeltype=="DiscreteTime",CreateBlock[{par},{parval},Max[Abs[Re[EcoEigenvalues[pt]]]]]-1
];

Return[Plot[var/.eq,{par,parmin,parmax},PlotRange->plotrange,AxesLabel->axeslabel,Evaluate[Sequence@@plotopts]]];

]];


Options[PlotEcoEq]={
	TestStability->True,StableStyle->{},UnstableStyle->{Dashed},
	PlotRange->Automatic,AxesLabel->Automatic,PlotRangePadding->Scaled[0.02],
	Verbose->False,Verbosity->0
};


(* no vars given = All *)
PlotEcoEq[eqs_?ListOfVariablesQ,{par_,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=
Module[{axeslabel,vars},
	axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotEcoEq]}]];
	vars=Keys[eqs[[1]]];
	
	If[axeslabel===Automatic,axeslabel={par,Row[Sort[Union[vars]],","]}];
	Show[Table[Table[PlotEcoEq[eq,var,{par,parmin,parmax},opts],{eq,eqs}],{var,vars}],AxesLabel->axeslabel]
];
	
(* thread over vars *)
PlotEcoEq[eq_,vars_List,{par_,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=Module[{axeslabel},
	axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotEcoEq]}]];
	If[axeslabel===Automatic,axeslabel={par,Row[Sort[Union[vars]],","]}];
	Show[Table[PlotEcoEq[eq,var,{par,parmin,parmax},opts],{var,vars}],AxesLabel->axeslabel]
];

(* thread over eqs *)
PlotEcoEq[eqs_?ListOfVariablesQ,var_?(Not@*ListQ),{par_,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=
	Show[Table[PlotEcoEq[eq,var,{par,parmin,parmax},opts],{eq,eqs}]];


Inv::usage=
"Inv[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

StablePopulationStructure::usage=
"StablePopulationStructure[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

ReproductiveValues::usage =
"ReproductiveValues[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the reproductive values of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the reproductive value of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

InvSPS::usage =
"InvSPS[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate and stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate and stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";


InvSPS[traitspopsandgs_?AttributesVariablesAndGsQ,opts:OptionsPattern[]]:=
	InvSPS[DeleteInvaders@ExtractAttributes[traitspopsandgs],DeleteInvaders@ExtractVariables[traitspopsandgs],
	ExtractInvaders@ExtractAttributes[traitspopsandgs],ExtractInvaders@ExtractVarCovs[traitspopsandgs],
	opts];
InvSPS[traitsandpops_?AttributesAndVariablesQ,invaderin:(_?InvaderQ):{},invaderGsin:(_?GsQ):{},opts:OptionsPattern[]]:=
InvSPS[ExtractAttributes[traitsandpops],ExtractVariables[traitsandpops],invaderin,invaderGsin,opts];


InvSPS[attributesin:(_?NotInvaderTraitsQ):{},solin:(_?VariablesQ):{},invaderin:(_?InvaderQ):{},invaderGsin:(_?GsQ):{},opts:OptionsPattern[]]:=Module[{
(* options *)
verbose,verboseall,method,
guild,time,simplifyresult,frominv,rv,qssics,
qssmethod,equalinvtraits,
ndsolveopts,nintegrateopts,integrateopts,
solveopts,nsolveopts,findrootopts,
findecocycleopts,eigensystemopts,simplifyopts,
(* other variables *)
attributes,invader,invtraits,variables,
invtype,invid,invunk,zeropcomps,sol,invaderGs,
inveqns,invunks,qsseqns,qssunks,qsssubs,mode,
tstart,tend,removets,qsssols,qsssol,eval,evec,invsol,j,tempIF},

Block[{\[ScriptCapitalN],verbosity,func="InvSPS"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[InvSPS]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[InvSPS]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[InvSPS]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=OptionValue[Method];
time=OptionValue[Time];
qssmethod=OptionValue[QSSMethod]; 
ndsolveopts=OptionValue[NDSolveOpts];
nintegrateopts=OptionValue[NIntegrateOpts];
integrateopts=OptionValue[IntegrateOpts];
solveopts=OptionValue[SolveOpts];
nsolveopts=OptionValue[NSolveOpts];
findrootopts=OptionValue[FindRootOpts];
findecocycleopts=OptionValue[FindEcoCycleOpts];
eigensystemopts=OptionValue[EigensystemOpts];
simplifyresult=OptionValue[SimplifyResult];
simplifyopts=OptionValue[SimplifyOpts];
guild=OptionValue[Guild];
If[guild===Automatic,guild=Append[guilds,1][[1]]];
frominv=OptionValue[FromInv];
rv=OptionValue[RV];
qssics=OptionValue[QSSICs];
equalinvtraits=OptionValue[EqualInvTraits];

(* fix attributes *)
attributes=FixAttributes[attributesin];

$InvCount++; (* increment $InvCount *)

VPrint[3,"attributesin=",attributesin];
VPrint[3,"attributes=",attributes];
VPrint[3,"solin=",solin];
VPrint[3,"invaderin=",invaderin];
VPrint[3,"opts=",opts];

(* figure out number of species in guilds *)
variables=FixVariables[solin];
(*Print["variables=",variables];*)

(* figure out number of species *)
Set\[ScriptCapitalN][attributes,variables];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[modelwhenevents!={},Message[InvSPS::whenevents]];

(* what kind of invader do we have? *)

invader=Flatten[{invaderin}];
VPrint[3,"invader=",invader];

invtraits={};
Which[
	(* no invader given *)
	invader==={},
	VPrint[3,"no invader given"];
	Which[
		nguilds!=0,{invtype,invid}={"guild ghost",guild},
		npops!=0,{invtype,invid}={"pop",pops[[1]]}
	];
,
	(* specific guild ghost invader *)
	AttributesQ[invader],
	VPrint[3,"specific guild ghost invader"];
	{invtype,invid}={"guild ghost",LookUp[invader[[1,1]]][[2]]};
	invtraits=ExtractAttributes[invader];
,
	(* whole-guild ghost invader *)
	LookUp[invader[[1]]][[1]]=="guild"&&Length[LookUp[invader[[1]]]]==2,
	VPrint[3,"whole-guild ghost invader"];
	{invtype,invid}={"guild ghost",invader[[1]]};
,
	(* whole-gcomp ghost invader -- is this even a good idea?! *)
	LookUp[invader[[1]]][[1]]=="gcomp"&&Length[LookUp[invader[[1]]]]==3,
	VPrint[3,"whole-gcomp ghost invader"];
	{invtype,invid}={"gcomp ghost",invader[[1]]};
	Return[{Simplify[Equation[Subscript[invid,0]]/Subscript[invid,0]/.sol/.attributes],"N/A"}]
,
	(* guild member invader *)
	LookUp[invader[[1]]][[1]]=="guild"||LookUp[invader[[1]]][[1]]=="gcomp",
	VPrint[3,"guild member invader"];
	{invtype,invid}={"guild member",invader[[1]]};
	VPrint[3,invid," -- ",invid/.WeightedAbundance[variables]];
	If[(invid/.WeightedAbundance[variables])>0,Message[InvSPS::nonzero](*;Abort[]*)]
,
	(* pop invader *)
	LookUp[invader[[1]]][[1]]=="pop"||LookUp[invader[[1]]][[1]]=="pcomp",
	VPrint[3,"pop invader"];
	{invtype,invid}={"pop",LookUp[invader[[1]]][[2]]};
	VPrint[3,invid," -- ",invid/.WeightedAbundance[variables]];
(*Print[comps[invid]];
Print[FilterRules[sol,comps[invid]]];
Print[TemporalMean@FilterRules[sol,comps[invid]]];
Print[WeightedAbundance@TemporalMean@FilterRules[sol,comps[invid]]];*)
	If[(invid/.WeightedAbundance@TemporalMean@FilterRules[variables,comps[invid]])>0,Message[InvSPS::nonzero](*;Abort[]*)]
,
	Else,
	Message[InvSPS::unkinv];Return[$Failed]
];

VPrint[3,"{invtype,invid}=",{invtype,invid}];
VPrint[3,"invtraits=",invtraits];

(* assemble sol [resident state] *)

(* in case any extensive pops weren't given, assume they're 0 *)
zeropcomps=Flatten[Table[Table[
	If[comptype[pcomp]=="Extensive"&&invtype=="pop",pcomp->0,pcomp->pcomp] (* maybe make it pop-specific?? *)
,{pcomp,pcomps[pop]}],{pop,pops}]];
sol=JoinFirst[variables,zeropcomps];
(*Print[sol];*)

(* if a time given, evaluate sol there *)
If[time=!=t&&!NumericRuleListQ[sol],sol=Slice[sol,time]];

VPrint[3,"sol=",sol];


(* process Gs *)
If[moments,
	invaderGs=ExpandGs[Join[invaderGsin,Thread[Flatten@MakeGMatrix[Subscript[invid, 0]]->Flatten@ConstantArray[0,{ngtraits[invid],ngtraits[invid]}]]]],
	invaderGs={}
];
VPrint[1,"invaderGs=",invaderGs];

(* set up inveqns, invunks, qss stuff *)

inveqns=invunks={};
qsssubs=qsseqns=qssunks={};

Do[
(*Print["comp=",comp];*)
	invunk=Switch[invtype,"guild ghost",Subscript[comp,0],"guild member",Subscript[comp,invid[[2]]],"pop",comp];
	If[comptype[invunk]=="Extensive",
		AppendTo[inveqns,Equation[invunk]];
		AppendTo[invunks,invunk];
		If[invtype=="guild ghost",AppendTo[qsssubs,invunk->0]];
	];
	If[comptype[invunk]=="Intensive",
		AppendTo[qsseqns,Equation[invunk]==0];
		If[qssmethod=="FindRoot",
			AppendTo[qssunks,{invunk,Min[range[invunk]]+0.01}],
			AppendTo[qssunks,invunk];
		];
	];
,{comp,Switch[invtype,"guild ghost",gcomps[invid],"guild member",gcomps[LookUp[invader[[1,1]]][[2]]],"pop",pcomps[invid]]}];

VPrint[3,"inveqns=",inveqns];
VPrint[3,"invunks=",invunks];
VPrint[3,"qsseqns=",qsseqns];
VPrint[3,"qsssubs=",qsssubs];
VPrint[3,"qssunks=",qssunks];

(* decide on mode *)

Which[
	(modelperiod==0&&(Length[sol]==0||!MemberQ[{InterpolatingFunction,TemporalData},Head[sol[[1,2]]]]))
	||(modelperiod=!=0&&(method==="Instantaneous"||time=!=t)),
	mode="eigenvalue",
	modeltype=="ContinuousTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===InterpolatingFunction)),
	mode="continuoustime floquet",
	modeltype=="DiscreteTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===TemporalData)),
	mode="discretetime floquet"
];
VPrint[3,"mode=",mode];


(* calculate invasion fitness *)

Which[
	(* ContinuousTime Floquet mode *)
	mode=="continuoustime floquet",
	VPrint[1,"ContinuousTime Floquet mode"];

	(* figure out period *)
	If[sol!={}&&Head[sol[[1,2]]]===InterpolatingFunction,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	VPrint[3,"{tstart,tend}=",{tstart,tend}];
	
	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[qssics===Automatic, (* no QSS ICs given? then average corresponding components from residents *)
			qssics=Table[qssunk->
				Mean[Select[Select[FinalSlice[sol],(#[[1,0]]==Subscript)&],(#[[1,1]]==qssunk[[1]])&][[All,2]]]
			,{qssunk,qssunks}];
		];
		If[verbose,
			With[{tr=Join[attributes,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[attributes,invtraits],Join[FinalSlice[sol],qssics],Sequence@@findecocycleopts];
		If[qsssol==$Failed,Message[InvSPS::noqsssol];Return[{$Failed}]];
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	VPrint[3,"qsssol=",qsssol];


	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		Which[
			method===Automatic||method=="NIntegrate",
			VPrint[1,"ContinuousTime Floquet mode (1 comp): NIntegrate"];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@nintegrateopts},
				PrintCall[Global`eval=NIntegrate[eq/.Global`sol/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=NIntegrate[Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@nintegrateopts]]/(tend-tstart);
			Return[{eval,"?"}]
		,
			method=="NDSolve",
			VPrint[3,"ContinuousTime Floquet mode (1 comp): NDSolve"];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
				PrintCall[Global`invsol=NDSolve[{Global`x'[t]==eq/.Global`qsssol,Global`x[tstart]==0},Global`x,{t,tstart,tend},op]];
				PrintCall[Global`eval=Global`x[tend]/dt/.Global`invsol]
			]];
			invsol=NDSolve[{x'[t]==Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,x[tstart]==0},x,
				{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]][[1]];
			eval=x[tend]/(tend-tstart)/.invsol;
			Return[{eval,"?"}];
		,
			method=="Integrate",
			VPrint[1,"ContinuousTime Floquet mode (1 comp): Integrate"];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@integrateopts},
				PrintCall[Global`eval=Integrate[eq/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=Integrate[Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@integrateopts]]/(tend-tstart);
			Return[{Chop[eval],"?"}];
		,
			method=="EcoSim",
			sol=EcoSim[];
		,
			Else,
			Message[InvSPS::bdmtd];
			Return[]
		];
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		VPrint[1,"ContinuousTime Floquet mode (2+ comps)"];
		removets={Subscript[x_/;(comptype[x]=="Extensive"),0][t]->Subscript[x,0],t->time};
(*Print[removets];*)
		j=D[inveqns/.AddVariablets/.attributes/.removets,{invunks}];
		VPrint[3,"j=",j];
		If[verbose,
			With[{j=j/.invtraits,liu=Length[invunks],tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
			PrintCall[Global`invsol=NDSolve[{Global`x'[t]==j . Global`x[t]/.Global`sol/.Global`qsssol,Global`x[tstart]==IdentityMatrix[liu]},Global`x,{t,tstart,tend},op]];
			PrintCall[Global`eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[Global`x[tend]/.Global`invsol]/dt]
		]];
		invsol=NDSolve[{x'[t]==j . x[t]/.invtraits/.sol/.qsssol,x[tstart]==IdentityMatrix[Length[invunks]]},x,{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]];
		eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[x[tend]/.invsol]/(tend-tstart);
		Return[{eval,"?"}];
	]
,
	(* DiscreteTime Floquet mode *)
	mode=="discretetime floquet",
	VPrint[1,"DiscreteTime Floquet mode"];

	(* figure out time range *)
	If[Head[sol[[1,2]]]===TemporalData,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	VPrint[3,"{tstart,tend}=",{tstart,tend}];

	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[verbose,
			With[{tr=Join[attributes,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[attributes,invtraits],Join[FinalSlice[sol],qssics],Evaluate[Sequence@@findecocycleopts]]
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	VPrint[3,": qsssol=",qsssol];

	removets={Subscript[x_/;comptype[x]=="Extensive",0][t]->Subscript[x,0],t->time};

	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		VPrint[1,"DiscreteTime Floquet mode (1 comp)"];
		If[verbose,
			With[{eq=Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits]/.SimplifyLogE],tstart=tstart,tend=tend,te=tend-tstart+1},
			(*PrintCall[Global`eval=Product[eq/.Global`sol/.Global`qsssol,{t,tstart,tend}]^(1/te)]*)
			PrintCall[Global`eval=Sum[eq/.Global`sol/.Global`qsssol,{t,tstart,tend}]/te]
		]];
		(*eval=Product[inveqns\[LeftDoubleBracket]1\[RightDoubleBracket]/invunks\[LeftDoubleBracket]1\[RightDoubleBracket]/.AddVariablets/.invtraits/.sol/.qsssol,{t,tstart,tend}]^(1/(tend-tstart+1));
		(*Print["eval=",eval];*)
		Return[{(Log@Chop@ComplexExpand[eval])/.SimplifyLogE,"?"}]*)
		eval=Sum[Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol]/.SimplifyLogE],{t,tstart,tend}]/(tend-tstart+1);
		If[tend==\[Infinity],
			Return[{With[{tstart=tstart,tend=tend,eq=Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol]/.SimplifyLogE]},Unevaluated@Defer[Sum[eq,{t,tstart,tend}]/\[Infinity]]],"?"}],
			Return[{eval,"?"}]
		]
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		VPrint[1,": DiscreteTime Floquet mode (2+ comps)"];
		j=D[inveqns/.AddVariablets/.attributes/.removets,{invunks}];
		If[verbose,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,tend=tend,te=tend+1},
			PrintCall[Global`invsol=ListMultiplier[Table[j/.Global`sol/.Global`qsssol,{t,0,tend}]]];
			PrintCall[Global`eval=Log[Max@Re@Chop@Sort@Eigenvalues[Global`invsol]^(1/te)]]
		]];
		invsol=ListMultiplier[Table[j/.invtraits/.sol/.qsssol,{t,0,tend}]];		
		Return[{Log[Max@Re@Chop@Sort@Eigenvalues[invsol]^(1/(tend+1))],"?"}];
	]
,
	(* Eigenvalue mode *)
	mode=="eigenvalue",
	VPrint[1,"eigenvalue mode"];
	
	(* subrule to remove [t]'s *)
	(*removets={t\[Rule]time};*)

	(* are there any Intensive components to be solved for? *)

	If[Length[qssunks]>0,
		Which[
			qssmethod=="Solve",
			qsssols=Solve[qsseqns/.qsssubs/.attributes/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@solveopts]],
			qssmethod=="NSolve",
			qsssols=NSolve[qsseqns/.qsssubs/.attributes/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@nsolveopts]],
			qssmethod=="FindRoot",
			qsssols={FindRoot[qsseqns/.qsssubs/.attributes/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@findrootopts]]}
		];
	,
		qsssols={{}}];
	VPrint[1,"qsssols=",qsssols];
	If[VectorQ[qsssols,NumericRuleListQ[#]&],
		qsssol=SelectValid[qsssols], (* should add SelectEcoStable here? *)
		qsssol=qsssols
	];
	VPrint[1,"qsssol=",qsssol];
	If[Length[qsssol]!=1,Message[InvSPS::noqsssol,Length[qsssol]];Return[{$Failed}]];
	If[Length[invunks]==1,
		VPrint[3,"Cancel[(inveqns\[LeftDoubleBracket]1\[RightDoubleBracket]/invunks\[LeftDoubleBracket]1\[RightDoubleBracket])]=",Cancel[(inveqns[[1]]/invunks[[1]])]];
		j={{Cancel[(inveqns[[1]]/invunks[[1]])]/.qsssol[[1]]/.qsssubs/.sol/.invtraits/.attributes/.invaderGs/.t->time}}
	,
		(* make Jacobian matrix of Extensive components *)
		(* what about 0th order terms?! *)
		j=D[inveqns/.attributes/.qsssol[[1]]/.invtraits,{invunks}]/.sol/.invaderGs/.t->time;
		(* equalize traits *)
		(*Print["gtraits[invid]=",gtraits[invid]];*)
		(*Print["invtype=",invtype];*)
		If[invtype=!="pop"&&equalinvtraits,j=j/.Table[tr[_]->tr,{tr,gtraits[invid]}]];
	];

	VPrint[3,"j=",j];

	Which[
		Length[j]==1, (* 1 extensive component *)
		VPrint[1,"1 extensive component"];
		eval=j[[1,1]];
		evec={1};
	,
		Length[j]>1, (* >1 extensive component *)
	
		(* calculate eigenvalues *)

		If[(MatrixQ[#,NumericQ]&)[j/.qsssubs],
			(* numerical jacobian *)
			VPrint[1,"numerical Jacobian"];
			
			If[rv,
				{{eval},{evec}}=SortedEigensystem[Transpose[j/.qsssubs],1,Sequence@@eigensystemopts],
				{{eval},{evec}}=SortedEigensystem[j/.qsssubs,1,Sequence@@eigensystemopts]
			];
			evec=evec/Sign[evec[[1]]]
		,
			(* symbolic jacobian *)
			VPrint[1,"symbolic Jacobian"];

			If[Dimensions[j/.qsssubs]=={2,2},
				eval=(*Simplify@*)Re[1/2*(j[[1,1]]+j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])];
				If[rv,
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[1,2]]),1}],
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[2,1]]),1}]
				]
			,
				eval=Max[Re[Eigenvalues[j/.qsssubs,Sequence@@eigensystemopts]]];
				evec="?";
				If[!frominv,Message[InvSPS::nosymev]];
			];
		];
	];
	
	(* add [t] to InterpolatingFunctions (but not ones with [var]) *)
	eval=eval/.x_InterpolatingFunction->x[t]/.x_InterpolatingFunction[t][var_]->x[var];

	VPrint[1,"eigenvalue=",eval];
	VPrint[1,"eigenvector=",evec];

	(* return answer *)
	Quiet[Which[
		modeltype=="ContinuousTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			simplifyresult===Real,
			Return[RealSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			Else,
			Return[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
	,
		modeltype=="DiscreteTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			Else,
			Return[{(Log@Max@Chop@ComplexExpand[eval])/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
		(*Return[{Simplify[Log@Max@Chop@ComplexExpand[eval],Assumptions\[Rule]{_\[Element]Reals}],evec}];*)
	],{Simplify::time,Simplify::gtime}];


];

]];


(*Options[Inv]=*)Options[InvSPS]={Verbose->False,Verbosity->0,
Method->Automatic,Time->t,
NIntegrateOpts->{Method->{Automatic,"SymbolicProcessing"->0}},IntegrateOpts->{},NDSolveOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},EigensystemOpts->{},FindEcoCycleOpts->{},
QSSMethod->"NSolve",QSSICs->Automatic,
SimplifyResult->True,SimplifyOpts->{_\[Element]Reals,TimeConstraint->{0.1,1}},
Guild->Automatic,FromInv->False,RV->False,
EqualInvTraits->True};


Inv[args___]:=InvSPS[args,FromInv->True][[1]];
(*Inv[args___,opts_?OptionQ]:=InvSPS[DeleteInvaders@ExtractTraits[Flatten[{args}]],DeleteInvaders@ExtractVariables[Flatten[{args}]],
	ExtractInvaders@ExtractTraits[Flatten[{args}]],ExtractInvaders@ExtractVarCovs[Flatten[{args}]],FromInv\[Rule]True,opts]\[LeftDoubleBracket]1\[RightDoubleBracket];*)
StablePopulationStructure[args___]:=InvSPS[args][[2]];
ReproductiveValues[args___]:=InvSPS[args,RV->True][[2]];


InvSPS::nosymev=
"Warning: don't know how to find analytical StablePopulationStructure for > 2x2 matrix.";

InvSPS::unkinv=
"Can't figure out who's invading: please specify.";

InvSPS::nonzero=
"Warning: invasion rate only defined for rare invaders.";

InvSPS::noqsssol=
"Found `1` QSS solutions for invader's Intensive components, need one.";

InvSPS::notraits=
"Trait of invader not defined, so NIntegrate can't work.  Try Method->\"Integrate\" or give invader traits.";

InvSPS::whenevents=
"Warning: WhenEvents involving populations and guilds are not handled properly in InvSPS yet.";


$InvCount::usage = "Counts number of times Inv called.";
$InvCount=0;


DInv::usage =
"DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] calculates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"sol\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where DInv will be evaluated.
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives derivatives for all traits in Guild (default=first).";

NDInv::usage =
"NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] numerically approximates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident traits \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"sol\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where NDInv will be evaluated.
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives derivatives for all traits in Guild (default=first).";


Options[DInv]={Verbose->False,Verbosity->0,
Fixed->{},InvOpts->{},Method->"D",Guild->Automatic,Species->All,FindEcoAttractorOpts->{},
Chop->True,SimplifyResult->False,RelativeStepSize->0.001,AbsoluteStepSize->0.001,Time->t,Verbose->False};

notDInvOpts=Except[Alternatives@@Replace[Options[DInv],h_[a_,_]:>h[a,_],1]];


NumDInv[traitsin_?NumericRuleListQ,rest___]:=DInv[traitsin,rest];


DInv[traitsin:(_?TraitsQ):{},solin:(_?VariablesQ):{},{var_:All,ord_?NumberQ},pointin:notDInvOpts:{},opts:OptionsPattern[]]:=

Module[{
(* options *)
verbose,fixed,fixedattributes,fixedvariables,method,\[Epsilon]r,\[Epsilon]a,invopts,guild,species,time,simplifyresult,chop,findecoattractoropts,
(* other variables *)
sol,res,res2,traits,traits2,point,targetgu,targettrait,inv,sp,vars,
pt1,pt2,
h,h1,h2,invl,invr,invc},

If[solin==$Failed,Return[$Failed]];

Block[{\[ScriptCapitalN],verbosity,func="DInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[DInv]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[DInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[DInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=OptionValue[Fixed];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
If[Global`debug,Print[func,": fixedattributes=",fixedattributes]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];

invopts=OptionValue[InvOpts];
method=OptionValue[Method];
\[Epsilon]a=OptionValue[AbsoluteStepSize];
\[Epsilon]r=OptionValue[RelativeStepSize];
guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
species=OptionValue[Species];
time=OptionValue[Time];
AppendTo[invopts,Time->time];
simplifyresult=OptionValue[SimplifyResult];
chop=OptionValue[Chop];
findecoattractoropts=OptionValue[FindEcoAttractorOpts];

(* handle blanks & figure out number of species in guilds *)
traits=DeleteInvaders[FixAttributes[traitsin]];
(*Print["traits=",traits];*)
sol=FixVariables[solin];

(* set number of species *)
Set\[ScriptCapitalN][Join[traits,fixedattributes]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[solin==="FindEcoAttractor",
	If[verbosity>=1,
		With[{tr=traits,op=Sequence@@findecoattractoropts},
		PrintCall[Global`sol=FindEcoAttractor[tr,op]]
	]];
	sol=FindEcoAttractor[traits,Evaluate[Sequence@@findecoattractoropts]]
];
VPrint[1,"sol=",sol];

(* thread a list of points *)
If[Length[Dimensions[pointin]]==2,
	(*Print["mapping over points"];*)
	Return[Map[DInv[traits,sol,{var,ord},#,opts]&,pointin]]
];

VPrint[3,"pointin=",pointin];
VPrint[3,"species=",species];

(* figure out point where to evaluate derivative *)
If[pointin=={},
	(* no point given *)
	If[var===All,
		targetgu=guild,
		If[ListQ[var],targetgu=LookUp[var[[1]]][[2]],targetgu=LookUp[var][[2]]]
	];
	If[species===All,If[\[ScriptCapitalN][targetgu]==0,species=0,species=Table[sp,{sp,\[ScriptCapitalN][targetgu]}]]];
	If[ListQ[species],
		If[method=="NDInv",Return[Table[DInv[traits,sol,{var,ord},{},Species->sp,opts],{sp,species}]]];
		point=Table[Table[Subscript[gtrait,0]->Subscript[gtrait,sp],{gtrait,gtraits[targetgu]}],{sp,species}]/.traits
	,
		pt1=Table[
			If[guild1[interaction]===targetgu,Subscript[interaction,0,sp\[Prime]_]->(Subscript[interaction,species,sp\[Prime]]/.traitsin),Nothing]
		,{interaction,interactions}];
		pt2=Table[
			If[guild2[interaction]===targetgu,Subscript[interaction,sp\[Prime]_,0]->(Subscript[interaction,sp\[Prime],species]/.traitsin),Nothing]
		,{interaction,interactions}];
		point=Join[pt1,pt2,Table[Subscript[gtrait,0]->(Subscript[gtrait,species]/.traitsin),{gtrait,gtraits[targetgu]}]]
	];
,
	(* point given *)
	targetgu=LookUp[pointin[[1,1]]][[2]];
	point=pointin
];
VPrint[3,"targetgu=",targetgu];
VPrint[3,"point=",point];

If[var===All,
	vars=Table[Subscript[gtrait,0],{gtrait,gtraits[targetgu]}],
	vars=var
];
VPrint[3,"vars=",vars];

VPrint[3,"method=",method];
Which[
	method=="D",
	If[verbosity>=1,
		With[{tr=traits,so=sol,tg=targetgu,op=Sequence@@invopts},
		PrintCall[Global`inv=Simplify[Inv[tr,so,Guild->tg,op],Assumptions->_\[Element]Reals]]
	]];
	inv=Inv[Join[traits,fixedattributes],Join[sol,fixedvariables],Guild->targetgu,Evaluate[Sequence@@invopts]];
	VPrint[1,"inv=",inv];
	If[verbosity>=1,
		With[{vars=vars,inv=inv,point=point,traits=traits},
		PrintCall[Global`res=D[inv,{vars,ord}]/.point/.traits]
	]];
	res=D[inv,{vars,ord}]/.point/.traits/.fixed; (* is /.traits necessary?? *)
	VPrint[1,"res=",res];
,
	method=="NDInv",
	Which[
		ord==1,
		If[ListQ[vars],
			(* gradient *)
			Return[DInv[traits,sol,{#,ord},point,opts]& /@ vars];
		, (* first derivative *)
			VPrint[3,"1st derivative (finite difference)"];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invl=",invl];
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invr=",invr];
			If[invl==$Failed||invr==$Failed,Return[$Failed]];
			res=(invr-invl)/(2h);
		]
	,
		ord==2, 
		If[ListQ[vars],
			(* Hessian matrix *)
			VPrint[3,"Hessian matrix (finite difference)"];
			res=ConstantArray[0,{Length[vars],Length[vars]}];
			Do[
				(* diagonal entries *)		
				h=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
				res=ReplacePart[res,{v1,v1}->
					(Inv[traits,sol,RuleListTweak[point,vars[[v1]],h],Evaluate[Sequence@@invopts]]
					-2Inv[traits,sol,point,Evaluate[Sequence@@invopts]]
					+Inv[traits,sol,RuleListTweak[point,vars[[v1]],-h],Evaluate[Sequence@@invopts]])/(h^2)
				];
				(* offdiagonal entries *)
				Do[
					h1=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
					h2=(\[Epsilon]r*vars[[v2]]/.point)+\[Epsilon]a;
					res=ReplacePart[res,{{v1,v2},{v2,v1}}->
						(Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,-h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,h2}],Evaluate[Sequence@@invopts]]
						+Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,-h2}],Evaluate[Sequence@@invopts]])/(4*h1*h2)
					];					
				,{v2,v1+1,Length[vars]}]
			,{v1,1,Length[vars]}];
		, (* second derivative *)
			VPrint[3,"2nd derivative (finite difference)"];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invl=",invl];
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			VPrint[1,"invr=",invr];
			If[verbosity>=1,
				With[{tr=traits,so=sol,pt=point,op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invc=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invc=Inv[tr,so,pt,op]]
				]
			]];
			invc=Inv[traits,sol,point,Evaluate[Sequence@@invopts]];
			VPrint[1,"invc=",invc];
			If[invl==$Failed||invr==$Failed||invc==$Failed,Return[$Failed]];
			res=(invr-2invc+invl)/(h^2);
			];
		]
	,
		Else,
		Message[DInv::badmtd];
		Return[$Failed];
	];

(* postprocess & return answer *)

Which[
	simplifyresult===True,
	res2=Simplify[res/.traits],
	simplifyresult===Real,
	res2=RealSimplify[res/.traits],
	simplifyresult===Full,
	res2=FullSimplify[res/.traits,Assumptions:>{_\[Element]Reals}],
	Else,
	res2=res/.traits
];

If[chop==True,Return[Chop[res2]],Return[res2]];

]];


(* first derivative abbreviated syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,1];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no point syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_?NumberQ},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,2];*)
	If[Global`debug,Print["DInv: no point given"]];
	DInv[traits,solin,{var,ord},Guild->Automatic,opts]
);


(* no order *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,3];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,4];*)
	If[Global`debug,Print["Dinv: no order, no point"]];
	DInv[traits,solin,{var,1},Guild->1,opts]
);


(* no var, no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,opts___?OptionQ]:=(
	(*AppendTo[Global`uses,5];*)
	If[Global`debug,Print["DInv: no var, no order, no point"]];
	DInv[traits,solin,{All,1},opts]
);


(* first derivative abbreviated syntax & break up traitsandpops *)
DInv[eesol_?AttributesAndVariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,6];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax & break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,1},pointin,opts]
);


(* general derivative abbreviated syntax *)
DInv[eesol_?AttributesAndVariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_Integer},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,7];*)
	If[Global`debug,Print["DInv: general derivative abbreviated syntax"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,ord},pointin,opts]
);


(* break up traitsandpops *)
DInv[eesol_?AttributesAndVariablesQ,rest___]:=(
	(*AppendTo[Global`uses,8];*)
	If[Global`debug,Print["DInv: break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],rest]
);


(* first derivative abbreviated syntax, no traits or variables *)
DInv[var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,9];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax, no traits or variables"]];
	DInv[{},{},{var,1},pointin,opts]
);


NDInv[args___]:=DInv[args,Method->"NDInv"];


MaximizeInv::usage = 
"MaximizeInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds the trait value(s) that maximize invasion fitness into a community with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


MaximizeInv[traits:(_?AttributesQ):{},sol:(_?VariablesQ):{},opts:OptionsPattern[]]:=
 
Module[{
(* options *)
verbose,guild,delayinv,invopts,maximizeopts,method,constraints,
(* other variables *)
vars,unks,inv,res},

Block[{\[ScriptCapitalN],verbosity,func="MaximizeInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[MaximizeInv]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[MaximizeInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[MaximizeInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
delayinv=OptionValue[DelayInv];
invopts=OptionValue[InvOpts];
maximizeopts=OptionValue[MaximizeOpts];
method=OptionValue[Method];
constraints=OptionValue[Constraints];

(* reset $InvCount *)
$InvCount=0;

vars=Table[Subscript[gtrait,0],{gtrait,gtraits[guild]}];
unks=Table[Unk[Subscript[gtrait,0]],{gtrait,gtraits[guild]}];


Which[
	constraints==="None",
	constraints={};
,
	constraints===Automatic,
	constraints=Table[Min[range[gtrait]]<=Subscript[gtrait,0]<=Max[range[gtrait]],{gtrait,gtraits[guild]}]
,
	Else,
	constraints=Table[Min[range[gtrait]]<=Subscript[gtrait,0]<=Max[range[gtrait]],{gtrait,gtraits[guild]}]
];

VPrint[3,"constraints=",constraints];

If[delayinv==True,
	inv[varz_?NumericListQ]:=Inv[traits,sol,Thread[vars->varz],Evaluate[Sequence@@invopts]];
	res=NMaximize[Prepend[constraints/.ToUnks,inv[unks]],unks,Evaluate[Sequence@@maximizeopts]];
	, (* else *)
	Off[NIntegrate::inumr];
	inv=Inv[traits,sol,Guild->guild,Evaluate[Sequence@@invopts]];
	VPrint[3,"inv=",inv];
	Which[
		method=="Maximize",
		res=Maximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]],
		method=="NMaximize",
		(* see https://mathematica.stackexchange.com/questions/245404/ *)
		If[$VersionNumber==12.2,
			Block[{Optimization`UseConvexMinimize=False},res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]]],
			res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]]
		],
		Else,
		Message[MaximizeInv::badmtd];
		Return[$Failed]
	];
	On[NIntegrate::inumr]
];

Return[res/.FromUnks];

]];


Options[MaximizeInv]={Verbose->False,Verbosity->0,
Guild->Automatic,DelayInv->False,InvOpts->{},MaximizeOpts->{},Constraints->Automatic,Method->"NMaximize"};


(* break up combined traitsandpops *)
MaximizeInv[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=MaximizeInv[ExtractAttributes[sol],ExtractVariables[sol],opts];


GlobalESSQ::usage =
"GlobalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks global ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


GlobalESSQ[traits_?AttributesQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,
maximizeinvopts,invthreshold,
(* other variables *)
inv,tmp},

Block[{\[ScriptCapitalN],verbosity,func="GlobalESSQ"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[GlobalESSQ]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[GlobalESSQ]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[GlobalESSQ]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

maximizeinvopts=Evaluate[MaximizeInvOpts/.Flatten[{opts,Options[GlobalESSQ]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[GlobalESSQ]}]];

(* find max invader rate .. if > invthreshold, then not globaless *)

Do[
	tmp[gu]=MaximizeInv[traits,sol,Guild->gu,maximizeinvopts];
	VPrint[1,"MaximizeInv guild ",gu,"=",tmp[gu]];
,{gu,guilds}];

Return[{
	Table[If[tmp[gu][[1]]>invthreshold,False,True],{gu,guilds}],
	Table[{tmp[gu][[1]],Table[gtrait->(Subscript[gtrait,0]/.tmp[gu][[2]]),{gtrait,gtraits[gu]}]},{gu,guilds}]}
];

]];


Options[GlobalESSQ]={Verbose->False,Verbosity->0,
MaximizeInvOpts->{},InvThreshold->10^-10};


GlobalESSQ[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
	GlobalESSQ[ExtractAttributes[eesol],ExtractVariables[eesol],opts];


LocalESSQ::usage=
"LocalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks local ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


LocalESSQ[traits_?AttributesQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["LocalESSQ"],
(* options *)
verbose,
(* other variables *)
res
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

res=Table[
	NegativeDefiniteMatrixQ/@DInv[traits,sol,{Replace[gtraits[gu],var_Symbol->Subscript[var, 0],1],2}]
,{gu,guilds}];

Return[res]
]];


Options[LocalESSQ]={
};


LocalESSQ[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=LocalESSQ[ExtractAttributes[eesol],ExtractVariables[eesol],opts];


PlotInv::usage =
"PlotInv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] plots a fitness landscape, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).";


PlotInv[attributes:(_?AttributesQ):{},sol:(_?VariablesQ):{},invaderGs:(_?GsQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,monitor,
fixed,species,delayinv,invopts,time,plotopts,plotspecies,markerstyle,plotguildopts,tf,axeslabel,plotrange,tadplotrange,
(* other variables *)
nb,x,iplot,
iopts,imin,imax,tmin,tmax,s,iaspectratio,iticks,iaxesorigin,iplotrangepadding,resplotrange,lmin,
gu,tr,per,res,inv,epilog,tad},

Block[{\[ScriptCapitalN],verbosity,func="PlotInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotInv]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotInv]}]];
species=Evaluate[Species/.Flatten[{opts,Options[PlotInv]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotInv]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotInv]}]];
If[delayinv===Automatic,If[modelperiod=!=0,delayinv=True,delayinv=False]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotInv]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotInv]}]];
plotspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PlotInv]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PlotInv]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PlotInv]}]];
plotguildopts=Join[Evaluate[PlotGuildOpts/.Flatten[{opts,Options[PlotInv]}]],{PlotRange->{0,All}}];
tadplotrange=PlotRange/.plotguildopts;
tf=Evaluate[TADVerticalScale/.Flatten[{opts,Options[PlotInv]}]];
plotopts=FilterRules[Flatten[{opts,Options[PlotInv]}],Options[Plot]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotInv]}]];
If[axeslabel===Automatic,axeslabel={trait1}];

(* figure out what trait is on the x-axis *)
{gu,tr}=LookUp[trait1][[2;;3]];

(* add to fixed if species is given *)
If[species=!=None,
	fixed=Flatten@{
		fixed,
		Table[
			{If[guild1[interaction]===gu,Subscript[interaction,0,sp\[Prime]_]->(Subscript[interaction,species,sp\[Prime]]/.attributes),Nothing],
			If[guild2[interaction]===gu,Subscript[interaction,sp\[Prime]_,0]->(Subscript[interaction,sp\[Prime],species]/.attributes),Nothing]}
		,{interaction,EcoEvo`Private`interactions}],
		Table[If[Subscript[gtrait,0]=!=trait1,Subscript[gtrait,0]->(Subscript[gtrait,species]/.attributes),Nothing],{gtrait,gtraits[gu]}]
		}
];
(*Print["fixed=",fixed];*)

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes,sol];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

If[monitor,PrintTemporary[Dynamic[ToString[TraditionalForm@trait1]<>"="<>ToString[TraditionalForm@x]]]];

(* plot fitness function *)
If[delayinv,
	(* delay inv *)
	inv[\[FormalX]_?NumberQ]:=Inv[attributes,sol,Join[{Subscript[tr,0]->\[FormalX]},fixed],invaderGs,Guild->gu,Evaluate[Sequence@@invopts],Time->time];
	iplot=Plot[(x=\[FormalX];Evaluate[inv[\[FormalX]]]),{\[FormalX],trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
,
	(* nondelay inv *)
	Off[NIntegrate::inumr];
	inv=Inv[attributes,sol,invaderGs,Guild->gu,Evaluate[Sequence@@invopts],Time->time]/.fixed/.attributes;
	VPrint[1,"inv=",inv];
	iplot=Plot[inv,{trait1,trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
	On[NIntegrate::inumr]
];

(*Print[iplot];*)

(* plot species markers *)
If[Subscript[\[ScriptCapitalN], gu]==0,plotspecies="None"];
Which[
	plotspecies==="Axis",
	If[markerstyle===Automatic,
		epilog=Table[{PointSize[0.015],Color[Subscript[tr,sp]][SpFrac[sp,\[ScriptCapitalN][gu]]],Point[{Subscript[tr,sp]/.attributes,0}]},{sp,\[ScriptCapitalN][gu]}],
		epilog=MapThread[Append,{PadRight[{},\[ScriptCapitalN][gu],
			Map[Flatten[{#}]&,markerstyle]],Table[Point[{Subscript[tr,sp]/.attributes,0}],{sp,\[ScriptCapitalN][gu]}]}]
	];
	res=Show[iplot,Epilog->epilog]
,
	plotspecies==="TAD",
	epilog={};
	tad=PlotGuild[attributes,TemporalMean[sol],PlotRange->{{trait1min,trait1max},tadplotrange},Evaluate[Sequence@@plotguildopts],
		ImagePadding->{{0,0},{0,Scaled[0.05]}},Axes->False,Guild->gu,Species->species,Time->time];
	{tmin,tmax}=(PlotRange/.AbsoluteOptions[tad,PlotRange])[[2]];
	iopts=AbsoluteOptions[iplot];
	{imin,imax}=(PlotRange/.iopts)[[2]];
	(*Print["{imin,imax}=",{imin,imax}];
	Print["{tmin,tmax}=",{tmin,tmax}];*)
	iaspectratio=AspectRatio/.iopts;
	iticks=Ticks/.iopts;
	iaxesorigin=AxesOrigin/.iopts;
	iplotrangepadding=PlotRangePadding/.iopts;
	(*Print["iaxesorigin=",iaxesorigin];
	Print["iplotrangepadding=",iplotrangepadding];*)
	s=Max[tf*imin/(tmax(tf-1)),tf*(imax-Min[0,imin])/tmax]; (* scale TAD *)
	(*Print["s=",s];*)
	resplotrange={Min[imin,tmin],Max[imax,s*tmax]};
	If[Head[iplotrangepadding[[2,2]]]===Scaled,
		lmin=imax+1.01*Differences[resplotrange][[1]]*iplotrangepadding[[2,2,1]],
		lmin=imax+iplotrangepadding[[2,2]]+0.01*Differences[resplotrange][[1]]
	];
	(*Print["lmin=",lmin];*)
	res=Show[iplot,
		PlotRange->{{trait1min,trait1max},resplotrange},Ticks->iticks,
		Prolog->{{White,Thick,Line[{{iaxesorigin[[1]],lmin},{iaxesorigin[[1]],10^10}}]},
		Inset[Show[tad,AspectRatio->iaspectratio*tf],{0,0},{0,0},Scaled[1]]}];
	(*res=Show[
		iplot,
		PlotRange\[Rule]{{trait1min,trait1max},plotrange},Ticks\[Rule]iticks,
		Epilog\[Rule]{{White,Line[{{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],lmin},{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],10^10}}]},
		Inset[Show[tad,AspectRatio\[Rule]iaspectratio*tf],{0,0},{0,0},Scaled[1]],
		Inset[Show[iplot,Axes\[Rule]False,PlotRange\[Rule]{{trait1min,trait1max},resplotrange}],{0,0},{0,0},Scaled[1]]}]*)
,
	Else,
	res=iplot
];

If[monitor,NotebookClose[nb]];

Return[res]
]];


(* split combined traitsandpops *)
PlotInv[traitsandpops_?AttributesAndVariablesQ,invaderGs:(_?GsQ):{},{trait1_,trait1min_,trait1max_},opts___?OptionQ]:=
PlotInv[ExtractAttributes[traitsandpops],ExtractVariables[traitsandpops],invaderGs,{trait1,trait1min,trait1max},opts];


Options[PlotInv]={Verbose->False,Verbosity->0,
InvOpts->{},Fixed->{},Species->None,
DelayInv->Automatic,Time->t,
MarkerStyle->Automatic,ShowSpecies->"TAD",PlotGuildOpts->{},TADVerticalScale->0.25,
AxesLabel->Automatic,PlotRange->Automatic,
PlotStyle->Gray,PlotPoints->5,
Monitor->False
};


PlotZIP::usage =
"PlotZIP[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] creates a zero invasion plot, with invader \!\(\*
StyleBox[\"inv\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(inferred if omitted).
PlotZIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PlotZIP[solin_:"FindEcoAttractor",{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},
invaderin:(_?InvaderQ):Automatic,opts___?OptionQ]:=

Module[{
(* options *)
verbose,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,ics,invthreshold,guild,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
fixedvars,traitinv,subrule,luv1,luv2,gu,tr1,tr2,invader,sol,inv,res},

Block[{\[ScriptCapitalN],verbosity,func="PlotInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotZIP]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotInv]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotZIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotZIP]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotZIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotZIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotZIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotZIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotZIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotZIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotZIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotZIP]}]];
If[invthreshold===Automatic,invthreshold=If[modeltype=="DiscreteTime",1,0]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotZIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotZIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotZIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

fixedvars=fixed[[All,1]];

(* figure out what are the traits on the x- and y-axes *)

luv1=LookUp[var1];
luv2=LookUp[var2];
VPrint[3,"LookUp[var1]=",luv1," LookUp[var2]=",luv2];

traitinv={};subrule={};
If[luv1[[1]]==="gtrait",
	{gu,tr1}=luv1[[2;;3]];
	AppendTo[traitinv,var1->\[FormalX]],
	AppendTo[subrule,var1->\[FormalX]]
];
If[luv2[[1]]==="gtrait",
	If[luv1[[1]]==="gtrait"&&(luv2[[2]]!=gu),Message[PlotZIP::diffsp];Return[$Failed]];
	{gu,tr2}=luv2[[2;;3]];
	AppendTo[traitinv,var2->\[FormalY]],
	AppendTo[subrule,var2->\[FormalY]]
];

(*Print["gu=",gu];
Print["traitinv=",traitinv];
Print["subrule=",subrule];*)

If[
	invaderin===Automatic,
	If[MemberQ[guilds,gu],
		invader=traitinv,
		Message[PlotZIP::unkinv];Return[$Failed]
	]
,
	invader=invaderin
];
(*Print["invader=",invader];*)

If[boundarystyle===Automatic,
	If[LookUp[invader][[1]]=="pcomp",
		boundarystyle={Color[invader],Opacity[1]},
		boundarystyle={Black,Opacity[1]}]
];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={var1,var2,"inv"},
		framelabel={var1,var2}
	]
];

(* define resident sol *)
If[solin==="FindEcoAttractor",
	If[fixed=={},
		sol[\[FormalX]_,\[FormalY]_]={}
	,
		If[ics=={},
			(* figure out number of species in guilds *)
			Set\[ScriptCapitalN][fixed];
			VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
			ics=DefaultICs;
			VPrint[1,"ics=",ics];
		];
		If[verbose,
			With[{tr=fixed,ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[\[FormalX],\[FormalY]]=FindEcoAttractor[trait,ics,op]]
		]];
		sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
			result=FindEcoAttractor[fixed,ics,Evaluate[Sequence@@findecoattractoropts]];
			If[printtrace,Print["EcoAttractor (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
			If[result=={$Failed},Message[PlotZIP::feafail,\[FormalX],\[FormalY]]];
			Return[result]
		];
		delayinv=True]
,
		If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{var1->\[FormalX],var2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{var1->\[FormalX],var2->\[FormalY]};
	VPrint[1,"sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]];
];

(* define inv *)

If[delayinv,
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[\[FormalX],\[FormalY]]=Inv[tr,so,in,op]/.{var1->\[FormalX],var2->\[FormalY]}]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[fixed,sol[\[FormalX],\[FormalY]],invader,Evaluate[Sequence@@invopts]]/.subrule;
		If[printtrace,Print["Inv (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts,sr=subrule,trinv=traitinv},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,in,op]/.sr/.trinv]
	]];
	inv[\[FormalX]_,\[FormalY]_]=Inv[fixed,sol[\[FormalX],\[FormalY]],invader/.Subscript[var_, sub_]->Subscript[var, 0],Evaluate[Sequence@@invopts]]/.subrule/.traitinv;
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]]
];

If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[var1],TextCell["="],Dynamic[x]},
		{ExpressionCell[var2],TextCell["="],Dynamic[y]}
		}],WindowTitle->"PlotZIP Progress...",WindowSize->All];
];


Which[
	plottype=="Plot3D",
	res=Plot3D[({x,y}={\[FormalX],\[FormalY]};{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold}),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"]],
	plottype=="ContourPlot",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,PlotRange->{{var1min,var1max},{var2min,var2max}}],
	plottype=="RegionZIP", 
	res=RegionPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="ZIP",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,
		ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,
		PlotRange->{{var1min,var1max},{var2min,var2max}}],
	Else,
	Message[PlotZIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotZIP]={Verbose->False,Verbosity->0,
FindEcoAttractorOpts->{},InvOpts->{},
DelayInv->False,PlotType->"ZIP",ICs->{},Fixed->{},InvThreshold->Automatic,
PlotOpts->{MaxRecursion->3},
BoundaryStyle->Automatic,InvStyle->Gray,NonInvStyle->Opacity[0],
Monitor->False
};


PlotZIP::unkinv=
"Can't figure out who's invading: please specify.";

PlotZIP::diffsp=
"\!\(\*
StyleBox[\"x\", \"TI\"]\)- and \!\(\*
StyleBox[\"y\", \"TI\"]\)-axes should have the same species.";


PlotZNGI::usage =
"PlotZNGI[\!\(\*
StyleBox[\"sp\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots a zero net growth isocline of \!\(\*
StyleBox[\"sp\", \"TI\"]\).
PlotZNGI[{\!\(\*
StyleBox[\"sp1\", \"TI\"]\), \!\(\*
StyleBox[\"sp2\", \"TI\"]\), \[Ellipsis]}, {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots multiple ZNGIs.
PlotZNGI[\!\(\*
StyleBox[\"traits\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ZNGIs with \!\(\*
StyleBox[\"traits\", \"TI\"]\).";


PlotZNGI[invaders_?RuleListQ,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
plotstyle,
(* other variables *)
boundarystyle
},
Block[{\[ScriptCapitalN],verbosity,func="PlotInv"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotZNGI]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotZNGI]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotZNGI]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotZNGI]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][invaders];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

Return[Show[Table[Table[
	If[plotstyle===Automatic,
		boundarystyle={Color[Subscript[gcomps[gu][[1]],0]][SpFrac[sp,\[ScriptCapitalN][gu]]],Opacity[1]},
		boundarystyle=Flatten[{plotstyle,Opacity[1]}]
	];
	PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},Table[Subscript[gtrait, 0]->Subscript[gtrait, sp]/.invaders,{gtrait,gtraits[gu]}],
		opts,InvStyle->Opacity[0],BoundaryStyle->boundarystyle]
,{sp,\[ScriptCapitalN][gu]}],{gu,guilds}]]]
]
];


PlotZNGI[invaders_List,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=
	Show[PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},#,opts,InvStyle->Opacity[0]]&/@invaders];


PlotZNGI[invader_,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=
	PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},invader,opts,InvStyle->Opacity[0]];


Options[PlotZNGI]={Verbose->False,Verbosity->0,
PlotStyle->Automatic};


PlotPIP::usage =
"PlotPIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a pairwise invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotPIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.";


PlotPIP[solin_:"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,randomseeding,
plotopts,plottype,ics,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,res,sol,resinv,inv},

Block[{\[ScriptCapitalN],verbosity,func="PlotPIP"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotPIP]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotPIP]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotPIP]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];
If[verbosity>=1,verbose=True];

(* handle options *)

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotPIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotPIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotPIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotPIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotPIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotPIP]}]];
randomseeding=Evaluate[RandomSeeding/.Flatten[{opts,Options[PlotPIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotPIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotPIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotPIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotPIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotPIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotPIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotPIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotPIP]}]];

If[zerodiagonal,inv[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={trait1,Subscript[tr1,0],"inv"},
		framelabel={trait1,Subscript[tr1,0]}
	]
];

(* fixed traits for invader *)
invfixed=Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}];

(* define resident sol *)

Which[
	solin==="FindEcoAttractor",
	If[ics=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Append[fixed,trait1->trait1]];
		VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
		ics=DefaultICs;
		VPrint[1,"ics=",ics];
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ]:=Global`sol[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol[\[FormalX]_?NumberQ]:=sol[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],EcoSimOpts->{RandomSeeding->randomseeding}];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotPIP::feafail,trait1,\[FormalX]]];
		Return[result]
	];
	delayinv=True;
,
	TemporalRuleListQ[solin],
	sol[\[FormalX]_]=solin/.(var_->if_)->(var->if[\[FormalX]]);
,
	Else,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_]=solin/.trait1->\[FormalX]]];
	sol[\[FormalX]_]=solin/.trait1->\[FormalX];
	VPrint[1,"sol[\[FormalX]]=",sol[\[FormalX]]];
];

(* define inv *)
If[delayinv,
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
				PrintCall[Global`resinv[(System`\[FormalX])_?NumberQ]:=Global`resinv[System`\[FormalX]]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_?NumberQ]:=resinv[\[FormalX]]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts]];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Global`sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
		If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		If[subtractdiagonal,result=result-resinv[\[FormalX]]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
			PrintCall[Global`resinv[(System`\[FormalX])_]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_]=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts]];
		VPrint[1,"resinv[\[FormalX]]=",resinv[\[FormalX]]];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_,\[FormalY]_]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]]
			-If[subtractdiagonal==True,resinv[\[FormalX]],0];
	VPrint[1,"inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]];
];

If[monitor,PrintTemporary[Grid[{{Dynamic[ToString[TraditionalForm@trait1]<>"="<>ToString[TraditionalForm@x]],
Dynamic[ToString[TraditionalForm@Subscript[tr1,0]]<>"="<>ToString[TraditionalForm@y]]}},ItemSize->10,Alignment->Left]]];

Which[
	plottype=="Plot3D",
	res=Plot3D[{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold},{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"],EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="ContourPlot",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="RegionPlot", 
	res=RegionPlot[Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="PIP",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	Else,
	Message[PlotPIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotPIP]={Verbose->False,Verbosity->0,
FindEcoAttractorOpts->{},InvOpts->{},RandomSeeding->1234,
DelayInv->False,PlotType->"PIP",ICs->{},ZeroDiagonal->False,Fixed->{},SubtractDiagonal->False,InvThreshold->0,
PlotOpts->{MaxRecursion->3},FrameLabel->Automatic,
BoundaryStyle->Black,InvStyle->Gray,NonInvStyle->White,
Monitor->False
};


PlotPIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";


PlotMIP::usage =
"PlotMIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a mutual invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotMIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotMIP[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotMIP[{\!\(\*
StyleBox[\"sol1\", \"TI\"]\), \!\(\*
StyleBox[\"sol2\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibria \!\(\*
StyleBox[\"sol1\", \"TI\"]\) and \!\(\*
StyleBox[\"sol2\", \"TI\"]\).";


PlotMIP[{solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",solin2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,icsin,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,spcolors,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,gu2,tr2,sp2,ics,sol1,sol2,inv12,inv21,pip1,pip2,res},

Block[{\[ScriptCapitalN],verbosity,func="PlotMIP"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotMIP]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[PlotMIP]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[PlotMIP]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotMIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotMIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotMIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotMIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotMIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotMIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotMIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotMIP]}]];
icsin=Evaluate[ICs/.Flatten[{opts,Options[PlotMIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotMIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotMIP]}]];
spcolors=Evaluate[SpeciesColors/.Flatten[{opts,Options[PlotMIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotMIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotMIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

If[zerodiagonal,inv12[\[FormalX]_,\[FormalX]_]=inv21[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* fixed traits for invader [why are there 2 of these?] *)
invfixed=Flatten[Join[
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}],
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu2],{tr2}]}]
]];

(* define resident sol *)

Which[
	solin1==="FindEcoAttractor",
	If[icsin=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Append[fixed,trait1->trait1]];
		VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
		ics=DefaultICs;
		VPrint[1,"ics=",ics];
	,
		ics=icsin
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol1[(System`\[FormalX])_?NumberQ]:=Global`sol1[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol1[\[FormalX]_?NumberQ]:=sol1[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts]];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotMIP::feafail,trait1,\[FormalX]]];
		Return[result];
	];
	delayinv=True;
,
	TemporalRuleListQ[solin1],
	sol1[\[FormalX]_]=solin1/.(var_->if_)->(var->if[\[FormalX]]);
,
	Else,
	If[verbose,PrintCall[Global`sol1[(System`\[FormalX])_]=solin1/.trait1->\[FormalX]]];
	sol1[\[FormalX]_]=solin1/.trait1->\[FormalX];
	VPrint[1,"sol1[\[FormalX]]=",sol1[\[FormalX]]]
];

If[trait1=!=trait2,
	Which[
		solin2==="FindEcoAttractor",
		delayinv=True;
		If[icsin=={},
			(* figure out number of species in guilds *)
			Set\[ScriptCapitalN][Append[fixed,trait2->trait2]];
			VPrint[3,"\[ScriptCapitalN]2=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];
			ics=DefaultICs;
			VPrint[1,"ics=",ics];
		,
			ics=icsin
		];
		If[verbose,
			With[{tr=Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol2[(System`\[FormalX])_?NumberQ]:=Global`sol2[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
		]];
		sol2[\[FormalX]_?NumberQ]:=sol2[\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts]];
			If[printtrace,Print["EcoAttractor (",trait2,"=",\[FormalX],"): ",result]];
			If[result=={$Failed},Message[PlotMIP::feafail,trait2,\[FormalX]]];
			Return[result];
		];
	,
		TemporalRuleListQ[solin2],
		sol2[\[FormalX]_]=solin2/.(var_->if_)->(var->if[\[FormalX]]);
	,
		Else,
		If[verbose,PrintCall[Global`sol2[(System`\[FormalX])_]=solin2/.trait2->\[FormalX]]];
		sol2[\[FormalX]_]=solin2/.trait2->\[FormalX];
		VPrint[1,"sol2[\[FormalX]]=",sol2[\[FormalX]]]
	]
,
	sol2[\[FormalX]_]:=sol1[\[FormalX]];
	VPrint[1,"sol2[\[FormalX]]=sol1[\[FormalX]]"]
];

(* define inv21 & inv12 *)
If[delayinv,
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Defer[Global`sol1][\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts,trinv=Subscript[trait[gu2,tr2],0]},
			PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv21[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
		If[printtrace,Print["Inv (",trait2,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		Return[result]
	];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Defer[Global`sol2][\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv12[\[FormalX],\[FormalY]]=Module[{result},
			result=Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
			If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr2,0],"=",\[FormalY],"): ",result]];
			Return[result]
		];
	,
		(* if trait1=trait2, then re-use inv21 *)
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]]
	]
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Defer[Global`sol1][\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts},
			PrintCall[Global`inv21[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_,\[FormalY]_]=
		Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts]];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Global`sol2[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_,\[FormalY]_]=
			Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts]]
	,
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]];
		VPrint[1,"inv12[\[FormalX],\[FormalY]]=inv21[\[FormalX],\[FormalY]]"]
	]
];


If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[trait1],TextCell["="],Dynamic[x]},
		{ExpressionCell[If[trait2===trait1,Subscript[tr1,sp1+1],trait2]],TextCell["="],Dynamic[y]}
		}],WindowTitle->"PlotMIP Progress...",WindowSize->All];
];


Which[
	plottype=="MIP",
	pip1=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv21[\[FormalX],\[FormalY]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv12[\[FormalY],\[FormalX]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1//AxisFlip
	];
	res=Show[Graphics[{invstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,Frame->True,FrameLabel->framelabel,
		Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionMIP",
	res=RegionPlot[{!Evaluate[(inv12[\[FormalY],\[FormalX]]>invthreshold&&inv21[\[FormalX],\[FormalY]]>invthreshold)],Evaluate[(inv12[\[FormalY],\[FormalX]]>invthreshold&&inv21[\[FormalX],\[FormalY]]>invthreshold)]},
		{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		PlotStyle->{noninvstyle,invstyle},BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="Outcome",
	pip1=ContourPlot[Evaluate[inv21[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[2]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[Evaluate[inv12[\[FormalY],\[FormalX]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[1]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1/.spcolors[[2]]->spcolors[[1]]//AxisFlip
	];
	res=Show[Graphics[{noninvstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,
		Frame->True,FrameLabel->framelabel,Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionOutcome",
	res=RegionPlot[Evaluate[{inv21[\[FormalX],\[FormalY]]>invthreshold,inv12[\[FormalY],\[FormalX]]>invthreshold}]
		,{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],BoundaryStyle->boundarystyle,
		PlotStyle->{Directive[spcolors[[1]],Opacity[0.4]],Directive[spcolors[[2]],Opacity[0.4]]},FrameLabel->framelabel],
	Else,
	Message[PlotMIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res];

]];


(* only one sol given *)
PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},
	{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
((*Print[1];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


(* only one sol given *)
PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},
	opts___?OptionQ]:=
((*Print[2];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait1,trait1min,trait1max},opts]);


(* no sol given *)
PlotMIP[{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},
	opts___?OptionQ]:=
((*Print[3];*)PlotMIP[{"FindEcoAttractor","FindEcoAttractor"},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


Options[PlotMIP]={Verbose->False,Verbosity->0,
PlotType->"MIP",DelayInv->False,FindEcoAttractorOpts->{},InvOpts->{},InvThreshold->0,
ICs->{},ZeroDiagonal->False,Fixed->{},
BoundaryStyle->Black,SpeciesColors->{Red,Blue},InvStyle->Gray,NonInvStyle->White,FrameLabel->Automatic,
PlotOpts->{MaxRecursion->3},
Monitor->False
};


PlotMIP::feafail="FindEcoAttractor failed at `1`=`2`.";
PlotMIP::badmtd="The PlotType option should be a built-in method name (\"MIP\", \"RegionMIP\", \"Outcome\", or \"RegionOutcome\").";


TraitEqns::usage=
"TraitEqns[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] sets up trait equations with ecological solution \!\(\*
StyleBox[\"sol\", \"TI\"]\) and trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


TraitEqns[solin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=
 
Module[{
(* options *)
verbose,verboseall,fixed,
logged,delaydinv,dinvopts,evoeqn,traitshiftrate,nsps,ics,time,ignorevar,momentbased,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedtraits,alltraits,Gs,
g,dtrait,pre,wt,sol,eqns},

Block[{\[ScriptCapitalN],verbosity,func="TraitEqns"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[TraitEqns]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[TraitEqns]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[TraitEqns]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[TraitEqns]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
VPrint[3,"fixedattributes=",fixedattributes];
fixedvariables=ExtractVariables[fixed];
VPrint[3,"fixedvariables=",fixedvariables];

nonfixedtraits=Evaluate[NonFixedTraits/.Flatten[{opts,Options[TraitEqns]}]];

logged=Evaluate[Logged/.Flatten[{opts,Options[TraitEqns]}]];
momentbased=Evaluate[MomentBased/.Flatten[{opts,Options[TraitEqns]}]];
If[momentbased==Automatic,If[moments==True,momentbased=True,momentbased=False]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[TraitEqns]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[TraitEqns]}]];
If[modelperiod=!=0,AppendTo[dinvopts,InvOpts->{Method->"Instantaneous"}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[TraitEqns]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[TraitEqns]}]];
nsps=Evaluate[\[ScriptCapitalN]s/.Flatten[{opts,Options[TraitEqns]}]];
time=Evaluate[Time/.Flatten[{opts,Options[TraitEqns]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[TraitEqns]}]];

(*Print["solin=",solin];*)
sol=FixVariables[solin];
VPrint[3,"sol=",sol];

(* figure out number of species in guilds *)
If[solin==="FindEcoAttractor"&&nsps=!={},
	Evaluate[Table[\[ScriptCapitalN][gu],{gu,guilds}]]=nsps,
	Set\[ScriptCapitalN][Join[sol,fixedvariables]]
];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(*Print["Gsin="Gsin];*)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(* determine nonfixedtraits = Complement[alltraits,fixedattributes] *)
alltraits=Flatten[Table[Table[Table[If[ngcomps[gu]==1,Subscript[gtrait, i],Table[Subscript[gtrait[gcomp], i],{gcomp,gcomps[gu]}]],{gtrait,gtraits[gu]}],{i,\[ScriptCapitalN][gu]}],{gu,guilds}]];
VPrint[3,"alltraits=",alltraits];
If[nonfixedtraits===Automatic,nonfixedtraits=OrderedComplement[alltraits,fixedattributes]];
VPrint[3,"nonfixedtraits=",nonfixedtraits];

(* shifting traits *)
Do[
	dtrait[gu,gtrait]=If[MemberQ[traitshiftrate[[All,1]],gtrait],gtrait/.traitshiftrate,0]
,{gu,guilds},{gtrait,gtraits[gu]}];
VPrint[3,"dtrait=",Table[dtrait[gu,gtrait],{gu,guilds},{gtrait,gtraits[gu]}]];


If[momentbased==False, (* DInv-based *)

(* set up G matrices *)
Do[
	Do[
		g[gu,sp]=If[MatrixQ[Subscript[G[gu], sp]/.Gs],
			(* if G-matrix is given, symmetrize it to be safe *)
			SymmetrizeMatrix[Subscript[G[gu], sp]/.Gs],
			(* otherwise make one based on given Var[] & Cov[], otherwise assume Var[]=1 & Cov[]=0 *)
			MakeGMatrix[Subscript[gu, sp]]/.Gs/.{Subscript[Var[_], sp]->1,Subscript[Cov[_,_], sp]->0}
		];
		VPrint[3,"g[",gu,",",sp,"]=",g[gu,sp]];
	,{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}]
,{gu,guilds}];

(* pre-factors for weighting population componnents in canonical equation *)
Which[
	evoeqn=="QG",
	Do[Do[pre[gu,sp]=1,{sp,0,\[ScriptCapitalN][gu]}],{gu,guilds}],
	evoeqn=="CE",
	Do[
		Do[
			If[comptype[gcomp]=="Extensive",wt[gu,gcomp]=1,wt[gu,gcomp]=0]
		,{gcomp,gcomps[gu]}];
		Do[
			pre[gu,sp]:=Sum[wt[gu,gcomp]*Subscript[gcomp,sp],{gcomp,gcomps[gu]}]
		,{sp,0,\[ScriptCapitalN][gu]}]
	,{gu,guilds}],
	Else,
	Message[TraitEqns::badte];
	Return[$Failed]
];

(*Print["setting eqns..."];*)

If[delaydinv==True,
	eqns=Flatten[Table[Table[Table[
		Subscript[gtrait,sp]'==(pre[gu,sp]/.ToUnks)*
		Sum[(g[gu,sp]/.ToUnks)[[index[gtrait],index[gtrait\[Prime]]]]NumDInv[BlankUnkTraits,sol,Subscript[gtrait\[Prime],0],Species->sp,Method->"NDInv",Evaluate[Sequence@@dinvopts]],{gtrait\[Prime],gtraits[gu]}]
		-dtrait[gu,gtrait]+If[modeltype=="DiscreteTime",Unk[Subscript[gtrait,sp]],0]
	,{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]]/.fixed
,
	If[sol==="FindEcoAttractor",sol=BlankVariables];
	eqns=Flatten[Table[Table[
		Thread[Table[Subscript[gtrait,sp]',{gtrait,gtraits[gu]}]==(
		pre[gu,sp]*g[gu,sp] . DInv[BlankTraits,sol,Guild->gu,Species->sp,Time->time,Fixed->fixed,Evaluate[Sequence@@dinvopts]]
		-Table[dtrait[gu,gtrait],{gtrait,gtraits[gu]}]
		+If[modeltype=="DiscreteTime",Table[Subscript[gtrait,sp],{gtrait,gtraits[gu]}],0]
		/.fixed)]
	,{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]](*/.FixVarCovts*)
];

VPrint[3,"eqns=",eqns];

eqns=DeleteCases[eqns,DT[var_]==_/;MemberQ[fixedvars,var]];

(*Print["AllVariables=",AllVariables];
Print["logged=",logged];
Print["ExpRule[AllVariables,logged]=",ExpRule[AllVariables,logged]];
Print["returning ",eqns/.ExpRule[AllVariables,logged]];*)

Return[eqns(*/.ExpRule[AllVariables,logged]*)];
,

(* moment-based *)

(*Print["Gs=",Gs];*)
If[ignorevar,
	Return[Table[var'==(dxdtnaive[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed/.Dispatch[ExpandGs[Gs,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]]),{var,nonfixedtraits}]],
	Return[Table[var'==(dxdt[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed/.Dispatch[ExpandGs[Gs,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]]]),{var,nonfixedtraits}]]
]

]

]];


Options[TraitEqns]={Verbose->False,Verbosity->0,
Time->t,DelayDInv->False,DInvOpts->{},EvoEquation->"QG",TraitShiftRate->{},Fixed->{},\[ScriptCapitalN]s->{},Logged->False,
NonFixedTraits->Automatic,MomentBased->Automatic,IgnoreVar->False};


VarEqns::usage=
"VarEqns[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] sets up trait variance/covariance equations with traits in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological solution \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


VarEqns[attributesin:(_?AttributesQ):{},solin:(_?VariablesQ):{},opts___?OptionQ]:=
 
Module[{
func=FuncStyle["VarEqns"],
(* options *)
verbose,verboseall,fixed,time,nonfixedvarcovs,ignorevar,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,fixedvarcovs,
allvarcovs,sol,attributes},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[VarEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[VarEqns]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[VarEqns]}]];
(*Print["fixed=",fixed];*)
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
If[Global`debug,Print[func,": fixedattributes=",fixedattributes]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];
fixedvarcovs=ExtractVarCovs[fixed];
If[Global`debug,Print[func,": fixedvarcovs=",fixedvarcovs]];

time=Evaluate[Time/.Flatten[{opts,Options[VarEqns]}]];
nonfixedvarcovs=Evaluate[NonFixedVarCovs/.Flatten[{opts,Options[VarEqns]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[VarEqns]}]];

sol=FixVariables[solin];
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[sol,fixedvariables],attributes];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

allvarcovs=Flatten[Table[Table[Table[MakeGMatrix[Subscript[gcomp, i]],{gcomp,gcomps[gu]}],{i,\[ScriptCapitalN][gu]}],{gu,guilds}]];
If[Global`debug,Print[func,": allvarcovs=",allvarcovs]];
If[nonfixedvarcovs===Automatic,nonfixedvarcovs=OrderedComplement[allvarcovs,fixedvarcovs]];
If[Global`debug,Print["nonfixedvarcovs=",nonfixedvarcovs]];

If[ignorevar,
	Return[Table[var'==(dGdtnaive[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed),{var,nonfixedvarcovs}]],
	Return[Table[var'==(dGdt[var/.Subscript[x_, _]->x]/.\[FormalI]->(var/.Subscript[x_, sp_]->sp)/.fixed),{var,nonfixedvarcovs}]]
];

]];


Options[VarEqns]={Verbose->False,Verbosity->0,
Time->t,Fixed->{},NonFixedVarCovs->Automatic,IgnoreVar->False};


PlotEvoStreams::usage=
"PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary streams.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


PlotEvoStreams[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoStreams"],
(* options *)
verbose,verboseall,monitor,printtrace,fixed,time,
evoeqn,fitnessgradient,dinvopts,delaydinv,findecoattractoropts,streamplotopts,framelabel,ecoattnumber,usesymmetry,zerodiagonal,
(* other variables *)
nb,evoeqns,dt,nsps,ics,sol,
x,y,
gu1,tr1,sp1,gu2,tr2,sp2,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoStreams]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoStreams]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoStreams]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoStreams]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoStreams]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[fitnessgradient=="NDInv",AppendTo[dinvopts,Method->"NDInv"]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];

streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEvoStreams]}],Options[StreamPlot]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoStreams]}]];
ecoattnumber=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoStreams]}]];
usesymmetry=Evaluate[UseSymmetry/.Flatten[{opts,Options[PlotEvoStreams]}]];

If[modelperiod!=0&&time==t,delaydinv=True;AppendTo[dinvopts,InvOpts->{}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[tr2===tr1,
		framelabel={trait1,SubscriptAdd[trait1,1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	(* figure out number of species in guilds *)
	Set\[ScriptCapitalN][Join[fixed,{trait1->trait1,trait2->trait2}]];
	ics=DefaultICs;
	nsps=Table[\[ScriptCapitalN][gu],{gu,guilds}];
	If[Global`debug,Print[func,": \[ScriptCapitalN]=",nsps]];
,
	nsps={}
];

evoeqns=TraitEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,\[ScriptCapitalN]s->nsps];
If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_'->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
If[verbose,Print[func,": evoeqns=",evoeqns]];

If[solin==="FindEcoAttractor",
	sol[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=sol[\[FormalX],\[FormalY]]=FindEcoAttractor[{trait1->\[FormalX],trait2->\[FormalY]},ics,Time->time,Evaluate[Sequence@@findecoattractoropts]]/.fixed;
	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=({x,y}={\[FormalX],\[FormalY]};evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=({x,y}={\[FormalX],\[FormalY]};evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];
(*Print[sol[12,18]];Print[dt[12,18]];*)
(*Print[sol[0.5,0]];Print[dt[0.5,0]];*)

If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[trait1],TextCell["="],Dynamic[EcoEvo`Private`xmon]},
		{ExpressionCell[If[tr2===tr1,SubscriptAdd[trait1,1],trait2]],TextCell["="],Dynamic[EcoEvo`Private`ymon]}
		}],WindowTitle->"PlotEvoStreams Progress...",WindowSize->All];
];

res=MyStreamPlot[dt[\[FormalX],\[FormalY]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@streamplotopts]];

If[monitor,NotebookClose[nb]];

Return[res]

]];


PlotEvoStreams[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoStreams[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts]


Options[PlotEvoStreams]={Fixed->{},Time->t,FindEcoAttractorOpts->{},DInvOpts->{},DelayDInv->False,
FrameLabel->Automatic,StreamColorFunction->None,StreamStyle->Gray,
UseSymmetry->False,FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,TraitShiftRate->{},
Monitor->False,PrintTrace->False,Verbose->False};


PlotEvoIsoclines::usage=
"PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary isoclines.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


PlotEvoIsoclines[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoIsoclines"],
(* options *)
verbose,verboseall,fixed,time,
monitor,printtrace,dinvopts,findecoattractoropts,plotopts,framelabel,ics,ecoattnum,
estest,isoclinestyle,delaydinv,delaydinv2,dinv2opts,excludediagonal,
(* other variables *)
nb,evoeqns,
ics1,nsps,color1,color1es,color1nes,color2,color2es,color2nes,style1,style1es,style1nes,style2,style2es,style2nes,
sol,dt,dinv21,dinv22,gu1,tr1,sp1,gu2,tr2,sp2,pre1,pre2,iso1,iso2},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ecoattnum=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
estest=Evaluate[ESTest/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv2=Evaluate[DelayDInv2/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinv2opts=Evaluate[DInv2Opts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
excludediagonal=Evaluate[ExcludeDiagonal/.Flatten[{opts,Options[PlotEvoIsoclines]}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[excludediagonal&&{gu1,tr1}=={gu2,tr2},AppendTo[plotopts,Exclusions->{\[FormalX]==\[FormalY]}]];

If[isoclinestyle===Automatic,
	color1es=color1nes=color1=Color[trait1][0];
	color2es=color2nes=color2=Color[trait2][1];
	style1es=Thick;style1nes=Thin;style1=Thickness[Medium];
	style2es=Thick;style2nes=Thin;style2=Thickness[Medium];
,
	If[ListQ[isoclinestyle[[1]]],
		color1es=ExtractColors[isoclinestyle[[1,1]]];
		color1nes=ExtractColors[isoclinestyle[[1,2]]];
		style1es=Complement[isoclinestyle[[1,1]],color1es];
		style1nes=Complement[isoclinestyle[[1,2]],color1nes];
	,
		color1=ExtractColors[isoclinestyle[[1]]];
		style1=Complement[isoclinestyle[[1,1]],color1];
	];
	If[ListQ[isoclinestyle[[2]]],
		color2es=ExtractColors[isoclinestyle[[2,1]]];
		color2nes=ExtractColors[isoclinestyle[[2,2]]];
		style2es=Complement[isoclinestyle[[2,1]],color2es];
		style2nes=Complement[isoclinestyle[[2,2]],color2nes];
	,
		color2=ExtractColors[isoclinestyle[[2]]];
		style2=Complement[isoclinestyle[[2,1]],color2];
	];
];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	delaydinv2=True;
	If[ics=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Join[fixed,{trait1->trait1}]];
		ics1=DefaultICs;
		Set\[ScriptCapitalN][Join[fixed,{trait1->trait1,trait2->trait2}]];
		nsps=Table[\[ScriptCapitalN][gu],{gu,guilds}];
		If[Global`debug,Print[func,": \[ScriptCapitalN]=",nsps]];
		ics=DefaultICs;
	];
	(* handle diagonal *)
	If[{gu1,tr1}=={gu2,tr2},
		sol[\[FormalX]_?NumberQ,\[FormalX]_?NumberQ]:=sol[\[FormalX],\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX]}],ics1,Time->time,Evaluate[Sequence@@findecoattractoropts]];
			Return[Join[result,Table[Subscript[gcomp,sp2]->0,{gcomp,gcomps[gu1]}]]]
		]
	];
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics=ics,time=time,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[System`\[FormalX],System`\[FormalY]]=
			FindEcoAttractor[tr,ics,Time->time,op]]]
	];
	sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
		result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics,Time->time,Evaluate[Sequence@@findecoattractoropts]];
		If[printtrace,Print["FindEcoAttractor ",{trait1->\[FormalX],trait2->\[FormalY]},"=",result]];
		If[ArrayDepth[result]<2,Return[result],Print[result," ",ArrayDepth[result]];Return[result[[ecoattnum]]]]
	];
, (* sol given *)
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]]
];

evoeqns=TraitEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,\[ScriptCapitalN]s->nsps];

If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_[t+1]->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
If[verbose,Print[func,": evoeqns=",evoeqns]];

If[solin==="FindEcoAttractor",
	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];

(*Print["solin=",solin];
Print[sol[0.1,0.2]];
Print[dt[0.1,0.2]];*)

If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[trait1],TextCell["="],Dynamic[EcoEvo`Private`xmon]},
		{ExpressionCell[trait2],TextCell["="],Dynamic[EcoEvo`Private`ymon]}
		}],WindowTitle->"PlotEvoIsoclines Progress...",WindowSize->All];
];

iso1=ContourPlot[({EcoEvo`Private`xmon,EcoEvo`Private`ymon}={\[FormalX],\[FormalY]};dt[\[FormalX],\[FormalY]][[1]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},
	Contours->{0},ContourShading->False,ContourStyle->Flatten[{color1,style1}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait1]&}
];
If[Global`debug,Print[iso1]];

(* add flip option to save 50% time *)

iso2=ContourPlot[({EcoEvo`Private`xmon,EcoEvo`Private`ymon}={\[FormalX],\[FormalY]};dt[\[FormalX],\[FormalY]][[2]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},
	Contours->{0},ContourShading->False,ContourStyle->Flatten[{color2,style2}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait2]&}];
If[Global`debug,Print[iso2]];

If[monitor,NotebookClose[nb]];

If[estest==False,
	Return[Show[iso1,iso2,FrameLabel->framelabel]]
];

(* ESTest\[Equal]True *)

If[delaydinv2,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv21[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv1,ts1,Method->"NDInv",Time->time,op]];
			PrintCall[Global`dinv22[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv22[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv2,ts2,Method->"NDInv",Time->time,op]]
	]];		
	dinv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv21[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts]];
	dinv22[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv22[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts]];
,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},sp1=sp1,sp2=sp2,
			time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv1,Species->sp1,Time->time,op]];
			PrintCall[Global`dinv22[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv2,Species->sp2,Time->time,op]]
	]];
	dinv21[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Time->time,Evaluate[Sequence@@dinv2opts]];
	dinv22[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Time->time,Evaluate[Sequence@@dinv2opts]];
	If[verbose,
		Print[func,": dinv21[\[FormalX],\[FormalY]]=",dinv21[\[FormalX],\[FormalY]]];
		Print[func,": dinv22[\[FormalX],\[FormalY]]=",dinv22[\[FormalX],\[FormalY]]]
	]
];

Return[Show[
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]>0,color1nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]<0,color1es,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]>0,color2nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]<0,color2es,{Opacity[0]}]]&)],
	Frame->True,Axes->False,AspectRatio->1,FrameLabel->framelabel,PlotRange->{{trait1min,trait1max},{trait2min,trait2max}}
]]

]];


PlotEvoIsoclines[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoIsoclines[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts];


Options[PlotEvoIsoclines]={Fixed->{},Time->t,
	FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,ExcludeDiagonal->True,TraitShiftRate->{},
	FindEcoAttractorOpts->{},DelayDInv->False,DInvOpts->{},PlotOpts->{},FrameLabel->Automatic,
	ESTest->True,DelayDInv2->False,DInv2Opts->{},IsoclineStyle->Automatic,
	Verbose->False,Monitor->False,PrintTrace->False};


PlotEvoPhasePlane::usage=
"PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] combines PlotMIP, PlotEvoStreams and PlotEvoIsoclines.
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq1\", \"TI\"]\), \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses one-species ecological equilibrium \!\(\*
StyleBox[\"eq1\", \"TI\"]\) and two-species ecological equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) for improved speed (2 species).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits (within or between guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses one-species ecological equilibria \!\(\*
StyleBox[\"eq11\", \"TI\"]\) and \!\(\*
StyleBox[\"eq12\", \"TI\"]\) and two-species ecological equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) (2 guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq0\", \"TI\"]\), \!\(\*
StyleBox[\"eq1\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] combines PlotZIP, PlotEvoStreams and PlotEvoIsoclines (2 traits)";


(* two guilds *)
PlotEvoPhasePlane[{eq11:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq12:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Gu)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[{eq11,eq12},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two species *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Sp)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[eq1,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two traits *)
PlotEvoPhasePlane[eq0:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Tr)"],
(* options *)
plotzipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
invader,pes,pei,zip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotzipopts=FilterRules[Flatten[{Evaluate[PlotZIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotZIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

invader=(Guild->LookUp[trait1][[2]]);

pes=PlotEvoStreams[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
zip=PlotZIP[eq0,{(trait1/.Subscript[x_,_]->Subscript[x,0]),trait1min,trait1max},{(trait2/.Subscript[x_,_]->Subscript[x,0]),trait2min,trait2max},
invader,InvStyle->Opacity[0],NonInvStyle->White,Evaluate[Sequence@@plotzipopts]];
If[Global`debug,Print[zip]];

Return[Show[pes,pei,zip]]
];


(* two traits - no eq0 alias *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
PlotEvoPhasePlane["FindEcoAttractor",eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts];


Options[PlotEvoPhasePlane]={PlotMIPOpts->{},PlotZIPOpts->{},PlotEvoIsoclinesOpts->{},PlotEvoStreamsOpts->{}};


EcoEvoSim::usage=
"EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoSim[traitsin_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},tmax_?NumericQ,opts___?OptionQ]:=
Module[{
(* options *)
verbose,
logged,boundarydetection,ndsolveopts,wheneventopts,delaydinv,fixed,tmin,outputtmin,output,freezetraits,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvars,
Gs,traits,tic,ecoeqns,evoeqns,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{\[ScriptCapitalN],verbosity,func="EcoEvoSim"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoSim]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoSim]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoSim]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEvoSim]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EcoEvoSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoEvoSim]}]];
If[outputtmin===Automatic,outputtmin=tmin];
output=Evaluate[Output/.Flatten[{opts,Options[EcoEvoSim]}]];
freezetraits=Evaluate[FreezeTraits/.Flatten[{opts,Options[EcoEvoSim]}]];

If[logged&&delaydinv,Message[EcoEvoSim::notimp];Return[$Failed]];

If[Max[Table[ngcomps[gu],{gu,guilds}]]>1&&modelperiod!=0,Message[EcoEvoSim::susmtd]];

(* expand traits *)
traits=ExpandTraits[traitsin];

fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits];
(*Print["nonfixedvars=",nonfixedvars];*)
(*nonfixedvars=Join[traits\[LeftDoubleBracket]All,1\[RightDoubleBracket],variables\[LeftDoubleBracket]All,1\[RightDoubleBracket]];*)
VPrint[3,"fixedvars=",fixedvars];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* set up ics *)
ics=Table[
	If[logged===True&&comptype[var]==="Extensive",
		log[var][tic]==Log[var/.variables],
		var[tic]==(var/.traits/.variables)]
,{var,nonfixedvars}];

(* insert unks[] for delaydinv *)
If[delaydinv,ics=ics/.ToUnks];

(* expand Gs *)
VPrint[3,"Gsin=",Gsin];
If[Gsin==={},
	Gs=Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}],
	Gs=Gsin];
Gs=ExpandGs[Gs,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(* set up ecoeqns & evoeqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVars->nonfixedvariables,opts]/.Gs;
evoeqns=TraitEqns[BlankVariables,Gs,NonFixedTraits->nonfixedtraits,opts]/.ExpRule[nonfixedvariables,logged];
VPrint[3,"ecoeqns=",ecoeqns];
VPrint[3,"evoeqns=",evoeqns];

(* insert Unks[] for delaydinv *)
If[delaydinv,
	VPrint[3,"processing DelayDInv..."];
	ecoeqns=ecoeqns/.ToUnks;
	evoeqns=evoeqns/.ToUnkRules/.ExpRule[AllVariables,logged];
	evoeqns=ReplaceLHS[evoeqns,ToUnks];
	VPrint[3,"ecoeqns=",ecoeqns];
	VPrint[3,"evoeqns=",evoeqns];
];

VPrint[3,"adding [t]'s..."];
ecoeqns=ecoeqns/.AddVariablets/.AddTraitts;
evoeqns=evoeqns/.AddVariablets/.AddTraitts;
If[delaydinv,evoeqns=ReplaceRHS[evoeqns,{(var1_[t]->var2_)->(var1->var2),Subscript[var_, 0][t]->Subscript[var, 0]}]];
VPrint[3,"ecoeqns=",ecoeqns];
VPrint[3,"evoeqns=",evoeqns];


(* boundary detection *)
If[boundarydetection==True,
	Which[
		modeltype=="ContinuousTime",
		bdwhens=Flatten[WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.(evoeqns/.(var_'[t]==rhs_):>{
			{event->var[t]>Max[range[var/.FromUnks]],action->in[var][t]->0},
			{event->var[t]<Min[range[var/.FromUnks]],action->in[var][t]->0},
			{event->rhs>0&&var[t]==Min[range[var/.FromUnks]],action->in[var][t]->1},
			{event->rhs<0&&var[t]==Max[range[var/.FromUnks]],action->in[var][t]->1}
		}),1];
		(*Print[func,": bdwhens="];Print[bdwhens];*)
		discretevars=evoeqns/.(var_'[t]==rhs_)->in[var];
		(*Print["discretevars=",discretevars];*)
		ics=Flatten[Join[ics,evoeqns/.(var_'[t]==rhs_)->in[var][0]==1]];
		(*Print["ics=",ics];*)
		evoeqns=evoeqns/.(var_'[t]==rhs_)->var'[t]==rhs*in[var][t]
	,
		modeltype=="DiscreteTime",
		evoeqns=evoeqns/.(var_[t+1]==rhs_):>var[t+1]==Clip[rhs,{Min[range[var]],Max[range[var]]}];
	];
,
	bdwhens={};
	discretevars={};
];


VPrint[3,"joining eqns..."];
eqns=Join[ecoeqns,evoeqns];
VPrint[3,"eqns=",eqns];

If[freezetraits,
	VPrint[3,"freezing traits..."];
	eqns=ReplaceRHS[ReplaceRHS[eqns,RemoveTraitts],traits];
	VPrint[3,"eqns=",eqns];
];

(*Print["doing something (?) with Unk..."];
eqns=ReplaceLHS[eqns,{log[Unk[var_]]'->log[Unk[var]]'[t],Unk[var_]'->Unk[var]'[t]}];
eqns=ReplaceRHS[eqns,{log[Unk[var_]]->log[Unk[var]][t],Unk[var_]->Unk[var][t]}];
Print["eqns=",eqns];*)

(* set up unks *)
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};

VPrint[1,"eqns=",eqns];
VPrint[1,"ics=",ics];
VPrint[1,"unks=",unks];
If[bdwhens!={},VPrint[1,"bdwhens=",bdwhens]];
VPrint[3,"discretevars=",discretevars];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens,modelwhenevents]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	sol=Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TimeSeries[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
	sol=Join[sol,Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[delaydinv,sol=sol/.FromUnks];

If[logged===True,
	res=Table[
		If[Head[var]===log,
			var[[1]]->Reinterpolation[E^var/.sol],
			var->(var/.sol)]
	,{var,Keys[sol]}]
,
	res=sol
];
	
If[output=="FinalSlice",Return[SortRuleList[Chop[Join[FinalSlice[res],fixed]],Join[AllVariables,AllTraits]]]];

Return[SortRuleList[res,Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoSim]={Verbose->False,Verbosity->0,
Fixed->{},Logged->False,BoundaryDetection->False,FreezeTraits->False,
NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
TMin->0,OutputTMin->Automatic,Output->"Dynamics"};


(* split traitsandvariables *)
EcoEvoSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],tmax,opts];
EcoEvoSim[sol_?AttributesAndVariablesQ,Gs:(_?RuleListQ):{},tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],Gs,tmax,opts];


EcoEvoSim::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

EcoEvoSim::susmtd=
"Warning: EcoEvoSim is likely to be inappropriate when there are multiple components and non-equilibrium dynamics.";

EcoEvoSim::notimp="Combining Logged and DelayDInv not currently implemented.";


FindEcoEvoEq::usage =
"FindEcoEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an eco-evolutionary equilibrium with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).";


FindEcoEvoEq[traitsin_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,method,boundarydetection,percapita,delaydinv,fixed,findrootopts,chop,
(* other variables *)
traits,Gs,fixedvars,fixedattributes,fixedvariables,ecoeqns,evoeqns,eqns,unks,newunk,unksics,sol},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoEvoEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[FindEcoEvoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoEq]}]];

(* expand traits *)
traits=ExpandTraits[traitsin];

fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
Gs=ExpandGs[Join[Gsin,Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]],Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],opts,PerCapita->percapita];
VPrint[3,"ecoeqns=",ecoeqns];
evoeqns=TraitEqns[BlankVariables,Gs,opts];
VPrint[3,"evoeqns=",evoeqns];
eqns=If[delaydinv,
	Join[ecoeqns/.Eq/.Gs/.ToUnks,evoeqns/.Eq/.ToUnkRules],
	Join[ecoeqns,evoeqns]/.Eq/.Gs
];

(* set up unksics *)
unks=Join[ecoeqns,evoeqns]/.LHS/.{var_'->var,var_[t+1]/var_[t]->var,var_[t+1]-var_[t]->var,var_[t+1]->var};
unksics={};
Do[
	newunk=If[delaydinv,{var/.ToUnks,var/.traits/.variables},{var,var/.traits/.variables}];
	If[method=="Secant",AppendTo[newunk,var+0.001/.traits/.variables]];
	If[boundarydetection,
		newunk=Join[newunk,{Min[range[var]],Max[range[var]]}];
		If[((var/.traits/.variables)<Min[range[var]])||((var/.traits/.variables)>Max[range[var]]),
			Message[FindEcoEvoEq::streg,var,var/.traits/.variables,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
			Abort[];
		];
	];
	AppendTo[unksics,newunk];
,{var,unks}];

VPrint[1,"eqns=",eqns];
VPrint[1,"unksics=",unksics];

(* solve it *)
sol=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]];
VPrint[3,"sol=",sol];
If[Length[$MessageList]>0&&$MessageList[[-1]]===HoldForm[FindRoot::reged],Message[FindEcoEvoEq::reged]];

If[chop,
	Return[SortRuleList[Chop[Join[sol,fixed]/.FromUnks],Join[AllVariables,AllTraits]]],
	Return[SortRuleList[Join[sol,fixed]/.FromUnks,Join[AllVariables,AllTraits]]]
];

]];


Options[FindEcoEvoEq]={Fixed->{},PerCapita->True,FindRootOpts->{},DelayDInv->False,Chop->True,Verbose->False,Verbosity->0};


(* split traitsandvariables *)
FindEcoEvoEq[sol_?AttributesAndVariablesQ,Gs_:{},opts___?OptionQ]:=
	FindEcoEvoEq[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


FindEcoEvoEq::badfg="Bad FitnessGradient method (should be either DInv or NDInv).";

FindEcoEvoEq::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

FindEcoEvoEq::streg="Initial value of `1` = `2` is outside the range `3` < `1` < `4`. Either fix it or set BoundaryDetection\[Rule]False.";

FindEcoEvoEq::reged="Warning: FindRoot reached boundary, don't trust result (maybe try again using Fixed to fix variables on the boundary).";


TrackEcoEvoEq::usage=
"TrackEcoEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\), \!\(\*
StyleBox[\"dpar\", \"TI\"]\)}] tracks an eco-evolutionary equilibrium, with initial guess \!\(\*
StyleBox[\"sol\", \"TI\"]\), over parameter \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\), with initial step size \!\(\*
StyleBox[\"dpar\", \"TI\"]\).";


TrackEcoEvoEq[init_?AttributesAndVariablesQ,{parname_,parmin_?NumericQ,parmax_?NumericQ,dparin_:Automatic},opts___?OptionQ]:=

Module[{
func=FuncStyle["TrackEcoEvoEq"],
(* options *)
verbose,monitor,printtrace,
tests,
minstepsize,maxstepsize,maxsteps,mindist,maxbend,maxchange,
findecoevoeqopts,interpolationopts,
(* other variables *)
par,dpar,tmp,ics,unks,count,sol,
m0,m1,list
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[Global`debug,verbose=True];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[TrackEcoEvoEq]}]];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[dparin===Automatic,dpar=Sign[parmax-parmin],dpar=dparin];
minstepsize=Evaluate[MinStepSize/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[minstepsize===Automatic,minstepsize=dpar*2^-10];
maxstepsize=Evaluate[MaxStepSize/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[maxstepsize===Automatic,maxstepsize=dpar*2^3];
maxsteps=Evaluate[MaxSteps/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
mindist=Evaluate[MinDistance/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
maxbend=Evaluate[MaxBend/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
maxchange=Evaluate[MaxChange/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
tests=Evaluate[Tests/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
findecoevoeqopts=Evaluate[FindEcoEvoEqOpts/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
interpolationopts=Evaluate[InterpolationOpts/.Flatten[{opts,Options[TrackEcoEvoEq]}]];

If[monitor,PrintTemporary[Dynamic[count]," ",parname,"=",Dynamic[par]," d",parname,"=",Dynamic[dpar]]];

Evaluate[parname]:=par;

unks=Keys[init];
tmp={};
par=parmin;
dpar=dpar/2;
ics=init;
count=0;

While[count<maxsteps,
	count++;
	sol=Check[Quiet[FindEcoEvoEq[ics,Evaluate[Sequence@@findecoevoeqopts]],FindRoot::lstol],"err"];
	If[printtrace&&sol=!="err",Print[Defer@parname,"=",NumberForm@par," sol=",sol]];
	(*Print[Flatten[Table[PartsAboveDiagonal[TraitDistance[sol,gu]],{gu,guilds}]]];*)
	(*Print[Table[{
				m1=((unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])-(unk/.tmp\[LeftDoubleBracket]-2,2\[RightDoubleBracket]))/(tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]-tmp\[LeftDoubleBracket]-2,1\[RightDoubleBracket]);
				m0=((unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket]))/(par-tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]);
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]],
				Abs[(unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])]/(Differences@MinMax[Table[unk/.ent\[LeftDoubleBracket]2\[RightDoubleBracket],{ent,tmp}]])\[LeftDoubleBracket]1\[RightDoubleBracket]}
			,{unk,unks}]];*)
	Which[
		sol==="err",
		If[par==parmin,Message[TrackEcoEvoEq::ferr,Defer@parname,NumberForm@par];Return[$Aborted]];
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," FindEcoEvoEq error"]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::err,Defer@parname,NumberForm@par];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"CSS"]&&Max[Re[EcoEvoEigenvalues[sol]]]>0,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-CSS, EcoEvoEigenvalues[sol]=",EcoEvoEigenvalues[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::noncss,Defer@parname,NumberForm@par,EcoEvoEigenvalues[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"LocalESS"]&&!CompoundAnd[Flatten[LocalESSQ[sol]]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-local ESS, LocalESSQ[sol]=",LocalESSQ[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::nonless,Defer@parname,NumberForm@par,LocalESSQ[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"GlobalESS"]&&!CompoundAnd[GlobalESSQ[sol][[1]]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-global ESS, GlobalESSQ[sol]=",GlobalESSQ[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::nongess,Defer@parname,NumberForm@par,GlobalESSQ[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"Extinction"]&&Cases[ExtinctSpecies[sol],_Subscript]!={},
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," extinction, sol=",sol]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::extinct,Defer@parname,NumberForm@par,sol];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"Convergence"]&&Min[Flatten[Table[PartsAboveDiagonal[TraitDistance[sol,gu]],{gu,guilds}]]]<mindist,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," traits converged, sol=",sol]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::converged,Defer@parname,NumberForm@par,sol];Break[]];
		par=par-dpar;
	,
		MemberQ[tests,"MaxBend"]&&Length[tmp]>=2&&CompoundOr[Table[
				m1=((unk/.tmp[[-1,2]])-(unk/.tmp[[-2,2]]))/(tmp[[-1,1]]-tmp[[-2,1]]);
				m0=((unk/.sol)-(unk/.tmp[[-1,2]]))/(par-tmp[[-1,1]]);
				list=Table[unk/.ent[[2]],{ent,tmp}];
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]]>maxbend
				&&
				Abs[(unk/.sol)-(unk/.tmp[[-1,2]])]/(10^-10+Differences[{Min[list],Max[list]}][[1]])>maxchange
			,{unk,unks}]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," MaxBend exceeded"]];
		If[dpar>0,dpar=Max[minstepsize,dpar/2],dpar=Min[minstepsize,dpar/2]];
		par=par-dpar;			
	,
		True,
		AppendTo[tmp,{par,sol}];
		If[par==parmax,Break[]]; (* reached end *)
		If[dpar>0,
			dpar=Min[maxstepsize,2dpar];
			par=Min[parmax,par+dpar];
		,
			dpar=Max[maxstepsize,2dpar];
			par=Max[parmax,par+dpar];
		];
	];
	ics=Quiet[Slice[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]],par],{Interpolation::inhr,InterpolatingFunction::dmval}];
];

If[count==maxsteps,Message[TrackEcoEvoEq::mxst,maxsteps,Defer@parname,NumberForm@par]];

Clear[parname];

Return[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]]]
]];


Options[TrackEcoEvoEq]={
	Verbose->False,PrintTrace->False,Monitor->True,
	MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->200,
	Tests->{"CSS","LocalESS","GlobalESS","Extinction","Convergence","MaxBend"},
	FindEcoEvoEqOpts->{},InterpolationOpts->{},
	MinDistance->10^-10,MaxBend->3,MaxChange->0.01
};


TrackEcoEvoEq::err="FindEcoEvoEq failed at `1`=`2`.";
TrackEcoEvoEq::ferr="FindEcoEvoEq failed at initial parameter value,`1`=`2`, can not continue.";
TrackEcoEvoEq::noncss="Non-convergence stable EcoEvoEq at `1`=`2`, eigenvalues=`3`).";
TrackEcoEvoEq::nonless="Not a local ESS at `1`=`2`, LocalESSQ=`3`.";
TrackEcoEvoEq::nongess="Not a global ESS at `1`=`2`, GlobalESSQ=`3`.";
TrackEcoEvoEq::extinct="Extinction at `1`=`2`, sol=`3`.";
TrackEcoEvoEq::converged="Traits converged at `1`=`2`, sol=`3`.";
TrackEcoEvoEq::mxst="Maximum number of `1` steps reached at `2`=`3`";


FindEcoEvoCycle::usage=
"FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an eco-evolutionary cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

FindEcoCycleEvoEq::usage=
"FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an evolutionary equilibrium with an ecological cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varscovars\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


(* Periodic system *)
FindEcoEvoCycle[traitsin_?TraitsQ,Gs:(_?GsQ):{},variablesin_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoCycle (Periodic)"],
(* options *)
verbose,verboseall,
method,fitnessgradient,evoeq,
ecosimopts,ndinvopts,ecoevosimopts,findrootopts,monitor,printtrace,fixed,traitshiftrate,
maxiterations,rulelistdistanceopts,
accuracygoal,traitaccuracygoal,variableaccuracygoal,
precisiongoal,traitprecisiongoal,variableprecisiongoal,
(* other variables *)
traits,variables,
fixedvars,fixedtraits,fixedvariables,nonfixedtraits,nonfixedvars,nonfixedvariables,
thing,fw,sol,unks,unksics,res,dtrait,v,nb},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
evoeq=Evaluate[EvoEq/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[fitnessgradient===Automatic,
	If[evoeq==False||Max[Table[ngcomps[gu],{gu,guilds}]]==1,fitnessgradient="EcoEvoSim",fitnessgradient="NDInv"]];
If[Max[Table[ngcomps[gu],{gu,guilds}]]>1&&fitnessgradient=="EcoEvoSim",Message[FindEcoEvoCycle::susmtd]];
If[verbose,Print[func,": FitnessGradient=",fitnessgradient]];
ndinvopts=Evaluate[NDInvOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecoevosimopts=Evaluate[EcoEvoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[evoeq==True,AppendTo[ecoevosimopts,FreezeTraits->True]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
maxiterations=Evaluate[MaxIterations/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
accuracygoal=Evaluate[AccuracyGoal/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[ListQ[accuracygoal],
	{variableaccuracygoal,traitaccuracygoal}=accuracygoal[[1;;2]],
	variableaccuracygoal=traitaccuracygoal=accuracygoal];
precisiongoal=Evaluate[PrecisionGoal/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[ListQ[precisiongoal],
	{variableprecisiongoal,traitprecisiongoal}=precisiongoal[[1;;2]],
	variableprecisiongoal=traitprecisiongoal=precisiongoal];
rulelistdistanceopts=Evaluate[RuleListDistanceOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];

(* drop fixed variables from traits and variables *)
traits=RuleListComplement[traitsin,fixed];
variables=RuleListComplement[variablesin,fixed];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedtraits=traits[[All,1]];
nonfixedvariables=variables[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedtraits],Join[variables,fixedvariables]];

Which[
	fitnessgradient=="EcoEvoSim",
	thing[varsandtraits_?NumericRuleListQ]:=Module[{},
		$FindEcoEvoCycleSteps++;
		sol=EcoEvoSim[varsandtraits,Gs,modelperiod,Fixed->fixed,TraitShiftRate->traitshiftrate,
			Evaluate[Sequence@@ecoevosimopts]];
		If[printtrace,Print[$FindEcoEvoCycleSteps," ",FinalSlice[sol]]];
		Return[Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&]]
	]
,	
	fitnessgradient=="NDInv",
	(* shifting traits *)
	Do[dtrait[tr]=If[MemberQ[traitshiftrate[[All,1]],tr[[1]]],tr[[1]]/.traitshiftrate,0],{tr,nonfixedtraits}];
	(* set up vs *)
	Do[v[tr]=V[DeleteSubscripts@tr]/.Gs/.V[DeleteSubscripts@tr]->1,{tr,nonfixedtraits}];

	thing[varsandtraits_?NumericRuleListQ]:=Module[{fg},
		$FindEcoEvoCycleSteps++;
		sol=EcoSim[varsandtraits,modelperiod,Fixed->fixed,Evaluate[Sequence@@ecosimopts]];
		fg=Flatten[Table[tr->
			v[tr]*NDInv[Join[varsandtraits,fixed]//ExtractTraits,sol,tr//ZeroSubscripts,{(tr//ZeroSubscripts)->(tr/.varsandtraits)},
			Evaluate[Sequence@@ndinvopts]]-dtrait[tr]
		,{tr,nonfixedtraits}]];
		If[printtrace,Print[$FindEcoEvoCycleSteps," ",FinalSlice[sol]," ",RuleListAdd[ExtractTraits[varsandtraits],fg]]];
		Return[Join[
			Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&],
			RuleListAdd[ExtractTraits[varsandtraits],fg]
		]]
	],
	Else,
	Message[FindEcoEvoCycle::badmtd];Return[$Failed]
];

If[monitor,
	nb=CreateDialog[{
		TextCell["evaluation: "],
		Dynamic[$FindEcoEvoCycleSteps],
		TextCell["vars:"],
		Dynamic[FinalSlice[sol]]
	},
	WindowTitle->"FindEcoEvoCycle Progress...",WindowSize->All];
];

(* solve it *)
$FindEcoEvoCycleSteps=0;
Which[
	method=="FindRoot",
	If[verbose,Print[func,": Method FindRoot"]];
	unks=nonfixedvars/.ToUnks;
	unksics=Table[{var/.ToUnks,var/.traits/.variables},{var,nonfixedvars}];
	fw[l_?NumericListQ]:=nonfixedvars/.thing[Thread[nonfixedvars->l]];
	res=FindRoot[fw[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]];
	If[monitor,NotebookClose[nb]];
	If[evoeq==True,
		Return[SortRuleList[Join[ExtractTraits[res/.FromUnks],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]],
		Return[SortRuleList[Join[sol,fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]]
	]
,
	method=="FixedPoint",
	If[verbose,Print[func,": Method FixedPoint"]];
	(*res=FixedPoint[thing[#]&,Join[variables,traits],maxiterations,SameTest\[Rule](RuleListDistance[#1,#2,Evaluate[Sequence@@rulelistdistanceopts]]<10^-accuracygoal&)];*)
	res=FixedPoint[thing[#]&,Join[variables,traits],maxiterations,SameTest->(
		RuleListDistance[ExtractTraits[#1],ExtractTraits[#2],Evaluate[Sequence@@rulelistdistanceopts]]<10^-traitaccuracygoal
			+RuleListDistance[ExtractTraits[#1],Evaluate[Sequence@@rulelistdistanceopts]]*10^-traitprecisiongoal &&
		RuleListDistance[ExtractVariables[#1],ExtractVariables[#2],Evaluate[Sequence@@rulelistdistanceopts]]<10^-variableaccuracygoal
			+RuleListDistance[ExtractVariables[#1],Evaluate[Sequence@@rulelistdistanceopts]]*10^-variableprecisiongoal
	&)];
	If[monitor,NotebookClose[nb]];
	If[$FindEcoEvoCycleSteps==maxiterations,Message[FindEcoEvoCycle::cvmit,maxiterations]];
	If[evoeq==True,
		Return[SortRuleList[Join[ExtractTraits[res],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]],	
		Return[SortRuleList[Join[sol,fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]]
	]
,
	Else,
	Message[FindEcoEvoCycle::badmtd];Return[$Failed]
];

]]/;modelperiod=!=0;


Options[FindEcoEvoCycle]={
	Method->"FindRoot",FitnessGradient->Automatic,EvoEq->False,
	RuleListDistanceOpts->{},
	BoundaryDetection->False,TraitShiftRate->{},
	FindRootOpts->{},Fixed->{},EcoSimOpts->{},EcoEvoSimOpts->{},NDInvOpts->{},
	Chop->True,MaxIterations->100,AccuracyGoal->4,PrecisionGoal->{4,\[Infinity]},
	PrintTrace->False,Monitor->False,
	Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
FindEcoEvoCycle[traitsandvariables_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
FindEcoEvoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],Gs,opts];
FindEcoCycleEvoEq[stuff___]:=FindEcoEvoCycle[stuff,EvoEq->True];


FindEcoCycleEvoEq::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoEvoCycle::susmtd=
"Warning: FitnessGradient\[Rule]\"EcoEvoSim\" is likely to be inappropriate when there are multiple components. Try EvoEq\[Rule]True and FitnessGradient\[Rule]\"EcoEvoSim\".";


EvoEq::usage = 
"EvoEq contains SolveEvoEq, NSolveEvoEq, and FindEvoEq. Use them instead.";

SolveEvoEq::usage = 
"SolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

NSolveEvoEq::usage = 
"NSolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] numerically solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

FindEvoEq::usage = 
"FindEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
FindEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\), with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\).";


EvoEq[traits:(_?AttributesQ):{},sol:(_?VariablesQ):{},Gs_List:{},opts___?OptionQ] :=
 
Module[{
func=FuncStyle["EvoEq"],
(* options *)
verbose,verboseall,method,fixed,delaydinv,solveopts,nsolveopts,findrootopts,findinstanceopts,boundarydetection,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,tounks,fromunks,evoeqns,eqns,unks,unksics,newunk,res},
   
Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts, Options[EvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts, Options[EvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoEq]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EvoEq]}]];
solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EvoEq]}]];
If[$VersionNumber>=12.2,AppendTo[solveopts,Assumptions->{}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EvoEq]}]];
findinstanceopts=Evaluate[FindInstanceOpts/.Flatten[{opts,Options[EvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EvoEq]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[sol,fixedvariables]];
(*Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];*)

evoeqns=TraitEqns[sol,Gs,opts];
(*Print["evoeqns=",evoeqns];*)
eqns=evoeqns/.Eq;
(*Print["eqns=",eqns];*)

(* set up unksics *)
unks=evoeqns/.LHS/.{var_'->var(*,var_[t+1]/var_[t]\[Rule]var,var_[t+1]-var_[t]\[Rule]var,var_[t+1]\[Rule]var*)};
(*Print["unks=",unks];*)
If[method=="FindRoot",
	unksics={};
	Do[
		newunk={var,var/.traits};
		If[boundarydetection,
			If[((var/.traits)<Min[range[var]])||((var/.traits)>Max[range[var]]),
				Message[FindEvoEq::streg,var,var/.traits,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
				Abort[];
			];
			newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]
		];
		AppendTo[unksics,newunk];
	,{var,unks}]
];

(* solve it *)
Which[
	method=="Solve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@solveopts},
		PrintCall[Global`res=Solve[eqns,unks,op]]]];
	res=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@nsolveopts},
		PrintCall[Global`res=NSolve[eqns,unks,op]]]];
	res=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[delaydinv,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,op]/.FromUnks]]];
		res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,Evaluate[Sequence@@findrootopts]]/.FromUnks
	,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns,unksics,op]]]];
		res=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]]
	],
	method=="FindInstance",
	If[delaydinv,
		Message[FindEvoEq::needic];Return[$Failed]
	,
		If[verbose,
			With[{eqns=eqns,unks=unks,op=Sequence@findinstanceopts},
			PrintCall[Global`res=FindInstance[eqns,unks,op][[1]]]]];
		res=FindInstance[eqns,unks,Evaluate[Sequence@@findinstanceopts]][[1]]
	],
	Else, (* else *)
	Message[EvoEq::badmtd];Return[$Failed]
];

If[MemberQ[{Solve,NSolve},Head[res]],
	Message[EvoEq::nosol];Return[$Failed],
	Return[SortRuleList[EqSort[Chop[res]],AllTraits]]
];

]];


SolveEvoEq[args___]:=EvoEq[args,Method->"Solve"];
NSolveEvoEq[args___]:=EvoEq[args,Method->"NSolve"];
FindEvoEq[sol:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=EvoEq[sol,Gs,opts,Method->"FindInstance"];
FindEvoEq[args___]:=EvoEq[args,Method->"FindRoot"];


Options[EvoEq]={
Method->"None",
DelayDInv->False,DInvOpts->{},SolveOpts->{Reals},NSolveOpts->{Reals},FindRootOpts->{},FindInstanceOpts->{Reals},
BoundaryDetection->False,Fixed->{},
Verbose->False,VerboseAll->False};


EvoEq::nosol="Solve/NSolve couldn't find a solution.  Try FindEcoEq instead.";

EvoEq::badmtd="The Method option should be \"Solve\", \"NSolve\", \"FindRoot\", or \"FindInstance\".";

FindEvoEq::needic="Method FindInstance doesn't work with DelayDInv.  Give an initial guess to use Method FindRoot instead.";

FindEvoEq::streg="Initial value of `1` = `2` is outside the range `3` < `1` < `4`. Either fix it or set BoundaryDetection\[Rule]False.";


EcoEvoJacobian::usage= 
"EcoEvoJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoJacobian[attributesin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed *)
fixedvars,fixedattributes,fixedvariables,
(* other variables *)
attributes,Gs,variables,interactions,ecoeqns,evoeqns,eqns,unks,jmat},

Block[{\[ScriptCapitalN],verbosity,func="EcoEvoJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoJacobian]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoJacobian]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
VPrint[3,"fixedvars=",fixedvars];

(* handle blanks & figure out number of species in guilds *)
attributes=FixAttributes[attributesin];
variables=FixVariables[variablesin];
VPrint[3,"attributes=",attributes];
VPrint[3,"variables=",variables];

(*interactions=ExtractInteractions[attributesin];*)
interactions=ExtractInteractions[attributes];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[attributes,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
(*Gs=ExpandGs[Join[Gsin,Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]],Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];*)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[1,"Gs=",Gs];

(* set up eqns & unks *)
ecoeqns=EcoEqns[Join[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],interactions,fixedattributes],opts];
evoeqns=TraitEqns[Join[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],fixedvariables],opts,Fixed->interactions];
VPrint[1,"ecoeqns=",ecoeqns];
VPrint[1,"evoeqns=",evoeqns];

eqns=Join[ecoeqns,evoeqns]/.Gs;
unks=eqns/.LHS/.var_'->var;
eqns=eqns/.RHS;

VPrint[1,"eqns=",eqns];
VPrint[1,"unks=",unks];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
VPrint[1,"jmat=",jmat];

If[chop,
	Return[Chop[jmat/.variables/.attributes]],
	Return[jmat/.variables/.attributes]
];

]];


Options[EcoEvoJacobian]={Verbose->False,Verbosity->0,
EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,IgnoreVar->False};


(* split traitsandvariables *)
EcoEvoJacobian[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
	EcoEvoJacobian[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];
EcoEvoJacobian[sol_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
	EcoEvoJacobian[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EcoEvoJacobian[___]:=Message[EcoEvoJacobian::noper]/;modelperiod=!=0;


EcoEvoJacobian::noper="EcoEvoJacobian can't handle periodic models yet.";


EcoEvoEigenvalues::usage= 
"EcoEvoEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoEigenvalues[attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoEigenvalues]}],Options[EcoEvoJacobian]];

	res=Eigenvalues[EcoEvoJacobian[attributes,variables,Gs,Evaluate[Sequence@@eejopts]]];
	
	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoEigenvalues]={(*EvoEquation\[Rule]"QG",Fixed\[Rule]{},TraitShiftRate\[Rule]{},*)
Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoEigenvalues[sol_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
	EcoEvoEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];


EcoEvoEigenvalues::noper="EcoEvoEigenvalues can't handle periodic models yet.";


EvoJacobian::usage = 
"EvoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EvoJacobian[traitsin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed vars *)
fixedvars,fixedtraits,fixedvariables,
(* other variables *)
traits,variables,eqns,unks,jmat},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=FixAttributes[traitsin];
variables=FixVariables[variablesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedtraits],Join[variables,fixedvariables]];

(* set up eqns & unks *)
eqns=TraitEqns[BlankVariables,Gs,opts];
unks=eqns/.LHS/.{var_'->var(*,var_[t+1]/var_[t]\[Rule]var,var_[t+1]\[Rule]var*)};
eqns=eqns/.RHS(*/.RemoveTraitts/.RemoveVariablets*);

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unks="];Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[Global`debug,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.variables/.traits]],
	Return[jmat/.variables/.traits]
];

]];


(* split traitsandvariables *)
EvoJacobian[sol_?AttributesAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=
EvoJacobian[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EvoJacobian[___]:=Message[EvoJacobian::noper]/;modelperiod=!=0;


Options[EvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoJacobian::noper="EvoJacobian can't handle periodic models yet.";


EvoEigenvalues::usage = 
"EvoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EvoEigenvalues[traits:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,ejopts,res},

	If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

	chop=Evaluate[Chop/.Flatten[{opts,Options[EvoEigenvalues]}]];
	ejopts=FilterRules[Flatten[{opts,Options[EvoEigenvalues]}],Options[EvoJacobian]];

	res=Eigenvalues[EvoJacobian[traits,variables,Gs,ejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


(* split traitsandvariables *)
EvoEigenvalues[sol_?AttributesAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=
EvoEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EvoEigenvalues[___]:=Message[EvoEigenvalues::noper]/;modelperiod=!=0;


Options[EvoEigenvalues]={EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoEigenvalues::noper="EvoEigenvalues can't handle periodic models yet.";


EcoEvoVarSim::usage=
"EcoEvoVarSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
EcoEvoVarSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarSim[traitsin_?AttributesQ,variables_?VariablesQ,Gsin_?GsQ,tmax_?NumericQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,logged,boundarydetection,ndsolveopts,wheneventopts,delaydinv,fixed,tmin,outputtmin,output,freezetraits,ignorevar,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvarcovs,nonfixedvars,
traits,Gs,
tic,ecoeqns,evoeqns,vareqns,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoCycle"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoCycle]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEvoVarSim]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoVarSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoVarSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoVarSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoVarSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoVarSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoEvoVarSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoEvoVarSim]}]];
freezetraits=Evaluate[FreezeTraits/.Flatten[{opts,Options[EcoEvoVarSim]}]];
ignorevar=Evaluate[IgnoreVar/.Flatten[{opts,Options[EcoEvoVarSim]}]];

(* expand traits *)
traits=ExpandTraits[traitsin];
VPrint[3,"traits=",traits];

fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvarcovs=Gs[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits,nonfixedvarcovs];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* set up ics *)
ics=Table[
	If[logged===True&&comptype[var]==="Extensive",
		log[var][tic]==Log[var/.variables],
		var[tic]==(var/.traits/.variables/.Gs)]
,{var,nonfixedvars}];

(* insert unks[] for delaydinv *)
If[delaydinv,ics=ics/.ToUnks];


(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVars->nonfixedvariables,opts];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedTraits->nonfixedtraits,opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVarCovs->nonfixedvarcovs,opts];

VPrint[2,"ecoeqns=",ecoeqns];
VPrint[2,"evoeqns=",evoeqns];
VPrint[2,"vareqns=",vareqns];

(* boundary detection *)
If[boundarydetection==True,
	Which[
		modeltype=="ContinuousTime",
		bdwhens=Flatten[WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.(evoeqns/.(var_'[t]==rhs_):>{
			{event->var[t]>Max[range[var/.FromUnks]],action->in[var][t]->0},
			{event->var[t]<Min[range[var]/.FromUnks],action->in[var][t]->0},
			{event->rhs>0&&var[t]==Min[range[var/.FromUnks]],action->in[var][t]->1},
			{event->rhs<0&&var[t]==Max[range[var/.FromUnks]],action->in[var][t]->1}
		}),1];
		(*Print[func,": bdwhens="];Print[bdwhens];*)
		discretevars=evoeqns/.(var_'[t]==rhs_)->in[var];
		(*Print["discretevars=",discretevars];*)
		ics=Flatten[Join[ics,evoeqns/.(var_'[t]==rhs_)->in[var][0]==1]];
		(*Print["ics=",ics];*)
		evoeqns=evoeqns/.(var_'[t]==rhs_)->var'[t]==rhs*in[var][t]
	,
		modeltype=="DiscreteTime",
		evoeqns=evoeqns/.(var_[t+1]==rhs_):>var[t+1]==Clip[rhs,{Min[range[var]],Max[range[var]]}];
	];
,
	bdwhens={};
	discretevars={};
];
(*Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns];*)

If[freezetraits,
	ecoeqns=ReplaceRHS[ecoeqns,{RemoveTraitts,traits}];
	evoeqns=ReplaceRHS[evoeqns,{RemoveTraitts,traits}];
];

eqns=Join[ecoeqns,evoeqns,vareqns]/.AddVariablets/.AddTraitts/.AddVarCovts;

(* set up unks *)
unks=eqns/.LHS/.var_'[t]->var;

VPrint[1,"eqns=",eqns];
VPrint[1,"ics=",ics];
VPrint[1,"unks=",unks];
If[bdwhens!={},VPrint[1,"bdwhens=",bdwhens]];
VPrint[3,"discretevars=",discretevars];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens,modelwhenevents]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	sol=Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TimeSeries[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
	sol=Join[sol,Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[delaydinv,sol=sol/.FromUnks];

If[logged===True,
	res=Table[
		If[Head[var]===log,
			var[[1]]->Reinterpolation[E^var/.sol],
			var->(var/.sol)]
	,{var,Keys[sol]}]
,
	res=sol
];
	
If[output=="FinalSlice",Return[SortRuleList[Chop[Join[FinalSlice[res],fixed]],Join[AllVariables,AllTraits]]]];

Return[SortRuleList[res,Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoVarSim]={Verbose->False,Verbosity->0,
Fixed->{},Logged->False,BoundaryDetection->False,FreezeTraits->False,
NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
TMin->0,OutputTMin->0,Output->"Dynamics"};


(* split traitsandvariables *)
EcoEvoVarSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoVarSim[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],tmax,opts];


FindEcoEvoVarEq::usage=
"FindEcoEvoVarEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] finds an eco-evolutionary equilibrium (abundance, traits, variances) with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), and \!\(\*
StyleBox[\"varscovs\", \"TI\"]\).";


FindEcoEvoVarEq[traitsin_?AttributesQ,variables_?VariablesQ,Gsin_?GsQ,opts___?OptionQ]:=

Module[{
(* options *)
verbose,method,boundarydetection,percapita,fixed,findrootopts,chop,
(* other variables *)
Gs,traits,fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvarcovs,nonfixedvars,
ecoeqns,evoeqns,vareqns,eqns,unks,newunk,unksics,sol},

Block[{\[ScriptCapitalN],verbosity,func="FindEcoEvoVarEq"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoVarEq]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[FindEcoEvoVarEq]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];

(* expand traits *)
traits=ExpandTraits[traitsin];
VPrint[3,"traits=",traits];

fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvarcovs=Gs[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits,nonfixedvarcovs];
VPrint[3,"nonfixedvars=",nonfixedvars];

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVars->nonfixedvariables,opts,PerCapita->percapita];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedTraits->nonfixedtraits,opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,NonFixedVarCovs->nonfixedvarcovs,opts];

VPrint[2,"ecoeqns=",ecoeqns];
VPrint[2,"evoeqns=",evoeqns];
VPrint[2,"vareqns=",vareqns];

eqns=Join[ecoeqns,evoeqns,vareqns]/.Eq;

(* set up unks *)
unks=Join[ecoeqns,evoeqns,vareqns]/.LHS/.var_'->var;
unksics={};
Do[
	newunk={var,var/.traits/.variables/.Gs};
	If[method=="Secant",AppendTo[newunk,var+0.001/.traits/.variables/.Gs]];
	If[boundarydetection,
		newunk=Join[newunk,{Min[range[var]],Max[range[var]]}];
		If[((var/.traits/.variables)<Min[range[var]])||((var/.traits/.variables)>Max[range[var]]),
			Message[FindEcoEvoEq::streg,var,var/.traits/.variables,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
			Abort[];
		];
	];
	AppendTo[unksics,newunk];
,{var,unks}];

VPrint[1,"eqns=",eqns];
VPrint[1,"unksics=",unksics];

(* solve it *)
sol=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]];
VPrint[3,"sol=",sol];

If[Length[$MessageList]>0&&$MessageList[[-1]]===HoldForm[FindRoot::reged],Message[FindEcoEvoEq::reged]];

If[chop,
	Return[SortRuleList[Chop[Join[sol,fixed]/.FromUnks],Join[AllVariables,AllTraits]]],
	Return[SortRuleList[Join[sol,fixed]/.FromUnks,Join[AllVariables,AllTraits]]]
];

]]


Options[FindEcoEvoVarEq]={Verbose->False,Verbosity->0,
PerCapita->True,FindRootOpts->{},Chop->True,Fixed->{}};


(* split traitsandvariables *)
FindEcoEvoVarEq[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
FindEcoEvoVarEq[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];


EcoEvoVarJacobian::usage= 
"EcoEvoVarJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarJacobian[traitsin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=
(*EcoEvoVarJacobian[traitsin_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=*)

Module[{
(* options *)
verbose,fixed,chop,
(* rules *)
removets,
(* fixed *)
fixedvars,fixedattributes,fixedvariables,nonfixedvariables,nonfixedtraits,nonfixedvarcovs,nonfixedvars,
(* other variables *)
Gs,traits,variables,interactions,ecoeqns,evoeqns,vareqns,eqns,unks,jmat},

Block[{\[ScriptCapitalN],verbosity,func="EcoEvoVarJacobian"},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* set verbosity *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoVarJacobian]}]];
If[verbose,
	verbosity=Max[1,Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoVarJacobian]}]]],
	verbosity=Evaluate[Verbosity/.Flatten[{opts,Options[EcoEvoVarJacobian]}]]
];
If[IntegerQ[Global`$verbosity],verbosity=Max[Global`$verbosity,verbosity]];

(* handle options *)

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
fixedvars=fixed[[All,1]];
VPrint[3,"fixedvars=",fixedvars];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];

(* handle blanks & figure out number of species in guilds *)
traits=FixAttributes[traitsin];
variables=FixVariables[variablesin];
VPrint[3,"traits=",traits];
VPrint[3,"variables=",variables];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
VPrint[3,"\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];

(* expand Gs *)
Gs=ExpandGs[Gsin,Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}]];
VPrint[3,"Gs=",Gs];

(*nonfixedvariables=variables[[All,1]];
nonfixedtraits=traits[[All,1]];
nonfixedvarcovs=Gs[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits,nonfixedvarcovs];
VPrint[3,"nonfixedvars=",nonfixedvars];*)

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,(*NonFixedVars\[Rule]nonfixedvariables,*)opts,PerCapita->percapita];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,(*NonFixedTraits->nonfixedtraits,*)opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,(*NonFixedVarCovs->nonfixedvarcovs,*)opts];

VPrint[2,"ecoeqns=",ecoeqns];
VPrint[2,"evoeqns=",evoeqns];
VPrint[2,"vareqns=",vareqns];

eqns=Join[ecoeqns,evoeqns,vareqns]/.RHS;
unks=Join[ecoeqns,evoeqns,vareqns]/.LHS/.var_'->var;

VPrint[1,"eqns=",eqns];
VPrint[1,"unks=",unks];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
VPrint[1,"jmat=",jmat];

(*If[Global`debug,
	Print["variables=",variables];
	Print["traits=",traits];
	Print["Gs=",Gs];
];*)

If[chop,
	Return[Chop[jmat/.variables/.traits/.Gs]],
	Return[jmat/.variables/.traits/.Gs]
];

]];


Options[EcoEvoVarJacobian]=
{Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoVarJacobian[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
EcoEvoVarJacobian[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];





EcoEvoVarEigenvalues::usage= 
"EcoEvoVarEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarEigenvalues[attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoVarEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoVarEigenvalues]}],Options[EcoEvoVarJacobian]];

	res=Eigenvalues[EcoEvoVarJacobian[attributes,variables,Gs,Evaluate[Sequence@@eejopts]]];

	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoVarEigenvalues]={(*EvoEquation\[Rule]"QG",Fixed\[Rule]{},TraitShiftRate\[Rule]{},*)
Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoVarEigenvalues[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
	EcoEvoVarEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];





(* Protect all package symbols *)
With[{syms=Names["EcoEvo`*"]},SetAttributes[syms,Protected]];
(* with a few exceptions... *)
Unprotect[Unk,t,LookUp,$FindEcoCycleSteps,$InvCount,$FindEcoEvoCycleSteps];


End[];
EndPackage[];


"EcoEvo Package Version "<>$EcoEvoVersion<>"
Christopher A. Klausmeier <christopher.klausmeier@gmail.com>"
