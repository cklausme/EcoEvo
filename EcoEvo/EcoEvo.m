(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* hack to address <https://mathematica.stackexchange.com/questions/167143/setdelayedwrsym-on-first-use-of-formalx> *)
Plot[0,{x,0,1}];
ContourPlot[0,{x,0,1},{y,0,1}];


BeginPackage["EcoEvo`"];


Unprotect@@Names["EcoEvo`*"];
ClearAll@@Names["EcoEvo`*"];


VarSort::usage="VarSort[rulelist, vars] sorts \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) in order of \!\(\*
StyleBox[\"vars\", \"TI\"]\)."

orderedComplement::usage="orderedComplement is like Complement, but doesn't sort the list.";

EqSort::usage="EqSort[\!\(\*
StyleBox[\"list\", \"TI\"]\)] sorts \!\(\*
StyleBox[\"list\", \"TI\"]\) in order of increasing species richness.";

RHS::usage="RHS is a replacement rule that returns the right hand side of equations.";

Eq::usage="Eq is a replacement rule that sets time derivatives to zero and next time steps equal to this time steps.";

ZeroLHS::usage="ZeroLHS is a replacement rule that sets the left hand side of equations equal to zero.";

ZeroVector::usage="ZeroVector[\!\(\*
StyleBox[\"d\", \"TI\"]\)] returns a \!\(\*
StyleBox[\"d\", \"TI\"]\)-dimensional zero vector.";

SubscriptAdd::usage="SubscriptAdd[\!\(\*
StyleBox[\"expr\", \"TI\"]\), \!\(\*
StyleBox[\"add\", \"TI\"]\)] adds \!\(\*
StyleBox[\"add\", \"TI\"]\) (default=1) to all subscripts in \!\(\*
StyleBox[\"expr\", \"TI\"]\)."

DeleteSubscript::usage="DeleteSubscript[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] removes the subscript from \!\(\*
StyleBox[\"expr\", \"TI\"]\).";

ZeroSubscript::usage="ZeroSubscript[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] changes the subscript in \!\(\*
StyleBox[\"expr\", \"TI\"]\) to zero.";

HighlightChanges::usage="HighlightChanges[True] turns on change highlighting. HighlightChanges[False] turns it off.";

ExtractColors::usage="ExtractColor[\!\(\*
StyleBox[\"list\", \"TI\"]\)] extracts colors from \!\(\*
StyleBox[\"list\", \"TI\"]\).";

axisFlip::usage="axisFlip exchanges axes on Graphics object."

FuncStyle::usage="FuncStyle[\!\(\*
StyleBox[\"string\", \"TI\"]\)] formats \!\(\*
StyleBox[\"string\", \"TI\"]\) for use in debugging output.";

PrintCall::usage="PrintCall[\!\(\*
StyleBox[\"expression\", \"TI\"]\)] prints \!\(\*
StyleBox[\"expression\", \"TI\"]\) unevaluated.";

Msg::usage="Msg[\!\(\*
StyleBox[\"message\", \"TI\"]\)] is a robust replacement for Message.";

RuleList::usage=
"RuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
RuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), {\!\(\*
StyleBox[\"min\", \"TI\"]\), \!\(\*
StyleBox[\"max\", \"TI\"]\)}] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) ranges from \!\(\*
StyleBox[\"min\", \"TI\"]\) to \!\(\*
StyleBox[\"max\", \"TI\"]\).
RuleList[\!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"vals\", \"TI\"]\)] makes a list of rules between corresponding elements of the lists \!\(\*
StyleBox[\"vars\", \"TI\"]\) and \!\(\*
StyleBox[\"vals\", \"TI\"]\).
RuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ns\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
RuleList[{\!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(1\)]\), \[Ellipsis], \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(nv\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(1\)]\), \[Ellipsis] , \!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(nv\)]\)}, {{\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(1\)]\)}, \[Ellipsis] , {\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(nv\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(nv\)]\)}}] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(i\)]\) ranges from \!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(i\)]\) to \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(i\)]\).";

\[IGrave]::usage="\[IGrave] is a placeholder index in RuleList and PlotTAD.";

ClearCache::usage="ClearCache[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), ...] removes memoized DownValues of \!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), etc.";

IFFQ::usage="IFFQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] is True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a InterpolatingFunction function.";

Avg::usage=
"Avg[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the average of the function \!\(\*
StyleBox[\"f\", \"TI\"]\), which contains an InterpolatingFunction, with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
Avg[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] gives the average of the function \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\), ranging from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).";

Var::usage=
"Var[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the variance of the function \!\(\*
StyleBox[\"f\", \"TI\"]\), which contains an InterpolatingFunction, with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
Var[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] gives the variance of the function \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\), ranging from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).";

Cov::usage=
"Cov[\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the covariance of \!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)and \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), at least one of which contains an InterpolatingFunction, with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
Cov[\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] gives the covariance of the functions \!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\) and \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\), ranging from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).";

ExtractPlotPoints::usage=
"ExtractPlotPoints[\!\(\*
StyleBox[\"plot\", \"TI\"]\)] extracts lists of points from lines in \!\(\*
StyleBox[\"plot\", \"TI\"]\).";

Else::usage=
"Else is an alias for True.";

SpFrac::usage=
"\!\(\*
StyleBox[\"SpFrac\", \"InlineCode\"]\)\!\(\*
StyleBox[\"[\", \"InlineCode\"]\)\!\(\*
StyleBox[\"sp\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"InlineCode\"]\)\!\(\*
StyleBox[\" \", \"InlineCode\"]\)\!\(\*
StyleBox[\"nsp\", \"TI\"]\)] gives (\!\(\*
StyleBox[\"sp\", \"TI\"]\)-1)/(\!\(\*
StyleBox[\"nsp\", \"TI\"]\)-1).";

ModPart::usage=
"ModPart[\!\(\*
StyleBox[\"list\", \"TI\"]\), \!\(\*
StyleBox[\"part\", \"TI\"]\)] returns part number \!\(\*
StyleBox[\"part\", \"TI\"]\) of \!\(\*
StyleBox[\"list\", \"TI\"]\) like Part, but wraps around.";

NumberedGridForm::usage=
"NumberedGridForm[\!\(\*
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"]\)] formats \!\(\*
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"]\) in a table with numbers";

FindMaxima::usage=
"FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local maxima of InterpolatingFunction \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).";

FindMinima::usage=
"FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local minima of InterpolatingFunction \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).";

FindExtrema::usage=
"FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local extrema of InterpolatingFunction \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).";

myStreamPlot::usage=
"myStreamPlot[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"xmin\", \"TI\"]\), \!\(\*
StyleBox[\"xmax\", \"TI\"]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\), \!\(\*
StyleBox[\"ymin\", \"TI\"]\), \!\(\*
StyleBox[\"ymax\", \"TI\"]\)}] is like StreamPlot, but with better arrow spacing.";

RealSimplify::usage=
"RealSimplify[\!\(\*
StyleBox[\"expression\", \"TI\"]\)] Simplifies \!\(\*
StyleBox[\"expression\", \"TI\"]\) assuming everything is Real.";

TD::usage=
"TD[\!\(\*
StyleBox[\"list\", \"TI\"]\)] returns a TemporalData object if Mathematica version >=9, otherwise returns \!\(\*
StyleBox[\"list\", \"TI\"]\).";

RunFile::usage=
"RunFile[\!\(\*
StyleBox[\"file\", \"TI\"]\)] displays & runs code from a file or URL.";

CompoundAnd::usage=
"CompoundAnd[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if all \!\(\*
StyleBox[\"conds\", \"TI\"]\) are True.";

CompoundOr::usage=
"CompoundOr[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if any of \!\(\*FormBox[
StyleBox[\"conds\", \"TI\"],
TraditionalForm]\) are True.";

SortedEigensystem::usage=
"SortedEigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] is Eigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)], sorted from largest to smallest Re[eigenvalue].";

ListMultiplier::usage=
"ListMultiplier[\!\(\*
StyleBox[\"list\", \"TI\"]\)] multiplies a list of matrices.";

NumericListQ::usage=
"NumericListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers, False otherwise.";

NumericFlattenedListQ::usage =
"NumericFlattenedListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers when Flattened, False otherwise.";

NumericRuleListQ::usage=
"NumericRuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of replacement rules with numeric values, False otherwise.";

RuleListQ::usage=
"RuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of replacement rules, False otherwise.";

RuleListListQ::usage=
"RuleListListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of RuleLists, False otherwise.";

InterpolatingFunctionTake::usage=
"InterpolatingFunctionTake[\!\(\*
StyleBox[\"if\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] takes part of an InterpolatingFunction from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";

Slice::usage=
"Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"t\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with its values at \!\(\*
StyleBox[\"t\", \"TI\"]\).
Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] extracts values from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";

InitialSlice::usage=
"InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the initial values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] extracts the initial values ending at \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";

FinalSlice::usage=
"FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the final values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmin\", \"TI\"]\)] extracts the final values starting at \!\(\*
StyleBox[\"tmin\", \"TI\"]\).";

FinalDerivatives::usage=
"FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with their final derivatives.
FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\)] averages over the final values starting at \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\).";

InitialTime::usage=
"InitialTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the initial time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

FinalTime::usage=
"FinalTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the final time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

FindPeriod::usage=
"FindPeriod[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the period of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

RuleListAdd::usage=
"RuleListAdd[\!\(\*
StyleBox[\"l1\", \"TI\"]\), \!\(\*
StyleBox[\"l2\", \"TI\"]\)] adds corresponding elements of two rulelists.";

RuleListMultiply::usage=
"RuleListMultiply[\!\(\*
StyleBox[\"l\", \"TI\"]\), \!\(\*
StyleBox[\"x\", \"TI\"]\)] or RuleListMultiply[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"l\", \"TI\"]\)] multiply elements of rulelist \!\(\*
StyleBox[\"l\", \"TI\"]\) by number \!\(\*
StyleBox[\"x\", \"TI\"]\).";

RuleListTweak::usage=
"RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variable \!\(\*
StyleBox[\"var\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).
RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).";

listMultiplier::usage=
"listMultiplier[\!\(\*
StyleBox[\"list\", \"TI\"]\)] multiplies a list of matrices.";

RouthHurwitzCriteria::usage=
"RouthHurwitzCriteria[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] gives the modified Routh-Hurwitz stability criteria (up to 3x3).";


$EcoEvoVersion::usage=
"$EcoEvoVersion gives the version of the loaded EcoEvo package.";

DeleteInvaders::usage=
"DeleteInvaders[\!\(\*
StyleBox[\"list\", \"TI\"]\)] removes invaders (with subscript 0) from \!\(\*
StyleBox[\"list\", \"TI\"]\).";

RuleListDistance::usage=
"RuleListDistance[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\),\!\(\*
StyleBox[\"rulelist2\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)] gives the \!\(\*
StyleBox[\"p\", \"TI\"]\)-norm distance between two rule lists (default \!\(\*
StyleBox[\"p\", \"TI\"]\)=\[Infinity]).";

TraitsQ::usage=
"TraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits.";

VariablesQ::usage=
"VariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of variables.";

ListOfVariablesQ::usage=
"ListOfVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of rulelists of variables.";

TraitsAndVariablesQ::usage=
"TraitsAndVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits and/or variables.";

InvaderQ::usage=
"InvaderQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a possible invader.";

NotInvaderTraitsQ::usage=
"NotInvaderTraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits with no invaders.";

GsQ::usage=
"GsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of G matrices or V variances.";

ExtractTraits::usage=
"ExtractTraits[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts traits from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractPops::usage=
"ExtractPops[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractAuxs::usage=
"ExtractAuxs[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts auxs from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractGuilds::usage=
"ExtractGuilds[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts guilds from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractVariables::usage=
"ExtractVariables[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops, guilds, and auxs from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

LookUp::usage =
"LookUp[\!\(\*
StyleBox[\"var\", \"TI\"]\)] finds the indices of a variable or trait.";

PlotDynamics::usage=
"PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots the functions in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.
PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"funcs\", \"TI\"]\)] plots \!\(\*
StyleBox[\"funcs\", \"TI\"]\) in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.";


t::usage="Reserved for time.";
Component::usage="Internal usage only ;)";
Variable::usage="Internal usage only ;)";
Equation::usage="Internal usage only ;)";
Trait::usage="Internal usage only ;)";
Aux::usage="Internal usage only ;)";
Type::usage="Internal usage only ;)";

ModelType::usage="Internal usage only ;)";
Name::usage="Internal usage only ;)";

FromUnks::usage="Internal usage only ;)";

Nsp::usage =
"Nsp[\!\(\*
StyleBox[\"gu\", \"TI\"]\)] is a reserved symbol that denotes the number of species in guild \!\(\*
StyleBox[\"gu\", \"TI\"]\).  Do not set directly.";

AllTraits::usage="Internal usage only ;)";
AllVariables::usage="Internal usage only ;)";
BlankTraits::usage="Internal usage only ;)";
BlankVariables::usage="Internal usage only ;)";

RemovePopts::usage="Internal usage only ;)";
RemovePopt1s::usage="Internal usage only ;)";
RemoveTraitts::usage="Internal usage only ;)";
AddPopts::usage="Internal usage only ;)";
AddTraitts::usage="Internal usage only ;)";

Color::usage="Color gives the color for a model part.";
Colors::usage="Colors is a list of default colors for model parts.";

LineStyle::usage="LineStyle gives the line style for a model part.";
LineStyles::usage="LineStyles is a list of default line styles for model parts.";

PlotMarker::usage="PlotMarker gives the plot marker for a model part.";
PlotMarkers::usage="PlotMarkers is a list of default plot markers for model part.";


EcoEqns::usage="EcoEqns[traits]";
EvoEqns::usage="EvoEqns[sol,Gs]";


SetModel::usage=
"SetModel[\!\(\*
StyleBox[\"model\", \"TI\"]\)] sets an EcoEvo \!\(\*
StyleBox[\"model\", \"TI\"]\) for analysis.";

ModelInfo::usage=
"ModelInfo gives a summary of the currently loaded EcoEvo model.";

MatrixToPopComponents::usage=
"MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";

MatrixToGuildComponents::usage=
"MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";

SelectValid::usage=
"SelectValid[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects valid solutions in list of rule lists \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

EcoSim::usage=
"EcoSim[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates ecological dynamics, with initial densities in \!\(\*
StyleBox[\"pops\", \"TI\"]\), from time \!\(\*
StyleBox[\"t\", \"TI\"]\)=0 to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
EcoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
EcoSim[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses combined \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

EcoEq::usage = 
"EcoEq[] solves for ecological equilibria.
EcoEq[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

SolveEcoEq::usage = 
"SolveEcoEq[] solves for ecological equilibria.
SolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

NSolveEcoEq::usage = 
"NSolveEcoEq[] numerically solves for ecological equilibria.
NSolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

FindEcoEq::usage = 
"FindEcoEq[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

FindEcoCycle::usage = 
"FindEcoCycle[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an ecological limit cycle using initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

EcoJacobian::usage = 
"EcoJacobian[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] returns the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

EcoEigenvalues::usage = 
"EcoEigenvalues[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] returns the eigenvalues of the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

PlotEcoIsoclines::usage =
"PlotEcoIsoclines[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoIsoclines[\!\(\*
StyleBox[\"traits\", \"TI\"]\),{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)},{\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

PlotEcoStreams::usage =
"PlotEcoStreams[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoStreams[\!\(\*
StyleBox[\"traits\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

PlotEcoPhasePlane::usage=
"PlotEcoPhasePlane[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams and isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoPhasePlane[\!\(\*
StyleBox[\"traits\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

SelectEcoStable::usage=
"SelectEcoStable[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects stable equilibria from \!\(\*
StyleBox[\"sol\", \"TI\"]\).
SelectEcoStable[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

EcoStableQ::usage=
"EcoStableQ[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] reports the linear stability of an equilibrium as True, False, or Indeterminate.
EcoStableQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
EcoStableQ[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

FindEcoAttractor::usage=
"FindEcoAttractor[] tries to find an ecological attractor.
FindEcoAttractor[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

Inv::usage=
"Inv[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=1), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

StablePopulationStructure::usage=
"StablePopulationStructure[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

ReproductiveValues::usage =
"ReproductiveValues[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the reproductive values of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the reproductive value of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

InvSPS::usage =
"InvSPS[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate and stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate and stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

DInv::usage =
"DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] calculates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident traits \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"pops\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where DInv will be evaluated.
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] gives derivatives for all traits in Guild (default=1).";

NDInv::usage =
"NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] numerically approximates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident traits \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"pops\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where NDInv will be evaluated.
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] gives derivatives for all traits in Guild (default=1).";

NumDInv::usage="";

GlobalESSQ::usage =
"GlobalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks global ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).
GlobalESSQ[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

PrestonPlot::usage =
"PrestonPlot[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] makes a Preston species abundance distribution plot based on \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

WhittakerPlot::usage =
"WhittakerPlot[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] makes a Whittaker rank-abundance plot based on \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

PlotTAD::usage =
"PlotTAD[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] plots abundance vs trait for the species in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

PlotZIP::usage =
"PlotZIP[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] creates a zero invasion plot, with invader \!\(\*
StyleBox[\"inv\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(inferred if omitted).
PlotZIP[\!\(\*
StyleBox[\"eq0\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] uses equilibrium \!\(\*
StyleBox[\"eq0\", \"TI\"]\).";

PlotInv::usage =
"PlotInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] plots a fitness landscape, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).";

PlotPIP::usage =
"PlotPIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a pairwise invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotPIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.";

PlotMIP::usage =
"PlotMIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a mutual invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotMIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotMIP[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotMIP[{\!\(\*
StyleBox[\"sol1\", \"TI\"]\), \!\(\*
StyleBox[\"sol2\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses equilibria \!\(\*
StyleBox[\"sol1\", \"TI\"]\) and \!\(\*
StyleBox[\"sol2\", \"TI\"]\).";

PlotEvoStreams::usage =
"PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary streams.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

PlotEvoIsoclines::usage =
"PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary isoclines.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

PlotEvoPhasePlane::usage = 
"PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] combines PlotMIP, PlotEvoStreams and PlotEvoIsoclines.
PlotEvoIsoclines[\!\(\*
StyleBox[\"eq1\", \"TI\"]\), \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses one-species equilibrium \!\(\*
StyleBox[\"eq1\", \"TI\"]\) and two-species equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) for improved speed (2 species).
PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits (within or between guilds).
PlotEvoIsoclines[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses one-species equilibria \!\(\*
StyleBox[\"eq11\", \"TI\"]\) and \!\(\*
StyleBox[\"eq12\", \"TI\"]\) and two-species equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) (2 guilds).
PlotEvoIsoclines[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq0\", \"TI\"]\), \!\(\*
StyleBox[\"eq1\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] combines PlotZIP, PlotEvoStreams and PlotEvoIsoclines (2 traits)";

EvoEq::usage = 
"EvoEq contains SolveEvoEq, NSolveEvoEq, and FindEvoEq. Use them instead.";

SolveEvoEq::usage = 
"SolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

NSolveEvoEq::usage = 
"NSolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] numerically solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

FindEvoEq::usage = 
"FindEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
FindEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\), with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

FindEcoEvoEq::usage =
"FindEcoEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an eco-evolutionary equilibrium with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoEvoEq[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined initial guess \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

FindEcoCycleEvoEq::usage =
"FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an evolutionary equilibrium with an ecological cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined initial guess \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

MaximizeInv::usage = 
"MaximizeInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds the trait value(s) that maximize invasion fitness into a community with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

EcoEvoSim::usage =
"EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EcoEvoJacobian::usage = 
"EcoEvoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EcoEvoEigenvalues::usage = 
"EcoEvoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EvoJacobian::usage = 
"EvoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EvoEigenvalues::usage = 
"EvoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


FindInstanceOpts::usage="FindInstanceOpts in an option for various EcoEvo functions that passes options to FindInstance."

MaximizeInvOpts::usage="MaximizeInvOpts is an option for GlobalESSQ that passes options to MaximizeInv.";

ExcludeDiagonal::usage="ExcludeDiagonal is an option for PlotEvoIsoclines that excludes the diagonal.";

PlotMIPOpts::usage="PlotMIPOpts is an option for PlotEvoPhasePlane that passes options to PlotMIP.";

PlotZIPOpts::usage="PlotZIPOpts is an option for PlotEvoPhasePlane that passes options to PlotZIP.";

PlotEvoStreamsOpts::usage="PlotEvoStreamsOpts is an option for PlotEvoPhasePlane that passes options to PlotEvoStreams.";

PlotEvoIsoclinesOpts::usage="";

IsoclineStyle::usage="IsoclineStyle is an option for PlotEcoIsoclines and PlotEvoIsoclines that defines the style for isoclines.";

UseSymmetry::usage="UseSymmetry is an option for PlotEvoStreams & PlotEvoIsoclines that assumes fitness gradients are symmetric.";

InvStyle::usage="InvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for successful invasion.";

NonInvStyle::usage="NonInvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for unsuccessful invasion.";

SpeciesColors::usage="SpeciesColors is an option for PlotMIP (PlotType->Outcome) that defines colors for each species.";

ShowSpecies::usage="ShowSpecies is an option for PrestonPlot that shows species markers or not.";

MarkerStyle::usage="MarkerStyle is an option for PrestonPlot that styles species markers.";

Bandwidth::usage="Bandwidth is an option for PrestonPlot that sets the bandwidth in SmoothKernelDistribution.";

MinPop::usage="MinPop is an option for varios EcoEvo functions that defines a minimum population size.";

Base::usage="Base is an option for PrestonPlot that sets the logarithm base.";

QSS::usage="QSS is an option for *EcoEq that indicates that nonspecified variables should be treated as unknowns.";

TMin::usage="TMin specifies the starting time for EcoSim and EcoEvoSim.";

EcoAttractorNumber::usage="EcoAttractorNumber specifies which EcoAttractor to choose in the case of multiple attractors.";

TestValidity::usage="TestValidity is an option for FindEcoAttractor that determines whether to test for valid equilibria.";

TestStability::usage="TestStability is an option for FindEcoAttractor that determines whether to test for stable equilibria.";

FinalTMax::usage="FinalTMax is an option for FindEcoAttractor that sets the length of an aperiodic solution.";

EigenvaluesOpts::usage="EigenvaluesOpts passes options to Eigenvalues.";

AvgOpts::usage="AvgOpts is an option for Variance and Covariance that passes options to Avg.";

Gradients::usage="Gradients is an option for SetModel that provides a list of base Colorradients for guilds.";

TimeScale::usage="TimeScale is an option for EcoSim that sets the overall timescale (default=1).";

OutputTMin::usage="OutputTMin is an option for EcoSim and EcoEvoSim that that sets the length of the results (default=0).";

Output::usage="Output is an option for various EcoEvo functions that determines the type of output.";

IsoclineLabels::usage="IsoclineLabels is an option for PlotEcoIsoclines and PlotEvoIsoclines that styles the isocline labels.";

PlotEcoIsoclinesOpts::usage="PlotEcoIsoclinesOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoIsoclines.";

PlotEcoStreamsOpts::usage="PlotEcoStreamsOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoStreams.";

BasePeriod::usage="BasePeriod is an option for FindPeriod that gives the period to look at multiples of.";

MaxPeriodMultiplier::usage="MaxPeriodMultiplier is an option for FindEcoAttractor that sets how many multiples of the Period to try.";

Multipliers::usage="Multipliers is an option for EcoEigenvalues that chooses Floquet multipliers (True) or exponents (False).";

TMaxPowerMin::usage="TMaxPowerMin is an option for FindEcoCycle that sets the minimum base-10 power of tmax to try.";

TMaxPowerMax::usage="TMaxPowerMax is an option for FindEcoCycle that sets the maximum base-10 power of tmax to try.";

dTMaxPower::usage="dTMaxPower is an option for FindEcoCycle that sets the stepsize base-10 power of tmax.";

V::usage="V is an option to set genetic variance in various EcoEvo functions.";

G::usage="G is an option to set genetic variance/covariance matrix in various EcoEvo functions.";

ESTest::usage="ESTest is an option for PlotEvoIsoclines that colors isoclines according to (local) evolutionary stability.";

NonESColor::usage="NonESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";

ESColor::usage="ESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";

DelayDInv2::usage="DelayDInv2 is an option for PlotEvoIsoclines whether to delay evaluation of DInv in ESS-test.";

DInv2Opts::usage="DInvOpts is an option for PlotEvoIsoclines that passed options to DInv in ESS-test.";

BoundaryDetection::usage="BoundaryDetection is an option for various EcoEvo functions to enforce variable/trait bounds.";

Period::usage="Period is an option for EcoEvoModel that defines its period.";

RV::usage="RV is an option for InvSPS when called from ReproductiveValues.";

FromInv::usage="FromInv is an option for InvSPS when called from Inv.";

NumTries::usage="NumTries is an option for FindEcoAttractor's method \"FindRoot\" that says how many initial guesses to try.";

Switches::usage="Switches is an option for EcoSimSSD that says when external mode switches occur.";

PrintTrace::usage="PrintTrace is an option for various EcoEvo functions to leave a trace of iterations.";

Guild::usage = 
"Guild is an option for various EcoEvo functions that sets which guild to use.";

Species::usage = 
"Species is an option for various EcoEvo functions that sets which species to use.";

Pop::usage = 
"Pop is an option for various EcoEvo functions that sets which population to use.";

Logged::usage =
"Logged is an option for EcoSim that logs population variables.";

Averaged::usage =
"Averaged is an option for Inv that averages growth if True, gives instantaneous growth if False.";

AbsoluteStepSize::usage = 
"AbsoluteStepSize is an option for NDInv that sets the absolute step size.";

RelativeStepSize::usage = 
"RelativeStepSize is an option for NDInv that sets the relative step size.";

PlotSpecies::usage =
"PlotSpecies is an option for PlotInv that puts points for species.";

PointStyle::usage =
"PointStyle is an option for PlotInv that determines the style of points for species.";

ICs::usage =
"ICs is an option for PlotPIP and PlotMIP that supplies initial guesses for FindEcoAttractor.";

ZeroDiagonal::usage = 
"ZeroDiagonal is an option for PlotPIP that forces Inv=0 along the diagonal.";

SubtractDiagonal::usage=
"SubtractDiagonal is an option for PlotPIP that subtracts the diagonal from all invasion rates.";

EqStop::usage = 
"EqStop is an option for various EcoEvo simulation functions that stops upon reaching an equilibrium.";

WhenEvents::usage =
"WhenEvents is an option for various EcoEvo simulation functions that adds WhenEvents to NDSolve.";

EqThreshold::usage = 
"EqThreshold is an option for various EcoEvo simulation functions that sets the sensitivity for EqStop.";

Fixed::usage =
"Fixed is an option for various EcoEvo functions that find equilibria, that fixes the values of certain species/traits.";

WarmUp::usage = 
"WarmUp is an option for various EcoEvo functions that numerical solves a model before refining.";

WarmUp2::usage = 
"WarmUp2 is an option for various EcoEvo functions that numerical solves a model before refining.";

WarmUp3::usage = 
"WarmUp3 is an option for various EcoEvo functions that numerical solves a model before refining.";

TriggerVariable::usage =
"TriggerVariable is an option for FindEcoCycle that sets which variable to focus on.";

SolveOpts::usage =
"SolveOpts is an option for various EcoEvo functions that passes options to Solve.";

NSolveOpts::usage =
"NSolveOpts is an option for various EcoEvo functions that passes options to NSolve.";

FindRootOpts::usage =
"FindRootOpts is an option for various EcoEvo functions that passes options to FindRoot.";

MaximizeOpts::usage =
"MaximizeOpts is an option for various EcoEvo functions that passes options to Maximize.";

NDSolveOpts::usage =
"NDSolveOpts is an option for various EcoEvo functions that passes options to NDSolve.";

WhenEventOpts::usage =
"WhenEventOpts is an option for various EcoEvo functions that passes options to WhenEvent.";

NDOpts::usage =
"NDOpts is an option for various EcoEvo functions that passes options to ND.";

NIntegrateOpts::usage =
"NIntegrateOpts is an option for various EcoEvo functions that passes options to NIntegrate.";

IntegrateOpts::usage =
"IntegrateOpts is an option for various EcoEvo functions that passes options to Integrate.";

FindEcoEvoEqOpts::usage =
"FindEcoEvoEqOpts is an option for TrackEcoEvoEq that passes options to FindEcoEvoEq.";

GlobalGlobalESSQOpts::usage =
"GlobalGlobalESSQOpts is an option for TrackEcoEvoEq that passes options to GlobalESSQ.";

EcoSimOpts::usage =
"EcoSimOpts is an option for various EcoEvo functions that passes options to EcoSim.";

EigensystemOpts::usage =
"EigenvaluesOpts is an option for various EcoEvo functions that passes options to Eigenvalues.";

BifurcationAction::usage =
"BifurcationAction is an option for TrackEcoEvoEq that selects what to do when a bifurcation is found.";

NMaximizeOpts::usage =
"NMaximizeOpts is an option for GlobalESSQ that passes options to NMaximize.";

Constraints::usage =
"Constraints is an option for various EcoEvo functions that add extra constraints.";

QSSMethod::usage =
"QSSMethod is an option for Inv that selects how to solve for qualitative structure of the invader.";

QSSICs::usage =
"QSSICs is an option for Inv that sets initial conditions for solving for qualitative structure of the invader.";

PerCapita::usage =
"PerCapita is an option for various EcoEvo functions that divides by population size.";

FindEcoCycleOpts::usage =
"FindEcoCycleOpts is an option for various EcoEvo functions that passes options to FindEcoCycle.";

FindEcoAttractorOpts::usage =
"FindEcoAttractorOpts is an option for various EcoEvo functions that passes options to FindEcoAttractor.";

SolveEcoEqOpts::usage=
"SolveEcoEqOpts is an option for various EcoEvo functions that passes options to SolveEcoEq.";

NSolveEcoEqOpts::usage=
"NSolveEcoEqOpts is an option for various EcoEvo functions that passes options to NSolveEcoEq.";

FindEcoEqOpts::usage=
"FindEcoEqOpts is an option for various EcoEvo functions that passes options to FindEcoEq.";

EcoEigenvaluesOpts::usage=
"EcoEigenvaluesOpts is an option for various EcoEvo functions that passes options to EcoEigenvalues.";

TMax::usage=
"TMax is an option for FindEcoAttractor that sets the maximum time for EcoSim.";

TMax2::usage=
"TMax2 is an option for FindEcoAttractor that sets the maximum time for EcoSim.";

InvOpts::usage =
"InvOpts is an option for various EcoEvo functions that passes options to Inv.";

NInvOpts::usage =
"NInvOpts is an option for various EcoEvo functions that passes options to NInv.";

DInvOpts::usage =
"DInvOpts is an option for various EcoEvo functions that passes options to DInv.";

NDInvOpts::usage =
"NDInvOpts is an option for various EcoEvo functions that passes options to NDInv.";

DelayInv::usage=
"DelayInv is an option for various EcoEvo functions that delays the evaluation of Inv.";

DelayDInv::usage=
"DelayDInv is an option for various EcoEvo functions that delays the evaluation of DInv.";

FitnessGradient::usage=
"FitnessGradient is an option for various EcoEvo functions that chooses whether to use DInv or NDInv to calculate fitness gradients.";

PlotOpts::usage=
"PlotOpts is an option for various EcoEvo functions that passes options to plotting functions.";

PlotType::usage=
"PlotType is an option for PlotPIP that chooses plot type (ZeroContourPlot [default], ContourPlot, Plot3D).";

InvThreshold::usage=
"InvThreshold is an option for PlotMIP that sets the threshold for successful invasion.";

SimplifyResult::usage=
"SimplifyResult is an option for various EcoEvo functions that applies Simplify before returning results.";

EvoEquation::usage=
"EvoEquation is an option for EcoEvoSim that sets whether to use the breeders' equation (\"QG\" -- default) or the canonical equation (\"CE\").";

VerboseAll::usage = 
"VerboseAll is an option for various EcoEvo functions that recursively turns on Verbose reporting.";

TraitShiftRate::usage =
"TraitShiftRate is an option for various evolutionary EcoEvo functions that changes into a moving frame of reference for an constantly changing environment.";

Time::usage =
"Time is an option for various EcoEvo functions that specifies when to evaluation the model.";

MaxPeriod::usage =
"MaxPeriod is an option for FindEcoAttactor that sets the largest discrete-time period to look for a cycle.";


$invcount::usage =
"Counts number of times Inv called.";

$findecocyclesteps::usage =
"Counts the number of EcoSim calls in FindEcoCycle.";
 
$findecoeqthingcount::usage =
"Counts number of times \"thing\" called inside EcoEq (FindRoot).";

$findevoeqthingcount::usage =
"Counts number of times \"thing\" called inside FindEvoEq.";

$ecoevoeqthingcount::usage =
"Counts number of times \"thing\" called inside FindEcoEvoEq.";

$findecocycleevoeqthingcount::usage=
"Counts number of times \"thing\" called inside FindEcoCycleEvoEq.";

$roundofftolerance::usage =
"Buffer when comparing numbers.";

$tmax::usage = 
"Default maximum time for *Sims.";


PlotZIP::unkinv=
"Can't figure out who's invading: please specify.";

PlotZIP::diffsp=
"\!\(\*
StyleBox[\"x\", \"TI\"]\)- and \!\(\*
StyleBox[\"y\", \"TI\"]\)-axes should have the same species.";

PlotPIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";

PlotMIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";

PlotMIP::badmtd=
"The PlotType option should be a built-in method name (\"MIP\", \"RegionMIP\", \"Outcome\", or \"RegionOutcome\").";

EcoEvoGeneral::nomodel="No model loaded. Use SetModel first.";

SetNsp::badnsp=
"Number of species inconsistent between traits `1` and densities `2`.";

SetNsp::badtr=
"Number of traits in guild `1` inconsistent: `2`.";

SetNsp::badcomm=
"Number of components in guild `1` inconsistent: `2`.";

SetModel::unktype=
"Unknown ModelType (\"ContinuousTime\", \"DiscreteTime\" currently supported).";

EcoSim::ndnum=
"Encountered non-numerical value for r.h.s. at t=0.";

FindEcoCycle::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoCycleEvoEq::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoCycle::nomaxima=
"Found no maxima in warmup #3, probably not periodic solution.";

FindEcoCycle::badmtd=
"The Method option should be a built-in method name (\"FindRoot\", \"FixedPoint\", \"EcoSim\" or \"Automatic\")";

FindEcoCycle::noecosim=
"\"EcoSim\" Method only applicable to unforced ContinuousTime models.";

EcoEq::nosol=
"NSolve failed to find a solution.";

InvSPS::nosymev=
"Warning: don't know how to find analytical StablePopulationStructure for > 2x2 matrix.";

InvSPS::unkinv=
"Can't figure out who's invading: please specify.";

InvSPS::nonzero=
"Invasion rate only defined for rare invaders.";

InvSPS::noqsssol=
"Couldn't find QSS solution for invader's Intensive components.";

InvSPS::notraits=
"Trait of invader not defined, so NIntegrate can't work.  Try Method->\"Integrate\" or give invader traits.";

FindEcoAttractor::badmtd=
"The Method option should be a built-in method name (\"SolveEcoEq\", \"NSolveEcoEq\", \"FindEcoEq\", or \"EcoSim\")";

FindEcoAttractor::nopops=
"No initial population sizes given, cannot continue with `1`.";

FindEcoAttractor::nocycle=
"Warning: couldn't find a cycle with period less than MaxPeriod=`1`.";

FindEcoAttractor::novalideq=
"Couldn't find a valid equilibrium.";

FindEcoAttractor::giveup=
"Couldn't find an equilibrium or cycle, returing EcoSim.";

TrackEcoEq::parvar=
"`1` cannot be used as a variable.";

TrackEcoEq::nosol=
"Could not find a solution at par=`1`, quitting.";

TrackEcoEvoEq::parvar=
"`1` cannot be used as a variable.";

TrackEcoEvoEq::nosol=
"Could not find a solution at par=`1`, quitting.";

TrackEcoEvoEq::conv=
"Two species converged at par=`1`, quitting";

FindEcoEvoEq::badfg="Bad FitnessGradient method (should be either DInv or NDInv).";

EcoEvoSim::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

FindEcoEvoEq::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

EcoEq::noneq="Can't find equilibrium of periodically forced model with FindRoot.  Give Time option or try FindEcoCycle instead.";

EcoEq::nosol="Solve/NSolve couldn't find a solution.  Try FindEcoEq instead.";

EvoEq::nosol="Solve/NSolve couldn't find a solution.  Try FindEcoEq instead.";

EvoEq::badmtd="The Method option should be \"Solve\", \"NSolve\", or \"FindRoot\".";

NInv::badmtd="The Method option should be a built-in method name.";

EcoEvoJacobian::noper="EcoEvoJacobian can't handle periodic models yet.";

EcoEvoEigenvalues::noper="EcoEvoEigenvalues can't handle periodic models yet.";

EvoJacobian::noper="EvoJacobian can't handle periodic models yet.";

EvoEigenvalues::noper="EvoEigenvalues can't handle periodic models yet.";


FindEcoAttractor::nosteq=
"Warning: couldn't find a stable equilibrium with traits `1`. Trying EcoSim.";
(*Off[FindEcoAttractor::nosteq];*)

FindEcoAttractor::musteq=
"Warning: found `1` stable equilibria with traits `2`.";
(*Off[FindEcoAttractor::musteq];*)

FindEcoAttractor::nostst=
"Warning: EcoSim did not find a steady state (d/dt=`1` at t=`2`). Trying FindEcoCycle.";
(*Off[FindEcoAttractor::nostst];*)


notEcoEigenvaluesOpts::usage="nmotEcoEigenvaluesOpts identifies non-options to EcoEigenvalues.";
notInvOpts::usage="notInvOpts identifies non-options to Inv.";
notDInvOpts::usage="notDInvOpts identifies non-options to DInv.";
notMaximizeInvOpts::usage="notDInvOpts identifies non-options to MaximizeInv.";
notEcoEvoJacobianOpts::usage="notEcoEvoJacobianOpts identifies non-options to EcoEvoJacobian.";
notEcoEvoEigenvaluesOpts::usage="notEcoEvoEigenvaluesOpts identifies non-options to EcoEvoEigenvalues.";
notEcoEvoSimOpts::usage="notEcoEvoSimOpts identifies non-options to EcoEvoSim.";


Begin["`Private`"];


$EcoEvoVersion="0.9.4\[Beta] (September 16, 2018)";


Print["EcoEvo Package Version ",$EcoEvoVersion];


SetOptions[NDSolve,MaxSteps->Infinity];
(*SetOptions[NIntegrate,MaxRecursion\[Rule]30];*)


$invcount=0;
$findecocyclesteps=0;
$findecoeqthingcount=0;
$findevoeqthingcount=0;
$ecoevoeqthingcount=0;
$roundofftolerance=10^-10;
$tmax=10^4;
modelloaded=False;


VarSort[eq_?RuleListQ,vars_List]:=SortBy[eq,Position[vars,#[[1]]]&];


VarSort[eqs_?RuleListListQ,vars_List]:=VarSort[#,vars]&/@eqs;


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/30434/6358> *)
orderedComplement[all_List, i__List] := 
  DeleteDuplicates[Join @ ##] ~Drop~ Length[#] &[Union @ i, DeleteDuplicates @ all];


EqSort[x_?RuleListListQ]:=SortBy[x,Reverse[Map[If[Abs[#]<$MachineEpsilon,0,1]&,#[[All,2]]]]&];


EqSort[x_?RuleListQ]:=x;


RHS=(_==rhs_->rhs);


Eq={var_[t+1]->var[t],var_'[t]->0};


ZeroLHS=(lhs_==rhs_->0==rhs);


ZeroVector[dim_Integer]:=Table[0,{i,dim}];


SubscriptAdd[x_Subscript,add_Integer:1]:=x/.Subscript[var_,sub_]->Subscript[var,sub+add];


DeleteSubscript[x_Subscript]:=x/.Subscript[var_,_]->var;


ZeroSubscript[x_Subscript]:=x/.Subscript[var_,sub_]->Subscript[var,0];


HighlightChanges[bool_]:=If[bool==True,
	SetOptions[EvaluationNotebook[],{
	CellProlog:>(
		SelectionMove[EvaluationCell[],All,GeneratedCell];
		$oldoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&]
	),
	CellEpilog:>(
	SelectionMove[EvaluationCell[],All,GeneratedCell];
	$newoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&];
	If[($oldoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"])=!=($newoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"]),
	Print[Style["Output change:",Red],"\nold=",$oldoutput]];
	If[Length[$newoutput]!=0,SelectionMove[EvaluationCell[],After,CellGroup,2],SelectionMove[EvaluationCell[],After,Cell]]
	)
	}],
	SetOptions[EvaluationNotebook[],{CellProlog->{},CellEpilog->{}}]
];


ExtractColors[list_List]:=Select[list,ColorQ[#]||Head[#]==Opacity&]


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/18669/6358> *)
axisFlip=#/.{x_Line|x_GraphicsComplex:>MapAt[#~Reverse~2&,x,1],x:(PlotRange->_):>x~Reverse~2}&;


FuncStyle[func_String]:=Style[func,Underlined];


(* based on <https://mathematica.stackexchange.com/a/158902/6358> by Szabolcs and <https://mathematica.stackexchange.com/a/161310/6358> by Carl Woll *)
SetAttributes[PrintCall,HoldAll]
(*PrintCall[expr_]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]"Running:"]*)
(*PrintCall[expr_]:=Print[Defer[expr]];*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=With[{expr2=Defer[expr/.Sequence[]\[Rule]Null]},
	CellPrint@ExpressionCell[Defer[expr2],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
];*)
(*PrintCall[expr_,dingbat_:""]:=
CellPrint@ExpressionCell[Defer[expr]/.Sequence[]\[Rule]Nothing,CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]],
CellBaseline\[Rule]Scaled[0.005],CellMargins\[Rule]{{66,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
*)
(*PrintCall[expr_]:=Print@DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]];*)
PrintCall[expr_,dingbat_:""]:=Print[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]]];


Msg[msgs__]:=Block[{$Messages=Streams["stdout"]},
If[!ListQ@$MessageList,$MessageList={}];
Message[msgs];
];
SetAttributes[Msg,HoldAll];


ColorData[1]; (* load ColorData *)

(*AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},{RGBColor[1,0.8,0.4],RGBColor[1,0.5,0],RGBColor[1,0,0],RGBColor[1,0,0.5],RGBColor[0.5,0,0.25]},""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},{RGBColor[0.8,1,0.4],RGBColor[0.5,1,0],RGBColor[0,1,0],RGBColor[0,1,0.4],RGBColor[0,0.5,0.25]},""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},{RGBColor[0.4,0.8,1],RGBColor[0,0.5,1],RGBColor[0,0,1],RGBColor[0.4,0,1],RGBColor[0.25,0,0.5]},""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];*)

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.083,0.4,1],Hue[0.083,0.7,1],Hue[0.083,1,1],Hue[0,1,1],Hue[0.917,1,1],Hue[0.917,1,0.7],Hue[0.917,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.25,0.4,1],Hue[0.25,0.7,1],Hue[0.25,1,1],Hue[0.333,1,1],Hue[0.417,1,1],Hue[0.417,1,0.7],Hue[0.417,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.567,0.4,1],Hue[0.583,0.7,1],Hue[0.583,1,1],Hue[0.667,1,1],Hue[0.75,1,1],Hue[0.75,1,0.7],Hue[0.75,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];

(*AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.1,0.5,1],Hue[0.1,0.7,1],Hue[0,0.7,1],Hue[0,1,1],Hue[0,1,0.7],Hue[0.9,1,0.7],Hue[0.9,1,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.233,0.5,1],Hue[0.233,0.7,1],Hue[0.333,0.8,1],Hue[0.333,1,1],Hue[0.333,1,0.7],Hue[0.433,1,0.7],Hue[0.433,1,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.567,0.5,1],Hue[0.567,0.7,1],Hue[0.667,0.6,1],Hue[0.667,1,1],Hue[0.667,1,0.7],Hue[0.767,1,0.6],Hue[0.767,1,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];*)


RuleList[var_Symbol,n_,val_]:=Table[Subscript[var,i]->val/.\[IGrave]->i,{i,n}];


RuleList[var_Symbol,n_,{min_?NumericQ,max_?NumericQ}]:=Table[Subscript[var,i]->min+(max-min)*(i-1)/(n-1),{i,n}];


RuleList[vars_List,n_,vals_List]:=Flatten[Table[Subscript[vars[[j]],i]->vals[[j]],{i,n},{j,Length[vars]}]];


RuleList[var_Symbol,ns_List,val_]:=
	Thread[
		Table[Subscript[var,i],{i,Times[Sequence@@ns]}]->
		Table[val,{i,Times[Sequence@@ns]}]
	]


RuleList[vars_List,ns_List,vals_List]:=Module[{n,min,max},
	Thread[
		Flatten[Table[Map[Subscript[#,i]&,vars],{i,Times[Sequence@@ns]}]]
		->
		Flatten[Outer[List,Sequence@@Table[
			n=ns[[j]];
			If[ListQ[vals[[j]]],{min,max}=vals[[j]],min=max=vals[[j]]];
			Table[min+(max-min)*(i-1)/(n-1),{i,n}]
		,{j,Length[ns]}]]]
		]
	]


SetAttributes[RuleList,HoldAll];


(* mostly by Simon - see <http://stackoverflow.com/questions/5086749/mathematica-how-to-clear-the-cache-for-a-symbol-i-e-unset-pattern-free-downva> *)
ClearCache[f_]:=(DownValues[f]=DeleteCases[DownValues[f],_?(FreeQ[First[#],Pattern]&)];);

(* make work on multiple arguments *)
ClearCache[f__]:=(Map[ClearCache,{f}];);


IFFQ[x_]:=If[Length[Cases[x,_InterpolatingFunction,\[Infinity],Heads->True]]!=0,True,False];
(*IFFQ[x_]:=If[Head[Head[x]]===InterpolatingFunction,True,False];*) (* why did I write this? <- breaks (c[t]/.sol)^2 *)


Avg[f_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,method},
	method=Evaluate[Method/.Flatten[{opts,Options[Avg]}]];
	If[IFFQ[f]==True,method="NIntegrate"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[Avg]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Avg]}]];
	
	Which[
		method=="Integrate",
		Return[Integrate[f,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[f,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		Else,
		Msg[General::badmtd];Return[$Failed]
	];
];


Avg[if_?IFFQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Avg]}]];
	
	ifdomains=Map[#["Domain"][[1]]&,Cases[if,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Msg[Avg::norange],
		numifdomains>1,
		Msg[Avg::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[Avg[if,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


Options[Avg]={Method->"Integrate",IntegrateOpts->{},NIntegrateOpts->{}};


Var[f_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg},
	method=Evaluate[Method/.Flatten[{opts,Options[Var]}]];
	If[IFFQ[f]==True,method="NIntegrate"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[Var]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Var]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Var]}]];

	avg=Avg[f,{var,varmin,varmax},Method->method];
	
	Which[
		method=="Integrate",
		Return[Integrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)^2],
		method=="NIntegrate",
		Return[NIntegrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)^2],
		Else,
		Msg[General::badmtd];Return[$Failed];
	];
];


Var[if_?IFFQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Var]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Var]}]];
		
	ifdomains=Map[#["Domain"][[1]]&,Cases[if,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Msg[Var::norange],
		numifdomains>1,
		Msg[Var::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[Var[if,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


Options[Var]={IntegrateOpts->{},NIntegrateOpts->{},AvgOpts->{},Method->"Integrate"};


Cov[f1_,f2_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg1,avg2},
	method=Evaluate[Method/.Flatten[{opts,Options[Cov]}]];
	If[(IFFQ[f1]==True)||(IFFQ[f2]==True),method="NIntegrate"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[Cov]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Cov]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Cov]}]];
	
	avg1=Avg[f1,{var,varmin,varmax},Method->method];
	avg2=Avg[f2,{var,varmin,varmax},Method->method];
	
	Which[
		method=="Integrate",
		Return[Integrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)^2],
		method=="NIntegrate",
		Return[NIntegrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)^2],
		Else,
		Msg[General::badmtd];Return[$Failed];
	];
];


Cov[if1_,if2_?IFFQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Cov]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Cov]}]];

	ifdomains=Map[#["Domain"][[1]]&,Cases[{if1,if2},_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Msg[Cov::norange],
		numifdomains>1,
		Msg[Cov::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[Cov[if1,if2,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


Cov[if1_?IFFQ,if2_,var_:t,opts___?OptionQ]:=Cov[if2,if1,var,opts];


Options[Cov]={IntegrateOpts->{},NIntegrateOpts->{},AvgOpts->{},Method->"Integrate"};


(* by Jens <http://mathematica.stackexchange.com/a/20282/6358> *)
ExtractPlotPoints[plot_Graphics]:=Cases[Normal@plot,Line[x_]:>x,\[Infinity]];


Else=True;


(*SpFrac[sp_Integer,nsp_Integer]:=If[nsp\[Equal]1,0.5,(sp-1.)/(nsp-1.)];*)
SpFrac[sp_Integer,nsp_Integer]:=sp/(nsp+1.);


ModPart[list_List,part_Integer]:=Part[list,Mod[part,Length[list],1]];


NumberedGridForm[list_List]:=Grid[Transpose[{Range[Length[list]],list}],Alignment->Left];


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358> & a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


FindMaxima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]<0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;


FindMaxima[if_InterpolatingFunction]:=FindMaxima[if,if["Domain"][[1]]];


FindMinima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]>0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;


FindMinima[if_InterpolatingFunction]:=FindMinima[if,if["Domain"][[1]]];


FindExtrema[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]==0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;


FindExtrema[if_InterpolatingFunction]:=FindExtrema[if,if["Domain"][[1]]];


FindPeriod[sol_,opts:OptionsPattern[]]:=Module[{var1,res,tmp},

Which[
	Head[sol[[1,2]]]===TemporalData,
	(* based on idea from bbgodfrey, http://mathematica.stackexchange.com/a/107741/6358 *)
	res=Length[DeleteDuplicates[Transpose[
		Map[(#/.sol)["Values"][[Max[-sol[[1,2]]["PathLength"],-OptionValue[MaxPeriod]];;]]&,sol[[All,1]]]],
		Norm[#1-#2]<10^-OptionValue[AccuracyGoal]+Norm[(#1-#2)/#1]*10^-OptionValue[PrecisionGoal]&]]
,
	Head[sol[[1,2]]]===InterpolatingFunction&&OptionValue[BasePeriod]=!=None,
	var1=sol[[1,1]];
	tmp={var1->TimeSeries[Table[{t,var1/.Slice[sol,t]},{t,InitialTime[sol],FinalTime[sol],OptionValue[BasePeriod]}]]};
	res=FindPeriod[tmp]*OptionValue[BasePeriod]
,
	True, (* else *)
	Return[];
];

Return[res]

];


Options[FindPeriod]={MaxPeriod->4,AccuracyGoal->5,PrecisionGoal->5,BasePeriod->None};


(* from <http://mathematica.stackexchange.com/a/42770/6358> by Rahul, tweaked by me *)
Options[myStreamPlot]=Options[StreamPlot];
myStreamPlot[f_,{x_,x0_,x1_},{y_,y0_,y1_},opts:OptionsPattern[]]:=Module[{u,v,a=OptionValue[AspectRatio]},
Show[StreamPlot[{1/(x1-x0),a/(y1-y0)} (f/.{x->x0+u (x1-x0),y->y0+v/a (y1-y0)}),{u,0,1},{v,0,a},opts]/.Arrow[pts_]:>Arrow[({x0,y0}+{x1-x0,(y1-y0)/a} #)&/@pts],PlotRange->{{x0,x1},{y0,y1}}]]


RealSimplify[foo_]:=Simplify[foo,Assumptions->{_\[Element]Reals}];


TD[list_List]:=If[$VersionNumber>=10,TimeSeries[list],list];


CompoundAnd[list_]:=Module[{},And[Evaluate[Sequence@@list]]];


CompoundOr[list_]:=Module[{},Or[Evaluate[Sequence@@list]]];


RuleListDistance[pop1_?NumericRuleListQ,pop2_?NumericRuleListQ,p_:\[Infinity]]:=Norm[Sort[pop1][[All,2]]-Sort[pop2][[All,2]],p];


NumericListQ[x_]:=VectorQ[x,NumericQ[#]&];


NumericFlattenedListQ[x_]:=If[ListQ[x],NumericListQ[Flatten[x]],False];


RuleListQ[x_]:=VectorQ[x,(#[[0]]==Rule||#[[0]]==RuleDelayed)&];


RuleListListQ[x_]:=VectorQ[x,RuleListQ[#]&];


NumericRuleListQ[x_]:=If[RuleListQ[x],VectorQ[x,NumericQ[#[[2]]]&],False];


RuleListTweak[point_?RuleListQ,var_Symbol,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_Subscript,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_List,h_List]:=Join[Select[point,!MemberQ[var,#[[1]]]&],#->((#/.point)+h[[Position[var,#][[1,1]]]])&/@var];


(*RuleListAdd[l1_?RuleListQ,l2_?RuleListQ,m2_:1,m1_:1]:=Table[e\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]m1*e\[LeftDoubleBracket]2\[RightDoubleBracket]+m2*(e\[LeftDoubleBracket]1\[RightDoubleBracket]/.l2),{e,l1}];*)
RuleListAdd[a_?RuleListQ,b_?RuleListQ] := Normal[Merge[{a,b},Total]]


RuleListMultiply[a_?RuleListQ,x_?NumericQ]:=Normal[Merge[a,x*#[[1]]&]];
RuleListMultiply[x_?NumericQ,a_?RuleListQ]:=Normal[Merge[a,x*#[[1]]&]];


(* based on code by MichaelE2 <https://mathematica.stackexchange.com/a/152861/6358> *)


ClearAll[ifnPart];
ifnPart["Domain"]=Sequence[1];(*bounding box for domain*)
ifnPart["X1"]=Sequence[1,1];(*lower bound for first coordinate*)
ifnPart["X2"]=Sequence[1,2];(*upper bound for first coordinate*)
ifnPart["Version"]=Sequence[2,1];
ifnPart["Flags"]=Sequence[2,2];(*flags indicating properties:bit field positions-inferred,perhaps mistaken $extrapolation=0;whether to warn about extrapolation $fullArrayBit=1;interpolation data is a full array (not ragged) $packed=2;packed array form (???) $repeatedBit=4;whether repeated abscissae are permitted*)
ifnPart["DerivativeOrder"]=Sequence[2,3];(*max derivative order*)
ifnPart["NGrid"]=Sequence[2,4];(*number of points in each coordinate grid*)
ifnPart["InterpolationOrder"]=Sequence[2,5];(*interpolation order*)
ifnPart["Derivative"]=Sequence[2,6];(*derivative to evaluate:0-->f[x],1-->f'[x],...*)
ifnPart["Periodic"]=Sequence[2,7];
ifnPart["ExtrapolationHandler"]=Sequence[2,10];
ifnPart["Coordinates"]=Sequence[3];(*list of lists,abscissae of interpolation grid*)
ifnPart["InterpolationData"]=Sequence[4];(*interpolation data (values or coefficients)*)
ifnPart["Offsets"]=Sequence[4,2];(*offsets in function/derivative array (PackedArrayForm)*)
ifnPart["FlatData"]=Sequence[4,3];(*flattened function/derivative values (PackedArrayForm)*)
ifnPart["InterpolationStructure"]=Sequence[5];(*{Automatic},or dense output interpolation structure:list of types for each unit/subinterval*)ifnPart["UnitIndices"]=Sequence[5,1,1];(*dense output:Indices (to grid) for corresponding coefficients*)
ifnPart["UnitTypes"]=Sequence[5,1,2];(*dense output types:Automatic|NDSolve`CubicHermite|NDSolve`LocalSeries|ChebyshevT*)
ifnPart["Properties"]=Cases[DownValues[ifnPart],Verbatim[ifnPart][prop_]:>prop,Infinity];

ifnPart["ValidPartQ","Chebyshev"|"Local Taylor Series","UnitIndices"|"UnitTypes",_]:=True;
ifnPart["ValidPartQ",_,"UnitIndices"|"UnitTypes",_]:=False;
ifnPart["ValidPartQ","Hermite","Offsets"|"FlatData",Developer`PackedArrayForm]:=True;
ifnPart["ValidPartQ",_,"Offsets"|"FlatData",_]:=False;
ifnPart["ValidPartQ",method_String,part_String,_]/;MemberQ[method,"Chebyshev"|"Local Taylor Series"|"Hermite"]&&MemberQ[part,ifnPart["Properties"]]:=True;
ifnPart["ValidPartQ",_,_,_]:=False;
ifnPart[if_InterpolatingFunction,part_String]/;ifnPart["ValidPartQ",if["InterpolationMethod"],part,if[[4,1]]]:=if~Part~ifnPart[part];


dupeLast[list_]:=Append[list,Last@list];

iDataTake["Local Taylor series"|"Chebyshev",data_,span_]:=Join[{data[[First@span,1;;2]]},data[[First@span+1;;Last@span]]];
iDataTake["Hermite",data:{Developer`PackedArrayForm,_,_},span:{s1_,s2_}]:=
	ReplacePart[data,{Rest@{ifnPart["Offsets"]}->data[[2,s1;;s2+1]]-data[[2,s1]],Rest@{ifnPart["FlatData"]}->data[[3,data[[2,s1]]+1;;data[[2,s2+1]]]]}];
iDataTake["Hermite",data:{__List},span_]:=data[[Span@@span]];

iStructureTake["Local Taylor series"|"Chebyshev",structure_,span_]:=
	ReplacePart[structure,{Rest@{ifnPart["UnitIndices"]}->Join[{{1}},1+structure[[##2&@ifnPart["UnitIndices"],First@span+1;;Last@span]]-structure[[##2&@ifnPart["UnitIndices"],First@span,-1]]//dupeLast],Rest@{ifnPart["UnitTypes"]}->Join[{Automatic},structure[[##2&@ifnPart["UnitTypes"],First@span+1;;Last@span]]//dupeLast]}];
iStructureTake["Hermite",structure_,span_]:=structure;

InterpolatingFunctionTake[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]/;Length@if["Domain"]==1:=Module[
{coords,newif=Hold@@if,span,method},

method=if["InterpolationMethod"];
coords=First@if["Coordinates"];
span=Clip[SparseArray[UnitStep[coords-tmin] UnitStep[tmax-coords]]["AdjacencyLists"][[{1,-1}]]+{-1,1},{1,Length@coords}];
newif[[ifnPart["Domain"]]]={{tmin,tmax}};
newif[[ifnPart["NGrid"]]]=1+Differences@span;
newif[[ifnPart["Coordinates"]]]=Developer`ToPackedArray@{coords[[Span@@span]]};
newif[[ifnPart["InterpolationData"]]]=iDataTake[method,if[[ifnPart["InterpolationData"]]],span];
newif[[ifnPart["InterpolationStructure"]]]=iStructureTake[method,if[[ifnPart["InterpolationStructure"]]],span];
InterpolatingFunction@@newif
];


Slice[sol_,t_?NumericQ]:=Which[
	MemberQ[{InterpolatingFunction,TemporalData},Head[#[[2]]]],
	ReplacePart[#,2->(#[[1]][t]/.#)]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],#[[1]]==t&,1][[1,2]]]
,
	Else,#
]&/@sol;

Slice[sol_,{t1_?NumericQ,t2_?NumericQ}]:=
Which[
	Head[#[[2]]]===InterpolatingFunction,
	ReplacePart[#,2->InterpolatingFunctionTake[#[[2]],{t1,t2}]]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],t1<=#[[1]]<=t2&]]
,
	Head[#[[2]]]===TemporalData,
	ReplacePart[#,2->TimeSeries[Transpose[{#[[2]]["Times"][[t1+1;;t2+1]],#[[2]]["Values"][[t1+1;;t2+1]]}]]]
,
	Else,#
]&/@sol


FinalSlice[sol_,n:(_?NumericQ):0]:=
	If[n==0,
		Return[Slice[sol,FinalTime[sol]]],
		Return[Slice[sol,{FinalTime[sol]-n,FinalTime[sol]}]]
	];


InitialSlice[sol_,n:(_?NumericQ):0]:=
	If[n==0,
		Return[Slice[sol,InitialTime[sol]+10.^-1.00]],
		Return[Slice[sol,{InitialTime[sol]+10.^-100,InitialTime[sol]+n}]]
	];


FinalDerivatives[sol_,dt:(_?NumericQ):0]:=Module[{res},
	If[dt==0,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]]'[#[[2,1,1,2]]]/.#)}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket]'[#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]/.#)}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-2,2]])/(#[[2,-1,1]]-#[[2,-2,1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-2]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-2]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-2\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]][#[[2,1,1,2]]]-#[[1]][#[[2,1,1,2]]-dt])/dt/.#}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]-#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]-dt])/dt/.#}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-(1+dt),2]])/(#[[2,-1,1]]-#[[2,-(1+dt),1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-(1+dt)]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-(1+dt)]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	];
	Return[res]
]


InitialTime[sol_]:=Which[
	Head[sol[[1,2]]]===InterpolatingFunction,sol[[1,2,1,1,1]],
	Head[sol[[1,2]]]===List,sol[[1,2,1,1]],
	Head[sol[[1,2]]]===TemporalData,sol[[1,2]]["FirstTime"]
];


FinalTime[sol_]:=Which[
	Head[sol[[1,2]]]===InterpolatingFunction,sol[[1,2,1,1,2]],
	Head[sol[[1,2]]]===List,sol[[1,2,-1,1]],
	Head[sol[[1,2]]]===TemporalData,sol[[1,2]]["LastTime"]
];


(* by Jens <http://mathematica.stackexchange.com/questions/59172/should-eigenvalues-be-ordered> *)
SortedEigensystem[matrix_?MatrixQ,opts___]:=
(Eigensystem[matrix+# IdentityMatrix[Dimensions[matrix]],opts]-{#,0})&@Norm[Flatten[matrix]];


(* by Joel Wallman <http://mathematica.stackexchange.com/a/113113/6358> *)
ListMultiplier[list_,partitionwidth_:5]:=NestWhile[Dot@@@Partition[#,partitionwidth,partitionwidth,1,{}]&,list,Dimensions[#][[1]]>1&][[1]];


RunFile[file_String]:=Module[{res},
	res=ReadString[file];
	CellPrint[Cell[StringTake[res,{1,-2}],"Program"]];
	ToExpression[res];
];


(* by Joel Wallman <http://mathematica.stackexchange.com/a/113113/6358> *)
listMultiplier[list_,partitionwidth_: 5]:=NestWhile[Dot@@@Partition[#,partitionwidth,partitionwidth,1,{}]&,list,Dimensions[#][[1]]>1&][[1]]


RouthHurwitzCriteria[a_?MatrixQ]:=Module[{c3},
	If[!SquareMatrixQ[a],Msg[RouthHurwitzCriteria::nonsq];Return[a]];
	Which[
		Length[a]==1,
		Return[Piecewise[{{True,a[[1,1]]<0},{False,a[[1,1]]>0}},Indeterminate]],
		Length[a]==2,
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]>0},{False,Tr[a]>0||Det[a]<0}},Indeterminate]],
		Length[a]==3,
		c3=Det[{{a[[1,1]]+a[[2,2]],a[[2,3]],-a[[1,3]]},{a[[3,2]],a[[1,1]]+a[[3,3]],a[[1,2]]},{-a[[3,1]],a[[2,1]],a[[2,2]]+a[[3,3]]}}];
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]<0&&c3<0},{False,Tr[a]>0||Det[a]>0||c3>0}},Indeterminate]],
		Length[a]>3,
		Msg[RouthHurwitzCriteria::toobig];Return[a]
	]
];


SetModel[model_?RuleListQ,opts___?OptionQ]:=Module[{
(* options *)
colors,linestyles,plotmarkers,gradients,
(* other *)
stylecount,basestyle,in},

(* options *)

colors=Evaluate[Colors/.Flatten[{opts,Options[SetModel]}]];
linestyles=Evaluate[LineStyles/.Flatten[{opts,Options[SetModel]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[SetModel]}]];

modelloaded=True;

Clear[LookUp];
(*LookUp[_:(Symbol|Subscript)]:={"parameter"};*)

(* model type - default="ContinuousTime" *)
modeltype=ModelType/.Append[model,ModelType->"ContinuousTime"];
If[!MemberQ[{"ContinuousTime","DiscreteTime"},modeltype],Msg[SetModel::unktype]];

(* model whenevents - default={} *)
modelwhenevents:=WhenEvents/.Append[model,WhenEvents->{}];

(* model assumptions - default={} *)
$Assumptions=Assumptions/.Append[model,Assumptions->True];

(* period - default=0 (unforced) *)
modelperiod=Period/.Append[model,Period->0];

stylecount=0;

(* pops *)

npops=Max[Select[Flatten[{model,Pop[0]->0}],#[[1,0]]==Pop&][[All,1,1]]];
pcompeqn[pop_,pco_]:=Equation/.If[RuleListQ[Component[pco]/.(Pop[pop]/.model)],Component[pco]/.(Pop[pop]/.model),Pop[pop]/.model];
popnames={};

Do[
	popname[pop]=Name/.Append[Pop[pop]/.model,Name->"Pop"<>ToString[pop]];
	LookUp[popname[pop]]={"pop",pop};
	AppendTo[popnames,popname[pop]];
	
	npcomps[pop]=Max[Select[Flatten[{Pop[pop]/.model,Component[1]->0}],#[[1,0]]==Component&][[All,1,1]]];
	Do[
		stylecount++;
		in=If[RuleListQ[Component[pco]/.(Pop[pop]/.model)],Component[pco]/.(Pop[pop]/.model),Pop[pop]/.model];
		pcomp[pop,pco]=Variable/.in;
		range[pcomp[pop,pco]]=pcomprange[pop,pco]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		type[pcomp[pop,pco]]=pcomptype[pop,pco]=Type/.Append[in,Type->"Extensive"];
		
		color[pcomp[pop,pco]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
		linestyle[pcomp[pop,pco]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[pcomp[pop,pco]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		
		LookUp[pcomp[pop,pco]]={"pcomp",pop,pco};
	,{pco,npcomps[pop]}];
,{pop,npops}];

(* auxs *)

naux=Max[Select[Append[model,Aux[0]->0],#[[1,0]]==Aux&][[All,1,1]]];
auxeqn[au_]:=Equation/.(Aux[au]/.model);
auxnames={};

Do[
	stylecount++;
	in=Aux[au]/.model;

	auxname[au]=Name/.Append[in,Name->"Aux"<>ToString[au]];
	LookUp[auxname[au]]={"aux",au};
	AppendTo[auxnames,auxname[au]];

	aux[au]=Variable/.in;
	range[aux[au]]=auxrange[au]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
	
	color[aux[au]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
	linestyle[aux[au]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
	plotmarker[aux[au]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
	
	LookUp[aux[au]]={"aux",au};
,{au,naux}];

(* guilds *)

stylecount=0;

nguilds=Max[Select[Append[model,Guild[0]->0],#[[1,0]]==Guild&][[All,1,1]]];
gcompeqn[gu_,gco_]:=Equation/.If[RuleListQ[Component[gco]/.(Guild[gu]/.model)],Component[gco]/.(Guild[gu]/.model),Guild[gu]/.model];
guildnames={};

Do[
	guildname[gu]=Name/.Append[Guild[gu]/.model,Name->"Guild"<>ToString[gu]];
	LookUp[guildname[gu]]={"guild",gu};
	AppendTo[guildnames,guildname[gu]];
	
	ngcomps[gu]=Max[Select[Append[Guild[gu]/.model,Component[1]->{}],#[[1,0]]==Component&][[All,1,1]]];
	ntraits[gu]=Max[Select[Append[Guild[gu]/.model,Trait[0]->{}],#[[1,0]]==Trait&][[All,1,1]]];
	
	(*Print[gu," ",ntraits[gu]];*)

	If[nguilds==1&&ngcomps[1]==1&&ntraits[1]==1,
		gradients={Evaluate[Gradient/.Flatten[{opts,Options[SetModel]}]]},
		gradients=Evaluate[Gradients/.Flatten[{opts,Options[SetModel]}]]
	];
	
	Do[
		stylecount++;
		basestyle[gu]=stylecount;
		in=If[RuleListQ[Component[gco]/.(Guild[gu]/.model)],Component[gco]/.(Guild[gu]/.model),Guild[gu]/.model];
		gcomp[gu,gco]=Variable/.in;
		range[Subscript[gcomp[gu,gco],_]]=range[gcomp[gu,gco]]=gcomprange[gu,gco]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		type[gcomp[gu,gco]]=gcomptype[gu,gco]=Type/.Append[in,Type->"Extensive"];
		
		color[Subscript[gcomp[gu,gco],_]]=Color/.Append[in,Color->With[{gradient=ModPart[gradients,stylecount]},ColorData[gradient][#]&]];
		linestyle[Subscript[gcomp[gu,gco],_]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[Subscript[gcomp[gu,gco],_]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];

		LookUp[gcomp[gu,gco]]={"gcomp",gu,gco};
		LookUp[Subscript[gcomp[gu,gco],sp_]]={"gcomp",gu,gco,sp};
	,{gco,ngcomps[gu]}];

	Do[
		stylecount=basestyle[gu];
		in=Trait[tr]/.(Guild[gu]/.model);
		trait[gu,tr]=Variable/.in;
		range[Subscript[trait[gu,tr],_]]=range[trait[gu,tr]]=traitrange[gu,tr]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
		
		color[Subscript[trait[gu,tr],_]]=Color/.Append[in,Color->With[{gradient=ModPart[gradients,stylecount]},ColorData[gradient][#]&]];
		linestyle[Subscript[trait[gu,tr],_]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[Subscript[trait[gu,tr],_]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];

		LookUp[trait[gu,tr]]={"trait",gu,tr};
		LookUp[Subscript[trait[gu,tr],sp_]]={"trait",gu,tr,sp};
	,{tr,ntraits[gu]}];
,{gu,nguilds}];

auxs=Table[aux[au],{au,naux}];
pcomps=Flatten[Table[Table[pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}]];
gcomps=Flatten[Table[Table[gcomp[gu,gco],{gco,ngcomps[gu]}],{gu,nguilds}]];
traits=Flatten[Table[Table[trait[gu,tr],{tr,ntraits[gu]}],{gu,nguilds}]];

Which[
	modeltype=="ContinuousTime",
	DT[var_]:=var'[t];
	TraitDT[var_]:=var'[t];
	modelinvthreshold=0
,
	modeltype=="DiscreteTime",
	DT[var_]:=var[t+1];
	TraitDT[var_]:=var[t+1]-var[t];
	modelinvthreshold=1
];

eqn[var_]:=Module[{luv=LookUp[var]},
	Which[
		luv[[1]]=="aux",auxeqn[luv[[2]]],
		luv[[1]]=="pcomp",pcompeqn[luv[[2]],luv[[3]]],
		luv[[1]]=="gcomp",gcompeqn[luv[[2]],luv[[3]]][luv[[4]]]
	]
];

];


Options[SetModel]={Colors->ColorData[97,"ColorList"],LineStyles->{{}},PlotMarkers->Graphics`PlotMarkers[],Gradient->"Rainbow",Gradients->{"EEGreens","EEReds","EEBlues"}};


MatrixToPopComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[c]->{Variable->var[c],Equation:>Evaluate[(Sum[a[[c,c\[Prime]]]var[c\[Prime]][t],{c\[Prime],ncomps}])]},{c,ncomps}];
	On[Part::partd];
	Return[res]
];


MatrixToGuildComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[c]->{Variable->var[c],Equation:>Evaluate[Sum[a[[c,c\[Prime]]]var[c\[Prime]][t],{c\[Prime],ncomps}]]/.{var[c_]->Subscript[var[c],#]}},{c,ncomps}];
	On[Part::partd];
	Return[res/.{(Equation:>eqn_)->(Equation:>(eqn&))}]
];


ModelInfo:=(

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* model type *)

Print["ModelType=",modeltype];

(* aux vars *)

Print["NumAuxs=",naux];
Do[
	Print["  AuxVar[",au,"]=",aux[au]];
	Print["  AuxEqn[",au,"]=",auxeqn[au]];
	Print["  AuxRange[",au,"]=",auxrange[au]];
,{au,naux}];

(* pops *)

Print["NumPops=",npops];
Do[
	Print["  NumComponents[",pop,"]=",npcomps[pop]];
	Do[
		Print["    PopVar[",pop,",",pco,"]=",pcomp[pop,pco]];
		Print["    PopEqn[",pop,",",pco,"]=",pcompeqn[pop,pco]];
		Print["    PopRange[",pop,",",pco,"]=",pcomprange[pop,pco]];
		Print["    PopType[",pop,",",pco,"]=",pcomptype[pop,pco]];
	,{pco,npcomps[pop]}];
,{pop,npops}];

(* guilds *)

Print["NumGuilds=",nguilds];
Do[
	Print["  GuildName[",gu,"]=",guildname[gu]];
	Print["  NumGuildComponents[",gu,"]=",ngcomps[gu]];
	Do[
		Print["    GuildComponentVar[",gu,",",gco,"]=",gcomp[gu,gco]];
		Print["    GuildComponentEqn[",gu,",",gco,"]=",gcompeqn[gu,gco]];
		Print["    GuildComponentRange[",gu,",",gco,"]=",gcomprange[gu,gco]];
		Print["    GuildComponentType[",gu,",",gco,"]=",gcomptype[gu,gco]];
	,{gco,ngcomps[gu]}];
	Print["  NumTraits[",gu,"]=",ntraits[gu]];
	Do[
		Print["    TraitVar[",gu,",",tr,"]=",trait[gu,tr]];
		Print["    TraitRange[",gu,",",tr,"]=",traitrange[gu,tr]];
	,{tr,ntraits[gu]}];
,{gu,nguilds}];

);


FromUnks:=Flatten[{
	Table[Table[unk[gcomp[gu,gco],sp_]->Subscript[gcomp[gu,gco],sp],{gco,ngcomps[gu]}],{gu,nguilds}],
	Table[Table[unk[pcomp[pop,pco]]->pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}],
	Table[unk[aux[au]]->aux[au],{au,naux}],
	Table[Table[unk[trait[gu,tr],sp_]->Subscript[trait[gu,tr],sp],{tr,ntraits[gu]}],{gu,nguilds}]
}]


AllTraits:=Flatten[
	Table[Table[Table[Subscript[trait[gu,tr],sp],{tr,ntraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,nguilds}]];


AllVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp[gu,gco],sp],{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}],
	Table[Table[pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au],{au,naux}]
]];


BlankTraits:=Flatten[
	Table[Table[Table[Subscript[trait[gu,tr],sp]->Subscript[trait[gu,tr],sp],{tr,ntraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,nguilds}]];


BlankVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp[gu,gco],sp]->Subscript[gcomp[gu,gco],sp],{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}],
	Table[Table[pcomp[pop,pco]->pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au]->aux[au],{au,naux}]
]];


ExpandNspInTraits[traits_]:=traits/.(Nsp[gu_]->nsp_):>
Sequence@@Flatten[Table[Table[Subscript[trait[gu,tr],sp]->Subscript[trait[gu,tr],sp],{tr,ntraits[gu]}],{sp,nsp}]];


ExpandNspInPops[pops_]:=pops/.(Nsp[gu_]->nsp_):>
Sequence@@Flatten[Table[Table[Subscript[gcomp[gu,pco],sp]->Subscript[gcomp[gu,pco],sp],{pco,ngcomps[gu]}],{sp,nsp}]];


SetNsp[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{}]:=Module[{tmp,tnsp,pnsp},
(*Print["In SetNsp, traits=",traits," pops=",pops];*)

	Do[
		tmp=Table[Max[Select[Select[pops,#[[1,0]]==Subscript&],#[[1,1]]==gcomp[gu,gco]&][[All,1,2]]],{gco,ngcomps[gu]}];
		If[Length[Union[tmp]]==1,
			pnsp[gu]=tmp[[1]],
			Msg[SetNsp::badcomm,gu,tmp];
			Abort[]
		];
		If[pnsp[gu]==-\[Infinity],pnsp[gu]=0];
	,{gu,nguilds}];
	
	Do[
		If[ntraits[gu]!=0,
			tmp=Table[Max[Select[Select[traits,#[[1,0]]==Subscript&],#[[1,1]]==trait[gu,tr]&][[All,1,2]]],{tr,ntraits[gu]}];
			If[Length[Union[tmp]]==1,
				tnsp[gu]=tmp[[1]],
				Msg[SetNsp::badtr,gu,tmp];
				Abort[]
			];
			If[tnsp[gu]==-\[Infinity],tnsp[gu]=0];
		,
			tnsp[gu]=pnsp[gu]
		]
	,{gu,nguilds}];
	
(*Print["SetNsp: tnsp=",Table[tnsp[gu],{gu,nguilds}]," pnsp=",Table[pnsp[gu],{gu,nguilds}]];*)

	If[Table[tnsp[gu],{gu,nguilds}]==Table[pnsp[gu],{gu,nguilds}]||pops=={}||traits=={},
		Do[
			Nsp[gu]=If[traits!={},tnsp[gu],pnsp[gu]]
		,{gu,nguilds}]
	,
		Msg[SetNsp::badnsp,Table[tnsp[gu],{gu,nguilds}],Table[pnsp[gu],{gu,nguilds}]];
		Abort[]
	];
]/;(nguilds!=0);


AddPopts:=DeleteDuplicates[Flatten[Join[
	Table[Table[Table[
		Subscript[gcomp[gu,gco],sp]->Subscript[gcomp[gu,gco],sp][t]
	,{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gco,ngcomps[gu]}],{gu,nguilds}],
	Table[Table[
		pcomp[pop,pco]->pcomp[pop,pco][t]
	,{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au]->aux[au][t],{au,naux}]
]]];


AddTraitts:=Flatten[Table[Table[Table[
	Subscript[trait[gu,tr],sp]->Subscript[trait[gu,tr],sp][t]
,{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{tr,ntraits[gu]}],{gu,nguilds}]];


RemovePopts:=DeleteDuplicates[Flatten[Join[
	Table[Table[Table[
		Subscript[gcomp[gu,gco],sp][t]->Subscript[gcomp[gu,gco],sp]
	,{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gco,ngcomps[gu]}],{gu,nguilds}],
	Table[Table[
		pcomp[pop,pco][t]->pcomp[pop,pco]
	,{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au][t]->aux[au],{au,naux}]
]]];


RemoveTraitts:=Flatten[Table[Table[Table[
	Subscript[trait[gu,tr],sp][t]->Subscript[trait[gu,tr],sp]
,{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{tr,ntraits[gu]}],{gu,nguilds}]];


ExtractTraits[in_List]:=Module[{res},
	Off[Part::partd];
	res=Join[
		Select[in,MemberQ[traits,#[[1,1]]]&],
		Select[in,(#[[1,0]]==Nsp)&]
	];
	On[Part::partd];
	Return[res]
];


ExtractAuxs[in_List]:=Module[{res},
	Off[Part::partd];
	res=Select[in,MemberQ[auxs,#[[1]]]&];
	On[Part::partd];
	Return[res]
];


ExtractPops[in_List]:=Module[{res},
	Off[Part::partd];
	res=Select[in,MemberQ[pcomps,#[[1]]]&];
	On[Part::partd];
	Return[res]
];


ExtractGuilds[in_List]:=Module[{res},
	Off[Part::partd];
	res=Join[
		Select[in,MemberQ[gcomps,#[[1,1]]]&],
		Select[in,(#[[1,0]]==Nsp)&]
	];
	On[Part::partd];
	Return[res]
];


ExtractVariables[in_List]:=Join[ExtractAuxs[in],ExtractPops[in],ExtractGuilds[in]];


(* make Listable *)
ExtractTraits[in_?RuleListListQ]:=ExtractTraits/@in;
ExtractAuxs[in_?RuleListListQ]:=ExtractAuxs/@in;
ExtractPops[in_?RuleListListQ]:=ExtractPops/@in;
ExtractGuilds[in_?RuleListListQ]:=ExtractGuilds/@in;
ExtractVariables[in_?RuleListListQ]:=ExtractVariables/@in;


TraitsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="trait"||#[[1,0]]===Nsp)&]


NotInvaderTraitsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&((LookUp[#[[1]]][[1]]==="trait"&&LookUp[#[[1]]][[4]]=!=0)||#[[1,0]]===Nsp)&]


VariablesQ[list_]:=list==="FindEcoAttractor"||VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(MemberQ[{"pcomp","gcomp","aux"},First@LookUp[#[[1]]]]||#[[1,0]]===Nsp)&]


(*TraitsAndVariablesQ[list_]:=VectorQ[list,(#\[LeftDoubleBracket]0\[RightDoubleBracket]\[Equal]Rule||#\[LeftDoubleBracket]0\[RightDoubleBracket]\[Equal]RuleDelayed)&&(MemberQ[{"pcomp","gcomp","aux","trait"},First@LookUp[#\[LeftDoubleBracket]1\[RightDoubleBracket]]]||#\[LeftDoubleBracket]1,0\[RightDoubleBracket]\[Equal]Nsp)&]*)


TraitsAndVariablesQ[list_]:=
If[ListQ[list]&&ExpandNspInTraits[ExtractTraits[list]]=!=list&&ExpandNspInPops[ExtractVariables[list]]=!=list,True,False,False]


ListOfVariablesQ[x_]:=If[x==={},False,VectorQ[x,VariablesQ[#]&]];


InvaderQ[x_]:=If[
	MemberQ[Join[pcomps,popnames],x]||
	(x[[0]]===Rule&&Length[LookUp[x[[1]]]]>=4&&LookUp[x[[1]]][[{1,4}]]==={"trait",0})||
	VectorQ[x,#[[0]]===Rule&&Length[LookUp[#[[1]]]]>=4&&LookUp[#[[1]]][[{1,4}]]==={"trait",0}&],True,False]


GsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(MemberQ[{G,V},#[[1,0]]])&]


DefaultICs:=Flatten[{
	Table[Table[Table[Subscript[gcomp[gu,gco],sp]->Min[(Min[gcomprange[gu,gco]]+Max[gcomprange[gu,gco]])/2,Min[gcomprange[gu,gco]]+1],{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}],
	Table[Table[pcomp[pop,pco]->Min[(Min[pcomprange[pop,pco]]+Max[pcomprange[pop,pco]])/2,Min[pcomprange[pop,pco]]+1],{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au]->Min[(Min[auxrange[au]]+Max[auxrange[au]])/2,Min[auxrange[au]]+1],{au,naux}]
}];


DeleteInvaders[list_List]:=DeleteCases[list,Subscript[_,0]->_];


PlotDynamics[sol_,plotvarsin_List,opts___?OptionQ]:=

Module[{
(* options *)
logged,plotstyle,plotmarkers,axeslabel,plotopts,(*plotrange,*)
(* other variables *)
lookup,vars,plotvars,yaxislabel,type,xinit,xfinal},
	
Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[PlotDynamics]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotDynamics]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[PlotDynamics]}]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotDynamics]}]];

vars=sol[[All,1]];

(* figure out number of species in guilds *)

Do[
	Nsp[gu]=Max[
		Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==gcomp[gu,gco])&][[All,2]]],{gco,ngcomps[gu]}],
		Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==trait[gu,tr])&][[All,2]]],{tr,ntraits[gu]}]
	];
	If[Nsp[gu]==-\[Infinity],Nsp[gu]=0];
	If[Global`debug,Print["Nsp[",gu,"]=",Nsp[gu]]];
,{gu,nguilds}];

(*Print["plotvarsin=",plotvarsin];*)

If[plotvarsin==={All},
	plotvars=vars,
	plotvars={};
	Do[
		lookup=LookUp[var];
		If[MemberQ[{"gcomp","trait"},lookup[[1]]]&&Length[lookup]==3,
			Do[AppendTo[plotvars,Subscript[var,sp]],{sp,Nsp[lookup[[2]]]}],
			AppendTo[plotvars,var]
		];
	,{var,plotvarsin}]
];

(*Print["plotvars=",plotvars];*)


If[axeslabel===Automatic,
	yaxislabel={};
	Do[
		lookup=LookUp[var];
		Which[
			lookup[[1]]=="gcomp",AppendTo[yaxislabel,Subscript[gcomp[lookup[[2]],lookup[[3]]],"i"]],
			lookup[[1]]=="trait",AppendTo[yaxislabel,Subscript[trait[lookup[[2]],lookup[[3]]],"i"]],
			Else,AppendTo[yaxislabel,var]
		]
	,{var,plotvars}];
	yaxislabel=Sort[Union[yaxislabel]];
	axeslabel={t,Row[yaxislabel,","]}
];

(*Print["axeslabel=",axeslabel];*)

type=sol[[1,2,0]]; (* either InterpolatingFunction, List or TemporalData *)

If[plotstyle==={},
	Do[
		lookup=LookUp[var];
		Which[
			lookup[[1]]=="gcomp"||lookup[[1]]=="trait",
			AppendTo[plotstyle,{color[var][SpFrac[lookup[[4]],Nsp[lookup[[2]]]]],linestyle[var]}]
		,
			lookup[[1]]=="pcomp"||lookup[[1]]=="aux",
			AppendTo[plotstyle,{color[var],linestyle[var]}]
		,
			Else,
			AppendTo[plotstyle,{}]
		]
	,{var,plotvars}]
];

(*Print["plotstyle=",plotstyle];*)

(*plotrange=(IntervalUnion[Sequence@@Table[range[var],{var,plotvars}]]/.\[Infinity]\[Rule]All)\[LeftDoubleBracket]1\[RightDoubleBracket];*)

If[type==InterpolatingFunction,
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[Plot]];
	(*Print["plotopts=",plotopts];
	Print["plotvars=",plotvars];*)
	{xinit,xfinal}=sol[[1,2,1,1]]; (* extract domain *)
	If[logged==True,
		Return[LogPlot[Evaluate[Table[var[x],{var,plotvars}]/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->All]]
	,
		Return[Plot[Evaluate[Table[var[x],{var,plotvars}]/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],(*AxesOrigin\[Rule]{xinit,0},*)PlotRange->All]]
	];
];

If[type==List||type==TemporalData,
	If[plotmarkers==={}&&(Joined/.{opts})===False,
		Do[
			lookup=LookUp[var];
			Which[
				lookup[[1]]=="gcomp"||lookup[[1]]=="trait",
				AppendTo[plotmarkers,plotmarker[var]]
			,
				lookup[[1]]=="pcomp"||lookup[[1]]=="aux",
				AppendTo[plotmarkers,plotmarker[var]]
			,
				Else,
				AppendTo[plotmarkers,{}]
			]
		,{var,vars}]
	];

	If[plotmarkers=={},plotmarkers=None];
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,PlotMarkers->plotmarkers,Options[PlotDynamics]}],Options[ListPlot]];
	xinit=InitialTime[sol];
	If[logged==True,
		Return[ListLogPlot[plotvars/.sol,Evaluate[Sequence@@plotopts],PlotRange->All]]
	,
		Return[ListPlot[plotvars/.sol,Evaluate[Sequence@@plotopts],AxesOrigin->{xinit,0},PlotRange->All]]
	];
];

	Return[]
]];

Options[PlotDynamics]={Logged->False,Joined->True,PlotStyle->{},PlotMarkers->{},AxesLabel->Automatic};


PlotDynamics[sol_,plotvarsin_Symbol:All,opts___?OptionQ]:=PlotDynamics[sol,{plotvarsin},opts];


EcoEqns[traitsin:(_?TraitsQ):{},opts___?OptionQ]:=Module[{
func=FuncStyle["EcoSim"],
(* options *)
verbose,verboseall,logged,fixed,fixedvars,timescale,
(* other variables *)
traits,nonfixedvars,eqns},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEqns]}]];
If[verboseall,verbose=True];

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEqns]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoEqns]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEqns]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];


(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
SetNsp[traits];

fixedvars=fixed[[All,1]];
nonfixedvars=orderedComplement[AllVariables,fixedvars];
If[Global`debug,Print["nonfixedvars=",nonfixedvars]];

Return[DeleteDuplicates[Table[DT[var]==timescale*eqn[var],{var,nonfixedvars}]/.traits]]

]];


Options[EcoEqns]={Fixed->{},TimeScale->1};


EcoSim[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{},tmax_?NumericQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoSim"],
(* options *)
verbose,verboseall,method,ndsolveopts,logged,interpolationpoints,interpolationorder,fixed,fixedvars,fixed2,whenevents,timescale,outputtmin,
output,tmin,
(* other variables *)
nonfixedvars,luv,gu,gco,sp,pop,pco,au,eqns,unks,ics,tic,exprule,logrule,sol,res,fixedres},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoSim]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoSim]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[EcoSim]}]];
interpolationpoints=Evaluate[InterpolationPoints/.Flatten[{opts,Options[EcoSim]}]];
interpolationorder=Evaluate[InterpolationOrder/.Flatten[{opts,Options[EcoSim]}]];
whenevents=Evaluate[WhenEvents/.Flatten[{opts,Options[EcoSim]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoSim]}]];
If[output=="FinalSlice",outputtmin=tmax];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoSim]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoSim]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
SetNsp[traits,Join[pops,fixed]];
(*Print["Nsp=",Table[Nsp[gu],{gu,nguilds}]];*)

(* nonfixedvars are those given ICs *)
nonfixedvars=pops[[All,1]];
If[Global`debug,Print[func,": nonfixedvars=",nonfixedvars]];


(* set up exprule and logrule for converting to/from logs *)

exprule=logrule={};
Do[
	If[logged===True&&type[var]==="Extensive",
		AppendTo[exprule,var[t]->E^log[var][t]];
		AppendTo[logrule,var->log[var][t]];
	];
,{var,nonfixedvars}];

(*Print["logrule=",logrule];
Print["exprule=",exprule];*)

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)

Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],pcomp[pop,pco]],
		AppendTo[fixed,pcomp[pop,pco]->0];
		AppendTo[fixedvars,pcomp[pop,pco]]
	];
,{pop,npops},{pco,npcomps[pop]}];

Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],aux[au]],
		AppendTo[fixed,aux[au]->0];
		AppendTo[fixedvars,aux[au]]
	];
,{au,naux}];

(*Print["fixedvars=",fixedvars];*)

(* add [t] to constant fixed variables *)

fixed2=ReplaceAll[fixed,(var:(_Subscript|_Symbol)->val_?NumericQ)->(var[t]->val)];


(* find time for ICs *)

tic=If[modelwhenevents=={},tmin,tmin-10^-15]; (* hack to ensure that events are triggered at t=tmin *)

(* set eqns, unks and ics *)

eqns=Table[
	If[logged===True&&type[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			DT[log[var]]-log[var][t]==RealSimplify[timescale*Log[eqn[var]/var[t]/.exprule]],
			modeltype=="ContinuousTime",
			DT[log[var]]==timescale*eqn[var]/var[t]/.exprule
		]
	,
		DT[var]==timescale*eqn[var]/.exprule
	]
,{var,nonfixedvars}];

unks=Table[If[logged===True&&type[var]==="Extensive",log[var],var],{var,nonfixedvars}];
ics=Table[If[logged===True&&type[var]==="Extensive",log[var][tic]==Log[var/.pops],var[tic]==(var/.pops)],{var,nonfixedvars}];

If[Global`debug,Print[func,": eqns=",eqns]];
If[Global`debug,Print[func,": unks=",unks]];
If[Global`debug,Print[func,": ics=",ics]];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	If[verbose,
		With[{ndsolveeqns=Join[eqns,ics,modelwhenevents,whenevents]/.Dispatch[traits]/.fixed2,unks=unks,outputtmin=outputtmin,options=Sequence@@ndsolveopts},
			PrintCall[Global`sol=NDSolve[ndsolveeqns,unks,{t,outputtmin,tmax},options][[1]]]
	]];
	sol=NDSolve[Join[eqns,ics,modelwhenevents,whenevents]/.Dispatch[traits]/.fixed2,unks,{t,outputtmin,tmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	If[verbose,
		With[{rteqns=Join[eqns,ics]/.Dispatch[traits]/.fixed2,unks=unks},
			PrintCall[Global`res=RecurrenceTable[rteqns,unks,{t,0,tmax},Method->{Compiled->False}]]
	]];
	res=Transpose[RecurrenceTable[Join[eqns,ics]/.Dispatch[traits]/.fixed2,unks,{t,0,tmax},Method->{Compiled->False}]];
	sol=Table[unks[[i]]->TD[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
];

If[Global`debug,Print[func,": sol=",sol]];


(* transform logged output back to natural scale *)

If[logged===True, (* need to write for DiscreteTime *)	
	res=Table[If[type[var]==="Extensive",
		var->Interpolation[Table[{t,E^log[var][t]/.sol},{t,tmin,tmax,(tmax-tmin)/interpolationpoints}],InterpolationOrder->interpolationorder],
		var->(var/.sol)]
	,{var,nonfixedvars}]
,
	res=sol
];


If[output=="FinalSlice",Return[VarSort[Join[FinalSlice[res],fixed],AllVariables]]];

(* add Fixed values back to results - Interpolate constants *)

If[fixed!={},
	fixedres=ReplaceAll[fixed,(var:(_Subscript|_Symbol)->val_?NumericQ)->(var->Interpolation[{{outputtmin,val},{tmax,val}},InterpolationOrder->0])],
	fixedres={}
];
Return[VarSort[Join[res,fixedres],AllVariables]];

]];


Options[EcoSim]={Verbose->False,VerboseAll->False,
Method->Automatic,NDSolveOpts->{},Logged->False,InterpolationOrder->7,InterpolationPoints->1000,Fixed->{},WhenEvents->{},
EqStop->False,EqThreshold->10^-8,TimeScale->1,OutputTMin->0,Output->"Dynamics",TMin->0};


EcoSim[eesol_?TraitsAndVariablesQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoSim[ExtractTraits[eesol],ExtractVariables[eesol],tmax,opts];


EcoEq[traitsin:(_?TraitsQ):{},pops:(_?VariablesQ):{},vars:(_List):All,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEq"],
(* options *)
method,solveopts,nsolveopts,findrootopts,boundarydetection,time,fixed,chop,qss,verbose,verboseall,
(* other variables *)
nonvars,nonfixedvars,traits,fixedvars,removets,eqns,unks,newunk,sol,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoEq]}]];
If[method===Automatic,If[pops!={},method="FindRoot",method="Solve"]];
If[Global`debug,Print[func,": method=",method]];

solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EcoEq]}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EcoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EcoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEq]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEq]}]];
qss=Evaluate[QSS/.Flatten[{opts,Options[EcoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEq]}]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* EcoEq doesn't work on Periodic models *)

If[modelperiod=!=0&&time===t&&method=="FindRoot",Msg[EcoEq::noneq];Return[]];

(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
SetNsp[traits];

If[vars===All,
	nonvars={},
	nonvars=orderedComplement[AllVariables,vars]
];
(*Print["nonvars=",nonvars];*)

If[qss==False,
	fixed=Join[fixed,Replace[nonvars,x_->(x->0),1]],
	fixed=Join[fixed,Replace[nonvars,x_->(x->x),1]]
];
(*Print["fixed=",fixed];*)

fixedvars=fixed[[All,1]];
nonfixedvars=orderedComplement[AllVariables,fixedvars];
(*Print["nonfixedvars=",nonfixedvars];*)

(* set eqns, unks and ics *)
eqns=EcoEqns[traits,Fixed->fixed]/.Eq/.RemovePopts/.t->time/.fixed/.traits;
(*Print["eqns=",eqns];*)

Which[
	MemberQ[{"Solve","NSolve"},method],
	unks=nonfixedvars
,
	method=="FindRoot",
	unks=Table[
		newunk={var,(var/.Append[pops,var->0])};
		If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
		newunk,{var,nonfixedvars}]
];

If[Global`debug,Print[func,": eqns=",eqns]];
If[Global`debug,Print[func,": unks=",unks]];

(* solve it *)

Which[
	method=="Solve",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@solveopts},PrintCall[Global`sol=Solve[eqns,unks,options]]]];
	sol=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@nsolveopts},PrintCall[Global`sol=NSolve[eqns,unks,options]]]];
	sol=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@findrootopts},PrintCall[Global`sol=FindRoot[eqns,unks,options]]]];
	sol=FindRoot[eqns,unks,Evaluate[Sequence@@findrootopts]],
	Else,
	Msg[EcoEq::badmtd];Return[$Failed];
];

If[Global`debug,Print[func,": sol=",sol]];

Which[
	MemberQ[{"Solve","NSolve"},method],
	res=Join[fixed,#]& /@ sol,
	method=="FindRoot",
	res=Join[fixed,sol]
];

If[chop,
	Return[VarSort[EqSort[Chop[res]],AllVariables]],
	Return[VarSort[EqSort[res],AllVariables]]
];

]];


SolveEcoEq[args___]:=EcoEq[args,Method->"Solve"];
NSolveEcoEq[args___]:=EcoEq[args,Method->"NSolve"];
FindEcoEq[args___]:=EcoEq[args,Method->"FindRoot"];


Options[EcoEq]={Method->Automatic,SolveOpts->{},NSolveOpts->{(*Reals,Method\[Rule]"EndomorphismMatrix"*)},FindRootOpts->{},
Fixed->{},Chop->True,QSS->False,Time->t,Verbose->False};


Options[SolveEcoEq]={SolveOpts->{},Fixed->{},Chop->True,QSS->False,Time->t,Verbose->False,VerboseAll->True};


FindEcoCycle[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{},opts:OptionsPattern[]]:=

Module[{
func=FuncStyle["FindEcoCycle"],
(* options *)
verbose,verboseall,period,method,monitor,printtrace,
findrootopts,ecosimopts,maxiterations,accuracygoal,precisiongoal,logged,fixed,
triggervar,warmup1,warmup2,warmup3,wheneventopts,
(* other variables *)
nonfixedvars,fixedvars,extrema,triggerpos,triggerval,max,ics2,ics3,ics4,diff,tmax,eq,
ic,nb,thing,eqns,unks,logd,vars,unksics,ics,res,sol,per},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

$findecocyclesteps=0;

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verboseall,verbose=True];

monitor=OptionValue[Monitor];
printtrace=OptionValue[PrintTrace];
period=OptionValue[Period];
method=OptionValue[Method];
If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0,method="EcoSim",method="FixedPoint"]];
If[Global`debug,Print[func,": method=",method]];
findrootopts=OptionValue[FindRootOpts];
ecosimopts=OptionValue[EcoSimOpts];
maxiterations=OptionValue[MaxIterations];
accuracygoal=OptionValue[AccuracyGoal];
triggervar=OptionValue[TriggerVariable];
warmup1=OptionValue[WarmUp];
warmup2=OptionValue[WarmUp2];
warmup3=OptionValue[WarmUp3];
tmax=OptionValue[TMax];
wheneventopts=OptionValue[WhenEventOpts];
logged=OptionValue[Logged];
fixed=OptionValue[Fixed];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];


(* figure out number of species in guilds *)
SetNsp[traits];

(* set up thing & unks *)
nonfixedvars=pops[[All,1]];

(* build various lists of vars *)
unks=Table[eq[var],{var,nonfixedvars}];
vars=Table[If[logged&&type[var]==="Extensive",Log[var],var],{var,nonfixedvars}];
ics=vars/.pops;
unksics=Transpose[{unks,ics}];
logd=Table[If[logged&&type[var]==="Extensive",True,False],{var,nonfixedvars}];

(*
Print["unks=",unks];
Print["unksics=",unksics];
Print["ics=",ics];
Print["logd=",logd];
Print["vars=",vars];
*)

(* "EcoSim" method for unforced ContinuousTime models *)
If[method==="EcoSim",

	If[!(modeltype=="ContinuousTime"&&modelperiod==0),Msg[FindEcoCycle::noecosim];Return[$Failed]];
	If[triggervar===Automatic,triggervar=nonfixedvars[[1]]];
	triggerpos=Position[nonfixedvars,triggervar][[1,1]];

	(* warmup #1 to get on limit cycle *)
	ics2=If[warmup1>0,
		FinalSlice[EcoSim[traits,pops,warmup1,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]],
		pops];

	(* warmup #2 to find maxima *)
	extrema={};
	EcoSim[traits,ics2,warmup2,WhenEvents->{
			WhenEvent[event,AppendTo[extrema,Table[var[t],{var,nonfixedvars}]],Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar'[t]==0)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

	If[extrema=={},Msg[FindEcoCycle::nomaxima];Return[$Failed]];

	max=Last@Sort[extrema,#1[[triggerpos]]<#2[[triggerpos]]&];
	ics3=Table[nonfixedvars[[i]]->max[[i]],{i,Length[nonfixedvars]}];

	(* warmup #3 to move a wee bit beyond the maximum *)
	ics4=FinalSlice[EcoSim[traits,ics3,warmup3,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]];

	If[verbose,Print[func,": ics4=",ics4]];

	Do[
		triggerval=triggervar/.ics4;
		
		sol=EcoSim[traits,ics4,tmax,WhenEvents->{
			WhenEvent[event,"StopIntegration",Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar[t]<triggerval)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

		diff=Sum[Abs[(var/.FinalSlice[sol])-(var/.ics4)],{var,nonfixedvars}];
		If[diff<10^-accuracygoal,Break[]];

		ics4=FinalSlice[sol];
	,{maxiterations}];

	If[diff>10^-accuracygoal,Msg[FindEcoCycle::cvmit,maxiterations]];
		
	Return[sol];
];

(* "FixedPoint" or "FindRoot" method *)

If[(modeltype=="ContinuousTime"&&modelperiod==0),
	AppendTo[unks,per];
	AppendTo[unksics,{per,period}];
	AppendTo[ics,period];
,
	If[period===Automatic,per=modelperiod,per=period];
];

(*
Print["unks=",unks];
Print["unksics=",unksics];
Print["ics=",ics];
*)

If[monitor,
	nb=CreateWindow[DialogNotebook[{
	TextCell["evaluation: "],
	Dynamic[$findecocyclesteps],
	TextCell["vars:"],
	Dynamic[Table[eq[var],{var,nonfixedvars}]]
	},
	WindowTitle->"FindEcoCycle Progress..."]];
];


(* function to advance model *)

thing[ps_?NumericListQ]:=Module[{popz,rez},
	$findecocyclesteps++;
	If[(modeltype=="ContinuousTime"&&modelperiod==0),tmax=ps[[-1]],tmax=per];
	popz=Table[If[logd[[i]],nonfixedvars[[i]]->E^ps[[i]],nonfixedvars[[i]]->ps[[i]]],{i,Length[nonfixedvars]}];
	sol=EcoSim[traits,popz,tmax,Fixed->fixed,Evaluate[Sequence@@ecosimopts],Logged->logged];
	rez=vars/.FinalSlice[sol];
	If[(modeltype=="ContinuousTime"&&modelperiod==0),AppendTo[rez,ps[[-1]]]];
	If[printtrace,Print[$findecocyclesteps,": ",FinalSlice[sol]]];
	Return[rez];
];

Which[
	method=="FindRoot",
	If[Global`debug,Print[func,": Method FindRoot"]];
	res=FindRoot[thing[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]]
,
	method=="FixedPoint",
	If[Global`debug,Print[func,": Method FixedPoint"]];
	res=FixedPoint[thing[#]&,ics,maxiterations,SameTest->(Max[Abs[#1-#2]]<10^-accuracygoal&)];
	If[$findecocyclesteps==maxiterations,Msg[FindEcoCycle::cvmit,maxiterations];Return[$Failed]]
,
	Else,
	Msg[FindEcoCycle::badmtd];Return[$Failed]
];

If[modeltype=="DiscreteTime",(* drop last point *)
	sol=ReplaceAll[sol,
		{(var_->td_List):>(var->Drop[td,-1]),(var_->td_TemporalData)->(var->TimeSeriesWindow[td,{0,per-1}])}]
];


(* return answer *)

If[monitor,NotebookClose[nb]];

Return[Sort[sol]];

]];


Options[FindEcoCycle]={
Method->Automatic,Fixed->{},FindRootOpts->{},EcoSimOpts->{},MaxIterations->100,AccuracyGoal->6,Logged->False,
WarmUp->1000,WarmUp2->100,WarmUp3->0.1,TMax->1000,TriggerVariable->Automatic,
WhenEventOpts->{(*"DetectionMethod"\[Rule]"Interpolation","LocationMethod"\[Rule]{"Brent",MaxIterations\[Rule]1000}*)},
Period->Automatic,
Monitor->False,PrintTrace->False,
Verbose->False,VerboseAll->False
};


FindEcoCycle[traitsandvariables_?TraitsAndVariablesQ,opts:OptionsPattern[]]:=
FindEcoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],opts];


SelectValid[sol:(_?RuleListListQ):{}]:=Module[{res},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

res={};
Do[
	If[CompoundAnd[Flatten@Table[
		Which[
			Head[el[[2]]]===TemporalData,
			Map[IntervalMemberQ[range[el[[1]]],#]&,Normal[el[[2]]][[All,2]]],
			Else,
			IntervalMemberQ[range[el[[1]]],el[[2]]]
		]
	,{el,eq}]],AppendTo[res,eq]]
,{eq,sol}];

Return[res]

];


(* make listable across pops *)
EcoJacobian[traits:(_?TraitsQ):{},pops_?ListOfVariablesQ,opts___?OptionQ]:=(EcoJacobian[traits,#,opts]&/@pops);


EcoJacobian[traitsin:(_?TraitsQ):{},pops:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoJacobian"],
(* options *)
time,fixed,verbose,
(* other variables *)
traits,fixedvars,nonfixedvars,eqns,unks,jmat},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoJacobian]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoJacobian]}]];
verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoJacobian]}]];

(* figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
SetNsp[traits];

fixedvars=fixed[[All,1]];
nonfixedvars=orderedComplement[AllVariables,fixedvars];

eqns=EcoEqns[BlankTraits,opts]/.RHS/.RemovePopts/.t->time;
unks=nonfixedvars;

If[verbose,
	Print[func,": eqns="];
	Print[eqns];
	Print[func,": unks="];
	Print[unks];
];

(* set up jacobian *)
jmat=D[eqns/.traits,{unks}];
If[verbose,Print[func,": jmat=",jmat]];

Which[
	(* DiscreteTime cycle *)
	pops!={}&&(pops[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t,
	Return[TD[Table[{t\[Prime],jmat/.AddPopts/.t->t\[Prime]},{t\[Prime],pops[[1,2]]["Times"]}]/.pops]];
,
	(* ContinuousTime cycle *)
	pops!={}&&(pops[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinuousTime"&&modelperiod=!=0))&&time===t,
	Return[jmat/.AddPopts/.pops];
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	If[time===t,
		Return[jmat/.pops],
		Return[jmat/.Slice[pops,time]]
	];
];

]];


EcoJacobian[traitsandpops_List,opts___?OptionQ]:=
EcoJacobian[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoJacobian]={Verbose->False,VerboseAll->False,Time->t,Fixed->{},Verbose->False,VerboseAll->False};


(* make listable across pops *)
EcoEigenvalues[traits:(_?TraitsQ):{},pops_?ListOfVariablesQ,opts___?OptionQ]:=(EcoEigenvalues[traits,#,opts]&/@pops);


EcoEigenvalues[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{},opts___?OptionQ]:=
Module[{
func=FuncStyle["EcoEigenvalues"],
(* options *)
verbose,chop,time,ndsolveopts,multipliers,j,
(* other variables *)
dim,per,xsol,res},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEigenvalues]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEigenvalues]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEigenvalues]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEigenvalues]}]];
multipliers=Evaluate[Multipliers/.Flatten[{opts,Options[EcoEigenvalues]}]];

j=EcoJacobian[traits,pops,Time->time];
If[verbose,Print[func,": Jacobian=",j]];

Which[
	(* DiscreteTime cycle *)
	pops!={}&&((pops[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t),
	res=Eigenvalues[listMultiplier[Table[j[t\[Prime]],{t\[Prime],j["Times"]}]]]
,
	(* ContinousTime cycle *)
	pops!={}&&((pops[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinousTime"&&modelperiod=!=0))&&time===t),
	dim=Length[j];
	per=FinalTime[pops];
	xsol=NDSolve[{x'[t]==j.x[t],x[0]==IdentityMatrix[dim]},x,{t,0,per},Sequence@@ndsolveopts][[1]];
	If[Global`debug,Print[func,": x[per]/.xsol=",x[per]/.xsol]];
	If[multipliers,
		res=Eigenvalues[x[per]/.xsol],
		res=Log[Chop[Eigenvalues[x[per]/.xsol]]]/per
	]
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	res=Eigenvalues[j/.t->time]
];

If[chop,Return[Chop[res]],Return[res]];

];


EcoEigenvalues[traitsandpops_?TraitsAndVariablesQ,opts___?OptionQ]:=EcoEigenvalues[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoEigenvalues]={Verbose->False,Chop->True,Time->t,NDSolveOpts->{},Multipliers->False};


(* make listable across pops *)
EcoStableQ[traits:(_?TraitsQ):{},pops_?ListOfVariablesQ,opts___?OptionQ]:=(EcoStableQ[traits,#,opts]&/@pops);


EcoStableQ[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{func=FuncStyle["EcoStableQ"],
method,verbose,verboseall,simplify,time,ecoeigenvaluesopts,assumptions,tolerance,
j,evs,res},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoStableQ]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoStableQ]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoStableQ]}]];
simplify=Evaluate[Simplify/.Flatten[{opts,Options[EcoStableQ]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoStableQ]}]];
ecoeigenvaluesopts=Evaluate[EcoEigenvaluesOpts/.Flatten[{opts,Options[EcoStableQ]}]];
assumptions=Evaluate[Assumptions/.Flatten[{opts,Options[EcoStableQ]}]];
tolerance=Evaluate[Tolerance/.Flatten[{opts,Options[EcoStableQ]}]];

If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0&&IFFQ[pops]==False&&Length[pops]<4,
		method="RouthHurwitz",
		method="Eigenvalues"
	];
	If[verbose,Print[func,": method=",method]];
];

Which[
	method=="RouthHurwitz",
	j=EcoJacobian[traits,pops,Time->time];
	res=RouthHurwitzCriteria[j]
,
	method=="Eigenvalues",
	evs=EcoEigenvalues[traits,pops,Time->time,Multipliers->True,Evaluate[Sequence@@ecoeigenvaluesopts]];
	If[verbose,Print[func,": evs=",evs]];
	Which[
		modeltype=="DiscreteTime",
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Max[Abs[evs]]<1+tolerance],True,
			Evaluate[Max[Abs[evs]]>1+tolerance],False,
			Else,Indeterminate
		],
		modeltype=="ContinuousTime"&&IFFQ[pops]==False,
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Max[Re[evs]]>tolerance],False,
			Evaluate[Max[Re[evs]]<tolerance],True, 
			Else,Indeterminate		
		],
		modeltype=="ContinuousTime"&&IFFQ[pops]==True,
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Abs[evs[[2]]]<1+tolerance],True,
			Evaluate[Abs[evs[[2]]]>1+tolerance],False,
			Else,Indeterminate
		]
	]
];

Which[
	simplify===True,
	Return[Simplify[res,Assumptions->assumptions]],
	simplify===Real,
	Return[RealSimplify[res,assumptions]],
	simplify===Full,
	Return[FullSimplify[res,assumptions]],
	simplify===False,
	Return[res]
];

];


EcoStableQ[traitsandpops_?TraitsAndVariablesQ,opts___?OptionQ]:=EcoStableQ[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoStableQ]={Verbose->False,VerboseAll->False,Method->Automatic,Simplify->True,Time->t,EcoEigenvaluesOpts->{},Assumptions->{},
Tolerance->0};


SelectEcoStable[traits:(_?TraitsQ):{},sol_?ListOfVariablesQ,opts___?OptionQ]:=Module[{stableqopts,stable},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

stableqopts=FilterRules[Flatten[{opts,Options[SelectEcoStable]}],Options[EcoStableQ]];

stable=EcoStableQ[traits,#,Evaluate[Sequence@@stableqopts]]&/@sol;

Return[Part[sol,Flatten[Position[stable,True]]]]
];


SelectEcoStable[traits:(_?TraitsQ):{},{},opts___?OptionQ]:={};


Options[SelectEcoStable]={};


FindEcoAttractor[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{},opts___?OptionQ]:=Module[{
func=FuncStyle["FindEcoAttactor"],
(*options*)
verbose,verboseall,method,chop,numtries,
solveecoeqopts,nsolveecoeqopts,findecoeqopts,ecosimopts,findecocycleopts,
warmup,tmax,finaltmax,eqthreshold,time,period,maxperiod,maxperiodmultiplier,
testvalidity,teststability,
(*other variables*)
eq,valideq,tmp,evs,ics,stableeq,res,essol,ddt,eqflag,per,ecosimflag},

Block[{Nsp},
If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(*handle options*)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[!MemberQ[{Automatic,"SolveEcoEq","NSolveEcoEq","FindEcoEq","EcoSim","FindEcoCycle"},method],
	Msg[FindEcoAttractor::badmtd];Return[$Failed]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoAttractor]}]];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
solveecoeqopts=Evaluate[SolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
nsolveecoeqopts=Evaluate[NSolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecoeqopts=Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecocycleopts=Evaluate[FindEcoCycleOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
warmup=Evaluate[WarmUp/.Flatten[{opts,Options[FindEcoAttractor]}]];
tmax=Evaluate[TMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[tmax===Automatic,If[modelperiod==0,tmax=1000,tmax=100*modelperiod]];
finaltmax=Evaluate[FinalTMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[finaltmax===Automatic,finaltmax=tmax];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqthreshold=Evaluate[EqThreshold/.Flatten[{opts,Options[FindEcoAttractor]}]];
time=Evaluate[Time/.Flatten[{opts,Options[FindEcoAttractor]}]];
period=Evaluate[Period/.Flatten[{opts,Options[FindEcoAttractor]}]];
maxperiod=Min[tmax-1,Evaluate[MaxPeriod/.Flatten[{opts,Options[FindEcoAttractor]}]]];
maxperiodmultiplier=Evaluate[MaxPeriodMultiplier/.Flatten[{opts,Options[FindEcoAttractor]}]];
testvalidity=Evaluate[TestValidity/.Flatten[{opts,Options[FindEcoAttractor]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[FindEcoAttractor]}]];

ecosimflag=False;

(* figure out number of species in guilds *)

SetNsp[traits];

If[method===Automatic,
	Which[
		modelperiod=!=0&&time===t,
		method="FindEcoCycle",
		pops=={},
		method="NSolveEcoEq",
		Else,
		If[naux+npops+Sum[Nsp[gu]*ngcomps[gu],{gu,nguilds}]<=4,
			method="NSolveEcoEq",
			method="FindEcoEq"
		];
	];
];

Which[
	method=="EcoSim",Goto[ecosim],
	method=="FindEcoCycle",Goto[findecocycle]
];


(* method FindEcoEq *)

If[method=="FindEcoEq",
	If[verbose,Print[func,": FindEcoEq Mode"]];
	If[pops=={},Msg[FindEcoAttractor::nopops,"FindEcoEq"];Return[$Failed]];
	If[warmup>0,
		If[verbose,
			Print[func,": Warming Up..."];
			With[{warmup=warmup,time=time,options=Sequence@@ecosimopts},
				PrintCall[FinalSlice[EcoSim[traits,pops,warmup,Time->time,options]],"ics:"]]
		];
		ics=FinalSlice[EcoSim[traits,pops,warmup,Time->time,Evaluate[Sequence@@ecosimopts]]];
	, (* else *)
		ics=pops;
	];
	If[verbose,
		With[{ics=ics,time=time,options=Sequence@@findecoeqopts},
			PrintCall[FindEcoEq[traits,ics,Time->time,options],"eq:"]]
	];
	eq={FindEcoEq[traits,ics,Time->time,Evaluate[Sequence@@findecoeqopts],VerboseAll->verboseall]};

	(* try more initial conditions if required *)

	If[numtries>=2,
		Do[
			(* perturb ICs *)
			ics=ReplacePart[#,2->#[[2]]*10^RandomReal[{-1,1}]]& /@ pops;
			If[verbose,
				With[{ics=ics,time=time,options=Sequence@@findecoeqopts},
					PrintCall[FindEcoEq[traits,ics,Time->time,options],"tmp:"]]
			];
			tmp=FindEcoEq[traits,ics,Time->time,Evaluate[Sequence@@findecoeqopts],VerboseAll->verboseall];
			(* if distinct eq, add to tmp *)
			If[tmp!={},
				If[CompoundAnd[Table[RuleListDistance[tmp,bar]>$roundofftolerance,{bar,eq}]],AppendTo[eq,tmp]];
			];
		,{numtries-1}];
	];	
];


(* method SolveEcoEq *)

If[method=="SolveEcoEq",
	If[verbose,
		Print[func,": SolveEcoEq Mode"];
		With[{time=time,options=Sequence@@solveecoeqopts},
			PrintCall[SolveEcoEq[traits,Time->time,options],"eq:"]]
	];
	eq=SolveEcoEq[traits,Time->time,Evaluate[Sequence@@solveecoeqopts],VerboseAll->verboseall];
];


(* method NSolveEcoEq *)

If[method=="NSolveEcoEq",
	If[verbose,
		Print[func,": NSolveEcoEq Mode"];
		With[{time=time,options=Sequence@@nsolveecoeqopts},
			PrintCall[Global`eq=Union[NSolveEcoEq[traits,Time->time,options]]]]
	];
	eq=Union[NSolveEcoEq[traits,Time->time,Evaluate[Sequence@@nsolveecoeqopts],VerboseAll->verboseall]];
];

(* method FindEcoCycle *)
Label[findecocycle];

If[method=="FindEcoCycle",
	If[verbose,Print[func,": FindEcoCycle Mode"]];
	If[pops=={},Msg[FindEcoAttractor::nopops,"FindEcoCycle"];Abort[]];

	(* figure out period to try *)
	If[period===Automatic,
		Which[
			modelperiod=!=0,
			per=modelperiod,
			modeltype=="DiscreteTime",
			per=1
		]
	,
		per=period
	];

	If[ecosimflag==False, (* if we haven't already been through ecosim *)
		If[warmup>0,
			If[verbose,
				Print[func,": Warming up..."];
				With[{warmup=warmup,per=per,time=time,options=Sequence@@ecosimopts},
					PrintCall[FinalSlice[EcoSim[traits,pops,Floor[warmup,per],Time->time,options]],"ics:"]]
			];
			ics=FinalSlice[EcoSim[traits,pops,Floor[warmup,per],Time->time,Evaluate[Sequence@@ecosimopts]]];
		, (* else *)
			ics=pops;
		],
		ics=FinalSlice[essol] (* if we have been through ecosim *)
	];
	
	Which[
		modeltype=="DiscreteTime",
		If[verbose,
			With[{ics=ics,per=per,maxperiodmultiplier=maxperiodmultiplier,options=Sequence@@findecocycleopts},
				PrintCall[Table[FindEcoCycle[traits,ics,options,Period->Global`permult*per],{Global`permult,maxperiodmultiplier}],"eq:"]]
		];
		eq=Table[
			FindEcoCycle[traits,ics,Evaluate[Sequence@@findecocycleopts],Period->permult*per]
		,{permult,maxperiodmultiplier}];
		(* remove $Failed & multiple period solutions *)
		eq=Select[eq,#=!=$Failed&&FindPeriod[#]==#[[1,2]]["PathLength"]&];
	,
		modeltype=="ContinuousTime",
		If[verbose,
			With[{ics=ics,options=Sequence@@findecocycleopts},
				PrintCall[FindEcoCycle[traits,ics,options],"eq:"]]
		];
		eq=Select[{FindEcoCycle[traits,ics,Evaluate[Sequence@@findecocycleopts]]},#=!=$Failed&]
	];	
];

If[verbose,Print[func,": eq=",eq]];

(* assess validity and stability of eq *)

If[testvalidity,
	If[!ListQ[eq]||eq=={}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		valideq={}
	, 
		If[Head[eq[[1,1,2]]]=!=InterpolatingFunction,
			valideq=SelectValid[eq];
			If[verbose,Print[func,": valid eq=",valideq]];
		,
			valideq=eq (* SelectValid doesn't work on IF's yet *)
		]
	];
	If[valideq=={},Msg[FindEcoAttractor::novalideq]];
];

If[teststability,
	stableeq=SelectEcoStable[traits,valideq,Time->time];
	If[verbose,Print[func,": stable eq=",stableeq]];
,
	stableeq=valideq
];

If[Length[stableeq]==0, (* no stable eq, try EcoSim once *)
	If[ecosimflag==False,
		Msg[FindEcoAttractor::nosteq,traits];
		method="EcoSim"
	,
		Msg[FindEcoAttractor::giveup];
		Return[EcoSim[traits,FinalSlice[essol],finaltmax,Time->time,Evaluate[Sequence@@ecosimopts],VerboseAll->verboseall]]
	]
];
If[Length[stableeq]==1,res=stableeq[[1]];Goto[done]]; (* successful *)
If[Length[stableeq]>=2,Msg[FindEcoAttractor::musteq,Length[stableeq],traits];Goto[done]];


(* if we're still here, no stable equilibrium, so switch to EcoSim *)
(* method EcoSim *)

Label[ecosim];
If[method=="EcoSim",
	If[verbose,Print[func,": EcoSim Mode"]];
	If[pops=={},Msg[FindEcoAttractor::nopops,"EcoSim"];Abort[]];
	
	If[Length[ics]==0,ics=pops];
	
	If[verbose,
		With[{ics=ics,tmax=tmax,time=time,options=Sequence@@ecosimopts},
			PrintCall[EcoSim[traits,ics,tmax,Time->time,options],"essol:"]]
	];
	
	essol=EcoSim[traits,ics,tmax,Time->time,Evaluate[Sequence@@ecosimopts],VerboseAll->verboseall];
	If[verbose,Print[PlotDynamics[essol]]];

	(* check for equilibrium *)
	
	If[modelperiod=!=0,
		ddt=FinalDerivatives[essol,modelperiod][[All,2]],
		ddt=FinalDerivatives[essol][[All,2]]
	];
	If[verbose,Print[func,": d/dt=",ddt]];
	If[Max[Abs[ddt]]<eqthreshold,
		If[verbose,Print[func,": Equilibrium found"]];
		(* construct stableeq *)
		If[modelperiod=!=0,
			res=FinalSlice[essol,modelperiod],
			res=FinalSlice[essol]
		];
		Goto[done];
	,
		(* steady state eq failed *)
		Msg[FindEcoAttractor::nostst,ddt,tmax];
		(* attempt to find Period using FindEcoCycle approach *)
		ecosimflag=True; (* already been through ecosim *)
		method="FindEcoCycle";
		period=FindPeriod[essol,MaxPeriod->maxperiod,Evaluate[Sequence@@findecocycleopts]];
		Goto[findecocycle];
	];
];

Label[done];

If[chop,
	Return[Chop[res]],
	Return[res]
];

]];


Options[FindEcoAttractor]={Verbose->False,VerboseAll->False,
Method->Automatic,Chop->True,NumTries->1,
SolveEcoEqOpts->{},NSolveEcoEqOpts->{},FindEcoEqOpts->{},EcoSimOpts->{},FindEcoCycleOpts->{},
WarmUp->0,TMax->Automatic,EqThreshold->10^-5,Time->t,Period->Automatic,MaxPeriod->16,MaxPeriodMultiplier->2,
TestValidity->True,TestStability->True,FinalTMax->Automatic};


PlotEcoIsoclines[traits:(_?TraitsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoIsoclines"],
(* options *)
verbose,verboseall,fixed,time,monitor,percapita,isoclinestyle,framelabel,contourplotopts,isoclinelabels,isoclinelabel1,isoclinelabel2,
(* other variables *)
fixedvars,nonfixedvars,lookup1,lookup2,unk1,eqn1,style1,unk2,eqn2,style2,g1,g2,removets,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print["PlotEcoIsoclines: fixedvars=",fixedvars]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
isoclinelabels=Evaluate[IsoclineLabels/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
{isoclinelabel1,isoclinelabel2}=Which[
	isoclinelabels===Automatic,
	{{None,Tooltip[Null,var1]&},{None,Tooltip[Null,var2]&}},
	isoclinelabels===True,
	{Text[var1,{#1,#2},Background->White]&,Text[var2,{#1,#2},Background->White]&},
	Length[isoclinelabels]==2,
	isoclinelabels,
	Else,
	{None,None}
];

(* figure out number of species in guilds *)
SetNsp[traits];

(* figure out what are the components on the x- and y-axes *)

lookup1=LookUp[var1];
lookup2=LookUp[var2];

Which[
	lookup1[[1]]=="gcomp",
	eqn1=gcompeqn[lookup1[[2]],lookup1[[3]]][lookup1[[4]]];
	style1=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var1][0]},linestyle[var1]],isoclinestyle[[1]]]
,
	lookup1[[1]]=="pcomp",
	eqn1=pcompeqn[lookup1[[2]],lookup1[[3]]];
	style1=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var1]},linestyle[var1]],isoclinestyle[[1]]]
,
	lookup1[[1]]=="aux",
	eqn1=auxeqn[lookup1[[2]]];
	style1=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var1]},linestyle[var1]],isoclinestyle[[1]]]
];

Which[
	lookup2[[1]]=="gcomp",
	eqn2=gcompeqn[lookup2[[2]],lookup2[[3]]][lookup2[[4]]];
	style2=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var2][1]},linestyle[var2]],isoclinestyle[[2]]]
,
	lookup2[[1]]=="pcomp",
	eqn2=pcompeqn[lookup2[[2]],lookup2[[3]]];
	style2=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var2]},linestyle[var2]],isoclinestyle[[2]]]
,
	lookup2[[1]]=="aux",
	eqn2=auxeqn[lookup2[[2]]];
	style2=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var2]},linestyle[var2]],isoclinestyle[[2]]]
];

(*Print["{style1,style2}=",{style1,style2}];*)

(* subrule to remove [t]'s *)

removets=Flatten[Join[
	Table[Table[Table[Subscript[gcomp[gu,gco],sp][t]->Subscript[gcomp[gu,gco],sp],{sp,Nsp[gu]}],{gco,ngcomps[gu]}],{gu,nguilds}],
	Table[Table[pcomp[pop,pco][t]->pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au][t]->aux[au],{au,naux}],
	{t->time}
]];

(* look for aux and pcomps not on the axes, treat as fixed at 0 *)

nonfixedvars={var1,var2};

Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],pcomp[pop,pco]],
		AppendTo[fixed,pcomp[pop,pco]->0];
		AppendTo[fixedvars,pcomp[pop,pco]]
	]
,{pop,npops},{pco,npcomps[pop]}];

Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],aux[au]],
		AppendTo[fixed,aux[au]->0];
		AppendTo[fixedvars,aux[au]]
	]
,{au,naux}];

g1[x1_,x2_]:=Module[{popsub,gres},
	popsub={var1->x1,var2->x2};
	Which[
		modeltype=="ContinuousTime",
		If[percapita,
			gres=eqn1/var1/.removets/.popsub/.fixed/.traits,
			gres=eqn1/.removets/.popsub/.fixed/.traits
		],
		modeltype=="DiscreteTime",
		If[percapita,
			gres=(eqn1/var1-1)/.removets/.popsub/.fixed/.traits,
			gres=(eqn1-var1)/.removets/.popsub/.fixed/.traits
		]
	];
	Return[gres];
];

g2[x1_,x2_]:=Module[{popsub,gres},
	popsub={var1->x1,var2->x2};
	Which[
		modeltype=="ContinuousTime",
		If[percapita,
			gres=eqn2/var2/.removets/.popsub/.fixed/.traits,
			gres=eqn2/.removets/.popsub/.fixed/.traits
		],
		modeltype=="DiscreteTime",
		If[percapita,
			gres=(eqn2/var2-1)/.removets/.popsub/.fixed/.traits,
			gres=(eqn2-var2)/.removets/.popsub/.fixed/.traits
		]
	];
	Return[gres];
];

contourplotopts=FilterRules[Flatten[{opts,ContourShading->None,Options[PlotEcoIsoclines]}],Options[ContourPlot]];

res=Show[
	ContourPlot[Evaluate[g1[x1,x2]],{x1,var1min-10^-10,var1max},{x2,var2min-10^-10,var2max},ContourStyle->style1,ContourLabels->isoclinelabel1,Contours->{0},Evaluate[Sequence@@contourplotopts]],
	ContourPlot[Evaluate[g2[x1,x2]],{x1,var1min-10^-10,var1max},{x2,var2min-10^-10,var2max},ContourStyle->style2,ContourLabels->isoclinelabel2,Contours->{0},Evaluate[Sequence@@contourplotopts]],
	FrameLabel->framelabel
];


If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotEcoIsoclines]={
	Monitor->False,
	Time->t,PerCapita->False,Fixed->{},
	IsoclineStyle->Automatic,FrameLabel->Automatic,IsoclineLabels->Automatic,ContourShading->False,
	MaxRecursion->3,
	Verbose->False,VerboseAll->False};


PlotEcoStreams[traits:(_?TraitsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoStreams"],
(* options *)
verbose,verboseall,fixed,time,monitor,framelabel,streamplotopts,
(* other variables *)
fixedvars,nonfixedvars,lookup1,lookup2,eqn1,eqn2,g1,g2,removets,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEcoStreams]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoStreams]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoStreams]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEcoStreams]}],Options[StreamPlot]];

(* figure out number of species in guilds *)
SetNsp[traits];

(* figure out what are the components on the x- and y-axes *)

lookup1=LookUp[var1];
lookup2=LookUp[var2];

(*Print[lookup1];Print[lookup2];*)

Which[
	lookup1[[1]]=="gcomp",
	eqn1=gcompeqn[lookup1[[2]],lookup1[[3]]][lookup1[[4]]],
	lookup1[[1]]=="pcomp",
	eqn1=pcompeqn[lookup1[[2]],lookup1[[3]]],
	lookup1[[1]]=="aux",
	eqn1=auxeqn[lookup1[[2]]];
];

Which[
	lookup2[[1]]=="gcomp",
	eqn2=gcompeqn[lookup2[[2]],lookup2[[3]]][lookup2[[4]]],
	lookup2[[1]]=="pcomp",
	eqn2=pcompeqn[lookup2[[2]],lookup2[[3]]],
	lookup2[[1]]=="aux",
	eqn2=auxeqn[lookup2[[2]]];
];

(* subrule to remove [t]'s *)

removets=Flatten[Join[
	Table[Table[Table[Subscript[gcomp[gu,gco],sp][t]->Subscript[gcomp[gu,gco],sp],{sp,Nsp[gu]}],{gco,ngcomps[gu]}],{gu,nguilds}],
	Table[Table[pcomp[pop,pco][t]->pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au][t]->aux[au],{au,naux}],
	{t->time}
]];

(* look for aux and pcomps not on the axes, treat as fixed at 0 *)

nonfixedvars={var1,var2};

Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],pcomp[pop,pco]],
		AppendTo[fixed,pcomp[pop,pco]->0];
		AppendTo[fixedvars,pcomp[pop,pco]]
	]
,{pop,npops},{pco,npcomps[pop]}];

Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],aux[au]],
		AppendTo[fixed,aux[au]->0];
		AppendTo[fixedvars,aux[au]]
	]
,{au,naux}];

g1[x1_,x2_]:=Module[{popsub,gres},
	popsub={var1->x1,var2->x2};
	Which[
		modeltype=="ContinuousTime",
		gres=eqn1/.removets/.popsub/.fixed/.traits,
		modeltype=="DiscreteTime",
		gres=(eqn1-var1)/.removets/.popsub/.fixed/.traits
	];
	Return[gres];
];

g2[x1_,x2_]:=Module[{popsub,gres},
	popsub={var1->x1,var2->x2};
	Which[
		modeltype=="ContinuousTime",
		gres=eqn2/.removets/.popsub/.fixed/.traits,
		modeltype=="DiscreteTime",
		gres=(eqn2-var2)/.removets/.popsub/.fixed/.traits
	];
	Return[gres];
];

res=myStreamPlot[Evaluate[{g1[x1,x2],g2[x1,x2]}],{x1,var1min,var1max},{x2,var2min,var2max},
	Evaluate[Sequence@@streamplotopts],PlotRange->{{var1min,var1max},{var2min,var2max}},FrameLabel->framelabel];

If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotEcoStreams]={
	Monitor->False,Fixed->{},Time->t,
	FrameLabel->Automatic,PlotRangePadding->Scaled[0.02],StreamStyle->Gray,
	Verbose->False,VerboseAll->False};


PlotEcoPhasePlane[traits:(_?TraitsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=
Module[{
(* options *)
plotecoisoclinesopts,plotecostreamsopts},

(* handle options *)

plotecoisoclinesopts=FilterRules[
	Flatten[{Evaluate[PlotEcoIsoclinesOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoIsoclines],Options[ContourPlot]]];
plotecostreamsopts=FilterRules[
	Flatten[{Evaluate[PlotEcoStreamsOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoStreams],Options[StreamPlot]]];

Return[Show[
	PlotEcoStreams[traits,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecostreamsopts](*,Evaluate[Sequence@@commonopts]*)],
	PlotEcoIsoclines[traits,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecoisoclinesopts](*,Evaluate[Sequence@@commonopts]*)]
]]
];


Options[PlotEcoPhasePlane]={
	Monitor->False,
	Fixed->{},Time->t,FrameLabel->Automatic,
	PlotEcoIsoclinesOpts->{},PlotEcoStreamsOpts->{},
	Verbose->False,VerboseAll->False};


InvSPS[traitsandpops_?TraitsAndVariablesQ,invaderin:(_?InvaderQ):{},opts:OptionsPattern[]]:=
((*Print["** traitsandpops"];*)InvSPS[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],invaderin,opts]);


InvSPS[traitsin:(_?NotInvaderTraitsQ):{},solin:(_?VariablesQ):{},invaderin:(_?InvaderQ):{},opts:OptionsPattern[]]:=Module[{
func=FuncStyle["InvSPS"],
(* options *)
verbose,verboseall,method,
guild,time,simplifyresult,frominv,rv,qssics,
ndsolveopts,qssmethod,nintegrateopts,integrateopts,solveopts,nsolveopts,findrootopts,findecocycleopts,eigensystemopts,
(* other variables *)
invader,traits,invtraits,pcomps,pops,
invtype,invnum,zeropcomps,sol,
inveqns,invunks,qsseqns,qssunks,qsssubs,mode,
tstart,tend,removets,qsssol,eval,evec,invsol,j},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

$invcount++; (* increment $invcount *)

(*Print[invaderin];*)

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

method=OptionValue[Method];
time=OptionValue[Time];
qssmethod=OptionValue[QSSMethod]; 
ndsolveopts=OptionValue[NDSolveOpts];
nintegrateopts=OptionValue[NIntegrateOpts];
integrateopts=OptionValue[IntegrateOpts];
solveopts=OptionValue[SolveOpts];
nsolveopts=OptionValue[NSolveOpts];
findrootopts=OptionValue[FindRootOpts];
findecocycleopts=OptionValue[FindEcoCycleOpts];
eigensystemopts=OptionValue[EigensystemOpts];
simplifyresult=OptionValue[SimplifyResult];
guild=OptionValue[Guild];
frominv=OptionValue[FromInv];
rv=OptionValue[RV];
qssics=OptionValue[QSSICs];

pcomps=ExtractPops[solin];

(* figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
pops=ExpandNspInPops[solin];
SetNsp[traits,pops];

(*Print["traits=",traits];*)

(* assemble sol [resident state] *)

(* in case any pops weren't given, assume they're 0 *)
zeropcomps=Flatten[Table[Table[If[pcomptype[pop,pco]=="Extensive",pcomp[pop,pco]->0,pcomp[pop,pco]->pcomp[pop,pco]],{pco,npcomps[pop]}],{pop,npops}]];
sol=Join[pops,zeropcomps];

(* if a time given, evaluate sol there *)
If[time=!=t&&!NumericRuleListQ[sol],sol=Slice[sol,time]];

If[Global`debug,Print[func,": sol=",sol]];

invader=Flatten[{invaderin}];

Which[
	(* no invader given *)
	invader==={},
	If[Global`debug,Print["no invader given"]];
	Which[
		nguilds!=0,{invtype,invnum}={"guild",guild},
		npops!=0,{invtype,invnum}={"pop",1}
	]
,
	(* guild invader *)
	RuleListQ[invader],
	If[Global`debug,Print["guild invader"]];
	{invtype,invnum}={"guild",LookUp[invader[[1,1]]][[2]]}
,
	(* pop invader *)
	LookUp[invader[[1]]][[1]]=="pop"||LookUp[invader[[1]]][[1]]=="pcomp",
	If[Global`debug,Print["pop invader"]];
	{invtype,invnum}={"pop",LookUp[invader[[1]]][[2]]};
	If[Max[Table[If[pcomptype[invnum,pco]=="Extensive",pcomp[invnum,pco]],{pco,npcomps[invnum]}]/.pcomps]>0,
		Msg[InvSPS::nonzero];Abort[]]
,
	Else,
	Msg[InvSPS::unkinv];Return[$Failed]
];

If[Global`debug,Print[func,": {invtype,invnum}=",{invtype,invnum}]];

Which[
	invtype=="pop",invtraits={},
	invtype=="guild",invtraits=ExtractTraits[invader]
];
If[Global`debug,Print["invtraits=",invtraits]];

(* set up inveqns, invunks, qss stuff *)

inveqns={};
invunks={};
qsssubs={};
qsseqns={};
qssunks={};

Which[
	(* guild invader *)
	invtype=="guild",
	Do[
		If[gcomptype[invnum,co]=="Extensive",
			AppendTo[inveqns,gcompeqn[invnum,co][0]];
			AppendTo[invunks,Subscript[gcomp[invnum,co],0]];
			AppendTo[qsssubs,Subscript[gcomp[invnum,co],0]->0];
		];
		If[gcomptype[invnum,co]=="Intensive",
			AppendTo[qsseqns,gcompeqn[invnum,co][0]==0];
			If[qssmethod=="FindRoot",
				AppendTo[qssunks,{Subscript[gcomp[invnum,co],0],Min[pcomprange[invnum,co]]+0.01}];,
				AppendTo[qssunks,Subscript[gcomp[invnum,co],0]];
			];
		];
	,{co,ngcomps[invnum]}];
,
	(* pop invader *)
	invtype=="pop",
	Do[
		If[pcomptype[invnum,pco]=="Extensive",
			AppendTo[inveqns,pcompeqn[invnum,pco]];
			AppendTo[invunks,pcomp[invnum,pco]];
			AppendTo[qsssubs,pcomp[invnum,pco]->0];
		];
		If[pcomptype[invnum,pco]=="Intensive",
			AppendTo[qsseqns,pcompeqn[invnum,pco]==0];
			If[qssmethod=="FindRoot",
				AppendTo[qssunks,{pcomp[invnum,pco],Min[pcomprange[invnum,pco]]+0.01}];,
				AppendTo[qssunks,pcomp[invnum,pco]];
			];
		];
	,{pco,npcomps[invnum]}];	
];

If[Global`debug,
	Print[func,": inveqns=",inveqns];
	Print[func,": invunks=",invunks];
	Print[func,": qsseqns=",qsseqns];
	Print[func,": qsssubs=",qsssubs];
	Print[func,": qssunks=",qssunks]
];


(* decide on mode *)

Which[
	(modelperiod==0&&(Length[sol]==0||!MemberQ[{InterpolatingFunction,TemporalData},Head[sol[[1,2]]]]))
	||(modelperiod=!=0&&(method==="Instantaneous"||time=!=t)),
	mode="eigenvalue",
	modeltype=="ContinuousTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===InterpolatingFunction)),
	mode="continuoustime floquet",
	modeltype=="DiscreteTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===TemporalData)),
	mode="discretetime floquet"
];
(*If[Global`debug,Print[func,": mode=",mode]];*)


(* calculate invasion fitness *)

Which[
	(* ContinuousTime Floquet mode *)
	mode=="continuoustime floquet",
	If[verbose,Print[func,": ContinuousTime Floquet mode"]];

	(* figure out period *)
	If[sol!={}&&Head[sol[[1,2]]]===InterpolatingFunction,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	If[Global`debug,Print[func,": {tstart,tend}=",{tstart,tend}]];
	
	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[qssics===Automatic, (* then average corresponding components from residents *)
			qssics=Table[qssunk->
				Mean[Select[Select[FinalSlice[sol],(#[[1,0]]==Subscript)&],(#[[1,1]]==qssunk[[1]])&][[All,2]]]
			,{qssunk,qssunks}];
		];
		If[verbose,
			With[{tr=Join[traits,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[tr,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[traits,invtraits],Join[FinalSlice[sol],qssics],Sequence@@findecocycleopts];
		If[qsssol==$Failed,Msg[InvSPS::noqsssol];Return[{$Failed}]];
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	If[Global`debug,Print[func,": qsssol=",qsssol]];

	removets={Subscript[x_/;type[x]=="Extensive",0][t]->Subscript[x,0],t->time};
	
	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		Which[
			method===Automatic||method=="NIntegrate",
			If[Global`debug,Print[func,": ContinuousTime Floquet mode (1 comp): NIntegrate"]];
			(*Print[invtraits];
			If[invtraits==={},Msg[InvSPS::notraits];Return[{$Failed,$Failed}]];*)
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits,
				tstart=tstart,tend=tend,op=Sequence@@nintegrateopts},
				PrintCall[Global`eval=NIntegrate[eq/.Global`sol/.Global`qsssol,{t,tstart,tend},op]]
			]];
			eval=NIntegrate[Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@nintegrateopts]]/(tend-tstart);
			Return[{eval,"?"}]
			,
			method=="NDSolve",
			If[Global`debug,Print[func,": ContinuousTime Floquet mode (1 comp): NDSolve"]];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
				PrintCall[Global`invsol=NDSolve[{Global`x'[t]==eq/.Global`qsssol,Global`x[tstart]==0},Global`x,{t,tstart,tend},op]];
				PrintCall[Global`eval=Global`x[tend]/dt/.Global`invsol]
			]];
			invsol=NDSolve[{x'[t]==Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol/.qsssol,x[tstart]==0},x,
				{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]][[1]];
			eval=x[tend]/(tend-tstart)/.invsol;
			Return[{eval,"?"}];
			,
			method=="Integrate",
			If[Global`debug,Print[func,": ContinuousTime Floquet mode (1 comp): Integrate"]];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol,
				tstart=tstart,tend=tend,op=Sequence@@integrateopts},
				PrintCall[Global`eval=Integrate[eq/.Global`qsssol,{t,tstart,tend},op]]
			]];
			Print["qsssol=",qsssol];
			eval=Integrate[Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@integrateopts]]/(tend-tstart);
			Return[{Chop[eval],"?"}];
			,
			True, (* else *)
			Msg[InvSPS::bdmtd];
			Return[]
		];
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		If[Global`debug,Print[func,": ContinuousTime Floquet mode (2+ comps)"]];
		j=D[inveqns/.traits/.removets,{invunks}];
		If[Global`debug,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,liu=Length[invunks],tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
			PrintCall[Global`invsol=NDSolve[{Global`x'[t]==j.Global`x[t]/.Global`sol/.Global`qsssol,Global`x[tstart]==IdentityMatrix[liu]},Global`x,{t,tstart,tend},op]];
			PrintCall[Global`eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[Global`x[tend]/.Global`invsol]/dt]
		]];
		invsol=NDSolve[{x'[t]==j.x[t]/.invtraits/.sol/.qsssol,x[tstart]==IdentityMatrix[Length[invunks]]},x,{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]];
		eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[x[tend]/.invsol]/(tend-tstart);
		Return[{eval,"?"}];
	]
,
	(* DiscreteTime Floquet mode -- add initial time? *)
	mode=="discretetime floquet",
	If[verbose,Print[func,": DiscreteTime Floquet mode"]];

	(* figure out period *)
	If[Head[sol[[1,2]]]===TemporalData,tend=FinalTime[sol],tend=modelperiod];
	If[Global`debug,Print["tend=",tend]];

	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[verbose,
			With[{tr=Join[traits,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[tr,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[traits,invtraits],Join[FinalSlice[sol],qssics],Evaluate[Sequence@@findecocycleopts]]
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	If[Global`debug,Print[func,": qsssol=",qsssol]];

	removets={Subscript[x_/;type[x]=="Extensive",0][t]->Subscript[x,0],t->time};

	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		If[Global`debug,Print[func,":  DiscreteTime Floquet mode (1 comp)"]];
		If[verbose,
			With[{eq=inveqns[[1]]/invunks[[1]][t]/.invtraits,tend=tend},
			PrintCall[Global`eval=Product[eq/.Global`sol/.Global`qsssol,{t,0,tend}]^(1/(tend+1))]
		]];
		eval=Product[inveqns[[1]]/invunks[[1]][t]/.invtraits/.sol/.qsssol,{t,0,tend}]^(1/(tend+1));
		Return[{Chop[eval],"?"}]
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		If[Global`debug,Print[func,":  DiscreteTime Floquet mode (2+ comps)"]];
		j=D[inveqns/.traits/.removets,{invunks}];
		If[Global`debug,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,tend=tend,te=tend+1},
			PrintCall[Global`invsol=ListMultiplier[Table[j/.Global`sol/.Global`qsssol,{t,0,tend}]]];
			PrintCall[Global`eval=Max@Re@Chop@Sort@Eigenvalues[Global`invsol]^(1/te)]
		]];
		invsol=ListMultiplier[Table[j/.invtraits/.sol/.qsssol,{t,0,tend}]];		
		Return[{Max@Re@Chop@Sort@Eigenvalues[invsol]^(1/(tend+1)),"?"}];
	]
,
	(* Eigenvalue mode *)
	mode=="eigenvalue",
	If[verbose,Print[func,": eigenvalue mode"]];
	
	(* subrule to remove [t]'s *)
	(*removets={t\[Rule]time,x_[t]\[Rule]x}; (* what if forcing function f[t]?? *)*)
	removets=Flatten[Join[
		{t->time},
		Table[Table[Table[Subscript[gcomp[gu,gco],sp][t]->Subscript[gcomp[gu,gco],sp],{sp,0,Nsp[gu]}],{gco,ngcomps[gu]}],{gu,nguilds}],
		Table[Table[pcomp[pop,pco][t]->pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}],
		Table[aux[au][t]->aux[au],{au,naux}]
	]];

	(* are there any Intensive components to be solved for? *)

	If[Length[qssunks]>0,
		Which[
			qssmethod=="Solve",
			qsssol=Solve[qsseqns/.removets/.qsssubs/.traits/.sol/.invtraits,qssunks,Evaluate[Sequence@@solveopts]],
			qssmethod=="NSolve",
			qsssol=NSolve[qsseqns/.removets/.qsssubs/.traits/.sol/.invtraits,qssunks,Evaluate[Sequence@@nsolveopts]],
			qssmethod=="FindRoot",
			qsssol={FindRoot[qsseqns/.removets/.qsssubs/.traits/.sol/.invtraits,qssunks,Evaluate[Sequence@@findrootopts]]}
		];
	,
		qsssol={{}}];
	If[verbose,Print[func,": qsssol=",qsssol]];
	(* should add SelectValid here? *)

	If[Length[invunks]==1,
		j={{Simplify[Cancel[(inveqns[[1]]/invunks[[1]])/.removets]/.qsssol[[1]]/.qsssubs/.invtraits/.traits/.sol]}}
	,
		(* make Jacobian matrix of Extensive components *)
		(* what about 0th order terms?! *)
		j=D[inveqns/.removets/.traits/.qsssol[[1]]/.invtraits,{invunks}]/.sol;
	];

	If[Global`debug,Print[func,": j=",j]];

	Which[
		Length[j]==1, (* 1 extensive component *)
		If[Global`debug,Print[func,": 1 extensive component"]];
		eval=j[[1,1]];
		evec={1};
	,
		Length[j]>1, (* >1 extensive component *)
	
		(* calculate eigenvalues *)

		If[(MatrixQ[#,NumericQ]&)[j/.qsssubs],
			(* numerical jacobian *)
			If[verbose,Print[func,": numerical Jacobian"]];
			
			If[rv,
				{{eval},{evec}}=SortedEigensystem[Transpose[j/.qsssubs],1,Sequence@@eigensystemopts],
				{{eval},{evec}}=SortedEigensystem[j/.qsssubs,1,Sequence@@eigensystemopts]
			];
			evec=evec/Sign[evec[[1]]]
		,
			(* symbolic jacobian *)
			If[verbose,Print[func,": symbolic Jacobian"]];

			If[Dimensions[j/.qsssubs]=={2,2},
				eval=Simplify[Re[1/2*(j[[1,1]]+j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])]];
				If[rv,
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[1,2]]),1}],
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[2,1]]),1}]
				]
			,
				eval=Max[Re[Eigenvalues[j/.qsssubs,Sequence@@eigensystemopts]]];
				evec="?";
				If[!frominv,Msg[InvSPS::nosymev]];
			];
		];
	];
	
	eval=eval/.x_InterpolatingFunction->x[t]; (* add [t] to InterpolatingFunctions *)
	
	If[verbose,Print[func,": eigenvalue=",eval]];
	If[verbose,Print[func,": eigenvector=",evec]];
	
	(* return answer *)

	Which[
		modeltype=="ContinuousTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Assumptions:>{_\[Element]Reals}]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Assumptions:>{_\[Element]Reals}]]
		,
			Else, (* else *)
			Return[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
	,
		modeltype=="DiscreteTime",
		Return[{(*Log@*)Max@Chop@ComplexExpand[eval],evec}];
	];

];

]];


Options[InvSPS]={
Method->Automatic,Time->t,
NIntegrateOpts->{Method->{Automatic,"SymbolicProcessing"->0}},IntegrateOpts->{},NDSolveOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},EigensystemOpts->{},FindEcoCycleOpts->{},
QSSMethod->"NSolve",QSSICs->Automatic,
SimplifyResult->False,Guild->1,FromInv->False,RV->False,
Verbose->False,VerboseAll->False};


Inv[args___]:=InvSPS[args,FromInv->True][[1]];
StablePopulationStructure[args___]:=InvSPS[args][[2]];
ReproductiveValues[args___]:=InvSPS[args,RV->True][[2]];


Options[DInv]={InvOpts->{},Method->"D",Guild->1,Species->All,FindEcoAttractorOpts->{},
Chop->True,Simplify->False,RelativeStepSize->0.001,AbsoluteStepSize->0.001,Time->t,Verbose->False,VerboseAll->All};

notDInvOpts=Except[Alternatives@@Replace[Options[DInv],h_[a_,_]:>h[a,_],1]];


NumDInv[traitsin_?NumericRuleListQ,rest___]:=DInv[traitsin,rest];


DInv[traitsin:(_?TraitsQ):{},solin:(_?VariablesQ):{},{var_:All,ord_?NumberQ},pointin:notDInvOpts:{},opts:OptionsPattern[]]:=

Module[{
func=FuncStyle["DInv"],
(* options *)
verbose,verboseall,method,\[Epsilon]r,\[Epsilon]a,invopts,guild,species,time,simplify,chop,findecoattractoropts,
(* other variables *)
sol,res,res2,traits,traits2,point,targetgu,targettr,inv,sp,vars,h,h1,h2,invl,invr,invc},

If[solin==$Failed,Return[$Failed]];

(*Print["traitsin=",traitsin];
Print["solin=",solin];
Print["{var,ord}=",{var,ord}];
Print["pointin=",pointin];*)

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

invopts=OptionValue[InvOpts];
method=OptionValue[Method];
\[Epsilon]a=OptionValue[AbsoluteStepSize];
\[Epsilon]r=OptionValue[RelativeStepSize];
guild=OptionValue[Guild];
species=OptionValue[Species];
time=OptionValue[Time];
AppendTo[invopts,Time->time];
simplify=OptionValue[Simplify];
chop=OptionValue[Chop];
findecoattractoropts=OptionValue[FindEcoAttractorOpts];

(* handle blanks & figure out number of species in guilds *)
traits=DeleteInvaders[ExpandNspInTraits[traitsin]];
sol=ExpandNspInPops[solin];
SetNsp[traits];

If[solin==="FindEcoAttractor",
	If[verbose,
		With[{tr=traits,op=Sequence@@findecoattractoropts},
		PrintCall[Global`sol=FindEcoAttractor[tr,op]]
	]];
	sol=FindEcoAttractor[traits,Evaluate[Sequence@@findecoattractoropts]]
];
If[verbose,Print[func,": sol=",sol]];

(* thread a list of points *)
If[Length[Dimensions[pointin]]==2,Return[Map[DInv[traits,sol,{var,ord},#,opts]&,pointin]]];

(*Print["pointin=",pointin];
Print["species=",species];*)

(* figure out point where to evaluate derivative *)
If[pointin=={},
	If[var===All,
		targetgu=guild,
		If[ListQ[var],targetgu=LookUp[var[[1]]][[2]],targetgu=LookUp[var][[2]]]
	];
	If[species===All,If[Nsp[targetgu]==0,species=0,species=Table[sp,{sp,Nsp[targetgu]}]]];
	If[ListQ[species],
		If[method=="NDInv",Return[Table[DInv[traits,sol,{var,ord},{},Species->sp,opts],{sp,species}]]];
		point=Table[Table[Subscript[trait[targetgu,tr],0]->Subscript[trait[targetgu,tr],sp],{tr,ntraits[targetgu]}],{sp,species}]/.traits
	,
		If[species!=0,
			point=Table[Subscript[trait[targetgu,tr],0]->Subscript[trait[targetgu,tr],species],{tr,ntraits[targetgu]}]/.traits
		,
			point=Table[Subscript[trait[targetgu,tr],0]->(Subscript[trait[targetgu,tr],species]/.traitsin),{tr,ntraits[targetgu]}]
		];
	];
,
	targetgu=LookUp[pointin[[1,1]]][[2]];
	point=pointin
];
If[Global`debug,Print[func,": targetgu=",targetgu]];
If[Global`debug,Print[func,": point=",point]];

If[var===All,
	vars=Table[Subscript[trait[targetgu,tr],0],{tr,ntraits[targetgu]}]
,
	vars=var
];
If[Global`debug,Print[func,": vars=",vars]];

Which[
	method=="D",
	If[verbose,
		With[{tr=traits,so=sol,tg=targetgu,op=Sequence@@invopts},
		PrintCall[Global`inv=Simplify[Inv[tr,so,Guild->tg,op],Assumptions->_\[Element]Reals]]
	]];
	inv=Simplify[Inv[traits,sol,Guild->targetgu,Evaluate[Sequence@@invopts]],Assumptions->_\[Element]Reals];
	If[verbose,Print[func,": inv=",inv]];
	If[verbose,
		With[{vars=vars,inv=inv,point=point,traits=traits},
		PrintCall[Global`res=D[inv,{vars,ord}]/.point/.traits]
	]];
	res=D[inv,{vars,ord}]/.point/.traits; (* is /.traits necessary?? *)
	If[verbose,Print[func,": res=",res]];

,
	method=="NDInv",
	Which[
		ord==1,
		If[ListQ[vars],
			(* gradient *)
			Return[DInv[traits,sol,{#,ord},point,opts]& /@ vars];
		, (* first derivative *)
			If[Global`debug,Print[func,": 1st derivative (finite difference)"]];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[IFFQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invl=",invl]];
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[IFFQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invr=",invr]];
			If[invl==$Failed||invr==$Failed,Return[$Failed]];
			res=(invr-invl)/(2h);
		]
	,
		ord==2, 
		If[ListQ[vars],
			(* Hessian matrix *)
			If[Global`debug,Print[func,": Hessian matrix (finite difference)"]];
			res=ConstantArray[0,{Length[vars],Length[vars]}];
			Do[
				(* diagonal entries *)		
				h=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
				res=ReplacePart[res,{v1,v1}->
					(Inv[traits,sol,RuleListTweak[point,vars[[v1]],h],Evaluate[Sequence@@invopts]]
					-2Inv[traits,sol,point,Evaluate[Sequence@@invopts]]
					+Inv[traits,sol,RuleListTweak[point,vars[[v1]],-h],Evaluate[Sequence@@invopts]])/(h^2)
				];
				(* offdiagonal entries *)
				Do[
					h1=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
					h2=(\[Epsilon]r*vars[[v2]]/.point)+\[Epsilon]a;
					res=ReplacePart[res,{{v1,v2},{v2,v1}}->
						(Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,-h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,h2}],Evaluate[Sequence@@invopts]]
						+Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,-h2}],Evaluate[Sequence@@invopts]])/(4*h1*h2)
					];					
				,{v2,v1+1,Length[vars]}]
			,{v1,1,Length[vars]}];
		, (* second derivative *)
			If[Global`debug,Print[func,": 2nd derivative (finite difference)"]];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[IFFQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invl=",invl]];
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[IFFQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invr=",invr]];
			If[verbose,
				With[{tr=traits,so=sol,pt=point,op=Sequence@@invopts},
				If[IFFQ[so],
					PrintCall[Global`invc=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invc=Inv[tr,so,pt,op]]
				]
			]];
			invc=Inv[traits,sol,point,Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invc=",invc]];
			If[invl==$Failed||invr==$Failed||invc==$Failed,Return[$Failed]];
			res=(invr-2invc+invl)/(h^2);
			];
		]
	,
		Else,
		Msg[DInv::badmtd];
		Return[$Failed];
	];

(* postprocess & return answer *)

Which[
	simplify===True,
	res2=Simplify[res/.traits,Assumptions:>{_\[Element]Reals}],
	simplify===Full,
	res2=FullSimplify[res/.traits,Assumptions:>{_\[Element]Reals}],
	Else,
	res2=res/.traits
];

If[chop==True,Return[Chop[res2]],Return[res2]];

]];


(* first derivative abbreviated syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=
((*Print[6];*)DInv[traits,solin,{var,1},pointin,opts]);


(* no point syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_?NumberQ},opts___?OptionQ]:=
((*Print[5];*)DInv[traits,solin,{var,ord},Guild->1,opts]);


(* no order *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},pointin:notDInvOpts:{},opts___?OptionQ]:=
((*Print[4];*)DInv[traits,solin,{var,1},pointin,opts]);


(* no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},opts___?OptionQ]:=
((*Print[3];*)DInv[traits,solin,{var,1},Guild->1,opts]);


(* no var, no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,opts___?OptionQ]:=
((*Print[2];*)DInv[traits,solin,{All,1},opts]);


(* first derivative abbreviated syntax *)
DInv[eesol_?TraitsAndVariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=
((*Print[7];*)DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,1},pointin,opts]);


(* general derivative abbreviated syntax *)
DInv[eesol_?TraitsAndVariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_Integer},pointin:notDInvOpts:{},opts___?OptionQ]:=
((*Print[8];*)DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,ord},pointin,opts]);


(* break up traitsandpops *)
DInv[eesol_?TraitsAndVariablesQ,rest___]:=
((*Print[1];*)DInv[ExtractTraits[eesol],ExtractVariables[eesol],rest]);


(* first derivative abbreviated syntax *)
DInv[var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=((*Print[0];*)DInv[{},{},{var,1},pointin,opts]);


NDInv[args___]:=DInv[args,Method->"NDInv"];


PrestonPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PrestonPlot"],
(* options *)
gu,gco,base,minpop,bandwidth,showspecies,markerstyle,plotopts,listplotopts,plotrange,
(* other variables *)
pops,pos,data,\[ScriptCapitalD],hist,stix
},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[PrestonPlot]}]];
gco=Evaluate[Component/.Flatten[{opts,Options[PrestonPlot]}]];
base=Evaluate[Base/.Flatten[{opts,Options[PrestonPlot]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[PrestonPlot]}]];
bandwidth=Evaluate[Bandwidth/.Flatten[{opts,Options[PrestonPlot]}]];
showspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PrestonPlot]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PrestonPlot]}]];
plotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[Plot]];
listplotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[ListPlot]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PrestonPlot]}]];

(* figure out number of species in guilds *)
SetNsp[sol];
pops=Select[sol,#[[1,1]]===gcomp[gu,gco]&&#[[2]]>minpop&];
pos=pops[[All,1,2]];
data=Log[base,pops[[All,2]]];
\[ScriptCapitalD]=SmoothKernelDistribution[data,bandwidth,{"Bounded",{Min[data],Max[data]},"Gaussian"}];
hist=Plot[PDF[\[ScriptCapitalD],x],{x,Min[data],Max[data]},Evaluate[Sequence@@plotopts]];
If[showspecies,
	If[markerstyle===Automatic,
		markerstyle=Table[color[Subscript[gcomp[gu,gco],i]][SpFrac[i,Nsp[gu]]],{i,pos}]];
	stix=ListPlot[
		Map[List,Transpose[{data,Table[0,Length[pos]]}]],PlotStyle->markerstyle,
		Evaluate[Sequence@@listplotopts],PlotMarkers->{"|",8}],
	stix={}];
Return[Show[stix,hist,AxesOrigin->{Max[data],0},PlotRange->plotrange]];

]];

Options[PrestonPlot]={Guild->1,Component->1,Base->10,MinPop->0,Bandwidth->"Scott",ShowSpecies->True,MarkerStyle->Automatic,PlotRange->{0,All}};


WhittakerPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WhittakerPlot"],
(* options *)
gu,gco,base,minpop,listplotopts,
(* other variables *)
pops,data
},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[WhittakerPlot]}]];
gco=Evaluate[Component/.Flatten[{opts,Options[WhittakerPlot]}]];
base=Evaluate[Base/.Flatten[{opts,Options[WhittakerPlot]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WhittakerPlot]}]];
listplotopts=FilterRules[Flatten[{opts,Options[WhittakerPlot]}],Options[ListPlot]];

(* figure out number of species in guilds *)
SetNsp[sol];
pops=Select[sol,#[[1,1]]===gcomp[gu,gco]&&#[[2]]>minpop&];
data=Log[base,pops[[All,2]]];
Return[ListPlot[Sort[data,Greater],Evaluate[Sequence@@listplotopts]]];

]];

Options[WhittakerPlot]={Guild->1,Component->1,Base->10,MinPop->0,PlotRange->All};


PlotTAD[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotTAD"],
(* options *)
logged,gu,tr,gco,minpop,plotstyle,markerstyle,plotopts,
(* other variables *)
pops,pos,plotmin
},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
logged=Evaluate[Logged/.Flatten[{opts,Options[PlotTAD]}]];
gu=Evaluate[Guild/.Flatten[{opts,Options[PlotTAD]}]];
tr=Evaluate[Trait/.Flatten[{opts,Options[PlotTAD]}]];
gco=Evaluate[Component/.Flatten[{opts,Options[PlotTAD]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[PlotTAD]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotTAD]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PlotTAD]}]];
plotopts=FilterRules[Flatten[{opts,Options[PlotTAD]}],Options[ListPlot]];

(* figure out number of species in guilds *)
SetNsp[traits,sol];

pops=Select[sol,#[[1,1]]===gcomp[gu,gco]&&#[[2]]>minpop&];
pos=pops[[All,1,2]];

If[markerstyle===Automatic,
	markerstyle=Table[color[Subscript[trait[gu,tr],i]][SpFrac[i,Nsp[gu]]],{i,pos}]];
	
If[logged==False,
	Return[ListPlot[
		Table[{{Subscript[trait[gu,tr],i],0},{Subscript[trait[gu,tr],i],Subscript[gcomp[gu,gco],i]}},{i,pos}]/.sol/.traits,
		PlotStyle->Join[plotstyle,markerstyle],
		Evaluate[Sequence@@plotopts],
		PlotRange->All,Joined->True
	]]
,
	plotmin=Min[Table[Subscript[gcomp[gu,gco],i],{i,pos}]/.sol];
	Return[ListLogPlot[
		Table[{{Subscript[trait[gu,tr],i],plotmin},
		{Subscript[trait[gu,tr],i],Subscript[gcomp[gu,gco],i]}},{i,pos}]/.sol/.traits,
		PlotStyle->Join[plotstyle,markerstyle],
		Evaluate[Sequence@@plotopts],
		PlotRange->{plotmin,All},Joined->True
	]]
];

]];

Options[PlotTAD]={Logged->False,Guild->1,Trait->1,Component->1,MinPop->0,MarkerStyle->Automatic,PlotStyle->{}};


PlotInv[traits:(_?TraitsQ):{},sol:(_?VariablesQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotInv"],
(* options *)
verbose,verboseall,monitor,
delayinv,invopts,time,plotopts,plotspecies,markerstyle,axeslabel,
(* other variables *)
nb,x,
gu1,tr1,per,res,inv,epi,zeroval},

Block[{Nsp},

(*Print["traits=",traits];
Print["sol=",sol];
Print["{trait1,trait1min,trait1max}=",{trait1,trait1min,trait1max}];*)

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotInv]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotInv]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotInv]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotInv]}]];
(*If[delayinv===Automatic,If[modelperiod=!=0,delayinv=True,delayinv=False]];*)
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotInv]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotInv]}]];
plotspecies=Evaluate[PlotSpecies/.Flatten[{opts,Options[PlotInv]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PlotInv]}]];
plotopts=FilterRules[Flatten[{opts,Options[PlotInv]}],Options[Plot]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotInv]}]];
If[axeslabel===Automatic,axeslabel={trait1}];

(* figure out what trait is on the x-axis *)
{gu1,tr1}=LookUp[trait1][[2;;3]];

(* figure out number of species in guilds *)
SetNsp[traits,sol];

(*Print[markerstyle];*)

If[plotspecies,
	zeroval=If[modeltype=="DiscreteTime",1,0];
	If[markerstyle===Automatic,
		epi=Table[{PointSize[0.015],color[Subscript[trait[gu1,tr1],sp]][SpFrac[sp,Nsp[gu1]]],Point[{Subscript[trait[gu1,tr1],sp]/.traits,zeroval}]},{sp,Nsp[gu1]}]
	,
		epi=MapThread[Append,{PadRight[{},Nsp[gu1],Map[Flatten[{#}]&,markerstyle]],Table[Point[{Subscript[trait[gu1,tr1],sp]/.traits,zeroval}],{sp,Nsp[gu1]}]}]
	]
,
	epi={}
];

(*Print[epi];*)

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{"\[FormalX]=",Dynamic[x]}}],WindowTitle->"PlotInv Progress..."]];
];

If[delayinv,
	(* delay inv *)
	inv[\[FormalX]_?NumberQ]:=Inv[traits,sol,{Subscript[trait[gu1,tr1],0]->\[FormalX]},Guild->gu1,Evaluate[Sequence@@invopts],Time->time,VerboseAll->verboseall];
	res=Plot[(x=\[FormalX];Evaluate[inv[\[FormalX]]]),{\[FormalX],trait1min,trait1max},AxesLabel->axeslabel,Evaluate[Sequence@@plotopts],Epilog->epi]
,
	(* nondelay inv *)
	Off[NIntegrate::inumr];
	inv=Inv[traits,sol,Guild->gu1,Evaluate[Sequence@@invopts],Time->time,VerboseAll->verboseall];
	res=Plot[inv,{trait1,trait1min,trait1max},AxesLabel->axeslabel,Evaluate[Sequence@@plotopts],Epilog->epi];
	On[NIntegrate::inumr]
];

If[monitor,NotebookClose[nb]];

Return[res]
]];

PlotInv[eesol_?TraitsAndVariablesQ,{trait1_,trait1min_,trait1max_},opts___?OptionQ]:=PlotInv[ExtractTraits[eesol],ExtractVariables[eesol],{trait1,trait1min,trait1max},opts];

Options[PlotInv]={
	InvOpts->{},Fixed->{},
	DelayInv->False,Time->t,
	MarkerStyle->Automatic,PlotSpecies->True,AxesLabel->Automatic,
	PlotStyle->Gray,PlotPoints->5,
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotZIP[solin_:"FindEcoAttractor",{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},
invaderin_Symbol:Automatic,opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotZIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,ics,invthreshold,guild,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
fixedvars,traitinv,subrule,luv1,luv2,gu,tr1,tr2,invader,sol,inv,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotZIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotZIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotZIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotZIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotZIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotZIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotZIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotZIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotZIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotZIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotZIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotZIP]}]];
If[invthreshold===Automatic,invthreshold=If[modeltype=="DiscreteTime",1,0]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotZIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotZIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotZIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

fixedvars=fixed[[All,1]];

(* figure out what are the traits on the x- and y-axes *)

luv1=LookUp[var1];
luv2=LookUp[var2];

traitinv={};subrule={};
If[luv1[[1]]==="trait",
	{gu,tr1}=luv1[[2;;3]];
	AppendTo[traitinv,var1->\[FormalX]],
	AppendTo[subrule,var1->\[FormalX]]
];
If[luv2[[1]]==="trait",
	If[luv1[[1]]==="trait"&&(luv2[[2]]!=gu),Msg[PlotZIP::diffsp];Return[$Failed]];
	{gu,tr2}=luv2[[2;;3]];
	AppendTo[traitinv,var2->\[FormalY]],
	AppendTo[subrule,var2->\[FormalY]]
];

(*Print["traitinv=",traitinv];
Print["subrule=",subrule];*)

If[invaderin===Automatic,
	If[IntegerQ[gu],
		invader=traitinv,
		Message[PlotZIP::unkinv];Return[$Failed]
	]
,
	invader=invaderin
];
(*Print["invader=",invader];*)

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={var1,var2,"inv"},
		framelabel={var1,var2}
	]
];

(* define resident sol *)

If[solin==="FindEcoAttractor",
	If[fixed=={},
		sol[\[FormalX]_,\[FormalY]_]={}
	,
		If[ics=={},
			(* figure out number of species in guilds *)
			SetNsp[fixed];
			If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,nguilds}]]];
			ics=DefaultICs;
			If[verbose,Print[func,": ics=",ics]];
		];
		If[verbose,
			With[{tr=fixed,ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[\[FormalX],\[FormalY]]=FindEcoAttractor[tr,ics,op]]
		]];
		sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
			result=FindEcoAttractor[fixed,ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			If[printtrace,Print["EcoAttractor (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
			If[result=={$Failed},Message[PlotZIP::feafail,\[FormalX],\[FormalY]]];
			Return[result]
		];
		delayinv=True]
,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{var1->\[FormalX],var2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{var1->\[FormalX],var2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]];
];

(* define inv *)

If[delayinv,
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[\[FormalX],\[FormalY]]=Inv[tr,so,in,op]/.{var1->\[FormalX],var2->\[FormalY]}]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[fixed,sol[\[FormalX],\[FormalY]],invader,Evaluate[Sequence@@invopts],VerboseAll->verboseall]/.subrule;
		If[printtrace,Print["Inv (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts,sr=subrule,trinv=traitinv},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,in,op]/.sr/.trinv]
	]];
	inv[\[FormalX]_,\[FormalY]_]=Inv[fixed,sol[\[FormalX],\[FormalY]],invader,Evaluate[Sequence@@invopts],VerboseAll->verboseall]/.subrule/.traitinv;
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]]
];

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{"\[FormalX]=",Dynamic[x]},{"\[FormalY]=",Dynamic[y]}}],WindowTitle->"PlotZIP Progress..."]];
];

Which[
	plottype=="Plot3D",
	res=Plot3D[({x,y}={\[FormalX],\[FormalY]};Evaluate[{inv[\[FormalX],\[FormalY]],invthreshold}]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"]],
	plottype=="ContourPlot",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel],
	plottype=="RegionZIP", 
	res=RegionPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="ZIP",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,
		ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel],
	Else,
	Message[PlotZIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotZIP]={
	FindEcoAttractorOpts->{},InvOpts->{},
	DelayInv->False,PlotType->"ZIP",ICs->{},Fixed->{},InvThreshold->Automatic,
	PlotOpts->{MaxRecursion->3},
	BoundaryStyle->Black,InvStyle->Gray,NonInvStyle->White,
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotPIP[solin_:"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotPIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,ics,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
fixedvars,gu1,tr1,sp1,res,sol,resinv,inv},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotPIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotPIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotPIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotPIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotPIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotPIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotPIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotPIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotPIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotPIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotPIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotPIP]}]];
If[invthreshold===Automatic,invthreshold=If[modeltype=="DiscreteTime",1,0]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotPIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotPIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotPIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];


fixedvars=fixed[[All,1]];

If[zerodiagonal,inv[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={trait1,Subscript[trait[gu1,tr1],0],"inv"},
		framelabel={trait1,Subscript[trait[gu1,tr1],0]}
	]
];

(* add fixed traits for invader *)
fixed=Join[fixed,Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[Table[trait[gu1,tr],{tr,ntraits[gu1]}],{trait[gu1,tr1]}]}]];

(* define resident sol *)

If[solin==="FindEcoAttractor",
	If[ics=={},
		(* figure out number of species in guilds *)
		SetNsp[Append[fixed,trait1->trait1]];
		If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,nguilds}]]];
		ics=DefaultICs;
		If[verbose,Print[func,": ics=",ics]];
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ]:=Global`sol[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol[\[FormalX]_?NumberQ]:=sol[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotPIP::feafail,trait1,\[FormalX]]];
		Return[result]
	];
	delayinv=True;
,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_]=solin/.trait1->\[FormalX]]];
	sol[\[FormalX]_]=solin/.trait1->\[FormalX];
	If[verbose,Print[func,": sol[\[FormalX]]=",sol[\[FormalX]]]];
];

(* define inv *)
If[delayinv,
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],tg=gu1,trinv=Subscript[trait[gu1,tr1],0],op=Sequence@@invopts},
				PrintCall[Global`resinv[(System`\[FormalX])_?NumberQ]:=Global`resinv[System`\[FormalX]]=Inv[tr,so,{trinv->\[FormalX]},op]]
		]];
		resinv[\[FormalX]_?NumberQ]:=resinv[\[FormalX]]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],{Subscript[trait[gu1,tr1],0]->\[FormalX]},Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],tg=gu1,op=Sequence@@invopts,trinv=Subscript[trait[gu1,tr1],0],
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,{trinv->\[FormalY]},op]-sub]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],{Subscript[trait[gu1,tr1],0]->\[FormalY]},Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[trait[gu1,tr1],0],"=",\[FormalY],"): ",result]];
		If[subtractdiagonal,result=result-resinv[\[FormalX]]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],tg=gu1,trinv=Subscript[trait[gu1,tr1],0],op=Sequence@@invopts},
			PrintCall[Global`resinv[(System`\[FormalX])_]=Inv[tr,so,{trinv->\[FormalX]},op]]
		]];
		resinv[\[FormalX]_]=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Subscript[trait[gu1,tr1],0]->\[FormalX],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[verbose,Print[func,": resinv[\[FormalX]]=",resinv[\[FormalX]]]];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],tg=gu1,op=Sequence@@invopts,trinv=Subscript[trait[gu1,tr1],0],
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,{trinv->\[FormalX]},op]-sub]
	]];
	inv[\[FormalX]_,\[FormalY]_]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],{Subscript[trait[gu1,tr1],0]->\[FormalY]},Evaluate[Sequence@@invopts],VerboseAll->verboseall]
		-If[subtractdiagonal==True,resinv[\[FormalX]],0];
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]];
];

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{"\[FormalX]=",Dynamic[x]},{"\[FormalY]=",Dynamic[y]}}],WindowTitle->"PlotPIP Progress..."]];
];

Which[
	plottype=="Plot3D",
	res=Plot3D[{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold},{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"],EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="ContourPlot",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="RegionPlot", 
	res=RegionPlot[Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="PIP",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	Else,
	Message[PlotPIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotPIP]={
	FindEcoAttractorOpts->{},InvOpts->{},
	DelayInv->False,PlotType->"PIP",ICs->{},ZeroDiagonal->False,Fixed->{},SubtractDiagonal->False,InvThreshold->Automatic,
	PlotOpts->{MaxRecursion->3},
	BoundaryStyle->Black,InvStyle->Gray,NonInvStyle->White,
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotMIP[{solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",solin2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotMIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,icsin,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,spcolors,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
gu1,tr1,sp1,gu2,tr2,sp2,ics,sol1,sol2,inv12,inv21,pip1,pip2,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotMIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotMIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotMIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotMIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotMIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotMIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotMIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotMIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotMIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotMIP]}]];
icsin=Evaluate[ICs/.Flatten[{opts,Options[PlotMIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotMIP]}]];
If[invthreshold===Automatic,invthreshold=If[modeltype=="DiscreteTime",1,0]+$MachineEpsilon];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotMIP]}]];
spcolors=Evaluate[SpeciesColors/.Flatten[{opts,Options[PlotMIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotMIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotMIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];
If[zerodiagonal,inv12[traitres_,traitres_]=inv21[traitres_,traitres_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[trait[gu1,tr1],sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* add fixed traits for invader *)
fixed=Join[fixed,
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[Table[trait[gu1,tr],{tr,ntraits[gu1]}],{trait[gu1,tr1]}]}],
	Table[Subscript[trt,0]->(Subscript[trt,sp2]/.fixed),{trt,Complement[Table[trait[gu2,tr],{tr,ntraits[gu2]}],{trait[gu2,tr2]}]}]
];
(*Print["fixed=",fixed];*)

If[solin1==="FindEcoAttractor",
	If[icsin=={},
		(* figure out number of species in guilds *)
		SetNsp[Append[fixed,trait1->trait1]];
		If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,nguilds}]]];
		ics=DefaultICs;
		If[verbose,Print[func,": ics=",ics]];
	,
		ics=icsin
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol1[(System`\[FormalX])_?NumberQ]:=Global`sol1[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol1[\[FormalX]_?NumberQ]:=sol1[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotMIP::feafail,trait1,\[FormalX]]];
		Return[result];
	];
	delayinv=True;
,
	If[verbose,PrintCall[Global`sol1[(System`\[FormalX])_]=solin1/.trait1->\[FormalX]]];
	sol1[\[FormalX]_]=solin1/.trait1->\[FormalX];
	If[verbose,Print[func,": sol1[\[FormalX]]=",sol1[\[FormalX]]]]
];

If[trait1=!=trait2,
	If[solin2==="FindEcoAttractor",
		delayinv=True;
		If[icsin=={},
			(* figure out number of species in guilds *)
			SetNsp[Append[fixed,trait2->trait2]];
			If[Global`debug,Print[func,": Nsp2=",Table[Nsp[gu],{gu,nguilds}]]];
			ics=DefaultICs;
			If[verbose,Print[func,": ics=",ics]];
		,
			ics=icsin
		];
		If[verbose,
			With[{tr=Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol2[(System`\[FormalX])_?NumberQ]:=Global`sol2[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
		]];
		sol2[\[FormalX]_?NumberQ]:=sol2[\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			If[printtrace,Print["EcoAttractor (",trait2,"=",\[FormalX],"): ",result]];
			If[result=={$Failed},Message[PlotMIP::feafail,trait2,\[FormalX]]];
			Return[result];
		];
	,
		If[verbose,PrintCall[Global`sol2[(System`\[FormalX])_]=solin2/.trait2->\[FormalX]]];
		sol2[\[FormalX]_]=solin2/.trait2->\[FormalX];
		If[verbose,Print[func,": sol2[\[FormalX]]=",sol2[\[FormalX]]]]
	]
,
	sol2[\[FormalX]_]:=sol1[\[FormalX]];
	If[verbose,Print[func,": sol2[\[FormalX]]=sol1[\[FormalX]]"]]
];

If[delayinv,
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Global`sol1[\[FormalX]],op=Sequence@@invopts,trinv=Subscript[trait[gu2,tr2],0]},
			PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=
				Inv[tr,so,{trinv->\[FormalY]},op]]
	]];
	inv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv21[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],{Subscript[trait[gu2,tr2],0]->\[FormalY]},Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[printtrace,Print["Inv (",trait2,"=",\[FormalX]," ",Subscript[trait[gu1,tr1],0],"=",\[FormalY],"): ",result]];
		Return[result]
	];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Global`sol2[\[FormalX]],op=Sequence@@invopts,trinv=Subscript[trait[gu1,tr1],0]},
				PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=
					Inv[tr,so,{trinv->\[FormalY]},op]]
		]];
		inv12[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv12[\[FormalX],\[FormalY]]=Module[{result},
			result=Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],{Subscript[trait[gu1,tr1],0]->\[FormalY]},Evaluate[Sequence@@invopts],VerboseAll->verboseall];
			If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[trait[gu2,tr2],0],"=",\[FormalY],"): ",result]];
			Return[result]
		];
	,
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]]
	]
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Global`sol1[\[FormalX]],op=Sequence@@invopts,trinv=Subscript[trait[gu1,tr1],0]},
			PrintCall[Global`inv21[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,{trinv->\[FormalX]},op]]
	]];
	inv21[\[FormalX]_,\[FormalY]_]=
		Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],{Subscript[trait[gu2,tr2],0]->\[FormalY]},Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Global`sol2[\[FormalX]],op=Sequence@@invopts,trinv=Subscript[trait[gu1,tr1],0]},
				PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,{trinv->\[FormalX]},op]]
		]];
		inv12[\[FormalX]_,\[FormalY]_]=
			Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],{Subscript[trait[gu1,tr1],0]->\[FormalY]},Evaluate[Sequence@@invopts],VerboseAll->verboseall]
	,
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]];
		If[verbose,Print[func,": inv12[\[FormalX]]=inv21[\[FormalX]]"]]
	]
];


If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{trait1,"=",Dynamic[x]},{SubscriptAdd[trait2,1],"=",Dynamic[y]}}],WindowTitle->"PlotMIP Progress..."]];
];

Which[
	plottype=="MIP",
	pip1=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv21[\[FormalX],\[FormalY]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv12[\[FormalY],\[FormalX]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1//axisFlip
	];
	res=Show[Graphics[{invstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,Evaluate[Sequence@@plotopts],Frame->True,FrameLabel->framelabel,
		Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionMIP",
	res=RegionPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[(inv12[\[FormalY],\[FormalX]]>invthreshold&&inv21[\[FormalX],\[FormalY]]>invthreshold)]),
		{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="Outcome",
	pip1=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv21[\[FormalX],\[FormalY]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[2]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv12[\[FormalY],\[FormalX]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[1]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1/.spcolors[[2]]->spcolors[[1]]//axisFlip
	];
	res=Show[Graphics[{noninvstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,Evaluate[Sequence@@plotopts],
		Frame->True,FrameLabel->framelabel,Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionOutcome",
	res=RegionPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[{inv21[\[FormalX],\[FormalY]]>invthreshold,inv12[\[FormalY],\[FormalX]]>invthreshold}])
		,{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],BoundaryStyle->boundarystyle,
		PlotStyle->{Directive[spcolors[[1]],Opacity[0.4]],Directive[spcolors[[2]],Opacity[0.4]]},FrameLabel->framelabel],
	Else,
	Message[PlotMIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res];

]];


PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},
	opts___?OptionQ]:=
((*Print[1];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
((*Print[2];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait1,trait1min,trait1max},opts]);


PlotMIP[{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},
	opts___?OptionQ]:=
	((*Print[3];*)PlotMIP[{"FindEcoAttractor","FindEcoAttractor"},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


Options[PlotMIP]={
	PlotType->"MIP",DelayInv->False,FindEcoAttractorOpts->{},InvOpts->{},InvThreshold->Automatic,
	ICs->{},ZeroDiagonal->False,Fixed->{},
	BoundaryStyle->Black,SpeciesColors->{Red,Blue},InvStyle->Gray,NonInvStyle->White,FrameLabel->Automatic,
	PlotOpts->{MaxRecursion->3},
	Monitor->False,Verbose->False,VerboseAll->False
};


EvoEqns[solin:(_?VariablesQ):{},Gs_List:{},opts___?OptionQ]:=
 
Module[{
func=FuncStyle["EvoEqns"],
(* options *)
verbose,verboseall,fixed,delaydinv,dinvopts,evoeqn,traitshiftrate,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,
g,dtrait,pre,wt,sol,eqns},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts, Options[EvoEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts, Options[EvoEqns]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoEqns]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
fixedtraits=ExtractTraits[fixed];
If[Global`debug,Print[func,": fixedtraits=",fixedtraits]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];

delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EvoEqns]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[EvoEqns]}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[EvoEqns]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[EvoEqns]}]];

sol=ExpandNspInPops[solin];

(* figure out number of species in guilds *)
SetNsp[Join[sol,fixedvariables]];
(*Print["Nsp=",Table[Nsp[gu],{gu,nguilds}]];*)

(* shifting traits *)
Do[
	dtrait[gu,tr]=If[MemberQ[traitshiftrate[[All,1]],trait[gu,tr]],trait[gu,tr]/.traitshiftrate,0]
,{gu,nguilds},{tr,ntraits[gu]}];
If[Global`debug,Print[func,": dtrait=",Table[dtrait[gu,tr],{gu,nguilds},{tr,ntraits[gu]}]]];

(* set up G matrix *)
Do[
	g[gu]=If[MatrixQ[G[gu]/.Gs],
		G[gu]/.Gs,
		DiagonalMatrix[Table[V[trait[gu,tr]]/.Gs/.V[trait[gu,tr]]->1,{tr,ntraits[gu]}]]
	]
,{gu,nguilds}];


(* traiteqns *)
Which[
	evoeqn=="QG",
	Do[Do[pre[gu,sp]=1,{sp,0,Nsp[gu]}],{gu,nguilds}],
	evoeqn=="CE",
	Do[
		Do[
			If[gcomptype[gu,gco]=="Extensive",wt[gu,gco]=1,wt[gu,gco]=0]
		,{gco,ngcomps[gu]}];
		Do[
			pre[gu,sp]:=Sum[wt[gu,gco]*Subscript[gcomp[gu,gco],sp],{gco,ngcomps[gu]}]
		,{sp,0,Nsp[gu]}]
	,{gu,nguilds}],
	Else,
	Msg[EvoEqns::badte];
	Return[$Failed]
];

eqns=Flatten[Table[Table[
	If[delaydinv==True,
		Thread[Table[TraitDT[Subscript[trait[gu,tr],sp]],{tr,ntraits[gu]}]==(
			pre[gu,sp]*g[gu].NumDInv[BlankTraits,sol,Guild->gu,Species->sp,Method->"NDInv",Evaluate[Sequence@@dinvopts],VerboseAll->verboseall]
			-Table[dtrait[gu,tr],{tr,ntraits[gu]}]/.fixed/.AddPopts/.AddTraitts)]
	,
		Thread[Table[TraitDT[Subscript[trait[gu,tr],sp]],{tr,ntraits[gu]}]==(
			pre[gu,sp]*g[gu].DInv[BlankTraits,sol,Guild->gu,Species->sp,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall]
			-Table[dtrait[gu,tr],{tr,ntraits[gu]}]/.fixed/.AddPopts/.AddTraitts)]
	]
,{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,nguilds}]];

eqns=DeleteCases[eqns,DT[var_]==_/;MemberQ[fixedvars,var]];

Return[eqns];

]];


Options[EvoEqns]={DelayDInv->False,DInvOpts->{},EvoEquation->"QG",TraitShiftRate->{},Fixed->{},Verbose->False,VerboseAll->False};


PlotEvoStreams[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoStreams"],
(* options *)
verbose,verboseall,monitor,printtrace,fixed,time,
evoeqn,fitnessgradient,dinvopts,ecoattractoropts,streamplotopts,framelabel,ics,ecoattnumber,usesymmetry,zerodiagonal,
(* other variables *)
nb,x,y,
g,sol,fg1,fg2,gu1,tr1,sp1,gu2,tr2,sp2,pre1,pre2,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoStreams]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoStreams]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoStreams]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoStreams]}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[PlotEvoStreams]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[PlotEvoStreams]}]];
ecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];
streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEvoStreams]}],Options[StreamPlot]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoStreams]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotEvoStreams]}]];
ecoattnumber=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoStreams]}]];
usesymmetry=Evaluate[UseSymmetry/.Flatten[{opts,Options[PlotEvoStreams]}]];

(*If[zerodiagonal,fg1[x1_,x1_]=fg2[x1_,x1_]=0];*)

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[trait[gu1,tr1],sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* set up G matrices *)

Do[
	g[gu]=If[MatrixQ[G[gu]/.Gs],
		G[gu]/.Gs,
		DiagonalMatrix[Table[If[NumberQ[V[trait[gu,tr]]/.Gs],V[trait[gu,tr]]/.Gs,1],{tr,ntraits[gu]}]]
	];
,{gu,nguilds}];

(* set up sol *)

If[solin==="FindEcoAttractor",
	fitnessgradient="NDInv";
	If[ics=={},
		(* figure out number of species in guilds *)
		SetNsp[Join[fixed,{trait1->trait1,trait2->trait2}]];
		If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,nguilds}]]];
		ics=DefaultICs;
	];
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics=ics,time=time,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[System`\[FormalX],System`\[FormalY]]=
			FindEcoAttractor[tr,ics,Time->time,op]]]
	];
	sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=
		Module[{result},
			result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics,Time->time,Evaluate[Sequence@@ecoattractoropts],VerboseAll->verboseall];
			If[printtrace,Print["FindEcoAttractor ",{trait1->\[FormalX],trait2->\[FormalY]},"=",result]];
			If[ArrayDepth[result]<2,Return[result],Return[result[[ecoattnumber]]]]
		];
, (* sol given *)
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]]

];

(* set up fitness gradients *)

Which[
	fitnessgradient=="NDInv"
,
	(* memoization seems ineffective *)
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu1,tr1],0],sp=sp1,time=time,op=Sequence@@dinvopts},
			PrintCall[Global`fg1[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=DInv[tr,so,trinv,Species->sp,Method->"NDInv",Time->time,op]]]
	];	
	fg1[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=((*fg1[\[FormalX],\[FormalY]]=*)Module[{dinv},
		dinv=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu1,tr1],0],Species->sp1,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall];
		If[printtrace,Print["fg1 ",{trait1->\[FormalX],trait2->\[FormalY]},"=",dinv]];
		Return[dinv]
	])/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY]);
	If[usesymmetry&&{gu1,tr1}==={gu2,tr2},
		fg2[\[FormalX]_,\[FormalY]_]:=fg1[\[FormalY],\[FormalX]];
		If[verbose,Print[func,": fg2[\[FormalX]_,\[FormalY]_]:=fg1[\[FormalY],\[FormalX]]"]];
	,
		If[verbose,
			With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu2,tr2],0],sp=sp2,time=time,op=Sequence@@dinvopts},
				PrintCall[Global`fg2[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=DInv[tr,so,trinv,Species->sp,Method->"NDInv",Time->time,op]]]
		];	
		fg2[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=((*fg2[\[FormalX],\[FormalY]]=*)Module[{dinv},
			dinv=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu2,tr2],0],Species->sp2,
				Method->"NDInv",Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall];
			If[printtrace,Print["fg2 ",{trait1->\[FormalX],trait2->\[FormalY]},"=",dinv]];	
			Return[dinv]
		])/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	fitnessgradient=="DInv"
,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu1,tr1],0],sp=sp1,time=time,op=Sequence@@dinvopts},
			PrintCall[Global`fg1[(System`\[FormalX])_,(System`\[FormalY])_]=DInv[tr,so,trinv,Species->sp,Time->time,op]]]
	];
	fg1[\[FormalX]_,\[FormalY]_]=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu1,tr1],0],Species->sp1,
		Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall];
	If[verbose,Print[func,": fg1[\[FormalX],\[FormalY]]=",fg1[\[FormalX],\[FormalY]]]];
	
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu2,tr2],0],sp=sp2,time=time,op=Sequence@@dinvopts},
			PrintCall[Global`fg2[(System`\[FormalX])_,(System`\[FormalY])_]=DInv[tr,so,trinv,Species->sp,Time->time,op]]]
	];
	fg2[\[FormalX]_,\[FormalY]_]=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu2,tr2],0],Species->sp2,
		Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall];
	If[verbose,Print[func,": fg2[\[FormalX],\[FormalY]]=",fg2[\[FormalX],\[FormalY]]]];
,
	Else,
	Msg[PlotEvoStreams::badfg];Return[$Failed];
];

(*Print["fg1[-1,-1]=",fg1[-1,-1]];*)

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{trait1,"=",Dynamic[x]},{trait2,"=",Dynamic[y]}}],WindowTitle->"PlotEvoStreams Progress..."]];
];

Which[
	evoeqn=="QG",
	pre1[_,_]=pre2[_,_]=1,
	evoeqn=="CE",
	pre1[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=
		Sum[If[gcomptype[gu1,gco]=="Extensive",Evaluate[Subscript[gcomp[gu1,gco],sp1]/.sol[\[FormalX],\[FormalY]],0]],{gco,ngcomps[gu1]}]/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max);
	pre2[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=
		Sum[If[gcomptype[gu2,gco]=="Extensive",Evaluate[Subscript[gcomp[gu2,gco],sp2]/.sol[\[FormalX],\[FormalY]],0]],{gco,ngcomps[gu2]}]/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max);
];

res=StreamPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[{
	pre1[\[FormalX],\[FormalY]]*(g[gu1][[tr1,tr1]]*fg1[\[FormalX],\[FormalY]]+If[gu1==gu2&&sp1==sp2,g[gu1][[tr1,tr2]]*fg2[\[FormalX],\[FormalY]],0]),
	pre2[\[FormalX],\[FormalY]]*(g[gu2][[tr2,tr2]]*fg2[\[FormalX],\[FormalY]]+If[gu1==gu2&&sp1==sp2,g[gu2][[tr1,tr2]]*fg1[\[FormalX],\[FormalY]],0])
	}]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},
	FrameLabel->framelabel,Evaluate[Sequence@@streamplotopts]];

If[monitor,NotebookClose[nb]];

Return[res]

]];


PlotEvoStreams[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoStreams[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts]


Options[PlotEvoStreams]={Fixed->{},Time->t,FindEcoAttractorOpts->{},DInvOpts->{},
FrameLabel->Automatic,StreamStyle->Gray,
UseSymmetry->False,FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,
Monitor->False,PrintTrace->False,Verbose->False,VerboseAll->False};


PlotEvoIsoclines[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoIsoclines"],
(* options *)
verbose,verboseall,fixed,time,
evoeqn,monitor,printtrace,fitnessgradient,dinvopts,findecoattractoropts,plotopts,framelabel,ics,ecoattnum,
estest,isoclinestyle,delaydinv2,dinv2opts,excludediagonal,
(* other variables *)
nb,x,y,
ics1,color1,color1es,color1nes,color2,color2es,color2nes,style1,style1es,style1nes,style2,style2es,style2nes,
g,sol,fg1,fg2,dinv21,dinv22,gu1,tr1,sp1,gu2,tr2,sp2,pre1,pre2,iso1,iso2},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ecoattnum=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
estest=Evaluate[ESTest/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv2=Evaluate[DelayDInv2/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinv2opts=Evaluate[DInv2Opts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
excludediagonal=Evaluate[ExcludeDiagonal/.Flatten[{opts,Options[PlotEvoIsoclines]}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[excludediagonal&&{gu1,tr1}=={gu2,tr2},AppendTo[plotopts,Exclusions->{\[FormalX]==\[FormalY]}]];

If[isoclinestyle===Automatic,
	color1es=color1nes=color1=color[trait1][0];
	color2es=color2nes=color2=color[trait2][1];
	style1es=Thick;style1nes=Thin;style1=Thickness[Medium];
	style2es=Thick;style2nes=Thin;style2=Thickness[Medium];
,
	If[ListQ[isoclinestyle[[1]]],
		color1es=ExtractColors[isoclinestyle[[1,1]]];
		color1nes=ExtractColors[isoclinestyle[[1,2]]];
		style1es=Complement[isoclinestyle[[1,1]],color1es];
		style1nes=Complement[isoclinestyle[[1,2]],color1nes];
	,
		color1=ExtractColors[isoclinestyle[[1]]];
		style1=Complement[isoclinestyle[[1,1]],color1];
	];
	If[ListQ[isoclinestyle[[2]]],
		color2es=ExtractColors[isoclinestyle[[2,1]]];
		color2nes=ExtractColors[isoclinestyle[[2,2]]];
		style2es=Complement[isoclinestyle[[2,1]],color2es];
		style2nes=Complement[isoclinestyle[[2,2]],color2nes];
	,
		color2=ExtractColors[isoclinestyle[[2]]];
		style2=Complement[isoclinestyle[[2,1]],color2];
	];
];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[trait[gu1,tr1],sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* set up G matrices *)

Do[
	g[gu]=If[MatrixQ[G[gu]/.Gs],
		G[gu]/.Gs,
		DiagonalMatrix[Table[If[NumberQ[V[trait[gu,tr]]/.Gs],V[trait[gu,tr]]/.Gs,1],{tr,ntraits[gu]}]]
	];
,{gu,nguilds}];

(* set up sol *)

If[solin==="FindEcoAttractor",
	fitnessgradient="NDInv";
	delaydinv2=True;
	If[ics=={},
		(* figure out number of species in guilds *)
		SetNsp[Join[fixed,{trait1->trait1}]];
		ics1=DefaultICs;
		SetNsp[Join[fixed,{trait1->trait1,trait2->trait2}]];
		If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,nguilds}]]];
		ics=DefaultICs;
	];
	If[{gu1,tr1}=={gu2,tr2},
		sol[\[FormalX]_?NumberQ,\[FormalX]_?NumberQ]:=sol[\[FormalX],\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX]}],ics1,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			Return[Join[result,Table[Subscript[gcomp[gu1,gco],sp2]->0,{gco,ngcomps[gu1]}]]]
		]
	];
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics=ics,time=time,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[System`\[FormalX],System`\[FormalY]]=
			FindEcoAttractor[tr,ics,Time->time,op]]]
	];
	sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
		result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["FindEcoAttractor ",{trait1->\[FormalX],trait2->\[FormalY]},"=",result]];
		If[ArrayDepth[result]<2,Return[result],Print[result," ",ArrayDepth[result]];Return[result[[ecoattnum]]]]
	];
, (* sol given *)
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]]
];

(* set up fitness gradients *)

Which[
	fitnessgradient=="NDInv"
,
	(* memoization seems ineffective *)
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu1,tr1],0],sp=sp1,time=time,op=Sequence@@dinvopts},
			PrintCall[Global`fg1[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=DInv[tr,so,trinv,Species->sp,Method->"NDInv",Time->time,op]]]
	];	
	fg1[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=(*fg1[\[FormalX],\[FormalY]]=*)Module[{dinv},
		dinv=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu1,tr1],0],Species->sp1,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall];
		If[printtrace,Print["fg1 ",{trait1->\[FormalX],trait2->\[FormalY]},"=",dinv]];
		Return[dinv]
	]/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max);
	
	(* If[True||{gu1,tr1}=!={gu2,tr2}, symmetricizing turned off for now *)
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu2,tr2],0],sp=sp2,time=time,op=Sequence@@dinvopts},
			PrintCall[Global`fg2[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=
				DInv[tr,so,trinv,Species->sp,Method->"NDInv",Time->time,op]]]
	];
	fg2[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=(*fg2[\[FormalX],\[FormalY]]=*)Module[{dinv},
		dinv=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu2,tr2],0],Species->sp2,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall];
		If[printtrace,Print["fg2 ",{trait1->\[FormalX],trait2->\[FormalY]},"=",dinv]];	
		Return[dinv]
	]/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max);
	(* leftover symmetrizing bit ,fg2[\[FormalX]_,\[FormalY]_]:=fg1[\[FormalY],\[FormalX]];
	If[verbose,Print[func,": fg2[\[FormalX]_,\[FormalY]_]:=fg1[\[FormalY],\[FormalX]]"]]*)
,
	fitnessgradient=="DInv"
,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu1,tr1],0],sp=sp1,time=time,op=Sequence@@dinvopts},
			PrintCall[Global`fg1[(System`\[FormalX])_,(System`\[FormalY])_]=DInv[tr,so,trinv,Species->sp,Time->time,op]]]
	];
	fg1[\[FormalX]_,\[FormalY]_]=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu1,tr1],0],Species->sp1,
		Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall];
	If[verbose,Print[func,": fg1[\[FormalX],\[FormalY]]=",fg1[\[FormalX],\[FormalY]]]];
	
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],trinv=Subscript[trait[gu2,tr2],0],sp=sp2,time=time,op=Sequence@@dinvopts},
			PrintCall[Global`fg2[(System`\[FormalX])_,(System`\[FormalY])_]=DInv[tr,so,trinv,Species->sp,Time->time,op]]]
	];
	fg2[\[FormalX]_,\[FormalY]_]=DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],Subscript[trait[gu2,tr2],0],Species->sp2,
		Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall
	];
	If[verbose,Print[func,": fg2[\[FormalX],\[FormalY]]=",fg2[\[FormalX],\[FormalY]]]];
,
	Else,
	Msg[PlotEvoStreams::badfg];Return[$Failed];
];

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{trait1,"=",Dynamic[x]},{trait2,"=",Dynamic[y]}}],WindowTitle->"Progress..."]];
];

Which[
	evoeqn=="QG",
	pre1[_,_]=pre2[_,_]=1,
	evoeqn=="CE",
	pre1[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=
		Sum[If[gcomptype[gu1,gco]=="Extensive",Evaluate[Subscript[gcomp[gu1,gco],sp1]/.sol[\[FormalX],\[FormalY]],0]],{gco,ngcomps[gu1]}]/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max);
	pre2[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=
		Sum[If[gcomptype[gu2,gco]=="Extensive",Evaluate[Subscript[gcomp[gu2,gco],sp2]/.sol[\[FormalX],\[FormalY]],0]],{gco,ngcomps[gu2]}]/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max);
];

iso1=ContourPlot[({x,y}={\[FormalX],\[FormalY]};
	Evaluate[pre1[\[FormalX],\[FormalY]]*(g[gu1][[tr1,tr1]]*fg1[\[FormalX],\[FormalY]]+If[gu1==gu2&&sp1==sp2,g[gu1][[tr1,tr2]]*fg2[\[FormalX],\[FormalY]],0])]),
	{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Contours->{0},ContourShading->False,
	ContourStyle->Flatten[{color1,style1}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait1]&}
];
If[Global`debug,Print[iso1]];

(* add flip option to save 50% time *)

iso2=ContourPlot[({x,y}={\[FormalX],\[FormalY]};
	Evaluate[pre2[\[FormalX],\[FormalY]]*(g[gu2][[tr2,tr2]]*fg2[\[FormalX],\[FormalY]]+If[gu1==gu2&&sp1==sp2,g[gu2][[tr1,tr2]]*fg1[\[FormalX],\[FormalY]],0])]),
	{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Contours->{0},ContourShading->False,
	ContourStyle->Flatten[{color2,style2}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait2]&}];
If[Global`debug,Print[iso2]];

Clear[x,y];
If[monitor,NotebookClose[nb]];

If[estest==False,Return[Show[iso1,iso2,FrameLabel->framelabel]]];

(* ESTest\[Equal]True *)

If[delaydinv2,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[trait[gu1,tr1],0],2},trinv2={Subscript[trait[gu2,tr2],0],2},time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv21[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv1,ts1,Method->"NDInv",Time->time,op]];
			PrintCall[Global`dinv22[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv22[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv2,ts2,Method->"NDInv",Time->time,op]]
	]];		
	dinv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv21[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[trait[gu1,tr1],0],2},Species->sp1,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	dinv22[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv22[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[trait[gu2,tr2],0],2},Species->sp2,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[trait[gu1,tr1],0],2},trinv2={Subscript[trait[gu2,tr2],0],2},sp1=sp1,sp2=sp2,
			time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv1,Species->sp1,Time->time,op]];
			PrintCall[Global`dinv22[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv2,Species->sp2,Time->time,op]]
	]];
	dinv21[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[trait[gu1,tr1],0],2},Species->sp1,
			Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	dinv22[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[trait[gu2,tr2],0],2},Species->sp2,
			Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	If[verbose,
		Print[func,": dinv21[\[FormalX],\[FormalY]]=",dinv21[\[FormalX],\[FormalY]]];
		Print[func,": dinv22[\[FormalX],\[FormalY]]=",dinv22[\[FormalX],\[FormalY]]]
	]
];

Return[Show[
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]>0,color1nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]<0,color1es,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]>0,color2nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]<0,color2es,{Opacity[0]}]]&)],
	Frame->True,Axes->False,AspectRatio->1,FrameLabel->framelabel,PlotRange->{{trait1min,trait1max},{trait2min,trait2max}}
]]

]];

Options[PlotEvoIsoclines]={Fixed->{},Time->t,
	FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,ExcludeDiagonal->True,
	FindEcoAttractorOpts->{},DInvOpts->{},PlotOpts->{},FrameLabel->Automatic,
	ESTest->True,DelayDInv2->False,DInv2Opts->{},IsoclineStyle->Automatic,
	Verbose->False,VerboseAll->False,Monitor->False,PrintTrace->False};


PlotEvoIsoclines[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoIsoclines[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts];


(* two guilds *)
PlotEvoPhasePlane[{eq11:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq12:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Gu)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[{eq11,eq12},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two species *)
PlotEvoPhasePlane[eq1:(_?RuleListQ):"FindEcoAttractor",eq2:(_?RuleListQ):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Sp)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[eq1,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two traits *)
PlotEvoPhasePlane[eq0:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Tr)"],
(* options *)
plotzipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
invader,pes,pei,zip},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotzipopts=FilterRules[Flatten[{Evaluate[PlotZIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotZIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

invader=(Guild->LookUp[trait1][[2]]);

pes=PlotEvoStreams[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
zip=PlotZIP[eq0,{(trait1/.Subscript[x_,_]->Subscript[x,0]),trait1min,trait1max},{(trait2/.Subscript[x_,_]->Subscript[x,0]),trait2min,trait2max},
invader,InvStyle->Opacity[0],Evaluate[Sequence@@plotzipopts]];
If[Global`debug,Print[zip]];

Return[Show[pes,pei,zip]]
];


(* two traits - no eq0 alias *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
PlotEvoPhasePlane["FindEcoAttractor",eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts];


Options[PlotEvoPhasePlane]={PlotMIPOpts->{},PlotZIPOpts->{},PlotEvoIsoclinesOpts->{},PlotEvoStreamsOpts->{}};


EcoEvoSim[traits_?TraitsQ,pops_?VariablesQ,Gs:(_?GsQ):{},tmax_?NumericQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoSim"],
(* options *)
verbose,verboseall,
boundarydetection,dinvopts,ndsolveopts,wheneventopts,delaydinv,evoeqn,fixed,traitshiftrate,tmin,outputtmin,output,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,dtrait,g,tic,wt,pre,fg,dtraitdt,rhs,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoSim]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoSim]}]];
If[verboseall,verbose=True];

boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoSim]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
If[modelperiod=!=0,AppendTo[dinvopts,InvOpts->{Method->"Instantaneous"}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EcoEvoSim]}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[EcoEvoSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoSim]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[EcoEvoSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoSim]}]];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[pops,fixedvariables]];
(*Print["Nsp=",Table[Nsp[gu],{gu,nguilds}]];*)

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* shifting traits *)
Do[Do[
	dtrait[gu,tr]=If[MemberQ[traitshiftrate[[All,1]],trait[gu,tr]],trait[gu,tr]/.traitshiftrate,0]
,{tr,ntraits[gu]}],{gu,nguilds}];
If[Global`debug,Print[func,": dtrait=",Table[Table[dtrait[gu,tr],{tr,ntraits[gu]}],{gu,nguilds}]]];

(* set up G matrix *)

Do[
	g[gu]=If[MatrixQ[G[gu]/.Gs],
		G[gu]/.Gs,
		DiagonalMatrix[Table[V[trait[gu,tr]]/.Gs/.V[trait[gu,tr]]->1,{tr,ntraits[gu]}]]
	];
,{gu,nguilds}];

(* construct equations *)

eqns={}; ics={}; unks={}; discretevars={};

Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[gcomp[gu,gco],sp]],
		AppendTo[eqns,DT[Subscript[gcomp[gu,gco],sp]]==gcompeqn[gu,gco][sp]/.fixed/.AddTraitts];
		AppendTo[ics,Subscript[gcomp[gu,gco],sp][tic]==(Subscript[gcomp[gu,gco],sp]/.pops)];
		AppendTo[unks,Subscript[gcomp[gu,gco],sp]];
	]
,{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}];

Do[Do[
	If[!MemberQ[fixedvars,pcomp[pop,pco]],
		AppendTo[eqns,DT[pcomp[pop,pco]]==pcompeqn[pop,pco]/.fixed/.AddTraitts];
		AppendTo[ics,pcomp[pop,pco][tic]==(pcomp[pop,pco]/.pops)];
		AppendTo[unks,pcomp[pop,pco]];
	]
,{pco,npcomps[pop]}],{pop,npops}];

Do[
	If[!MemberQ[fixedvars,aux[au]],
		AppendTo[eqns,DT[aux[au]]==auxeqn[au]/.fixed/.AddTraitts];
		AppendTo[ics,aux[au][tic]==(aux[au]/.pops)];
		AppendTo[unks,aux[au]];
	]
,{au,naux}];

(* traiteqns / traitunks *)

Which[
	evoeqn=="QG",
	Do[Do[pre[gu,sp]=1,{sp,Nsp[gu]}],{gu,nguilds}]
	,
	evoeqn=="CE",
	Do[
		Do[
			If[gcomptype[gu,gco]=="Extensive",wt[gu,gco]=1,wt[gu,gco]=0]
		,{gco,ngcomps[gu]}];
		Do[
			pre[gu,sp]:=Sum[wt[gu,gco]*Subscript[gcomp[gu,gco],sp][t],{gco,ngcomps[gu]}]
		,{sp,Nsp[gu]}]
	,{gu,nguilds}],
	Else,
	Msg[EcoEvoSim::badte];
	Return[$Failed]
];

(* compute fitness gradient fg *)

If[delaydinv==True,
	fg[gu0_,sp0_,tr0_,traitvals_?NumericFlattenedListQ,popvals_?NumericFlattenedListQ]:=
		DInv[
			Flatten[Table[Table[Table[Subscript[trait[gu,tr],sp]->traitvals[[gu,sp,tr]],{tr,ntraits[gu]}],{sp,Nsp[gu]}],{gu,nguilds}]],
			Flatten[Join[				
				Table[Table[Table[Subscript[gcomp[gu,gco],sp]->popvals[[1,gu,sp,gco]],{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}],
				Table[Table[pcomp[pop,pco]->popvals[[2,pop,pco]],{pco,npcomps[pop]}],{pop,npops}],
				Table[aux[au]->popvals[[3,au]],{au,naux}]
			]],
			{Subscript[trait[gu0,tr0],0],1},
			Species->sp0,
			Method->"NDInv",
			Evaluate[Sequence@@dinvopts]
		];
	dtraitdt[gu_,tr_,sp_,traitvals_?NumericFlattenedListQ,popvals_?NumericFlattenedListQ]:=
		pre[gu,sp]*Sum[fg[gu,sp,tr1,traitvals,popvals]*g[gu][[tr,tr1]],{tr1,ntraits[gu]}];
	, (* else *)
	Do[
		fg=DInv[
			BlankTraits,BlankVariables,
			{Table[Subscript[trait[gu0,tr],0],{tr,ntraits[gu0]}],1},
			(*Guild\[Rule]gu0,*)
			Evaluate[Sequence@@dinvopts],VerboseAll->verboseall
		]/.fixed;
		If[Global`debug,Print[func,": fg[",gu0,"]=",fg]];
		Do[Do[
			dtraitdt[gu0,tr,sp]=pre[gu0,sp]*Sum[fg[[sp,tr1]]*g[gu0][[tr,tr1]],{tr1,ntraits[gu0]}]
				/.Table[Subscript[trait[gu0,tr1],0]->Subscript[trait[gu0,tr1],sp],{tr1,ntraits[gu0]}]
				/.fixed/.AddTraitts/.AddPopts
		,{tr,ntraits[gu0]}],{sp,Nsp[gu0]}];
	,{gu0,nguilds}]
];

Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[trait[gu,tr],sp]],
		If[delaydinv==True,
			rhs[gu,tr,sp]:=(dtraitdt[gu,tr,sp,
				Table[Table[Table[Subscript[trait[gu1,tr1],sp1][t],{tr1,ntraits[gu1]}],{sp1,Nsp[gu1]}],{gu1,nguilds}],
				{Table[Table[Table[Subscript[gcomp[gu1,gco1],sp1][t],{gco1,ngcomps[gu1]}],{sp1,Nsp[gu1]}],{gu1,nguilds}],
				Table[Table[pcomp[pop1,pco1][t],{pco1,npcomps[pop1]}],{pop1,npops}],
				Table[aux[au1][t],{au1,naux}]}
				]-dtrait[gu,tr]);
		,
			rhs[gu,tr,sp]:=dtraitdt[gu,tr,sp]-dtrait[gu,tr];
		];
		Which[
			modeltype=="ContinuousTime",
			AppendTo[eqns,Subscript[trait[gu,tr],sp]'[t]==in[gu,tr,sp][t]*rhs[gu,tr,sp]],
			modeltype=="DiscreteTime",
			If[boundarydetection==True,
				AppendTo[eqns,Subscript[trait[gu,tr],sp][t+1]==Max[Min[traitrange[gu,tr]],Min[Max[traitrange[gu,tr]],Subscript[trait[gu,tr],sp][t]+rhs[gu,tr,sp]]]],
				AppendTo[eqns,Subscript[trait[gu,tr],sp][t+1]==Subscript[trait[gu,tr],sp][t]+rhs[gu,tr,sp]]
			];
		];
		AppendTo[ics,Subscript[trait[gu,tr],sp][tic]==(Subscript[trait[gu,tr],sp]/.traits)];
		AppendTo[unks,Subscript[trait[gu,tr],sp]];
		If[modeltype=="ContinuousTime",AppendTo[ics,in[gu,tr,sp][tic]==1]];
		AppendTo[discretevars,in[gu,tr,sp]]
	];
,{tr,ntraits[gu]}],{sp,Nsp[gu]}],{gu,nguilds}];

(* boundary detection *)

If[boundarydetection==True,
	bdwhens=Flatten[Table[Table[Table[{
		WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.
		{event->Subscript[trait[gu,tr],sp][t]>Max[traitrange[gu,tr]],action->in[gu,tr,sp][t]->0},
		WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.
		{event->Subscript[trait[gu,tr],sp][t]<Min[traitrange[gu,tr]],action->in[gu,tr,sp][t]->0},
		WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.
			{event->rhs[gu,tr,sp]>0&&Subscript[trait[gu,tr],sp][t]==Min[traitrange[gu,tr]],
			action->in[gu,tr,sp][t]->1},
		WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.
			{event->rhs[gu,tr,sp]<0&&Subscript[trait[gu,tr],sp][t]==Max[traitrange[gu,tr]],
			action->in[gu,tr,sp][t]->1}
	},{tr,ntraits[gu]}],{sp,Nsp[gu]}],{gu,nguilds}]];
,
	bdwhens={}
];

If[verbose,
	Print[func,": eqns="];
	Print[eqns];
	Print[func,": ics="];
	Print[ics];
	Print[func,": unks="];
	Print[unks];
	Print[func,": bdwhens="];
	Print[bdwhens];
	Print[func,": discretevars="];
	Print[discretevars];
];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	(*sol=NDSolve[Join[eqns,ics,modelwhenevents,whenevents]/.traits/.fixed2,unks,{t,tmin,tmax},Evaluate[Sequence@@ndsolveopts]]\[LeftDoubleBracket]1\[RightDoubleBracket];*)
	On[NDSolve::wenset];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TD[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
];

(*Print["sol=",sol];
Print["Join[AllVariables,AllTraits]=",Join[AllVariables,AllTraits]];*)

If[output=="FinalSlice",Return[VarSort[Chop[Join[FinalSlice[sol],fixed]],Join[AllVariables,AllTraits]]]];

Return[VarSort[Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]],
	Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoSim]=
	{Fixed->{},BoundaryDetection->False,
	NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
	TMin->0,OutputTMin->0,Output->"Dynamics",
	Verbose->False,VerboseAll->False};


EcoEvoSim[sol_?TraitsAndVariablesQ,Gs:(_?RuleListQ):{},tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],Gs,tmax,opts];


FindEcoEvoEq[traits_?TraitsQ,pops_?VariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoEq"],
(* options *)
verbose,verboseall,method,percapita,boundarydetection,dinvopts,ndsolveopts,wheneventopts,delaydinv,evoeqn,fixed,traitshiftrate,findrootopts,chop,
(* rules *)
removets,tounks,fromunks,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,dtrait,g,wt,pre,fg,dtraitdt,rhs,eqns,unks,newunk,sol},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoEq]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[FindEcoEvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[FindEcoEvoEq]}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[FindEcoEvoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoEq]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[FindEcoEvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoEq]}]];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[pops,fixedvariables]];

(* shifting traits *)
Do[
	dtrait[gu,tr]=If[MemberQ[traitshiftrate[[All,1]],trait[gu,tr]],trait[gu,tr]/.traitshiftrate,0]
,{gu,nguilds},{tr,ntraits[gu]}];
If[Global`debug,Print[func,": dtrait=",Table[dtrait[gu,tr],{gu,nguilds},{tr,ntraits[gu]}]]];

(* set up G matrix *)
Do[
	g[gu]=If[MatrixQ[G[gu]/.Gs],
		G[gu]/.Gs,
		DiagonalMatrix[Table[V[trait[gu,tr]]/.Gs/.V[trait[gu,tr]]->1,{tr,ntraits[gu]}]]
	]
,{gu,nguilds}];


(* subrule to remove [t]'s *)

removets=Flatten[Join[
	Table[Table[Table[Subscript[gcomp[gu,gco],sp][t]->Subscript[gcomp[gu,gco],sp],{sp,Nsp[gu]}],{gco,ngcomps[gu]}],{gu,nguilds}],
	Table[Table[pcomp[pop,pco][t]->pcomp[pop,pco],{pco,npcomps[pop]}],{pop,npops}],
	Table[aux[au][t]->aux[au],{au,naux}]
]];

(* construct equations & to/from unksrules *)

eqns=unks={};
tounks=fromunks={};

Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[gcomp[gu,gco],sp]],
		If[percapita&&gcomptype[gu,gco]=="Extensive",
			AppendTo[eqns,If[modeltype=="ContinuousTime",0,1]==gcompeqn[gu,gco][sp]/Subscript[gcomp[gu,gco],sp]/.removets/.fixed],
			AppendTo[eqns,If[modeltype=="ContinuousTime",0,Subscript[gcomp[gu,gco],sp]]==gcompeqn[gu,gco][sp]/.removets/.fixed]
		];
		AppendTo[tounks,Subscript[gcomp[gu,gco],sp]->unk[gcomp[gu,gco],sp]];
		AppendTo[fromunks,unk[gcomp[gu,gco],sp]->Subscript[gcomp[gu,gco],sp]];
		newunk={unk[gcomp[gu,gco],sp],Subscript[gcomp[gu,gco],sp]/.pops};
		If[method=="Secant",AppendTo[newunk,(Subscript[gcomp[gu,gco],sp]/.pops)+0.001]];
		If[boundarydetection,newunk=Join[newunk,{Min[gcomprange[gu,gco]],Max[gcomprange[gu,gco]]}]];
		AppendTo[unks,newunk];
	];
,{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}];

Do[Do[
	If[!MemberQ[fixedvars,pcomp[pop,pco]],
		If[percapita&&pcomptype[pop,pco]=="Extensive",
			AppendTo[eqns,If[modeltype=="ContinuousTime",0,1]==pcompeqn[pop,pco]/pcomp[pop,pco]/.removets/.fixed],
			AppendTo[eqns,If[modeltype=="ContinuousTime",0,pcomp[pop,pco]]==pcompeqn[pop,pco]/.removets/.fixed]
		];
		AppendTo[tounks,pcomp[pop,pco]->unk[pcomp[pop,pco]]];
		AppendTo[fromunks,unk[pcomp[pop,pco]]->pcomp[pop,pco]];
		newunk={unk[pcomp[pop,pco]],pcomp[pop,pco]/.pops};
		If[method=="Secant",AppendTo[newunk,(pcomp[pop,pco]/.pops)+0.001]];
		If[boundarydetection,newunk=Join[newunk,{Min[pcomprange[pop,pco]],Max[pcomprange[pop,pco]]}]];
		AppendTo[unks,newunk];
	];
,{pco,npcomps[pop]}],{pop,npops}];

Do[
	If[!MemberQ[fixedvars,aux[au]],
		AppendTo[eqns,If[modeltype=="ContinuousTime",0,aux[u]]==auxeqn[au]/.removets/.fixed];
		AppendTo[tounks,aux[au]->unk[aux[au]]];
		AppendTo[fromunks,unk[aux[au]]->aux[au]];
		newunk={unk[aux[au]],aux[au]/.pops};
		If[method=="Secant",AppendTo[newunk,(aux[au]/.pops)+0.001]];
		If[boundarydetection,newunk=Join[newunk,{Min[auxrange[au]],Max[auxrange[au]]}]];
		AppendTo[unks,newunk];
	];
,{au,naux}];

(* traiteqns / traitunks *)

Which[
	evoeqn=="QG",
	Do[Do[pre[gu,sp]=1,{sp,Nsp[gu]}],{gu,nguilds}],
	evoeqn=="CE",
	Do[
		Do[
			If[gcomptype[gu,gco]=="Extensive",wt[gu,gco]=1,wt[gu,gco]=0]
		,{gco,ngcomps[gu]}];
		Do[
			pre[gu,sp]:=Sum[wt[gu,gco]*Subscript[gcomp[gu,gco],sp],{gco,ngcomps[gu]}]
		,{sp,Nsp[gu]}]
	,{gu,nguilds}],
	Else,
	Msg[EcoEvoEq::badte];
	Return[$Failed]
];

(* compute fitness gradient fg *)

If[delaydinv==True,
	fg[gu0_,sp0_,tr0_,traitvals_?NumericFlattenedListQ,popvals_?NumericFlattenedListQ]:=
		DInv[			
			Flatten[Table[Table[Table[Subscript[trait[gu,tr],sp]->traitvals[[gu,sp,tr]],{tr,ntraits[gu]}],{sp,Nsp[gu]}],{gu,nguilds}]],
			Flatten[Join[				
				Table[Table[Table[Subscript[gcomp[gu,gco],sp]->popvals[[1,gu,sp,gco]],{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}],
				Table[Table[pcomp[pop,pco]->popvals[[2,pop,pco]],{pco,npcomps[pop]}],{pop,npops}],
				Table[aux[au]->popvals[[3,au]],{au,naux}]
			]],
			{Subscript[trait[gu0,tr0],0],1},
			Species->sp0,
			Method->"NDInv",Evaluate[Sequence@@dinvopts]
		];
	dtraitdt[gu_,tr_,sp_,traitvals_?NumericFlattenedListQ,popvals_?NumericFlattenedListQ]:=
		pre[gu,sp]*Sum[fg[gu,sp,tr1,traitvals,popvals]*g[gu][[tr,tr1]],{tr1,ntraits[gu]}];
	, (* else *)
	Do[
		fg=DInv[
			BlankTraits,
			BlankVariables,
			{Table[Subscript[trait[gu0,tr],0],{tr,ntraits[gu0]}],1},
			Evaluate[Sequence@@dinvopts],VerboseAll->verboseall
		]/.fixed;
		If[Global`debug,Print[func,": fg[",gu0,"]=",fg]];
		Do[Do[
			dtraitdt[gu0,tr,sp]=pre[gu0,sp]*Sum[fg[[sp,tr1]]*g[gu0][[tr,tr1]],{tr1,ntraits[gu0]}]
				/.Table[Subscript[trait[gu0,tr1],0]->Subscript[trait[gu0,tr1],sp],{tr1,ntraits[gu0]}]
				/.fixed
		,{tr,ntraits[gu0]}],{sp,Nsp[gu0]}];
	,{gu0,nguilds}]
];

Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[trait[gu,tr],sp]],
		If[delaydinv==True,
			rhs[gu,tr,sp]:=(dtraitdt[gu,tr,sp,
				Table[Table[Table[Subscript[trait[gu1,tr1],sp1],{tr1,ntraits[gu1]}],{sp1,Nsp[gu1]}],{gu1,nguilds}],
				{Table[Table[Table[Subscript[gcomp[gu1,gco1],sp1],{gco1,ngcomps[gu1]}],{sp1,Nsp[gu1]}],{gu1,nguilds}],
				Table[Table[pcomp[pop1,pco1],{pco1,npcomps[pop1]}],{pop1,npops}],
				Table[aux[au1],{au1,naux}]}
				]-dtrait[gu,tr]);
		,
			rhs[gu,tr,sp]:=dtraitdt[gu,tr,sp]-dtrait[gu,tr];
		];
		AppendTo[eqns,0==rhs[gu,tr,sp]];
		AppendTo[tounks,Subscript[trait[gu,tr],sp]->unk[trait[gu,tr],sp]];
		AppendTo[fromunks,unk[trait[gu,tr],sp]->Subscript[trait[gu,tr],sp]];
		newunk={unk[trait[gu,tr],sp],Subscript[trait[gu,tr],sp]/.traits};
		If[method=="Secant",AppendTo[newunk,(Subscript[trait[gu,tr],sp]/.traits)+0.001]];
		If[boundarydetection,newunk=Join[newunk,{Min[traitrange[gu,tr]],Max[traitrange[gu,tr]]}]];
		AppendTo[unks,newunk];
	];
,{tr,ntraits[gu]}],{sp,Nsp[gu]}],{gu,nguilds}];

If[verbose,
	Print[func,": eqns="];
	Print[eqns];
	Print[func,": unks="];
	Print[unks/.fromunks];
];

(* solve it *)

sol=FindRoot[eqns/.tounks,unks,Evaluate[Sequence@@findrootopts]];

If[Global`debug,
	Print[func,": sol="];
	Print[sol];
];

If[chop,
	Return[VarSort[Chop[Join[sol,fixed]/.fromunks],Join[AllVariables,AllTraits]]],
	Return[VarSort[Join[sol,fixed]/.fromunks,Join[AllVariables,AllTraits]]]
];

]];


Options[FindEcoEvoEq]={Fixed->{},PerCapita->True,BoundaryDetection->False,
	EcoSimOpts->{},DInvOpts->{},FindRootOpts->{},Method->"Newton",
	DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},Chop->True,
	Verbose->False,VerboseAll->False};


FindEcoEvoEq[sol_?TraitsAndVariablesQ,Gs_:{},opts___?OptionQ]:=FindEcoEvoEq[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


FindEcoCycleEvoEq[traits_?TraitsQ,pops_?VariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoCycleEvoEq (Periodic)"],
(* options *)
verbose,verboseall,method,findrootopts,dinvopts,ecosimopts,monitor,fixed,traitshiftrate,maxiterations,accuracygoal,
(* other variables *)
fixedvars,fixedtraits,nonfixedtraits,nonfixedvars,dtrait,v,popz,traitz,
tstart,tinics,thing,eqns,popunks,unksics,traitunks,popics,traitics,sol,res,fromunks,nb},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
maxiterations=Evaluate[MaxIterations/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];
accuracygoal=Evaluate[AccuracyGoal/.Flatten[{opts,Options[FindEcoCycleEvoEq]}]];

fixedtraits=ExtractTraits[fixed][[All,1]];
fixedvars=ExtractVariables[fixed][[All,1]];

(* figure out number of species in guilds *)
SetNsp[Join[traits,ExtractTraits[fixed]],Join[pops,ExtractVariables[fixed]]];

nonfixedtraits=orderedComplement[AllTraits,fixedtraits];
nonfixedvars=orderedComplement[AllVariables,fixedvars];
(*Print["nonfixedtraits=",nonfixedtraits];
Print["nonfixedvars=",nonfixedvars];*)

(* shifting traits *)
Do[Do[
	dtrait[gu,tr]=If[MemberQ[traitshiftrate[[All,1]],trait[gu,tr]],trait[gu,tr]/.traitshiftrate,0]
,{tr,ntraits[gu]}],{gu,nguilds}];
If[Global`debug,Print[func,": dtrait=",Table[Table[dtrait[gu,tr],{tr,ntraits[gu]}],{gu,nguilds}]]];

(* set up vs *)
Do[v[tr]=V[DeleteSubscript@tr]/.Gs/.V[DeleteSubscript@tr]->1,{tr,nonfixedtraits}];

thing[{ps_?NumericListQ,trs_?NumericListQ}]:=Module[{rez,fg},
	$findecocycleevoeqthingcount++;
	popz=Thread[nonfixedvars->ps];
	traitz=Join[Thread[nonfixedtraits->trs],ExtractTraits@fixed];
	sol=EcoSim[traitz,popz,modelperiod,Fixed->(ExtractVariables@fixed),Evaluate[Sequence@@ecosimopts]];
	fg=Flatten[Table[
		v[tr]*NDInv[Join[traitz,fixed//ExtractTraits],sol,tr//ZeroSubscript,{(tr//ZeroSubscript)->(tr/.traitz)},Evaluate[Sequence@@dinvopts]],{tr,nonfixedtraits}]];
	(*Print[fg];*)
	Return[{nonfixedvars/.FinalSlice[sol],fg+trs}]
];

(* for Method FixedPoint *)
popics=nonfixedvars/.pops;
traitics=nonfixedtraits/.traits;

(* for Method FindRoot *)
popunks=nonfixedvars/.Subscript->unk;
traitunks=nonfixedtraits/.Subscript->unk;
unksics=Join[Transpose[{nonfixedvars,popics}],Transpose[{nonfixedtraits,traitics}]]/.Subscript->unk;

If[Global`debug,Print[func,": popunks="];Print[popunks]];
If[Global`debug,Print[func,": traitunks="];Print[traitunks]];
If[Global`debug,Print[func,": unksics="];Print[unksics]];

If[monitor,
	nb=CreateWindow[DialogNotebook[{
	TextCell["evaluation: "],
	Dynamic[$findecocycleevoeqthingcount],
	TextCell["traits:"],
	Dynamic[traitz],
	TextCell["pops:"],
	Dynamic[popz]
	},
	WindowTitle->"FindEcoCycleEvoEq Progress..."]];
];

(* solve it*)

$findecocycleevoeqthingcount=0;
Which[
	method=="FindRoot",
	If[Global`debug,Print[func,": Method FindRoot"]];
	res=FindRoot[thing[{popunks,traitunks}]=={popunks,traitunks},unksics,Evaluate[Sequence@@findrootopts]];
	If[monitor,NotebookClose[nb]];
	Return[Join[Sort[sol],ExtractTraits[res/.FromUnks],fixed]];
,
	method=="FixedPoint",
	If[Global`debug,Print[func,": Method FixedPoint"]];
	res=FixedPoint[thing[#]&,{popics,traitics},maxiterations,SameTest->(Max[Abs[#1-#2]]<10^-accuracygoal&)];
	If[monitor,NotebookClose[nb]];
	If[$findecocycleevoeqthingcount==maxiterations,Msg[FindEcoCycleEvoEq::cvmit,maxiterations]];
	Return[Join[Sort[sol],Thread[nonfixedtraits->res[[2]]],fixed]]
,
	Else,
	Msg[FindEcoCycleEvoEq::badmtd];Return[$Failed]
];

]]/;modelperiod=!=0;


Options[FindEcoCycleEvoEq]={
	BoundaryDetection->False,FindRootOpts->{},Method->"FindRoot",PerCapita->True,
	DInvOpts->{},DelayDInv->False,EvoEquation->"QG",Fixed->{},TraitShiftRate->{},EcoSimOpts->{},Chop->True,MaxIterations->100,AccuracyGoal->6,
	Verbose->False,VerboseAll->False};


FindEcoCycleEvoEq[traitsandvariables_?TraitsAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
FindEcoCycleEvoEq[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],Gs,opts]


EvoEq[traits:(_?TraitsQ):{},sol:(_?VariablesQ):{},Gs_List:{},opts___?OptionQ] :=
 
Module[{
func=FuncStyle["EvoEq"],
(* options *)
verbose,verboseall,method,fixed,delaydinv,solveopts,nsolveopts,findrootopts,findinstanceopts,boundarydetection,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,tounks,fromunks,eqns,unks,res},
   
Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts, Options[EvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts, Options[EvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoEq]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EvoEq]}]];
solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EvoEq]}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EvoEq]}]];
findinstanceopts=Evaluate[FindInstanceOpts/.Flatten[{opts,Options[EvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EvoEq]}]];

(* figure out number of species in guilds *)
(*SetNsp[Join[traits,fixedtraits],Join[sol,fixedvariables]];*)
SetNsp[Join[sol,fixedvariables]];

(* rules to convert to and from unks[] *)

tounks=Flatten@Table[
	(Subscript[trait[gu,tr],sp]->Subscript[trait[gu,tr],sp])->(Subscript[trait[gu,tr],sp]->unk[trait[gu,tr],sp])
,{gu,nguilds},{sp,If[Nsp[gu]==0,0,1],Nsp[gu]},{tr,ntraits[gu]}];

fromunks=Flatten@Table[
	unk[trait[gu,tr],sp]->Subscript[trait[gu,tr],sp]
,{gu,nguilds},{sp,If[Nsp[gu]==0,0,1],Nsp[gu]},{tr,ntraits[gu]}];

(*fromunks=Flatten@Table[unk[trait[gu,tr],sp_]\[Rule]Subscript[trait[gu,tr],sp],{gu,nguilds},{tr,ntraits[gu]}];*)

eqns=EvoEqns[sol,Gs,opts]/.Eq/.RemoveTraitts/.RemovePopts;

unks={};
Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[trait[gu,tr],sp]],
		If[method=="FindRoot",
			If[delaydinv,
				AppendTo[unks,{unk[trait[gu,tr],sp],Subscript[trait[gu,tr],sp]/.traits}],
				AppendTo[unks,{Subscript[trait[gu,tr],sp],Subscript[trait[gu,tr],sp]/.traits}]
			],
			AppendTo[unks,Subscript[trait[gu,tr],sp]]
		]
	]
,{tr,ntraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,nguilds}];

(*If[verbose,Print["eqns="];Print[eqns]];
If[verbose,Print["unks="];Print[unks]];*)

(* solve it *)

Which[
	method=="Solve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@solveopts},
		PrintCall[Global`res=Solve[eqns,unks,op]]]];
	res=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@nsolveopts},
		PrintCall[Global`res=NSolve[eqns,unks,op]]]];
	res=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[delaydinv,
		If[verbose,
			With[{eqns=eqns,unks=unks,op=Sequence@@findrootopts,fromunks=fromunks},
			PrintCall[Global`res=FindRoot[eqns/.tounks,unks,op]/.fromunks]]];
		res=FindRoot[eqns/.tounks,unks,Evaluate[Sequence@@findrootopts]]/.fromunks
	,
		If[verbose,
			With[{eqns=eqns,unks=unks,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns,unks,op]]]];
		res=FindRoot[eqns,unks,Evaluate[Sequence@@findrootopts]]
	],
	method=="FindInstance",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@findinstanceopts},
		PrintCall[Global`res=FindInstance[eqns,unks,op]]]];
	res=FindInstance[eqns,unks,Evaluate[Sequence@@findinstanceopts]],
	Else, (* else *)
	Msg[EvoEq::badmtd];Return[$Failed]
];

If[MemberQ[{Solve,NSolve},Head[res]],
	Msg[EvoEq::nosol];Return[$Failed],
	Return[VarSort[EqSort[Chop[res]],AllTraits]]
];

]];


SolveEvoEq[args___]:=EvoEq[args,Method->"Solve"];
NSolveEvoEq[args___]:=EvoEq[args,Method->"NSolve"];
FindEvoEq[sol:(_?VariablesQ):{},Gs_List:{},opts___?OptionQ]:=EvoEq[sol,Gs,opts,Method->"FindInstance"];
FindEvoEq[args___]:=EvoEq[args,Method->"FindRoot"];


Options[EvoEq]={Method->"None",
DelayDInv->False,DInvOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},FindInstanceOpts->{Reals},
EvoEquation->"QG",BoundaryDetection->False,TraitShiftRate->{},Fixed->{},
Verbose->False,VerboseAll->False};


EcoEvoJacobian[traitsin:(_?TraitsQ):{},popsin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed variables *)
fixedvars,fixedtraits,fixedvariables,
(* other variables *)
traits,pops,eqns,unks,jmat},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
pops=ExpandNspInPops[popsin];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[pops,fixedvariables]];

eqns=Join[EcoEqns[BlankTraits,opts],EvoEqns[BlankVariables,Gs,opts]]/.RHS/.RemoveTraitts/.RemovePopts;

unks={};
Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[gcomp[gu,gco],sp]],AppendTo[unks,Subscript[gcomp[gu,gco],sp]]]
,{gco,ngcomps[gu]}],{sp,Nsp[gu]}],{gu,nguilds}];
Do[Do[
	If[!MemberQ[fixedvars,pcomp[pop,pco]],AppendTo[unks,pcomp[pop,pco]]]
,{pco,npcomps[pop]}],{pop,npops}];
Do[
	If[!MemberQ[fixedvars,aux[au]],AppendTo[unks,aux[au]]]
,{au,naux}];
Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[trait[gu,tr],sp]],AppendTo[unks,Subscript[trait[gu,tr],sp]]]
,{tr,ntraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,nguilds}];

If[verbose,
	Print[func,": eqns="];
	Print[eqns];
	Print[func,": unks="];
	Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[verbose,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.pops/.traits]],
	Return[jmat/.pops/.traits]
];

]];


Options[EcoEvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EcoEvoJacobian[sol_?TraitsAndVariablesQ,Gs_List:{},opts___?OptionQ]:=EcoEvoJacobian[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];
EcoEvoJacobian[___]:=Msg[EcoEvoJacobian::noper]/;modelperiod=!=0;


EcoEvoEigenvalues[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoEigenvalues]}],Options[EcoEvoJacobian]];

	res=Eigenvalues[EcoEvoJacobian[traits,pops,Gs,eejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoEigenvalues]={EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EcoEvoEigenvalues[sol_?TraitsAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
EcoEvoEigenvalues[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


EvoJacobian[traitsin:(_?TraitsQ):{},popsin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed vars *)
fixedvars,fixedtraits,fixedvariables,
(* other variables *)
traits,pops,eqns,unks,jmat},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
pops=ExpandNspInPops[popsin];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[pops,fixedvariables]];

eqns=EvoEqns[BlankVariables,Gs,opts]/.RHS/.RemoveTraitts/.RemovePopts;

unks={};
Do[Do[Do[
	If[!MemberQ[fixedvars,Subscript[trait[gu,tr],sp]],AppendTo[unks,Subscript[trait[gu,tr],sp]]]
,{tr,ntraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,nguilds}];

If[verbose,
	Print[func,": eqns="];
	Print[eqns];
	Print[func,": unks="];
	Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[Global`debug,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.pops/.traits]],
	Return[jmat/.pops/.traits]
];

]];


EvoJacobian[sol_?TraitsAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=EvoJacobian[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];
EvoJacobian[___]:=Msg[EvoJacobian::noper]/;modelperiod=!=0;


Options[EvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoEigenvalues[traits:(_?TraitsQ):{},pops:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,ejopts,res},

	If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

	chop=Evaluate[Chop/.Flatten[{opts,Options[EvoEigenvalues]}]];
	ejopts=FilterRules[Flatten[{opts,Options[EvoEigenvalues]}],Options[EvoJacobian]];

	res=Eigenvalues[EvoJacobian[traits,pops,Gs,ejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


EvoEigenvalues[sol_?TraitsAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=EvoEigenvalues[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


Options[EvoEigenvalues]={EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


MaximizeInv[traits:(_?TraitsQ):{},sol:(_?VariablesQ):{},opts:OptionsPattern[]]:=
 
Module[{
func=FuncStyle["MaximizeInv"],
(* options *)
verbose,verboseall,guild,delayinv,invopts,maximizeopts,method,constraints,
(* other variables *)
vars,unks,inv,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* reset $invcount *)
$invcount=0;

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

guild=OptionValue[Guild];
delayinv=OptionValue[DelayInv];
invopts=OptionValue[InvOpts];
maximizeopts=OptionValue[MaximizeOpts];
method=OptionValue[Method];
constraints=OptionValue[Constraints];

vars=Table[Subscript[trait[guild,tr],0],{tr,ntraits[guild]}];
unks=Table[unk[trait[guild,tr],0],{tr,ntraits[guild]}];


Which[
	constraints==="None",
	constraints={};
,
	constraints===Automatic,
	constraints=Table[Min[traitrange[guild,tr]]<=Subscript[trait[guild,tr],0]<=Max[traitrange[guild,tr]],{tr,ntraits[guild]}]
,
	Else,
	constraints=Join[constraints,Table[Min[traitrange[guild,tr]]<=Subscript[trait[guild,tr],0]<=Max[traitrange[guild,tr]],{tr,ntraits[guild]}]]
];

(*Print["constraints=",constraints];*)

If[delayinv==True,
	inv[varz_?NumericListQ]:=Inv[traits,sol,Thread[vars->varz],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	res=NMaximize[Prepend[constraints/.Subscript->unk,inv[unks]],unks,Evaluate[Sequence@@maximizeopts]];
	, (* else *)
	Off[NIntegrate::inumr];
	inv=Inv[traits,sol,Guild->guild,Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	If[Global`debug,Print[func,": inv=",inv]];
	Which[
		method=="Maximize",
		res=Maximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]],
		method=="NMaximize",
		res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]],
		Else,
		Msg[MaximizeInv::badmtd];
		Return[$Failed]
	];
	On[NIntegrate::inumr]
];

Return[res/.unk->Subscript];

]];


Options[MaximizeInv]={Guild->1,DelayInv->False,InvOpts->{},MaximizeOpts->{},Constraints->Automatic,Method->"NMaximize",
Verbose->False,VerboseAll->False};


MaximizeInv[sol_?TraitsAndVariablesQ,opts___?OptionQ]:=MaximizeInv[ExtractTraits[sol],ExtractVariables[sol],opts];


GlobalESSQ[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["GlobalESSQs"],
(* options *)
verbose,verboseall,
maximizeinvopts,invthreshold,
(* other variables *)
inv,tmp},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

maximizeinvopts=Evaluate[MaximizeInvOpts/.Flatten[{opts,Options[GlobalESSQ]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[GlobalESSQ]}]];
If[invthreshold===Automatic,invthreshold=modelinvthreshold+$roundofftolerance];
verbose=Evaluate[Verbose/.Flatten[{opts,Options[GlobalESSQ]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[GlobalESSQ]}]];
If[verboseall,verbose=True];

(* find max invader rate .. if > invthreshold, then not globaless *)

Do[
	tmp[gu]=MaximizeInv[traits,sol,Guild->gu,maximizeinvopts];
	If[verbose,Print[func,": MaximizeInv guild ",gu,"=",tmp[gu]]];
,{gu,nguilds}];

Return[{
	Table[If[tmp[gu][[1]]>invthreshold,False,True],{gu,nguilds}],
	Table[{tmp[gu][[1]],Table[trait[gu,tr]->(Subscript[trait[gu,tr],0]/.tmp[gu][[2]]),{tr,ntraits[gu]}]},{gu,nguilds}]}
];

]];


Options[GlobalESSQ]={MaximizeInvOpts->{},InvThreshold->Automatic,Verbose->False,VerboseAll->False};


GlobalESSQ[eesol_?TraitsAndVariablesQ,opts___?OptionQ]:=GlobalESSQ[ExtractTraits[eesol],ExtractVariables[eesol],opts];


End[];
EndPackage[];
