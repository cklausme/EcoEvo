(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* hack to address <https://mathematica.stackexchange.com/questions/167143/setdelayedwrsym-on-first-use-of-formalx> *)
Plot[0,{x,0,1}];
ContourPlot[0,{x,0,1},{y,0,1}];


BeginPackage["EcoEvo`"];


Unprotect@@Names["EcoEvo`*"];
ClearAll@@Names["EcoEvo`*"];


SimplifyLogE::usage="SimplifyLogE is a replacement rule that simplifies Log[\!\(\*
StyleBox[\"a\", \"TI\"]\) \!\(\*SuperscriptBox[\(E\), 
StyleBox[\"x\", \"TI\"]]\)] to Log[\!\(\*
StyleBox[\"a\", \"TI\"]\)]+\!\(\*
StyleBox[\"x\", \"TI\"]\)."

RestrictedTo::usage="RestrictedTo[\!\(\*
StyleBox[\"x\", \"TI\"]\), {\!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}] restricts numerical value \!\(\*
StyleBox[\"x\", \"TI\"]\) to the range {\!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}.
RestrictedTo[\!\(\*
StyleBox[\"x\", \"TI\"]\), Interval[{\!\(\*
StyleBox[SubscriptBox[\"x\", \"min\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"x\", \"max\"], \"TI\"]\)}]] does the same.";

VarSort::usage="VarSort[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] sorts \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) in order of \!\(\*
StyleBox[\"vars\", \"TI\"]\).";

orderedComplement::usage="orderedComplement is like Complement, but doesn't sort the list.";

EqSort::usage="EqSort[\!\(\*
StyleBox[\"list\", \"TI\"]\)] sorts \!\(\*
StyleBox[\"list\", \"TI\"]\) in order of increasing species richness.";

ReplaceRHS::usage="ReplaceRHS[\!\(\*
StyleBox[\"eqn\", \"TI\"]\), \!\(\*
StyleBox[\"rule\", \"TI\"]\)] applies replacement rule \!\(\*
StyleBox[\"rule\", \"TI\"]\) to the right-hand side of \!\(\*
StyleBox[\"eqn\", \"TI\"]\).";

ReplaceLHS::usage="ReplaceLHS[eqn, rule] applies replacement rule rule to the left-hand side of eqn.";

RHS::usage="RHS is a replacement rule that returns the right-hand side of equations.";

LHS::usage="LHS is a replacement rule that returns the left-hand side of equations.";

Eq::usage="Eq is a replacement rule that sets time derivatives to zero and next time steps equal to this time steps.";

ZeroLHS::usage="ZeroLHS is a replacement rule that sets the left hand side of equations equal to zero.";

ZeroVector::usage="ZeroVector[\!\(\*
StyleBox[\"d\", \"TI\"]\)] returns a \!\(\*
StyleBox[\"d\", \"TI\"]\)-dimensional zero vector.";

SubscriptAdd::usage="SubscriptAdd[\!\(\*
StyleBox[\"expr\", \"TI\"]\), \!\(\*
StyleBox[\"add\", \"TI\"]\)] adds \!\(\*
StyleBox[\"add\", \"TI\"]\) (default=1) to all subscripts in \!\(\*
StyleBox[\"expr\", \"TI\"]\).";

DeleteSubscript::usage="DeleteSubscript[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] removes the subscript from \!\(\*
StyleBox[\"expr\", \"TI\"]\).";

ZeroSubscript::usage="ZeroSubscript[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] changes the subscript in \!\(\*
StyleBox[\"expr\", \"TI\"]\) to zero.";

HighlightChanges::usage="HighlightChanges[True] turns on change highlighting. HighlightChanges[False] turns it off.";

ExtractColors::usage="ExtractColor[\!\(\*
StyleBox[\"list\", \"TI\"]\)] extracts colors from \!\(\*
StyleBox[\"list\", \"TI\"]\).";

axisFlip::usage="axisFlip exchanges axes on Graphics object.";

FuncStyle::usage="FuncStyle[\!\(\*
StyleBox[\"string\", \"TI\"]\)] formats \!\(\*
StyleBox[\"string\", \"TI\"]\) for use in debugging output.";

PrintCall::usage="PrintCall[\!\(\*
StyleBox[\"expression\", \"TI\"]\)] prints \!\(\*
StyleBox[\"expression\", \"TI\"]\) unevaluated.";

Msg::usage="Msg[\!\(\*
StyleBox[\"message\", \"TI\"]\)] is a robust replacement for Message.";

RuleList::usage=
"RuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
RuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), {\!\(\*
StyleBox[\"min\", \"TI\"]\), \!\(\*
StyleBox[\"max\", \"TI\"]\)}] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) ranges from \!\(\*
StyleBox[\"min\", \"TI\"]\) to \!\(\*
StyleBox[\"max\", \"TI\"]\).
RuleList[\!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"vals\", \"TI\"]\)] makes a list of rules between corresponding elements of the lists \!\(\*
StyleBox[\"vars\", \"TI\"]\) and \!\(\*
StyleBox[\"vals\", \"TI\"]\).
RuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ns\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
RuleList[{\!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(1\)]\), \[Ellipsis], \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(nv\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(1\)]\), \[Ellipsis] , \!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(nv\)]\)}, {{\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(1\)]\)}, \[Ellipsis] , {\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(nv\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(nv\)]\)}}] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(i\)]\) ranges from \!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(i\)]\) to \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(i\)]\).";

\[IGrave]::usage="\[IGrave] is a placeholder index in RuleList.";

ClearCache::usage="ClearCache[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), ...] removes memoized DownValues of \!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), etc.";

IntepolatingFunctionFunctionQ::usage="IntepolatingFunctionFunctionQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] is True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a InterpolatingFunction function.";

TemporalDataFunctionQ::usage="TemporalDataFunctionQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] is True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a TemporalData function.";

Avg::usage=
"Avg[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the average of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
Avg[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] gives the average of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\), ranging from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
Avg[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

Var::usage=
"Var[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the variance of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
Var[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] gives the variance of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\), ranging from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
Var[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

Cov::usage=
"Cov[\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the covariance of \!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)and \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), at least one of which contains an InterpolatingFunction, with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
Cov[\!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] gives the covariance of the functions \!\(\*
StyleBox[SubscriptBox[\"f\", \"1\"], \"TI\"]\) and \!\(\*
StyleBox[SubscriptBox[\"f\", \"2\"], \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\), ranging from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).";

ExtractPlotPoints::usage=
"ExtractPlotPoints[\!\(\*
StyleBox[\"plot\", \"TI\"]\)] extracts lists of points from lines in \!\(\*
StyleBox[\"plot\", \"TI\"]\).";

Else::usage=
"Else is an alias for True.";

SpFrac::usage=
"\!\(\*
StyleBox[\"SpFrac\", \"InlineCode\"]\)\!\(\*
StyleBox[\"[\", \"InlineCode\"]\)\!\(\*
StyleBox[\"sp\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"InlineCode\"]\)\!\(\*
StyleBox[\" \", \"InlineCode\"]\)\!\(\*
StyleBox[\"nsp\", \"TI\"]\)] gives (\!\(\*
StyleBox[\"sp\", \"TI\"]\)-1)/(\!\(\*
StyleBox[\"nsp\", \"TI\"]\)-1).";

ModPart::usage=
"ModPart[\!\(\*
StyleBox[\"list\", \"TI\"]\), \!\(\*
StyleBox[\"part\", \"TI\"]\)] returns part number \!\(\*
StyleBox[\"part\", \"TI\"]\) of \!\(\*
StyleBox[\"list\", \"TI\"]\) like Part, but wraps around.";

NumberedGridForm::usage=
"NumberedGridForm[\!\(\*
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"]\)] formats \!\(\*
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"]\) in a table with numbers";

FindMaxima::usage=
"FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local maxima of InterpolatingFunction \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).";

FindMinima::usage=
"FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local minima of InterpolatingFunction \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).";

FindExtrema::usage=
"FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local extrema of InterpolatingFunction \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).";

myStreamPlot::usage=
"myStreamPlot[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"xmin\", \"TI\"]\), \!\(\*
StyleBox[\"xmax\", \"TI\"]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\), \!\(\*
StyleBox[\"ymin\", \"TI\"]\), \!\(\*
StyleBox[\"ymax\", \"TI\"]\)}] is like StreamPlot, but with better arrow spacing.";

RealSimplify::usage=
"RealSimplify[\!\(\*
StyleBox[\"expression\", \"TI\"]\)] Simplifies \!\(\*
StyleBox[\"expression\", \"TI\"]\) assuming everything is Real.";

TD::usage=
"TD[\!\(\*
StyleBox[\"list\", \"TI\"]\)] returns a TemporalData object if Mathematica version >=9, otherwise returns \!\(\*
StyleBox[\"list\", \"TI\"]\).";

RunFile::usage=
"RunFile[\!\(\*
StyleBox[\"file\", \"TI\"]\)] displays & runs code from a file or URL.";

CompoundAnd::usage=
"CompoundAnd[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if all \!\(\*
StyleBox[\"conds\", \"TI\"]\) are True.";

CompoundOr::usage=
"CompoundOr[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if any of \!\(\*FormBox[
StyleBox[\"conds\", \"TI\"],
TraditionalForm]\) are True.";

SortedEigensystem::usage=
"SortedEigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] is Eigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)], sorted from largest to smallest Re[eigenvalue].";

ListMultiplier::usage=
"ListMultiplier[\!\(\*
StyleBox[\"list\", \"TI\"]\)] multiplies a list of matrices.";

NumericListQ::usage=
"NumericListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers, False otherwise.";

NumericFlattenedListQ::usage =
"NumericFlattenedListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers when Flattened, False otherwise.";

NumericRuleListQ::usage=
"NumericRuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of replacement rules with numeric values, False otherwise.";

RuleListQ::usage=
"RuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of replacement rules, False otherwise.";

RuleListListQ::usage=
"RuleListListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of RuleLists, False otherwise.";

InterpolatingFunctionTake::usage=
"InterpolatingFunctionTake[\!\(\*
StyleBox[\"if\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] takes part of an InterpolatingFunction from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";

Slice::usage=
"Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"t\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with its values at \!\(\*
StyleBox[\"t\", \"TI\"]\).
Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] extracts values from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";

InitialSlice::usage=
"InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the initial values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] extracts the initial values ending at \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";

FinalSlice::usage=
"FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the final values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmin\", \"TI\"]\)] extracts the final values starting at \!\(\*
StyleBox[\"tmin\", \"TI\"]\).";

FinalDerivatives::usage=
"FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with their final derivatives.
FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\)] averages over the final values starting at \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\).";

InitialTime::usage=
"InitialTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the initial time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

FinalTime::usage=
"FinalTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the final time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

FindPeriod::usage=
"FindPeriod[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the period of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";

RuleListAdd::usage=
"RuleListAdd[\!\(\*
StyleBox[\"l1\", \"TI\"]\), \!\(\*
StyleBox[\"l2\", \"TI\"]\)] adds corresponding elements of two rulelists.";

RuleListSubtract::usage=
"RuleListSubtract[\!\(\*
StyleBox[\"l1\", \"TI\"]\), \!\(\*
StyleBox[\"l2\", \"TI\"]\)] subtracts corresponding elements of two rulelists.";

RuleListMultiply::usage=
"RuleListMultiply[\!\(\*
StyleBox[\"l\", \"TI\"]\), \!\(\*
StyleBox[\"x\", \"TI\"]\)] or RuleListMultiply[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"l\", \"TI\"]\)] multiply elements of rulelist \!\(\*
StyleBox[\"l\", \"TI\"]\) by number \!\(\*
StyleBox[\"x\", \"TI\"]\).";

RuleListTweak::usage=
"RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variable \!\(\*
StyleBox[\"var\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).
RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).";

NumericRuleListToNumericList::usage=
"NumericRuleListToNumericList[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] converts a numeric rule list \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) to a numeric list, in order of \!\(\*
StyleBox[\"vars\", \"TI\"]\).";

listMultiplier::usage=
"listMultiplier[\!\(\*
StyleBox[\"list\", \"TI\"]\)] multiplies a list of matrices.";

RouthHurwitzCriteria::usage=
"RouthHurwitzCriteria[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] gives the modified Routh-Hurwitz stability criteria (up to 3x3).";


$EcoEvoVersion::usage=
"$EcoEvoVersion gives the version of the loaded EcoEvo package.";

DeleteInvaders::usage=
"DeleteInvaders[\!\(\*
StyleBox[\"list\", \"TI\"]\)] removes invaders (with subscript 0) from \!\(\*
StyleBox[\"list\", \"TI\"]\).";

RuleListDistance::usage=
"RuleListDistance[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\),\!\(\*
StyleBox[\"rulelist2\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)] gives the \!\(\*
StyleBox[\"p\", \"TI\"]\)-norm distance between two rule lists (default \!\(\*
StyleBox[\"p\", \"TI\"]\)=\[Infinity]).";

TraitsQ::usage=
"TraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits.";

VariablesQ::usage=
"VariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of variables.";

ListOfVariablesQ::usage=
"ListOfVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of rulelists of variables.";

TraitsAndVariablesQ::usage=
"TraitsAndVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits and variables.";

InvaderQ::usage=
"InvaderQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a possible invader.";

NotInvaderTraitsQ::usage=
"NotInvaderTraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits with no invaders.";

GsQ::usage=
"GsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of G matrices or V variances.";

ExtractTraits::usage=
"ExtractTraits[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts traits from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractPops::usage=
"ExtractPops[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractAuxs::usage=
"ExtractAuxs[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts auxs from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractGuilds::usage=
"ExtractGuilds[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts guilds from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractVariables::usage=
"ExtractVariables[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops, guilds, and auxs from rulelist or list of rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

LookUp::usage =
"LookUp[\!\(\*
StyleBox[\"var\", \"TI\"]\)] finds the indices of a variable or trait.";

PlotDynamics::usage=
"PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots the functions in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.
PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"funcs\", \"TI\"]\)] plots \!\(\*
StyleBox[\"funcs\", \"TI\"]\) in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.";


t::usage="Reserved for time.";
log::usage="Indicates a log-transformed variable.";

ModelType::usage="Type of model (\"ContinuousTime\" or \"DiscreteTime\").";
ModelName::usage="Model name.";
ModelPeriod::usage="Model period (0=unforced, \[Infinity]=aperiodic)."

Component::usage="Defines a Component of a Pop or Guild in SetModel.";
Equation::usage="Defines the equation of a Pop or Guild Component in SetModel.";
Aux::usage="Defines an Aux variable in SetModel.";
Pop::usage="Defines a Pop in SetModel.";
Guild::usage="Defines a Guild in SetModel. Also an option for various EcoEvo functions.";
Trait::usage="Defines a trait in SetModel.";
Type::usage="Defines a Component type in SetModel.";

FromUnks::usage="Internal usage only ;)";
ToUnks::usage="Internal usage only ;)";
ToUnkRules::usage="Internal usage only ;)";

ExpRules::usage="Internal usage only ;)";

Nsp::usage =
"Nsp[\!\(\*
StyleBox[\"gu\", \"TI\"]\)] is a reserved symbol that denotes the number of species in guild \!\(\*
StyleBox[\"gu\", \"TI\"]\).  Do not set directly.";

Color::usage="Color gives the color for a model part.";
Colors::usage="Colors is a list of default colors for model parts.";

LineStyle::usage="LineStyle gives the line style for a model part.";
LineStyles::usage="LineStyles is a list of default line styles for model parts.";

PlotMarker::usage="PlotMarker gives the plot marker for a model part.";
(*PlotMarkers::usage="PlotMarkers is a list of default plot markers for model part.";*)

Unk::usage="An internal header for unknown variables.";


AllTraits::usage="Internal usage only ;)";
AllVariables::usage="Internal usage only ;)";
AllPopsAndAuxs::usage="Internal usage only ;)";
BlankTraits::usage="Internal usage only ;)";
BlankUnkTraits::usage="Internal usage only ;)";
BlankVariables::usage="Internal usage only ;)";
BlankUnkVariables::usage="Internal usage only ;)";

RemoveVariablets::usage="Internal usage only ;)";
RemovePopt1s::usage="Internal usage only ;)";
RemoveTraitts::usage="Internal usage only ;)";
AddPopts::usage="Internal usage only ;)";
AddTraitts::usage="Internal usage only ;)";
AddUnkts::usage="Internal usage only ;)";


EcoEqns::usage="EcoEqns[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] sets up ecological equations corresponding to species with \!\(\*
StyleBox[\"traits\", \"TI\"]\).";
EvoEqns::usage="EvoEqns[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"Gs\", \"TI\"]\)] set up trait equations with ecological solution \!\(\*
StyleBox[\"sol\", \"TI\"]\) and G matrices \!\(\*
StyleBox[\"Gs\", \"TI\"]\).";


SetModel::usage=
"SetModel[\!\(\*
StyleBox[\"model\", \"TI\"]\)] sets an EcoEvo \!\(\*
StyleBox[\"model\", \"TI\"]\) for analysis.";

UnsetModel::usage=
"UnsetModel clears the currently set EcoEvo model.";

ModelInfo::usage=
"ModelInfo gives a summary of the currently loaded EcoEvo model.";

MatrixToPopComponents::usage=
"MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";

MatrixToGuildComponents::usage=
"MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";

SelectValid::usage=
"SelectValid[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects valid solutions in list of rule lists \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

EcoSim::usage=
"EcoSim[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates ecological dynamics, with initial densities in \!\(\*
StyleBox[\"pops\", \"TI\"]\), from time \!\(\*
StyleBox[\"t\", \"TI\"]\)=0 to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
EcoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
EcoSim[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses combined \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

EcoEq::usage = 
"EcoEq[] solves for ecological equilibria.
EcoEq[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

SolveEcoEq::usage = 
"SolveEcoEq[] solves for ecological equilibria.
SolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

NSolveEcoEq::usage = 
"NSolveEcoEq[] numerically solves for ecological equilibria.
NSolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

FindEcoEq::usage = 
"FindEcoEq[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

FindEcoCycle::usage = 
"FindEcoCycle[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an ecological limit cycle using initial guess \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

EcoJacobian::usage = 
"EcoJacobian[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] returns the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

EcoEigenvalues::usage = 
"EcoEigenvalues[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] returns the eigenvalues of the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

PlotEcoIsoclines::usage =
"PlotEcoIsoclines[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoIsoclines[\!\(\*
StyleBox[\"traits\", \"TI\"]\),{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)},{\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

PlotEcoStreams::usage =
"PlotEcoStreams[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoStreams[\!\(\*
StyleBox[\"traits\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

PlotEcoPhasePlane::usage=
"PlotEcoPhasePlane[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams and isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoPhasePlane[\!\(\*
StyleBox[\"traits\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

SelectEcoStable::usage=
"SelectEcoStable[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects stable equilibria from \!\(\*
StyleBox[\"sol\", \"TI\"]\).
SelectEcoStable[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

EcoStableQ::usage=
"EcoStableQ[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] reports the linear stability of an equilibrium as True, False, or Indeterminate.
EcoStableQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
EcoStableQ[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

FindEcoAttractor::usage=
"FindEcoAttractor[] tries to find an ecological attractor.
FindEcoAttractor[\!\(\*
StyleBox[\"traits\", \"TI\"]\)] uses trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

Inv::usage=
"Inv[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=1), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

StablePopulationStructure::usage=
"StablePopulationStructure[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

ReproductiveValues::usage =
"ReproductiveValues[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the reproductive values of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the reproductive value of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

InvSPS::usage =
"InvSPS[\!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate and stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"pops\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate and stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\), using resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses combined trait and community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

DInv::usage =
"DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] calculates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident traits \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"pops\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where DInv will be evaluated.
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] gives derivatives for all traits in Guild (default=1).";

NDInv::usage =
"NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] numerically approximates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident traits \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"pops\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where NDInv will be evaluated.
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] gives derivatives for all traits in Guild (default=1).";

NumDInv::usage="";

GlobalESSQ::usage =
"GlobalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks global ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).
GlobalESSQ[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

PrestonPlot::usage =
"PrestonPlot[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] makes a Preston species abundance distribution plot based on \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

WhittakerPlot::usage =
"WhittakerPlot[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] makes a Whittaker rank-abundance plot based on \!\(\*
StyleBox[\"pops\", \"TI\"]\).";

PlotTAD::usage =
"PlotTAD[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] plots abundance vs trait for the species in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).
PlotTAD[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined community state \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

PlotZIP::usage =
"PlotZIP[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] creates a zero invasion plot, with invader \!\(\*
StyleBox[\"inv\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(inferred if omitted).
PlotZIP[\!\(\*
StyleBox[\"eq0\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] uses equilibrium \!\(\*
StyleBox[\"eq0\", \"TI\"]\).";

PlotInv::usage =
"PlotInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] plots a fitness landscape, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).";

PlotPIP::usage =
"PlotPIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a pairwise invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotPIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.";

PlotMIP::usage =
"PlotMIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a mutual invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotMIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotMIP[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotMIP[{\!\(\*
StyleBox[\"sol1\", \"TI\"]\), \!\(\*
StyleBox[\"sol2\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses equilibria \!\(\*
StyleBox[\"sol1\", \"TI\"]\) and \!\(\*
StyleBox[\"sol2\", \"TI\"]\).";

PlotEvoStreams::usage =
"PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary streams.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

PlotEvoIsoclines::usage =
"PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary isoclines.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

PlotEvoPhasePlane::usage = 
"PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] combines PlotMIP, PlotEvoStreams and PlotEvoIsoclines.
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq1\", \"TI\"]\), \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses one-species equilibrium \!\(\*
StyleBox[\"eq1\", \"TI\"]\) and two-species equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) for improved speed (2 species).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits (within or between guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses one-species equilibria \!\(\*
StyleBox[\"eq11\", \"TI\"]\) and \!\(\*
StyleBox[\"eq12\", \"TI\"]\) and two-species equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) (2 guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq0\", \"TI\"]\), \!\(\*
StyleBox[\"eq1\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] combines PlotZIP, PlotEvoStreams and PlotEvoIsoclines (2 traits)";

EvoEq::usage = 
"EvoEq contains SolveEvoEq, NSolveEvoEq, and FindEvoEq. Use them instead.";

SolveEvoEq::usage = 
"SolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

NSolveEvoEq::usage = 
"NSolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] numerically solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

FindEvoEq::usage = 
"FindEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
FindEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\), with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\).";

FindEcoEvoEq::usage =
"FindEcoEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an eco-evolutionary equilibrium with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoEvoEq[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined initial guess \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

FindEcoCycleEvoEq::usage =
"FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an evolutionary equilibrium with an ecological cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\). An alias to FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), EvoEq\[Rule]True].
FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined initial guess \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

FindEcoEvoCycle::usage =
"FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] finds an eco-evolutionary cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).
FindEcoEvoCycle[\!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\)] uses combined initial guess \!\(\*
StyleBox[\"traitsandpops\", \"TI\"]\).";

MaximizeInv::usage = 
"MaximizeInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds the trait value(s) that maximize invasion fitness into a community with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

EcoEvoSim::usage =
"EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"pops\", \"TI\"]\).
EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EcoEvoSimOld::usage = "old";

EcoEvoJacobian::usage = 
"EcoEvoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EcoEvoEigenvalues::usage = 
"EcoEvoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EvoJacobian::usage = 
"EvoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

EvoEigenvalues::usage = 
"EvoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


PlotTADOpts::usage="PlotTADOpts is an option for PlotInv that passes options to PlotTAD.";

TADVerticalScale::usage="TADVerticalScale is an option for PlotInv that sets the vertical extent of the TAD. Should be between zero and one.";

Nsps::usage="Nsps is an option for EvoEqns that sets the number of species in each Guild.";

NonFixedVars::usage="NonFixedVars is an option for EcoEqns that lists variables that need equations.";

EcoEvoSimOpts::usage="EcoEvoSimOpts is an option for various EcoEvo functions that passes options to EcoEvoSim.";

FindInstanceOpts::usage="FindInstanceOpts in an option for various EcoEvo functions that passes options to FindInstance.";

MaximizeInvOpts::usage="MaximizeInvOpts is an option for GlobalESSQ that passes options to MaximizeInv.";

ExcludeDiagonal::usage="ExcludeDiagonal is an option for PlotEvoIsoclines that excludes the diagonal.";

PlotMIPOpts::usage="PlotMIPOpts is an option for PlotEvoPhasePlane that passes options to PlotMIP.";

PlotZIPOpts::usage="PlotZIPOpts is an option for PlotEvoPhasePlane that passes options to PlotZIP.";

PlotEvoStreamsOpts::usage="PlotEvoStreamsOpts is an option for PlotEvoPhasePlane that passes options to PlotEvoStreams.";

PlotEvoIsoclinesOpts::usage="";

IsoclineStyle::usage="IsoclineStyle is an option for PlotEcoIsoclines and PlotEvoIsoclines that defines the style for isoclines.";

UseSymmetry::usage="UseSymmetry is an option for PlotEvoStreams & PlotEvoIsoclines that assumes fitness gradients are symmetric.";

InvStyle::usage="InvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for successful invasion.";

NonInvStyle::usage="NonInvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for unsuccessful invasion.";

SpeciesColors::usage="SpeciesColors is an option for PlotMIP (PlotType->Outcome) that defines colors for each species.";

ShowSpecies::usage="ShowSpecies is an option for PrestonPlot that shows species markers or not.";

MarkerStyle::usage="MarkerStyle is an option for PrestonPlot that styles species markers.";

Bandwidth::usage="Bandwidth is an option for PrestonPlot that sets the bandwidth in SmoothKernelDistribution.";

MinPop::usage="MinPop is an option for varios EcoEvo functions that defines a minimum population size.";

Base::usage="Base is an option for PrestonPlot that sets the logarithm base.";

QSS::usage="QSS is an option for *EcoEq that indicates that nonspecified variables should be treated as unknowns.";

TMin::usage="TMin specifies the starting time for EcoSim and EcoEvoSim.";

EcoAttractorNumber::usage="EcoAttractorNumber specifies which EcoAttractor to choose in the case of multiple attractors.";

TestValidity::usage="TestValidity is an option for FindEcoAttractor that determines whether to test for valid equilibria.";

TestStability::usage="TestStability is an option for FindEcoAttractor that determines whether to test for stable equilibria.";

FinalTMax::usage="FinalTMax is an option for FindEcoAttractor that sets the length of an aperiodic solution.";

EigenvaluesOpts::usage="EigenvaluesOpts passes options to Eigenvalues.";

AvgOpts::usage="AvgOpts is an option for Variance and Covariance that passes options to Avg.";

Gradients::usage="Gradients is an option for SetModel that provides a list of base Colorradients for guilds.";

TimeScale::usage="TimeScale is an option for EcoSim that sets the overall timescale (default=1).";

OutputTMin::usage="OutputTMin is an option for EcoSim and EcoEvoSim that that sets the length of the results (default=0).";

Output::usage="Output is an option for various EcoEvo functions that determines the type of output.";

IsoclineLabels::usage="IsoclineLabels is an option for PlotEcoIsoclines and PlotEvoIsoclines that styles the isocline labels.";

PlotEcoIsoclinesOpts::usage="PlotEcoIsoclinesOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoIsoclines.";

PlotEcoStreamsOpts::usage="PlotEcoStreamsOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoStreams.";

BasePeriod::usage="BasePeriod is an option for FindPeriod that gives the period to look at multiples of.";

MaxPeriodMultiplier::usage="MaxPeriodMultiplier is an option for FindEcoAttractor that sets how many multiples of the Period to try.";

Multipliers::usage="Multipliers is an option for EcoEigenvalues that chooses Floquet multipliers (True) or exponents (False).";

TMaxPowerMin::usage="TMaxPowerMin is an option for FindEcoCycle that sets the minimum base-10 power of tmax to try.";

TMaxPowerMax::usage="TMaxPowerMax is an option for FindEcoCycle that sets the maximum base-10 power of tmax to try.";

dTMaxPower::usage="dTMaxPower is an option for FindEcoCycle that sets the stepsize base-10 power of tmax.";

V::usage="V is an option to set genetic variance in various EcoEvo functions.";

G::usage="G is an option to set genetic variance/covariance matrix in various EcoEvo functions.";

ESTest::usage="ESTest is an option for PlotEvoIsoclines that colors isoclines according to (local) evolutionary stability.";

NonESColor::usage="NonESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";

ESColor::usage="ESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";

DelayDInv2::usage="DelayDInv2 is an option for PlotEvoIsoclines whether to delay evaluation of DInv in ESS-test.";

DInv2Opts::usage="DInvOpts is an option for PlotEvoIsoclines that passed options to DInv in ESS-test.";

BoundaryDetection::usage="BoundaryDetection is an option for various EcoEvo functions to enforce variable/trait bounds.";

Period::usage="Period is an option for EcoEvoModel that defines its period.";

RV::usage="RV is an option for InvSPS when called from ReproductiveValues.";

FromInv::usage="FromInv is an option for InvSPS when called from Inv.";

NumTries::usage="NumTries is an option for FindEcoAttractor's method \"FindRoot\" that says how many initial guesses to try.";

Switches::usage="Switches is an option for EcoSimSSD that says when external mode switches occur.";

PrintTrace::usage="PrintTrace is an option for various EcoEvo functions to leave a trace of iterations.";

Guild::usage = 
"Guild is an option for various EcoEvo functions that sets which guild to use.";

Species::usage = 
"Species is an option for various EcoEvo functions that sets which species to use.";

Pop::usage = 
"Pop is an option for various EcoEvo functions that sets which population to use.";

Logged::usage =
"Logged is an option for EcoSim that logs population variables.";

Averaged::usage =
"Averaged is an option for Inv that averages growth if True, gives instantaneous growth if False.";

AbsoluteStepSize::usage = 
"AbsoluteStepSize is an option for NDInv that sets the absolute step size.";

RelativeStepSize::usage = 
"RelativeStepSize is an option for NDInv that sets the relative step size.";

PlotSpecies::usage =
"PlotSpecies is an option for PlotInv that puts points for species.";

PointStyle::usage =
"PointStyle is an option for PlotInv that determines the style of points for species.";

ICs::usage =
"ICs is an option for PlotPIP and PlotMIP that supplies initial guesses for FindEcoAttractor.";

ZeroDiagonal::usage = 
"ZeroDiagonal is an option for PlotPIP that forces Inv=0 along the diagonal.";

SubtractDiagonal::usage=
"SubtractDiagonal is an option for PlotPIP that subtracts the diagonal from all invasion rates.";

EqStop::usage = 
"EqStop is an option for various EcoEvo simulation functions that stops upon reaching an equilibrium.";

WhenEvents::usage =
"WhenEvents is an option for various EcoEvo simulation functions that adds WhenEvents to NDSolve.";

EqThreshold::usage = 
"EqThreshold is an option for various EcoEvo simulation functions that sets the sensitivity for EqStop.";

Fixed::usage =
"Fixed is an option for various EcoEvo functions that find equilibria, that fixes the values of certain species/traits.";

WarmUp::usage = 
"WarmUp is an option for various EcoEvo functions that numerical solves a model before refining.";

WarmUp2::usage = 
"WarmUp2 is an option for various EcoEvo functions that numerical solves a model before refining.";

WarmUp3::usage = 
"WarmUp3 is an option for various EcoEvo functions that numerical solves a model before refining.";

TriggerVariable::usage =
"TriggerVariable is an option for FindEcoCycle that sets which variable to focus on.";

SolveOpts::usage =
"SolveOpts is an option for various EcoEvo functions that passes options to Solve.";

NSolveOpts::usage =
"NSolveOpts is an option for various EcoEvo functions that passes options to NSolve.";

FindRootOpts::usage =
"FindRootOpts is an option for various EcoEvo functions that passes options to FindRoot.";

MaximizeOpts::usage =
"MaximizeOpts is an option for various EcoEvo functions that passes options to Maximize.";

NDSolveOpts::usage =
"NDSolveOpts is an option for various EcoEvo functions that passes options to NDSolve.";

WhenEventOpts::usage =
"WhenEventOpts is an option for various EcoEvo functions that passes options to WhenEvent.";

NDOpts::usage =
"NDOpts is an option for various EcoEvo functions that passes options to ND.";

NIntegrateOpts::usage =
"NIntegrateOpts is an option for various EcoEvo functions that passes options to NIntegrate.";

IntegrateOpts::usage =
"IntegrateOpts is an option for various EcoEvo functions that passes options to Integrate.";

FindEcoEvoEqOpts::usage =
"FindEcoEvoEqOpts is an option for TrackEcoEvoEq that passes options to FindEcoEvoEq.";

GlobalESSQOpts::usage =
"GlobalESSQOpts is an option for TrackEcoEvoEq that passes options to GlobalESSQ.";

EcoSimOpts::usage =
"EcoSimOpts is an option for various EcoEvo functions that passes options to EcoSim.";

EigensystemOpts::usage =
"EigenvaluesOpts is an option for various EcoEvo functions that passes options to Eigenvalues.";

BifurcationAction::usage =
"BifurcationAction is an option for TrackEcoEvoEq that selects what to do when a bifurcation is found.";

NMaximizeOpts::usage =
"NMaximizeOpts is an option for GlobalESSQ that passes options to NMaximize.";

Constraints::usage =
"Constraints is an option for various EcoEvo functions that add extra constraints.";

QSSMethod::usage =
"QSSMethod is an option for Inv that selects how to solve for qualitative structure of the invader.";

QSSICs::usage =
"QSSICs is an option for Inv that sets initial conditions for solving for qualitative structure of the invader.";

PerCapita::usage =
"PerCapita is an option for various EcoEvo functions that divides by population size.";

FindEcoCycleOpts::usage =
"FindEcoCycleOpts is an option for various EcoEvo functions that passes options to FindEcoCycle.";

FindEcoAttractorOpts::usage =
"FindEcoAttractorOpts is an option for various EcoEvo functions that passes options to FindEcoAttractor.";

SolveEcoEqOpts::usage=
"SolveEcoEqOpts is an option for various EcoEvo functions that passes options to SolveEcoEq.";

NSolveEcoEqOpts::usage=
"NSolveEcoEqOpts is an option for various EcoEvo functions that passes options to NSolveEcoEq.";

FindEcoEqOpts::usage=
"FindEcoEqOpts is an option for various EcoEvo functions that passes options to FindEcoEq.";

EcoEigenvaluesOpts::usage=
"EcoEigenvaluesOpts is an option for various EcoEvo functions that passes options to EcoEigenvalues.";

TMax::usage=
"TMax is an option for FindEcoAttractor that sets the maximum time for EcoSim.";

TMax2::usage=
"TMax2 is an option for FindEcoAttractor that sets the maximum time for EcoSim.";

InvOpts::usage =
"InvOpts is an option for various EcoEvo functions that passes options to Inv.";

NInvOpts::usage =
"NInvOpts is an option for various EcoEvo functions that passes options to NInv.";

DInvOpts::usage =
"DInvOpts is an option for various EcoEvo functions that passes options to DInv.";

NDInvOpts::usage =
"NDInvOpts is an option for various EcoEvo functions that passes options to NDInv.";

DelayInv::usage=
"DelayInv is an option for various EcoEvo functions that delays the evaluation of Inv.";

DelayDInv::usage=
"DelayDInv is an option for various EcoEvo functions that delays the evaluation of DInv.";

FitnessGradient::usage=
"FitnessGradient is an option for various EcoEvo functions that chooses which method to use to calculate fitness gradients.";

PlotOpts::usage=
"PlotOpts is an option for various EcoEvo functions that passes options to plotting functions.";

PlotType::usage=
"PlotType is an option for PlotPIP that chooses plot type (ZeroContourPlot [default], ContourPlot, Plot3D).";

InvThreshold::usage=
"InvThreshold is an option for PlotMIP that sets the threshold for successful invasion.";

SimplifyResult::usage=
"SimplifyResult is an option for various EcoEvo functions that applies Simplify before returning results.";

EvoEquation::usage=
"EvoEquation is an option for EcoEvoSim that sets whether to use the breeders' equation (\"QG\" -- default) or the canonical equation (\"CE\").";

FreezeTraits::usage=
"FreezeTraits is an option for EcoEvoSim that freezes traits at their initial conditions.";

VerboseAll::usage = 
"VerboseAll is an option for various EcoEvo functions that recursively turns on Verbose reporting.";

TraitShiftRate::usage =
"TraitShiftRate is an option for various evolutionary EcoEvo functions that changes into a moving frame of reference for an constantly changing environment.";

Time::usage =
"Time is an option for various EcoEvo functions that specifies when to evaluation the model.";

MaxPeriod::usage =
"MaxPeriod is an option for FindEcoAttactor that sets the largest discrete-time period to look for a cycle.";


$invcount::usage =
"Counts number of times Inv called.";

$findecocyclesteps::usage =
"Counts the number of EcoSim calls in FindEcoCycle.";
 
$findecoeqthingcount::usage =
"Counts number of times \"thing\" called inside EcoEq (FindRoot).";

$findevoeqthingcount::usage =
"Counts number of times \"thing\" called inside FindEvoEq.";

$ecoevoeqthingcount::usage =
"Counts number of times \"thing\" called inside FindEcoEvoEq.";

$findecocycleevoeqthingcount::usage=
"Counts number of times \"thing\" called inside FindEcoCycleEvoEq.";

$roundofftolerance::usage =
"Buffer when comparing numbers.";

$tmax::usage = 
"Default maximum time for *Sims.";


PlotZIP::unkinv=
"Can't figure out who's invading: please specify.";

PlotZIP::diffsp=
"\!\(\*
StyleBox[\"x\", \"TI\"]\)- and \!\(\*
StyleBox[\"y\", \"TI\"]\)-axes should have the same species.";

PlotPIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";

PlotMIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";

PlotMIP::badmtd=
"The PlotType option should be a built-in method name (\"MIP\", \"RegionMIP\", \"Outcome\", or \"RegionOutcome\").";

EcoEvoGeneral::nomodel="No model loaded. Use SetModel first.";

SetNsp::badnsp=
"Number of species inconsistent between traits `1` and densities `2`.";

SetNsp::badtrait=
"Number of traits in guild `1` inconsistent: `2`.";

SetNsp::badcomm=
"Number of components in guild `1` inconsistent: `2`.";

SetModel::unktype=
"Unknown ModelType (\"ContinuousTime\", \"DiscreteTime\" currently supported).";

EcoSim::ndnum=
"Encountered non-numerical value for r.h.s. at t=0.";

FindEcoCycle::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoCycleEvoEq::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoCycle::nomaxima=
"Found no maxima in warmup #3, probably not periodic solution.";

FindEcoCycle::badmtd=
"The Method option should be a built-in method name (\"FindRoot\", \"FixedPoint\", \"EcoSim\" or \"Automatic\")";

FindEcoCycle::noecosim=
"\"EcoSim\" Method only applicable to unforced ContinuousTime models.";

InvSPS::nosymev=
"Warning: don't know how to find analytical StablePopulationStructure for > 2x2 matrix.";

InvSPS::unkinv=
"Can't figure out who's invading: please specify.";

InvSPS::nonzero=
"Invasion rate only defined for rare invaders.";

InvSPS::noqsssol=
"Couldn't find QSS solution for invader's Intensive components.";

InvSPS::notraits=
"Trait of invader not defined, so NIntegrate can't work.  Try Method->\"Integrate\" or give invader traits.";

FindEcoAttractor::badmtd=
"The Method option should be a built-in method name (\"SolveEcoEq\", \"NSolveEcoEq\", \"FindEcoEq\", or \"EcoSim\")";

FindEcoAttractor::novars=
"No initial population sizes given, cannot continue with `1`.";

FindEcoAttractor::nocycle=
"Warning: couldn't find a cycle with period less than MaxPeriod=`1`.";

FindEcoAttractor::novalideq=
"Couldn't find a valid equilibrium.";

FindEcoAttractor::giveup=
"Couldn't find an equilibrium or cycle, returing EcoSim.";

TrackEcoEq::parvar=
"`1` cannot be used as a variable.";

TrackEcoEq::nosol=
"Could not find a solution at par=`1`, quitting.";

TrackEcoEvoEq::parvar=
"`1` cannot be used as a variable.";

TrackEcoEvoEq::nosol=
"Could not find a solution at par=`1`, quitting.";

TrackEcoEvoEq::conv=
"Two species converged at par=`1`, quitting";

FindEcoEvoEq::badfg="Bad FitnessGradient method (should be either DInv or NDInv).";

EcoEvoSim::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

FindEcoEvoEq::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

EcoEq::noneq="Can't find equilibrium of periodically forced model with FindRoot.  Give Time option or try FindEcoCycle instead.";

EcoEq::nosol="`1` couldn't find a solution.  Try FindEcoEq instead.";

EvoEq::nosol="Solve/NSolve couldn't find a solution.  Try FindEcoEq instead.";

EvoEq::badmtd="The Method option should be \"Solve\", \"NSolve\", \"FindRoot\", or \"FindInstance\".";

FindEvoEq::needic="Method FindInstance doesn't work with DelayDInv.  Give an initial guess to use Method FindRoot instead.";

NInv::badmtd="The Method option should be a built-in method name.";

EcoEvoJacobian::noper="EcoEvoJacobian can't handle periodic models yet.";

EcoEvoEigenvalues::noper="EcoEvoEigenvalues can't handle periodic models yet.";

EvoJacobian::noper="EvoJacobian can't handle periodic models yet.";

EvoEigenvalues::noper="EvoEigenvalues can't handle periodic models yet.";


FindEcoAttractor::nosteq=
"Warning: couldn't find a stable equilibrium with traits `1`. Trying EcoSim.";
(*Off[FindEcoAttractor::nosteq];*)

FindEcoAttractor::musteq=
"Warning: found `1` stable equilibria with traits `2`.";
(*Off[FindEcoAttractor::musteq];*)

FindEcoAttractor::nostst=
"Warning: EcoSim did not find a steady state (d/dt=`1` at t=`2`). Trying FindEcoCycle.";
(*Off[FindEcoAttractor::nostst];*)

FindEcoEvoCycle::susmtd=
"Warning: FitnessGradient\[Rule]\"EcoEvoSim\" is likely to be inappropriate when there are multiple components. Try EvoEq\[Rule]True and FitnessGradient\[Rule]\"EcoEvoSim\".";


notEcoEigenvaluesOpts::usage="nmotEcoEigenvaluesOpts identifies non-options to EcoEigenvalues.";
notInvOpts::usage="notInvOpts identifies non-options to Inv.";
notDInvOpts::usage="notDInvOpts identifies non-options to DInv.";
notMaximizeInvOpts::usage="notDInvOpts identifies non-options to MaximizeInv.";
notEcoEvoJacobianOpts::usage="notEcoEvoJacobianOpts identifies non-options to EcoEvoJacobian.";
notEcoEvoEigenvaluesOpts::usage="notEcoEvoEigenvaluesOpts identifies non-options to EcoEvoEigenvalues.";
notEcoEvoSimOpts::usage="notEcoEvoSimOpts identifies non-options to EcoEvoSim.";


Begin["`Private`"];


$EcoEvoVersion="0.9.7X (June 7, 2019)";


Print["EcoEvo Package Version ",$EcoEvoVersion,"
Christopher A. Klausmeier <christopher.klausmeier@gmail.com>"];


SetOptions[NDSolve,MaxSteps->Infinity];
(*SetOptions[NIntegrate,MaxRecursion\[Rule]30];*)


$invcount=0;
$findecocyclesteps=0;
$findecoeqthingcount=0;
$findevoeqthingcount=0;
$ecoevoeqthingcount=0;
$roundofftolerance=10^-10;
$tmax=10^4;
modelloaded=False;


SimplifyLogE=Log[(a_:1) E^x_]:>x+Log[a]


RestrictedTo[x_,range_]:=Module[{xmin,xmax},
	{xmin,xmax}=MinMax[range];
	Max[Min[x,xmax],xmin]
]


RestrictedTo[x_,{xmin_?NumericQ,xmax_?NumericQ}]:=Max[Min[x,xmax],xmin];


VarSort[eq_?RuleListQ,vars_List]:=SortBy[eq,Position[vars,#[[1]]]&];


VarSort[eqs_?RuleListListQ,vars_List]:=VarSort[#,vars]&/@eqs;


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/30434/6358> *)
orderedComplement[all_List, i__List] := 
  DeleteDuplicates[Join @ ##] ~Drop~ Length[#] &[Union @ i, DeleteDuplicates @ all];


EqSort[x_?RuleListListQ]:=SortBy[x,Reverse[Map[If[Abs[#]<$MachineEpsilon,0,1]&,#[[All,2]]]]&];


EqSort[x_?RuleListQ]:=x;


RHS=(_==rhs_->rhs);


LHS=(lhs_==_->lhs);


ReplaceRHS[eqn_,rules_]:=eqn//.(relop_[lhs_,rhs_]:>relop[lhs,rhs/.Flatten@rules]);
ReplaceLHS[eqn_,rules_]:=eqn//.(relop_[lhs_,rhs_]:>relop[lhs/.Flatten@rules,rhs]);

ReplaceRHS[eqns_List,rules_]:=ReplaceRHS[#,rules]&/@eqns;
ReplaceLHS[eqns_List,rules_]:=ReplaceLHS[#,rules]&/@eqns;


Eq={var_[t+1]->var[t],var_'[t]->0};


ZeroLHS=(lhs_==rhs_->0==rhs);


ZeroVector[dim_Integer]:=Table[0,{i,dim}];


SubscriptAdd[x_Subscript,add_Integer:1]:=x/.Subscript[var_,sub_]->Subscript[var,sub+add];


DeleteSubscript[x_Subscript]:=x/.Subscript[var_,_]->var;


ZeroSubscript[x_Subscript]:=x/.Subscript[var_,sub_]->Subscript[var,0];


HighlightChanges[bool_]:=If[bool==True,
	SetOptions[EvaluationNotebook[],{
	CellProlog:>(
		SelectionMove[EvaluationCell[],All,GeneratedCell];
		$oldoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&]
	),
	CellEpilog:>(
	SelectionMove[EvaluationCell[],All,GeneratedCell];
	$newoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&];
	If[($oldoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"])=!=($newoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"]),
	Print[Style["Output change:",Red],"\nold=",$oldoutput]];
	If[Length[$newoutput]!=0,SelectionMove[EvaluationCell[],After,CellGroup,2],SelectionMove[EvaluationCell[],After,Cell]]
	)
	}],
	SetOptions[EvaluationNotebook[],{CellProlog->{},CellEpilog->{}}]
];


ExtractColors[list_List]:=Select[list,ColorQ[#]||Head[#]==Opacity&]


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/18669/6358> *)
axisFlip=#/.{x_Line|x_GraphicsComplex:>MapAt[#~Reverse~2&,x,1],x:(PlotRange->_):>x~Reverse~2}&;


FuncStyle[func_]:=Style[func,Underlined];
(*FuncStyle[func_String]:=Style[func,Underlined];*)


(* based on <https://mathematica.stackexchange.com/a/158902/6358> by Szabolcs and <https://mathematica.stackexchange.com/a/161310/6358> by Carl Woll *)
SetAttributes[PrintCall,HoldAll]
(*PrintCall[expr_]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]"Running:"]*)
(*PrintCall[expr_]:=Print[Defer[expr]];*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=With[{expr2=Defer[expr/.Sequence[]\[Rule]Null]},
	CellPrint@ExpressionCell[Defer[expr2],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
];*)
(*PrintCall[expr_,dingbat_:""]:=
CellPrint@ExpressionCell[Defer[expr]/.Sequence[]\[Rule]Nothing,CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]],
CellBaseline\[Rule]Scaled[0.005],CellMargins\[Rule]{{66,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
*)
(*PrintCall[expr_]:=Print@DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]];*)
PrintCall[expr_,dingbat_:""]:=Print[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]]];


Msg[msgs__]:=Block[{$Messages=Streams["stdout"]},
	If[!ListQ@$MessageList,$MessageList={}];
	Message[msgs];
];
SetAttributes[Msg,HoldAll];


ColorData[1]; (* load ColorData *)

(*AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},{RGBColor[1,0.8,0.4],RGBColor[1,0.5,0],RGBColor[1,0,0],RGBColor[1,0,0.5],RGBColor[0.5,0,0.25]},""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},{RGBColor[0.8,1,0.4],RGBColor[0.5,1,0],RGBColor[0,1,0],RGBColor[0,1,0.4],RGBColor[0,0.5,0.25]},""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},{RGBColor[0.4,0.8,1],RGBColor[0,0.5,1],RGBColor[0,0,1],RGBColor[0.4,0,1],RGBColor[0.25,0,0.5]},""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];*)

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.083,0.4,1],Hue[0.083,0.7,1],Hue[0.083,1,1],Hue[0,1,1],Hue[0.917,1,1],Hue[0.917,1,0.7],Hue[0.917,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.25,0.4,1],Hue[0.25,0.7,1],Hue[0.25,1,1],Hue[0.333,1,1],Hue[0.417,1,1],Hue[0.417,1,0.7],Hue[0.417,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.567,0.4,1],Hue[0.583,0.7,1],Hue[0.583,1,1],Hue[0.667,1,1],Hue[0.75,1,1],Hue[0.75,1,0.7],Hue[0.75,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];

(*AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.1,0.5,1],Hue[0.1,0.7,1],Hue[0,0.7,1],Hue[0,1,1],Hue[0,1,0.7],Hue[0.9,1,0.7],Hue[0.9,1,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.233,0.5,1],Hue[0.233,0.7,1],Hue[0.333,0.8,1],Hue[0.333,1,1],Hue[0.333,1,0.7],Hue[0.433,1,0.7],Hue[0.433,1,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.567,0.5,1],Hue[0.567,0.7,1],Hue[0.667,0.6,1],Hue[0.667,1,1],Hue[0.667,1,0.7],Hue[0.767,1,0.6],Hue[0.767,1,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];*)


RuleList[var_Symbol,n_,val_]:=Table[Subscript[var,i]->val/.\[IGrave]->i,{i,n}];


RuleList[var_Symbol,n_,{min_?NumericQ,max_?NumericQ}]:=Table[Subscript[var,i]->min+(max-min)*(i-1)/(n-1),{i,n}];


RuleList[vars_List,n_,vals_List]:=Flatten[Table[Subscript[vars[[j]],i]->vals[[j]],{i,n},{j,Length[vars]}]];


RuleList[var_Symbol,ns_List,val_]:=
	Thread[
		Table[Subscript[var,i],{i,Times[Sequence@@ns]}]->
		Table[val,{i,Times[Sequence@@ns]}]
	]


RuleList[vars_List,ns_List,vals_List]:=Module[{n,min,max},
	Thread[
		Flatten[Table[Map[Subscript[#,i]&,vars],{i,Times[Sequence@@ns]}]]
		->
		Flatten[Outer[List,Sequence@@Table[
			n=ns[[j]];
			If[ListQ[vals[[j]]],{min,max}=vals[[j]],min=max=vals[[j]]];
			Table[min+(max-min)*(i-1)/(n-1),{i,n}]
		,{j,Length[ns]}]]]
		]
	]


SetAttributes[RuleList,HoldAll];


(* mostly by Simon - see <http://stackoverflow.com/questions/5086749/mathematica-how-to-clear-the-cache-for-a-symbol-i-e-unset-pattern-free-downva> *)
ClearCache[f_]:=(DownValues[f]=DeleteCases[DownValues[f],_?(FreeQ[First[#],Pattern]&)];);

(* make work on multiple arguments *)
ClearCache[f__]:=(Map[ClearCache,{f}];);


IntepolatingFunctionFunctionQ[x_]:=If[Length[Cases[x,_InterpolatingFunction,\[Infinity],Heads->True]]!=0,True,False];
(*IntepolatingFunctionFunctionQ[x_]:=If[Head[Head[x]]===InterpolatingFunction,True,False];*) (* why did I write this? <- breaks (c[t]/.sol)^2 *)


TemporalDataFunctionQ[x_]:=If[Length[Cases[x,_TemporalData,\[Infinity],Heads->True]]!=0,True,False];


(* main *)
Avg[f_,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,method},
(*Print["main"];*)
	method=Evaluate[Method/.Flatten[{opts,Options[Avg]}]];
	If[IntepolatingFunctionFunctionQ[f]==True,method="NIntegrate"];
	If[TemporalDataFunctionQ[f]==True,method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[Avg]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Avg]}]];
	Which[
		method=="Integrate",
		Return[Integrate[f,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[f,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[f,{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Msg[General::badmtd];Return[$Failed]
	];
];


(* thread over RuleLists *)
Avg[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(x->Avg[val,opts]));
Avg[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["rulelist2"];*)
f/.(x_->val_):>(x->Avg[val,{var,varmin,varmax},opts]));


(* InterpolatingFunctionFunctions *)
Avg[f_?IntepolatingFunctionFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{nintegrateopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Avg]}]];
	
	ifdomains=Map[#["Domain"][[1]]&,Cases[f,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Msg[Avg::norange],
		numifdomains>1,
		Msg[Avg::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[Avg[f,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


(* InterpolatingFunctions *)
Avg[f_InterpolatingFunction,opts___?OptionQ]:=((*Print["IF"];*)Avg[f[t],opts]);
Avg[f_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)Avg[f[t],{var,varmin,varmax}opts]);


(* TemporalData *)
Avg[f_TemporalData,opts___?OptionQ]:=((*Print["td"];*)Mean[f]);
Avg[f_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["td2"];*)
Mean[TimeSeriesWindow[f,{varmin,varmax}]]);


(* fallthrough *)
Avg[f_?((!RuleListQ[#]&&!IntepolatingFunctionFunctionQ[#])&),opts___?OptionQ]:=((*Print["otherwise"];*)f);


Options[Avg]={Method->"Integrate",IntegrateOpts->{},NIntegrateOpts->{}};


(* main *)
Var[f_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg},
	method=Evaluate[Method/.Flatten[{opts,Options[Var]}]];
	If[IntepolatingFunctionFunctionQ[f]==True,method="NIntegrate"];
	If[TemporalDataFunctionQ[f]==True,method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[Var]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Var]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Var]}]];
	avg=Avg[f,{var,varmin,varmax},Method->method];
	Which[
		method=="Integrate",
		Return[Integrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)^2],
		method=="NIntegrate",
		Return[NIntegrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)^2],
		method=="Sum",
		Return[Sum[(f-avg)^2,{var,varmin,varmax}]/(varmax-varmin+1)^2],
		Else,
		Msg[General::badmtd];Return[$Failed];
	];
];


(* thread over RuleLists *)
Var[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(x->Var[val,opts]));
Var[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["rulelist2"];*)
f/.(x_->val_):>(x->Var[val,{var,varmin,varmax},opts]));


(* InterpolatingFunctionFunctions *)
Var[if_?IntepolatingFunctionFunctionQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Var]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Var]}]];
		
	ifdomains=Map[#["Domain"][[1]]&,Cases[if,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Msg[Var::norange],
		numifdomains>1,
		Msg[Var::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[Var[if,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


(* InterpolatingFunctions *)
Var[f_InterpolatingFunction,opts___?OptionQ]:=((*Print["raw IF"];*)Var[f[t],opts]);
Var[f_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)Var[f[t],{var,varmin,varmax}opts]);


(* TemporalData *)
Var[f_TemporalData,opts___?OptionQ]:=((*Print["td"];*)Variance[f]);
Var[f_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["td2"];*)
Variance[TimeSeriesWindow[f,{varmin,varmax}]]);


(* fallthrough *)
Var[f_?((!RuleListQ[#]&&!IntepolatingFunctionFunctionQ[#])&),opts___?OptionQ]:=((*Print["otherwise"];*)0);


Options[Var]={IntegrateOpts->{},NIntegrateOpts->{},AvgOpts->{},Method->"Integrate"};


Cov[f1_,f2_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg1,avg2},
	method=Evaluate[Method/.Flatten[{opts,Options[Cov]}]];
	If[(IntepolatingFunctionFunctionQ[f1]==True)||(IntepolatingFunctionFunctionQ[f2]==True),method="NIntegrate"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[Cov]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Cov]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Cov]}]];
	
	avg1=Avg[f1,{var,varmin,varmax},Method->method];
	avg2=Avg[f2,{var,varmin,varmax},Method->method];
	
	Which[
		method=="Integrate",
		Return[Integrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)^2],
		method=="NIntegrate",
		Return[NIntegrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)^2],
		Else,
		Msg[General::badmtd];Return[$Failed];
	];
];


Cov[if1_,if2_?IntepolatingFunctionFunctionQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[Cov]}]];
	avgopts=Evaluate[AvgOpts/.Flatten[{opts,Options[Cov]}]];

	ifdomains=Map[#["Domain"][[1]]&,Cases[{if1,if2},_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Msg[Cov::norange],
		numifdomains>1,
		Msg[Cov::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[Cov[if1,if2,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


Cov[if1_?IntepolatingFunctionFunctionQ,if2_,var_:t,opts___?OptionQ]:=Cov[if2,if1,var,opts];


Options[Cov]={IntegrateOpts->{},NIntegrateOpts->{},AvgOpts->{},Method->"Integrate"};


(* by Jens <http://mathematica.stackexchange.com/a/20282/6358> *)
ExtractPlotPoints[plot_Graphics]:=Cases[Normal@plot,Line[x_]:>x,\[Infinity]];


Else=True;


(*SpFrac[sp_Integer,nsp_Integer]:=If[nsp\[Equal]1,0.5,(sp-1.)/(nsp-1.)];*)
SpFrac[sp_Integer,nsp_Integer]:=sp/(nsp+1.);


ModPart[list_List,part_Integer]:=Part[list,Mod[part,Length[list],1]];


NumberedGridForm[list_List]:=Grid[Transpose[{Range[Length[list]],list}],Alignment->Left];


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358> & a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


FindMaxima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]<0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;


FindMaxima[if_InterpolatingFunction]:=FindMaxima[if,if["Domain"][[1]]];


FindMinima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]>0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;


FindMinima[if_InterpolatingFunction]:=FindMinima[if,if["Domain"][[1]]];


FindExtrema[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]==0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;


FindExtrema[if_InterpolatingFunction]:=FindExtrema[if,if["Domain"][[1]]];


FindPeriod[sol_,opts:OptionsPattern[]]:=Module[{var1,res,tmp},

Which[
	Head[sol[[1,2]]]===TemporalData,
	(* based on idea from bbgodfrey, http://mathematica.stackexchange.com/a/107741/6358 *)
	res=Length[DeleteDuplicates[Transpose[
		Map[(#/.sol)["Values"][[Max[-sol[[1,2]]["PathLength"],-OptionValue[MaxPeriod]];;]]&,sol[[All,1]]]],
		Norm[#1-#2]<10^-OptionValue[AccuracyGoal]+Norm[(#1-#2)/#1]*10^-OptionValue[PrecisionGoal]&]]
,
	Head[sol[[1,2]]]===InterpolatingFunction&&OptionValue[BasePeriod]=!=None,
	var1=sol[[1,1]];
	tmp={var1->TimeSeries[Table[{t,var1/.Slice[sol,t]},{t,InitialTime[sol],FinalTime[sol],OptionValue[BasePeriod]}]]};
	res=FindPeriod[tmp]*OptionValue[BasePeriod]
,
	True, (* else *)
	Return[];
];

Return[res]

];


Options[FindPeriod]={MaxPeriod->4,AccuracyGoal->5,PrecisionGoal->5,BasePeriod->None};


(* originally by Rahul <http://mathematica.stackexchange.com/a/42770/6358>,
tweaked by me <https://mathematica.stackexchange.com/a/157613/6358>,
RegionFunction fixed by kglr <https://mathematica.stackexchange.com/a/193304/6358> *)
ClearAll[myStreamPlot]
Options[myStreamPlot]=Options[StreamPlot];
myStreamPlot[f_,{x_,x0_,x1_},{y_,y0_,y1_},opts:OptionsPattern[]]:=Module[
	{u,v,a=OptionValue[AspectRatio]/.Automatic->1,rf=OptionValue[RegionFunction]},
	Show[StreamPlot[{1/(x1-x0),a/(y1-y0)} (f/.{x->Rescale[u,{0,1},{x0,x1}],y->Rescale[v,{0,a},{y0,y1}]}),{u,0,1},{v,0,a},
	RegionFunction->(rf[Rescale[#,{0,1},{x0,x1}],Rescale[#2,{0,a},{y0,y1}],##3]&),opts]
	/.Arrow[pts_]:>Arrow[Transpose[{Rescale[#,{0,1},{x0,x1}],Rescale[#2,{0,a},{y0,y1}]}&@@Transpose[pts]]],
	PlotRange->{{x0,x1},{y0,y1}}]
]


RealSimplify[foo_]:=Simplify[foo,Assumptions->{_\[Element]Reals}];


TD[list_List]:=If[$VersionNumber>=10,TimeSeries[list],list];


CompoundAnd[list_]:=Module[{},And[Evaluate[Sequence@@list]]];


CompoundOr[list_]:=Module[{},Or[Evaluate[Sequence@@list]]];


RuleListDistance[pop1_?NumericRuleListQ,pop2_?NumericRuleListQ,p_:\[Infinity]]:=Norm[Sort[pop1][[All,2]]-Sort[pop2][[All,2]],p];


NumericListQ[x_]:=VectorQ[x,NumericQ[#]&];


NumericFlattenedListQ[x_]:=If[ListQ[x],NumericListQ[Flatten[x]],False];


RuleListQ[x_]:=VectorQ[x,(#[[0]]==Rule||#[[0]]==RuleDelayed)&];


RuleListListQ[x_]:=VectorQ[x,RuleListQ[#]&];


NumericRuleListQ[x_]:=If[RuleListQ[x],VectorQ[x,NumericQ[#[[2]]]&],False];


RuleListTweak[point_?RuleListQ,var_Symbol,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_Subscript,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_List,h_List]:=Join[Select[point,!MemberQ[var,#[[1]]]&],#->((#/.point)+h[[Position[var,#][[1,1]]]])&/@var];


(*RuleListAdd[l1_?RuleListQ,l2_?RuleListQ,m2_:1,m1_:1]:=Table[e\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]m1*e\[LeftDoubleBracket]2\[RightDoubleBracket]+m2*(e\[LeftDoubleBracket]1\[RightDoubleBracket]/.l2),{e,l1}];*)
RuleListAdd[a_?RuleListQ,b_?RuleListQ] := Normal[Merge[{a,b},Total]]


RuleListSubtract[a_?RuleListQ,b_?RuleListQ]:=RuleListAdd[a,RuleListMultiply[b,-1]];


RuleListMultiply[a_?RuleListQ,x_?NumericQ]:=Normal[Merge[a,x*#[[1]]&]];
RuleListMultiply[x_?NumericQ,a_?RuleListQ]:=Normal[Merge[a,x*#[[1]]&]];


NumericRuleListToNumericList[rl_?NumericRuleListQ,vars_List]:=vars/.rl;


(* based on code by MichaelE2 <https://mathematica.stackexchange.com/a/152861/6358> *)


ClearAll[ifnPart];
ifnPart["Domain"]=Sequence[1];(*bounding box for domain*)
ifnPart["X1"]=Sequence[1,1];(*lower bound for first coordinate*)
ifnPart["X2"]=Sequence[1,2];(*upper bound for first coordinate*)
ifnPart["Version"]=Sequence[2,1];
ifnPart["Flags"]=Sequence[2,2];(*flags indicating properties:bit field positions-inferred,perhaps mistaken $extrapolation=0;whether to warn about extrapolation $fullArrayBit=1;interpolation data is a full array (not ragged) $packed=2;packed array form (???) $repeatedBit=4;whether repeated abscissae are permitted*)
ifnPart["DerivativeOrder"]=Sequence[2,3];(*max derivative order*)
ifnPart["NGrid"]=Sequence[2,4];(*number of points in each coordinate grid*)
ifnPart["InterpolationOrder"]=Sequence[2,5];(*interpolation order*)
ifnPart["Derivative"]=Sequence[2,6];(*derivative to evaluate:0-->f[x],1-->f'[x],...*)
ifnPart["Periodic"]=Sequence[2,7];
ifnPart["ExtrapolationHandler"]=Sequence[2,10];
ifnPart["Coordinates"]=Sequence[3];(*list of lists,abscissae of interpolation grid*)
ifnPart["InterpolationData"]=Sequence[4];(*interpolation data (values or coefficients)*)
ifnPart["Offsets"]=Sequence[4,2];(*offsets in function/derivative array (PackedArrayForm)*)
ifnPart["FlatData"]=Sequence[4,3];(*flattened function/derivative values (PackedArrayForm)*)
ifnPart["InterpolationStructure"]=Sequence[5];(*{Automatic},or dense output interpolation structure:list of types for each unit/subinterval*)ifnPart["UnitIndices"]=Sequence[5,1,1];(*dense output:Indices (to grid) for corresponding coefficients*)
ifnPart["UnitTypes"]=Sequence[5,1,2];(*dense output types:Automatic|NDSolve`CubicHermite|NDSolve`LocalSeries|ChebyshevT*)
ifnPart["Properties"]=Cases[DownValues[ifnPart],Verbatim[ifnPart][prop_]:>prop,Infinity];

ifnPart["ValidPartQ","Chebyshev"|"Local Taylor Series","UnitIndices"|"UnitTypes",_]:=True;
ifnPart["ValidPartQ",_,"UnitIndices"|"UnitTypes",_]:=False;
ifnPart["ValidPartQ","Hermite","Offsets"|"FlatData",Developer`PackedArrayForm]:=True;
ifnPart["ValidPartQ",_,"Offsets"|"FlatData",_]:=False;
ifnPart["ValidPartQ",method_String,part_String,_]/;MemberQ[method,"Chebyshev"|"Local Taylor Series"|"Hermite"]&&MemberQ[part,ifnPart["Properties"]]:=True;
ifnPart["ValidPartQ",_,_,_]:=False;
ifnPart[if_InterpolatingFunction,part_String]/;ifnPart["ValidPartQ",if["InterpolationMethod"],part,if[[4,1]]]:=if~Part~ifnPart[part];


dupeLast[list_]:=Append[list,Last@list];

iDataTake["Local Taylor series"|"Chebyshev",data_,span_]:=Join[{data[[First@span,1;;2]]},data[[First@span+1;;Last@span]]];
iDataTake["Hermite",data:{Developer`PackedArrayForm,_,_},span:{s1_,s2_}]:=
	ReplacePart[data,{Rest@{ifnPart["Offsets"]}->data[[2,s1;;s2+1]]-data[[2,s1]],Rest@{ifnPart["FlatData"]}->data[[3,data[[2,s1]]+1;;data[[2,s2+1]]]]}];
iDataTake["Hermite",data:{__List},span_]:=data[[Span@@span]];

iStructureTake["Local Taylor series"|"Chebyshev",structure_,span_]:=
	ReplacePart[structure,{Rest@{ifnPart["UnitIndices"]}->Join[{{1}},1+structure[[##2&@ifnPart["UnitIndices"],First@span+1;;Last@span]]-structure[[##2&@ifnPart["UnitIndices"],First@span,-1]]//dupeLast],Rest@{ifnPart["UnitTypes"]}->Join[{Automatic},structure[[##2&@ifnPart["UnitTypes"],First@span+1;;Last@span]]//dupeLast]}];
iStructureTake["Hermite",structure_,span_]:=structure;

InterpolatingFunctionTake[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]/;Length@if["Domain"]==1:=Module[
{coords,newif=Hold@@if,span,method},

method=if["InterpolationMethod"];
coords=First@if["Coordinates"];
span=Clip[SparseArray[UnitStep[coords-tmin] UnitStep[tmax-coords]]["AdjacencyLists"][[{1,-1}]]+{-1,1},{1,Length@coords}];
newif[[ifnPart["Domain"]]]={{tmin,tmax}};
newif[[ifnPart["NGrid"]]]=1+Differences@span;
newif[[ifnPart["Coordinates"]]]=Developer`ToPackedArray@{coords[[Span@@span]]};
newif[[ifnPart["InterpolationData"]]]=iDataTake[method,if[[ifnPart["InterpolationData"]]],span];
newif[[ifnPart["InterpolationStructure"]]]=iStructureTake[method,if[[ifnPart["InterpolationStructure"]]],span];
InterpolatingFunction@@newif
];


Slice[sol_,t_?NumericQ]:=Which[
	MemberQ[{InterpolatingFunction,TemporalData},Head[#[[2]]]],
	ReplacePart[#,2->(#[[1]][t]/.#)]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],#[[1]]==t&,1][[1,2]]]
,
	Else,#
]&/@sol;

Slice[sol_,{t1_?NumericQ,t2_?NumericQ}]:=
Which[
	Head[#[[2]]]===InterpolatingFunction,
	ReplacePart[#,2->InterpolatingFunctionTake[#[[2]],{t1,t2}]]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],t1<=#[[1]]<=t2&]]
,
	Head[#[[2]]]===TemporalData,
	ReplacePart[#,2->TimeSeries[Transpose[{#[[2]]["Times"][[t1+1;;t2+1]],#[[2]]["Values"][[t1+1;;t2+1]]}]]]
,
	Else,#
]&/@sol


FinalSlice[sol_,n:(_?NumericQ):0]:=
	If[n==0,
		Return[Slice[sol,FinalTime[sol]]],
		Return[Slice[sol,{FinalTime[sol]-n,FinalTime[sol]}]]
	];


InitialSlice[sol_,n:(_?NumericQ):0]:=
	If[n==0,
		Return[Slice[sol,InitialTime[sol]+10.^-100]],
		Return[Slice[sol,{InitialTime[sol]+10.^-100,InitialTime[sol]+n}]]
	];


FinalDerivatives[sol_,dt:(_?NumericQ):0]:=Module[{res},
	If[dt==0,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]]'[#[[2,1,1,2]]]/.#)}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket]'[#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]/.#)}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-2,2]])/(#[[2,-1,1]]-#[[2,-2,1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-2]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-2]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-2\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]][#[[2,1,1,2]]]-#[[1]][#[[2,1,1,2]]-dt])/dt/.#}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]-#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]-dt])/dt/.#}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-(1+dt),2]])/(#[[2,-1,1]]-#[[2,-(1+dt),1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-(1+dt)]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-(1+dt)]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	];
	Return[res]
]


InitialTime[sol_]:=Which[
	Head[sol[[1,2]]]===InterpolatingFunction,sol[[1,2,1,1,1]],
	Head[sol[[1,2]]]===List,sol[[1,2,1,1]],
	Head[sol[[1,2]]]===TemporalData,sol[[1,2]]["FirstTime"]
];


FinalTime[sol_]:=Which[
	Head[sol[[1,2]]]===InterpolatingFunction,sol[[1,2,1,1,2]],
	Head[sol[[1,2]]]===List,sol[[1,2,-1,1]],
	Head[sol[[1,2]]]===TemporalData,sol[[1,2]]["LastTime"]
];


(* by Jens <http://mathematica.stackexchange.com/questions/59172/should-eigenvalues-be-ordered> *)
SortedEigensystem[matrix_?MatrixQ,opts___]:=
(Eigensystem[matrix+# IdentityMatrix[Dimensions[matrix]],opts]-{#,0})&@Norm[Flatten[matrix]];


(* by Joel Wallman <http://mathematica.stackexchange.com/a/113113/6358> *)
ListMultiplier[list_,partitionwidth_:5]:=NestWhile[Dot@@@Partition[#,partitionwidth,partitionwidth,1,{}]&,list,Dimensions[#][[1]]>1&][[1]];


RunFile[file_String]:=Module[{res},
	res=ReadString[file];
	CellPrint[Cell[StringTake[res,{1,-2}],"Program"]];
	ToExpression[res];
];


(* by Joel Wallman <http://mathematica.stackexchange.com/a/113113/6358> *)
listMultiplier[list_,partitionwidth_: 5]:=NestWhile[Dot@@@Partition[#,partitionwidth,partitionwidth,1,{}]&,list,Dimensions[#][[1]]>1&][[1]]


RouthHurwitzCriteria[a_?MatrixQ]:=Module[{c3},
	If[!SquareMatrixQ[a],Msg[RouthHurwitzCriteria::nonsq];Return[a]];
	Which[
		Length[a]==1,
		Return[Piecewise[{{True,a[[1,1]]<0},{False,a[[1,1]]>0}},Indeterminate]],
		Length[a]==2,
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]>0},{False,Tr[a]>0||Det[a]<0}},Indeterminate]],
		Length[a]==3,
		c3=Det[{{a[[1,1]]+a[[2,2]],a[[2,3]],-a[[1,3]]},{a[[3,2]],a[[1,1]]+a[[3,3]],a[[1,2]]},{-a[[3,1]],a[[2,1]],a[[2,2]]+a[[3,3]]}}];
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]<0&&c3<0},{False,Tr[a]>0||Det[a]>0||c3>0}},Indeterminate]],
		Length[a]>3,
		Msg[RouthHurwitzCriteria::toobig];Return[a]
	]
];


UnsetModel:=(
	modelloaded=False;
	Clear[LookUp,type,range,comptype,color,linestyle,plotmarker,DT,modelinvthreshold,
	modeltype,modelwhenevents,modelperiod,
	pops,npops,npcomps,pcomps,pcompeqn,
	auxs,nauxs,auxeqn,
	guilds,nguilds,gcomps,ngcomps,gcompeqn,gtraits,ngtraits,
	pcompvars,auxvars,gcompvars,traitvars,eqns];
	$Assumptions={};
	);


SetModel[model_?RuleListQ,opts___?OptionQ]:=Module[{
(* options *)
colors,linestyles,plotmarkers,gradients,assumptions,
(* other *)
stylecount,basestyle,indexcount,in},

(* options *)

colors=Evaluate[Colors/.Flatten[{opts,Options[SetModel]}]];
linestyles=Evaluate[LineStyles/.Flatten[{opts,Options[SetModel]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[SetModel]}]];
assumptions=Evaluate[Assumptions/.Flatten[{model,Options[SetModel]}]];

UnsetModel;

modelloaded=True;

(* model name - default="UnnamedModel"*)
modelname=ModelName/.Append[model,ModelName->"UnnamedModel"];

(* model type - default="ContinuousTime" *)
modeltype=ModelType/.Append[model,ModelType->"ContinuousTime"];
If[!MemberQ[{"ContinuousTime","DiscreteTime"},modeltype],Msg[SetModel::unktype]];

(* model whenevents - default={} *)
modelwhenevents:=WhenEvents/.Append[model,WhenEvents->{}];

(* period - default=0 (unforced) *)
modelperiod:=Period/.Append[model,Period->0];

stylecount=0;

(* pops *)

pops=Select[model,#[[1,0]]==Pop&][[All,1,1]];
(*Print["pops=",pops];*)
npops=Length[pops];
(*Print["npops=",npops];*)
pcompeqn[pop_,pco_]:=Equation/.If[RuleListQ[Component[pco]/.(Pop[pop]/.model)],Component[pco]/.(Pop[pop]/.model),Pop[pop]/.model];

Do[
	in=Pop[pop]/.model;
	type[pop]="pop";
	pcomps[pop]=Select[in,#[[1,0]]==Component&][[All,1,1]];
	If[pcomps[pop]=={},pcomps[pop]={pop}];
	(*Print["pcomps["<>ToString@pop<>"]=",pcomps[pop]];*)
	npcomps[pop]=Length[pcomps[pop]];
	(*Print["npcomps["<>ToString[pop]<>"]=",npcomps[pop]];*)
	Do[
		stylecount++;
		type[pcomp]="pcomp";
		in=If[RuleListQ[Component[pco]/.(Pop[pop]/.model)],Component[pcomp]/.(Pop[pop]/.model),Pop[pop]/.model];
		comptype[pcomp]=Type/.Append[in,Type->"Extensive"];
		range[pcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		color[pcomp]=Color/.Append[in,Color->ModPart[colors,stylecount]];
		linestyle[pcomp]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[pcomp]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[pcomp]={"pcomp",pop,pcomp};
	,{pcomp,pcomps[pop]}];
,{pop,pops}];

(* auxs *)
auxs=Select[model,#[[1,0]]==Aux&][[All,1,1]];
(*Print["auxs=",auxs];*)
naux=Length[auxs];
(*Print["naux=",naux];*)
auxeqn[au_]:=Equation/.(Aux[au]/.model);

Do[
	stylecount++;
	type[aux]="aux";
	in=Aux[aux]/.model;
	range[aux]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
	color[aux]=Color/.Append[in,Color->ModPart[colors,stylecount]];
	linestyle[aux]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
	plotmarker[aux]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
	LookUp[aux]={"aux",aux};
,{aux,auxs}];

(* guilds *)

stylecount=0;

guilds=Select[model,#[[1,0]]==Guild&][[All,1,1]];
(*Print["guilds=",guilds];*)
nguilds=Length[guilds];
(*Print["nguilds=",nguilds];*)
gcompeqn[gu_,gco_]:=Equation/.If[RuleListQ[Component[gco]/.(Guild[gu]/.model)],Component[gco]/.(Guild[gu]/.model),Guild[gu]/.model];

Do[
	(*Print[Guild[gu]/.model];*)
	type[gu]="guild";
	gcomps[gu]=Select[Guild[gu]/.model,#[[1,0]]==Component&][[All,1,1]];
	If[Length[gcomps[gu]]==0,gcomps[gu]={Guild[gu][[1]]}];
	ngcomps[gu]=Length[gcomps[gu]];
	gtraits[gu]=Select[Guild[gu]/.model,#[[1,0]]==Trait&][[All,1,1]];
	ngtraits[gu]=Length[gtraits[gu]];
	(*Print[gu," ",{gcomps[gu],gtraits[gu]}];*)

	If[nguilds==1&&ngcomps[guilds[[1]]]==1&&ngtraits[guilds[[1]]]==1,
		gradients={Evaluate[Gradient/.Flatten[{opts,Options[SetModel]}]]},
		gradients=Evaluate[Gradients/.Flatten[{opts,Options[SetModel]}]]
	];
	
	indexcount=0;
	Do[
		indexcount++;
		stylecount++;
		basestyle[gu]=stylecount;
		in=If[RuleListQ[Component[gcomp]/.(Guild[gu]/.model)],Component[gcomp]/.(Guild[gu]/.model),Guild[gu]/.model];
		type[Subscript[gcomp,_]]=index[gcomp]="gcomp";
		index[Subscript[gcomp,_]]=index[gcomp]=indexcount;
		comptype[Subscript[gcomp,_]]=comptype[gcomp]=Type/.Append[in,Type->"Extensive"];
		range[Subscript[gcomp,_]]=range[gcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		color[Subscript[gcomp,_]]=Color/.Append[in,Color->With[{gradient=ModPart[gradients,stylecount]},ColorData[gradient][#]&]];
		linestyle[Subscript[gcomp,_]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[Subscript[gcomp,_]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[gcomp]={"gcomp",gu,gcomp};
		LookUp[Subscript[gcomp,sp_]]={"gcomp",gu,gcomp,sp};
	,{gcomp,gcomps[gu]}];

	indexcount=0;
	Do[
		indexcount++;
		stylecount=basestyle[gu];
		in=Trait[gtrait]/.(Guild[gu]/.model);
		type[Subscript[gtrait,_]]=index[gtrait]="gtrait";
		index[Subscript[gtrait,_]]=index[gtrait]=indexcount;
		range[Subscript[gtrait,_]]=range[gtrait]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
		color[Subscript[gtrait,_]]=Color/.Append[in,Color->With[{gradient=ModPart[gradients,stylecount]},ColorData[gradient][#]&]];
		linestyle[Subscript[gtrait,_]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[Subscript[gtrait,_]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[gtrait]={"gtrait",gu,gtrait};
		LookUp[Subscript[gtrait,sp_]]={"gtrait",gu,gtrait,sp};
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];

auxvars=Table[aux,{aux,auxs}];
pcompvars=Flatten[Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}]];
gcompvars=Flatten[Table[Table[gcomp,{gcomp,gcomps[gu]}],{gu,guilds}]];
gtraitvars=Flatten[Table[Table[gtrait,{gtrait,gtraits[gu]}],{gu,guilds}]];

(* model assumptions - default={} *)
$Assumptions=Flatten[assumptions/.Automatic->Join[
	Table[Region`SpecialRegionProperty[range[aux],{aux},"ImplicitDescription"],{aux,auxs}],
	Table[Table[Region`SpecialRegionProperty[range[pcomp],{pcomp},"ImplicitDescription"],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gcomp],{Subscript[gcomp,sp]},"ImplicitDescription"],{sp,0,2}],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gtrait],{Subscript[gtrait,sp]},"ImplicitDescription"],{sp,0,2}],{gtrait,gtraits[gu]}],{gu,guilds}]
]];
(*Print["$Assumptions=",$Assumptions];*)

Which[
	modeltype=="ContinuousTime",
	DT[var_]:=var'[t];modelinvthreshold=0
,
	modeltype=="DiscreteTime",
	DT[var_]:=var[t+1];modelinvthreshold=1
];

eqn[var_]:=Module[{luv=LookUp[var]},
	Which[
		luv[[1]]=="aux",auxeqn[luv[[2]]],
		luv[[1]]=="pcomp",pcompeqn[luv[[2]],luv[[3]]],
		luv[[1]]=="gcomp",gcompeqn[luv[[2]],luv[[3]]][luv[[4]]]
	]
];

]


Options[SetModel]={
	LineStyles->{{}},PlotMarkers->Graphics`PlotMarkers[],
	Colors->ColorData[97,"ColorList"],Gradient->"Rainbow",Gradients->{"EEGreens","EEReds","EEBlues"},
	Assumptions->{Automatic}
};


ModelInfo:=(

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[]];

(* model name *)
Print["modelname=",modelname];

(* model type *)
Print["modeltype=",modeltype,", modelperiod=",modelperiod];

(* aux vars *)
Print["auxs=",auxs," (naux=",naux,")"];
Do[
	Print["  ",FuncStyle[aux]];
	Print["  eqn[",aux,"]=",eqn[aux]];
	Print["  range[",aux,"]=",range[aux]];
,{aux,auxs}];

(* pops *)

Print["pops=",pops," (npops=",npops,")"];
Do[
	Print["  pcomps[",pop,"]=",pcomps[pop]," (npcomps[",pop,"]=",npcomps[pop],")"];
	Do[
		Print["    ",FuncStyle[pcomp]];
		Print["    eqn[",pcomp,"]=",eqn[pcomp]];
		Print["    comptype[",pcomp,"]=",comptype[pcomp]];
		Print["    range[",pcomp,"]=",range[pcomp]];
	,{pcomp,pcomps[pop]}];
,{pop,pops}];

(* guilds *)

Print["guilds=",guilds," (nguilds=",nguilds,")"];
Do[
	Print["  gcomps[",gu,"]=",gcomps[gu]," (ngcomps[",gu,"]=",ngcomps[gu],")"];
	Do[
		Print["    ",FuncStyle[gcomp]];
		Print["    eqn[",Subscript[gcomp,Global`i],"]=",eqn[Subscript[gcomp,Global`i]]];
		Print["    comptype[",gcomp,"]=",comptype[gcomp]];
		Print["    range[",gcomp,"]=",range[gcomp]];
	,{gcomp,gcomps[gu]}];
	Print["  gtraits[",gu,"]=",gtraits[gu]," (ngtraits[",gu,"]=",ngtraits[gu],")"];
	Do[
		Print["    ",FuncStyle[gtrait]];
		Print["    range[",gtrait,"]=",range[gtrait]];
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];

);


MatrixToPopComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[(Sum[a[[c,c\[Prime]]]var[c\[Prime]][t],{c\[Prime],ncomps}])]},{c,ncomps}];
	On[Part::partd];
	Return[res]
];


MatrixToGuildComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[Sum[a[[c,c\[Prime]]]var[c\[Prime]][t],{c\[Prime],ncomps}]]/.{var[c_]->Subscript[var[c],#]}},{c,ncomps}];
	On[Part::partd];
	Return[res/.{(Equation:>eqn_)->(Equation:>(eqn&))}]
];


FromUnks:=Flatten[{
	Table[Table[Unk[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[Unk[pcomp]->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Unk[aux]->aux,{aux,auxs}],
	Table[Table[Unk[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]],{gtrait,gtraits[gu]}],{gu,guilds}]
}]


FromUnks:=Unk[stuff___]->stuff


ToUnks:=Flatten[{
	Table[Table[Subscript[gcomp,\[FormalS]_]->Unk[Subscript[gcomp,\[FormalS]]],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}],
	Table[Table[Subscript[gtrait,\[FormalS]_]->Unk[Subscript[gtrait,\[FormalS]]],{gtrait,gtraits[gu]}],{gu,guilds}]
}]


ToUnkRules:=Flatten[Join[
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_][t])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]][t])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[(pcomp->pcomp)->(pcomp->Unk[pcomp]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[(pcomp->pcomp[t])->(pcomp->Unk[pcomp][t]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[(aux->aux)->(aux->Unk[aux]),{aux,auxs}],
	Table[(aux->aux[t])->(aux->Unk[aux][t]),{aux,auxs}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]])
	,{gtrait,gtraits[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_][t])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]][t])
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]]


AllTraits:=Flatten[Table[Table[Table[Subscript[gtrait,sp],{gtrait,gtraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,guilds}]];


AllVariables:=Flatten[Join[
	Table[Table[Table[Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,Nsp[gu]}],{gu,guilds}],
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


AllPopsAndAuxs:=Flatten[Join[
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


BlankTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Subscript[gtrait,sp],{gtrait,gtraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,guilds}]];


BlankUnkTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Unk[Subscript[gtrait,sp]],{gtrait,gtraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,guilds}]];


BlankVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,Nsp[gu]}],{gu,guilds}],
	Table[Table[pcomp->pcomp,{pcomp,pcomps}],{pop,pops}],
	Table[aux->aux,{aux,auxs}]
]];


BlankUnkVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Unk[Subscript[gcomp,sp]],{gcomp,gcomps[gu]}],{sp,Nsp[gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}]
]];


ExpandNspInTraits[traits_]:=traits/.(Nsp[gu_]->nsp_):>
Sequence@@Flatten[Table[Table[Subscript[gtrait,sp]->Subscript[gtrait,sp],{gtrait,gtraits[gu]}],{sp,nsp}]];


ExpandNspInPops[pops_]:=pops/.(Nsp[gu_]->nsp_):>
Sequence@@Flatten[Table[Table[Subscript[gcomp,sp]->Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,nsp}]];


ExpRule[vars_List,logged_]:=Table[If[logged===True&&comptype[var]==="Extensive",var[t]->E^log[var][t],Nothing],{var,vars}];


SetNsp[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{}]:=Module[{tmp,tnsp,pnsp},
(*Print["In SetNsp, traits=",traits," variables=",variables];*)

	Do[
		tmp=Table[Max[Select[Select[variables,#[[1,0]]==Subscript&],#[[1,1]]==gcomp&][[All,1,2]]],{gcomp,gcomps[gu]}];
		If[Length[Union[tmp]]==1,
			pnsp[gu]=tmp[[1]],
			Msg[SetNsp::badcomm,gu,tmp];
			Abort[]
		];
		If[pnsp[gu]==-\[Infinity],pnsp[gu]=0];
	,{gu,guilds}];
	
	Do[
		If[ngtraits[gu]!=0,
			tmp=Table[Max[Select[Select[traits,#[[1,0]]==Subscript&],#[[1,1]]==gtrait&][[All,1,2]]],{gtrait,gtraits[gu]}];
			If[Length[Union[tmp]]==1,
				tnsp[gu]=tmp[[1]],
				Msg[SetNsp::badtrait,gu,tmp];
				Abort[]
			];
			If[tnsp[gu]==-\[Infinity],tnsp[gu]=0];
		,
			tnsp[gu]=pnsp[gu]
		]
	,{gu,guilds}];
	
(*Print["SetNsp: tnsp=",Table[tnsp[gu],{gu,guilds}]," pnsp=",Table[pnsp[gu],{gu,guilds}]];*)

	If[Table[tnsp[gu],{gu,guilds}]==Table[pnsp[gu],{gu,guilds}]||variables=={}||traits=={},
		Do[
			Nsp[gu]=If[traits!={},tnsp[gu],pnsp[gu]]
		,{gu,guilds}]
	,
		Msg[SetNsp::badnsp,Table[tnsp[gu],{gu,guilds}],Table[pnsp[gu],{gu,guilds}]];
		Abort[]
	];
]/;(nguilds!=0);


AddUnkts:=(var_->Unk[stuff___])->(var->Unk[stuff][t]);


AddVariablets:=DeleteDuplicates[Flatten[Join[
	Table[Table[
		{Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]][t],Unk[gcomp,\[FormalS]_]->Unk[gcomp,\[FormalS]][t]}
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[
		{pcomp->pcomp[t],Unk[pcomp]->Unk[pcomp][t]}
	,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[{aux->aux[t],Unk[aux]->Unk[aux][t]},{aux,auxs}]
]]];


AddTraitts:=Flatten[Table[Table[
	{Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]][t],Unk[gtrait,\[FormalS]_]->Unk[gtrait,\[FormalS]][t]}
,{gtrait,gtraits[gu]}],{gu,guilds}]];


RemoveVariablets:=DeleteDuplicates[Flatten[Join[
	Table[Table[
		Subscript[gcomp,\[FormalS]_][t]->Subscript[gcomp,\[FormalS]]
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp[t]->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux[t]->aux,{aux,auxs}]
]]];


RemoveTraitts:=Flatten[Table[Table[
	Subscript[gtrait,\[FormalS]_][t]->Subscript[gtrait,\[FormalS]]
,{gtrait,gtraits[gu]}],{gu,guilds}]];


ExtractTraits[in_?RuleListQ]:=Module[{res},
	Off[Part::partd];
	res=Join[
		Select[in,MemberQ[gtraitvars,#[[1,1]]]&],
		Select[in,(#[[1,0]]==Nsp)&]
	];
	On[Part::partd];
	Return[res]
];


ExtractAuxs[in_?RuleListQ]:=Module[{res},
	Off[Part::partd];
	res=Select[in,MemberQ[auxvars,#[[1]]]&];
	On[Part::partd];
	Return[res]
];


ExtractPops[in_?RuleListQ]:=Module[{res},
	Off[Part::partd];
	res=Select[in,MemberQ[pcompvars,#[[1]]]&];
	On[Part::partd];
	Return[res]
];


ExtractGuilds[in_?RuleListQ]:=Module[{res},
	Off[Part::partd];
	res=Join[
		Select[in,MemberQ[gcompvars,#[[1,1]]]&],
		Select[in,(#[[1,0]]==Nsp)&]
	];
	On[Part::partd];
	Return[res]
];


ExtractVariables[in_?RuleListQ]:=Join[ExtractAuxs[in],ExtractPops[in],ExtractGuilds[in]];


(* make Listable *)
ExtractTraits[in_?RuleListListQ]:=ExtractTraits/@in;
ExtractAuxs[in_?RuleListListQ]:=ExtractAuxs/@in;
ExtractPops[in_?RuleListListQ]:=ExtractPops/@in;
ExtractGuilds[in_?RuleListListQ]:=ExtractGuilds/@in;
ExtractVariables[in_?RuleListListQ]:=ExtractVariables/@in;


TraitsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="gtrait"||#[[1,0]]===Nsp)&]


NotInvaderTraitsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&((LookUp[#[[1]]][[1]]==="gtrait"&&LookUp[#[[1]]][[4]]=!=0)||#[[1,0]]===Nsp)&]


VariablesQ[list_]:=list==="FindEcoAttractor"||VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(MemberQ[{"pcomp","gcomp","aux"},First@LookUp[#[[1]]]]||#[[1,0]]===Nsp)&]


(*TraitsAndVariablesQ[list_]:=VectorQ[list,(#\[LeftDoubleBracket]0\[RightDoubleBracket]\[Equal]Rule||#\[LeftDoubleBracket]0\[RightDoubleBracket]\[Equal]RuleDelayed)&&(MemberQ[{"pcomp","gcomp","aux","trait"},First@LookUp[#\[LeftDoubleBracket]1\[RightDoubleBracket]]]||#\[LeftDoubleBracket]1,0\[RightDoubleBracket]\[Equal]Nsp)&]*)


TraitsAndVariablesQ[list_]:=
If[RuleListQ[list]&&ExpandNspInTraits[ExtractTraits[list]]=!=list&&ExpandNspInPops[ExtractVariables[list]]=!=list,True,False,False]


ListOfVariablesQ[x_]:=If[x==={},False,VectorQ[x,VariablesQ[#]&]];


InvaderQ[x_]:=If[
	MemberQ[Join[pcompvars,pops],x]||
	(x[[0]]===Rule&&Length[LookUp[x[[1]]]]>=4&&LookUp[x[[1]]][[{1,4}]]==={"gtrait",0})||
	VectorQ[x,#[[0]]===Rule&&Length[LookUp[#[[1]]]]>=4&&LookUp[#[[1]]][[{1,4}]]==={"gtrait",0}&],True,False]


GsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(MemberQ[{G,V},#[[1,0]]])&]


DefaultICs:=Flatten[{
	Table[Table[Table[Subscript[gcomp,sp]->Min[(Min[range[gcomp]]+Max[range[gcomp]])/2,Min[range[gcomp]]+1],{gcomp,gcomps[gu]}],{sp,Nsp[gu]}],{gu,guilds}],
	Table[Table[pcomp->Min[(Min[range[pcomp]]+Max[range[pcomp]])/2,Min[range[pcomp]]+1],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Min[(Min[range[aux]]+Max[range[aux]])/2,Min[range[aux]]+1],{aux,auxs}]
}];


DeleteInvaders[list_List]:=DeleteCases[list,Subscript[_,0]->_];


PlotDynamics[sol_,plotvarsin_List,opts___?OptionQ]:=

Module[{
(* options *)
logged,plotstyle,plotmarkers,axeslabel,plotopts,plotrange,
(* other variables *)
lookup,vars,plotvars,yaxislabel,xinit,xfinal,ifvars,tdvars,cvars,tdsol,ifplot,tdplot,cplot},
	
Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[PlotDynamics]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotDynamics]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[PlotDynamics]}]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotDynamics]}]];

vars=sol[[All,1]];
(*Print["vars=",vars];*)

(* figure out number of species in guilds *)
Do[
	Nsp[gu]=Max[
		Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==gcomp)&][[All,2]]],{gcomp,gcomps[gu]}],
		Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==gtrait)&][[All,2]]],{gtrait,gtraits[gu]}]
	];
	If[Nsp[gu]==-\[Infinity],Nsp[gu]=0];
	If[Global`debug,Print["Nsp[",gu,"]=",Nsp[gu]]];
,{gu,guilds}];


(*Print["plotvarsin=",plotvarsin];*)
If[plotvarsin==={All},
	plotvars=vars,
	plotvars={};
	Do[
		lookup=LookUp[var];
		If[MemberQ[{"gcomp","gtrait"},lookup[[1]]]&&Length[lookup]==3,
			Do[AppendTo[plotvars,Subscript[var,sp]],{sp,Nsp[lookup[[2]]]}],
			AppendTo[plotvars,var]
		];
	,{var,plotvarsin}]
];
(*Print["plotvars=",plotvars];*)


If[axeslabel===Automatic,
	yaxislabel=Table[var/.{Subscript[v_,sp_]->Subscript[v,"i"]},{var,plotvars}];
	yaxislabel=Sort[Union[yaxislabel]];
	axeslabel={t,Row[yaxislabel,","]}
];
(*Print["axeslabel=",axeslabel];*)

(* split into InterpolatingFunctions, TemporalData, and constants *)
ifvars=Select[plotvars,Head[#/.sol]==InterpolatingFunction&];
(*Print["ifvars=",ifvars];*)
tdvars=Select[plotvars,Head[#/.sol]==TemporalData||Head[#/.sol]==List&];
(*Print["tdvars=",tdvars];*)
cvars=Select[plotvars,NumericQ[#/.sol]&];
(*Print["cvars=",cvars];*)

If[plotstyle==={},
	Do[
		lookup=LookUp[var];
		Which[
			lookup[[1]]=="gcomp"||lookup[[1]]=="gtrait",
			AppendTo[plotstyle,{color[var][SpFrac[lookup[[4]],Nsp[lookup[[2]]]]],linestyle[var]}]
		,
			lookup[[1]]=="pcomp"||lookup[[1]]=="aux",
			AppendTo[plotstyle,{color[var],linestyle[var]}]
		,
			Else,
			AppendTo[plotstyle,{}]
		]
	,{var,plotvars}]
];
(*Print["plotstyle=",plotstyle];*)

If[logged==True,
	plotrange=(IntervalUnion[Sequence@@Table[range[var],{var,plotvars}]]/.{\[Infinity]->All,0->All})[[1]],
	plotrange=(IntervalUnion[Sequence@@Table[range[var],{var,plotvars}],Interval[{0,\[Infinity]}]]/.{-\[Infinity]->All,\[Infinity]->All})[[1]]
];
(*Print[plotrange];*)

If[ifvars!={},
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[Plot]];
	(*Print["plotopts=",plotopts];
	Print["ifvars=",ifvars];*)
	{xinit,xfinal}=(ifvars[[1]]/.sol)["Domain"][[1]]; (* extract domain *)
	(*Print["{xinit,xfinal}=",{xinit,xfinal}];*)
	If[logged==True,
		ifplot=LogPlot[Evaluate[Table[var[x],{var,ifvars}]/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange]
	,
		ifplot=Plot[Evaluate[Table[var[x],{var,ifvars}]/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange]
	]
,
	ifplot={};
];

If[tdvars!={},
	If[plotmarkers==={}&&(Joined/.{opts})===False,
		plotmarkers=Table[plotmarker[var],{var,tdvars}]
		(*Do[
			lookup=LookUp[var];
			Which[
				lookup\[LeftDoubleBracket]1\[RightDoubleBracket]\[Equal]"gcomp"||lookup\[LeftDoubleBracket]1\[RightDoubleBracket]\[Equal]"gtrait",
				AppendTo[plotmarkers,plotmarker[var]]
			,
				lookup\[LeftDoubleBracket]1\[RightDoubleBracket]\[Equal]"pcomp"||lookup\[LeftDoubleBracket]1\[RightDoubleBracket]\[Equal]"aux",
				AppendTo[plotmarkers,plotmarker[var]]
			,
				Else,
				AppendTo[plotmarkers,{}]
			]
		,{var,vars}]*)
	];

	If[plotmarkers=={},plotmarkers=None];
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,PlotMarkers->plotmarkers,Options[PlotDynamics]}],Options[ListPlot]];
	tdsol=Select[sol,MemberQ[tdvars,#[[1]]]&];
	{xinit,xfinal}={InitialTime[tdsol],FinalTime[tdsol]};
	If[logged==True,
		tdplot=ListLogPlot[tdvars/.sol,Evaluate[Sequence@@plotopts],PlotRange->plotrange]
	,
		tdplot=ListPlot[tdvars/.sol,Evaluate[Sequence@@plotopts],AxesOrigin->{xinit,0},PlotRange->plotrange];
	]
,
	tdplot={};
];

If[cvars!={},
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[Plot]];
	cplot=Plot[Evaluate[cvars/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange]
,
	cplot={}
];

	Return[Show[ifplot,tdplot,cplot]]
]];

Options[PlotDynamics]={Logged->False,Joined->True,PlotStyle->{},PlotMarkers->{},AxesLabel->Automatic};


PlotDynamics[sol_,plotvarsin_Symbol:All,opts___?OptionQ]:=PlotDynamics[sol,{plotvarsin},opts];


EcoEqns[traitsin:(_?TraitsQ):{},opts___?OptionQ]:=Module[{

func=FuncStyle["EcoEqns"],
(* options *)
verbose,verboseall,logged,fixed,fixedvars,fixedvariables,timescale,percapita,
(* other variables *)
traits,nonfixedvars,fixed2,eqns},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEqns]}]];
If[verboseall,verbose=True];

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEqns]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoEqns]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[EcoEqns]}]];
nonfixedvars=Evaluate[NonFixedVars/.Flatten[{opts,Options[EcoEqns]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEqns]}]];
fixedvars=fixed[[All,1]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
(*Print["traits=",traits];*)
SetNsp[traits];
(*Print["Nsp=",Table[Nsp[gu],{gu,guilds}]];*)

If[nonfixedvars===Automatic,nonfixedvars=orderedComplement[AllVariables,fixedvars]];
If[Global`debug,Print["nonfixedvars=",nonfixedvars]];

(* add [t] to constant fixed variables *)
fixed2=ReplaceAll[fixed,(var_/;MemberQ[fixedvariables[[All,1]],var]->val_?NumericQ)->(var[t]->val)];

eqns=Table[
	Which[
		logged===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			DT[log[var]]-log[var][t]==RealSimplify[timescale*Log[eqn[var]/var[t]]],
			modeltype=="ContinuousTime",
			DT[log[var]]==timescale*eqn[var]/var[t]
		]
	,
		percapita===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			DT[var]/var[t]==timescale*eqn[var]/var[t],
			modeltype=="ContinuousTime",
			DT[var]==timescale*eqn[var]/var[t]
		]
	,
		Else,
		DT[var]==timescale*eqn[var]
	]
,{var,nonfixedvars}];

Return[DeleteDuplicates[eqns/.ExpRule[nonfixedvars,logged]/.Dispatch[traits]/.fixed2]]

]];


Options[EcoEqns]={Fixed->{},TimeScale->1,Logged->False,PerCapita->False,NonFixedVars->Automatic};


EcoSim[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{},tmax_?NumericQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoSim"],
(* options *)
verbose,verboseall,method,ndsolveopts,logged,interpolationpoints,interpolationorder,fixed,fixedvars,whenevents,timescale,outputtmin,
output,tmin,
(* other variables *)
nonfixedvars,luv,sp,eqns,unks,ics,tic,exprule,sol,res,fixedres},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoSim]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoSim]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[EcoSim]}]];
interpolationpoints=Evaluate[InterpolationPoints/.Flatten[{opts,Options[EcoSim]}]];
interpolationorder=Evaluate[InterpolationOrder/.Flatten[{opts,Options[EcoSim]}]];
whenevents=Evaluate[WhenEvents/.Flatten[{opts,Options[EcoSim]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoSim]}]];
If[output=="FinalSlice",outputtmin=tmax];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoSim]}]];

(* process fixed variables *)
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoSim]}]];
fixedvars=fixed[[All,1]];
nonfixedvars=variables[[All,1]]; (* nonfixedvars are those given ICs *)
(*Print["nonfixedvars=",nonfixedvars];*)

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],
		AppendTo[fixed,var->0];
		AppendTo[fixedvars,var];
	]
,{var,AllPopsAndAuxs}];

(* figure out number of species in guilds *)
SetNsp[traits,Join[variables,fixed]];
If[Global`debug,Print[func," Nsp=",Table[Nsp[gu],{gu,guilds}]]];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-10^-15]; (* hack to ensure that events are triggered at t=tmin *)

(* set eqns, unks and ics *)
eqns=EcoEqns[traits,Fixed->fixed,NonFixedVars->nonfixedvars,opts];
unks=Table[If[logged===True&&comptype[var]==="Extensive",log[var],var],{var,nonfixedvars}];
ics=Table[If[logged===True&&comptype[var]==="Extensive",log[var][tic]==Log[var/.variables],var[tic]==(var/.variables)],{var,nonfixedvars}];

If[Global`debug,Print[func,": eqns=",eqns]];
If[Global`debug,Print[func,": unks=",unks]];
If[Global`debug,Print[func,": ics=",ics]];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	If[verbose,
		With[{ndsolveeqns=Join[eqns,ics,modelwhenevents,whenevents],unks=unks,outputtmin=outputtmin,options=Sequence@@ndsolveopts},
			PrintCall[Global`sol=NDSolve[ndsolveeqns,unks,{t,outputtmin,tmax},options][[1]]]
	]];
	sol=NDSolve[Join[eqns,ics,modelwhenevents,whenevents],unks,{t,outputtmin,tmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	If[logged===True,
		res=Table[If[comptype[var]==="Extensive",
			var->Interpolation[Table[{t,E^log[var][t]/.sol},{t,tmin,tmax,(tmax-tmin)/interpolationpoints}],InterpolationOrder->interpolationorder],
			var->(var/.sol)]
		,{var,nonfixedvars}]
	,
		res=sol
	];
	res=Join[res,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
	,
	modeltype=="DiscreteTime",(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	If[verbose,
		With[{rteqns=Join[eqns,ics],unks=unks},
			PrintCall[Global`res=RecurrenceTable[rteqns,unks,{t,0,tmax},Method->{Compiled->False}]]
	]];
	sol=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,0,tmax},Method->{Compiled->False}]];
	res=Join[Table[
		If[Head[unks[[i]]]===log,unks[[i,1]],unks[[i]]]->TD[Transpose[{Table[t,{t,tmin,tmax}],If[Head[unks[[i]]]===log,E^sol[[i]],sol[[i]]]}]]
	,{i,Length[unks]}],
	Table[fixedvar->TD[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[Global`debug,Print[func,": res=",res]];

If[output=="FinalSlice",Return[VarSort[FinalSlice[res],AllVariables]]];

Return[VarSort[res,AllVariables]];

]];


Options[EcoSim]={Verbose->False,VerboseAll->False,
Method->Automatic,NDSolveOpts->{},Logged->False,InterpolationOrder->7,InterpolationPoints->1000,Fixed->{},WhenEvents->{},
EqStop->False,EqThreshold->10^-8,TimeScale->1,OutputTMin->0,Output->"Dynamics",TMin->0};


EcoSim[eesol_?TraitsAndVariablesQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoSim[ExtractTraits[eesol],ExtractVariables[eesol],tmax,opts];


EcoEq[traitsin:(_?TraitsQ):{},variables:(_?VariablesQ):{},vars:(_List):All,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEq"],
(* options *)
method,solveopts,nsolveopts,findrootopts,boundarydetection,time,fixed,chop,qss,verbose,verboseall,
(* other variables *)
nonvars,nonfixedvars,traits,fixedvars,removets,eqns,unks,newunk,sol,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoEq]}]];
If[method===Automatic,If[variables!={},method="FindRoot",method="Solve"]];
If[Global`debug,Print[func,": method=",method]];

solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EcoEq]}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EcoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EcoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEq]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEq]}]];
qss=Evaluate[QSS/.Flatten[{opts,Options[EcoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEq]}]];

(* EcoEq doesn't work on Periodic models *)

If[modelperiod=!=0&&time===t&&method=="FindRoot",Msg[EcoEq::noneq];Return[]];

(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
SetNsp[traits];

If[vars===All,
	nonvars={},
	nonvars=orderedComplement[AllVariables,vars]
];
(*Print["nonvars=",nonvars];*)

If[qss==False,
	fixed=Join[fixed,Replace[nonvars,x_->(x->0),1]],
	fixed=Join[fixed,Replace[nonvars,x_->(x->x),1]]
];
(*Print["fixed=",fixed];*)

fixedvars=fixed[[All,1]];
nonfixedvars=orderedComplement[AllVariables,fixedvars];
(*Print["nonfixedvars=",nonfixedvars];*)

(* set eqns, unks and ics *)
eqns=EcoEqns[traits,Fixed->fixed]/.Eq/.RemoveVariablets/.t->time/.fixed/.traits;

Which[
	MemberQ[{"Solve","NSolve"},method],
	unks=nonfixedvars
,
	method=="FindRoot",
	unks=Table[
		newunk={var,(var/.Append[variables,var->0])};
		If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
		newunk,{var,nonfixedvars}]
];

If[Global`debug,Print[func,": eqns=",eqns]];
If[Global`debug,Print[func,": unks=",unks]];

(* solve it *)

Which[
	method=="Solve",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@solveopts},PrintCall[Global`sol=Solve[eqns,unks,options]]]];
	sol=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@nsolveopts},PrintCall[Global`sol=NSolve[eqns,unks,options]]]];
	sol=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@findrootopts},PrintCall[Global`sol=FindRoot[eqns,unks,options]]]];
	sol=FindRoot[eqns,unks,Evaluate[Sequence@@findrootopts]],
	Else,
	Msg[EcoEq::badmtd];Return[$Failed];
];

If[Global`debug,Print[func,": sol=",sol]];
If[MemberQ[{Solve,NSolve},Head[sol]],Msg[EcoEq::nosol,Head[sol]];Return[$Failed]];

(* add in Fixed variables *)
Which[
	MemberQ[{"Solve","NSolve"},method],
	res=Join[fixed,#]& /@ sol,
	method=="FindRoot",
	res=Join[fixed,sol]
];

If[chop,
	Return[VarSort[EqSort[Chop[res]],AllVariables]],
	Return[VarSort[EqSort[res],AllVariables]]
];

]];


SolveEcoEq[args___]:=EcoEq[args,Method->"Solve"];
NSolveEcoEq[args___]:=EcoEq[args,Method->"NSolve"];
FindEcoEq[args___]:=EcoEq[args,Method->"FindRoot"];


Options[EcoEq]={Method->Automatic,SolveOpts->{},NSolveOpts->{Reals,Method->"EndomorphismMatrix"},FindRootOpts->{},
Fixed->{},Chop->True,QSS->False,Time->t,Verbose->False};


SelectValid[sol:(_?RuleListListQ):{}]:=Module[{res},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

res={};
Do[
	If[CompoundAnd[Flatten@Table[
		Which[
			Head[el[[2]]]===TemporalData,
			Map[IntervalMemberQ[range[el[[1]]],#]&,Normal[el[[2]]][[All,2]]],
			Else,
			IntervalMemberQ[range[el[[1]]],el[[2]]]
		]
	,{el,eq}]],AppendTo[res,eq]]
,{eq,sol}];

Return[res]

];


(* make listable across pops *)
EcoJacobian[traits:(_?TraitsQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=(EcoJacobian[traits,#,opts]&/@variables);


EcoJacobian[traitsin:(_?TraitsQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoJacobian"],
(* options *)
time,fixed,verbose,
(* other variables *)
traits,fixedvars,nonfixedvars,eqns,unks,jmat},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoJacobian]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoJacobian]}]];
verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoJacobian]}]];

(* figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
SetNsp[traits];

fixedvars=fixed[[All,1]];
nonfixedvars=orderedComplement[AllVariables,fixedvars];

eqns=EcoEqns[traits,opts]/.RHS/.RemoveVariablets/.t->time;
unks=nonfixedvars;

If[verbose,
	Print[func,": eqns="];
	Print[eqns];
	Print[func,": unks="];
	Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}];
If[verbose,Print[func,": jmat=",jmat]];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&(variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t,
	Return[TD[Table[{t\[Prime],jmat/.AddVariablets/.t->t\[Prime]},{t\[Prime],variables[[1,2]]["Times"]}]/.variables/.traits]];
,
	(* ContinuousTime cycle *)
	variables!={}&&(variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinuousTime"&&modelperiod=!=0))&&time===t,
	Return[jmat/.AddVariablets/.variables/.traits];
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	If[time===t,
		Return[jmat/.variables/.traits],
		Return[jmat/.Slice[variables,time]/.traits]
	];
];

]];


EcoJacobian[traitsandpops_List,opts___?OptionQ]:=
EcoJacobian[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoJacobian]={Verbose->False,VerboseAll->False,Time->t,Fixed->{},Verbose->False,VerboseAll->False};


(* make listable across pops *)
EcoEigenvalues[traits:(_?TraitsQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=(EcoEigenvalues[traits,#,opts]&/@variables);


EcoEigenvalues[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=
Module[{
func=FuncStyle["EcoEigenvalues"],
(* options *)
verbose,chop,time,ndsolveopts,multipliers,j,
(* other variables *)
dim,per,xsol,res},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEigenvalues]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEigenvalues]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEigenvalues]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEigenvalues]}]];
multipliers=Evaluate[Multipliers/.Flatten[{opts,Options[EcoEigenvalues]}]];

j=EcoJacobian[traits,variables,Time->time];
If[verbose,Print[func,": Jacobian=",j]];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&((variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t),
	res=Eigenvalues[listMultiplier[Table[j[t\[Prime]],{t\[Prime],j["Times"]}]]]
,
	(* ContinousTime cycle *)
	variables!={}&&((variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinousTime"&&modelperiod=!=0))&&time===t),
	dim=Length[j];
	per=FinalTime[variables];
	xsol=NDSolve[{x'[t]==j.x[t],x[0]==IdentityMatrix[dim]},x,{t,0,per},Sequence@@ndsolveopts][[1]];
	If[Global`debug,Print[func,": x[per]/.xsol=",x[per]/.xsol]];
	If[multipliers,
		res=Eigenvalues[x[per]/.xsol],
		res=Log[Chop[Eigenvalues[x[per]/.xsol]]]/per
	]
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	res=Eigenvalues[j/.t->time]
];

If[chop,Return[Chop[res]],Return[res]];

];


EcoEigenvalues[traitsandpops_?TraitsAndVariablesQ,opts___?OptionQ]:=EcoEigenvalues[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoEigenvalues]={Verbose->False,Chop->True,Time->t,NDSolveOpts->{},Multipliers->False};


(* make listable across variables *)
EcoStableQ[traits:(_?TraitsQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=(EcoStableQ[traits,#,opts]&/@variables);


EcoStableQ[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{func=FuncStyle["EcoStableQ"],
method,verbose,verboseall,simplify,time,ecoeigenvaluesopts,assumptions,tolerance,
j,evs,res},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoStableQ]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoStableQ]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoStableQ]}]];
simplify=Evaluate[Simplify/.Flatten[{opts,Options[EcoStableQ]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoStableQ]}]];
ecoeigenvaluesopts=Evaluate[EcoEigenvaluesOpts/.Flatten[{opts,Options[EcoStableQ]}]];
assumptions=Evaluate[Assumptions/.Flatten[{opts,Options[EcoStableQ]}]];
tolerance=Evaluate[Tolerance/.Flatten[{opts,Options[EcoStableQ]}]];

If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0&&IntepolatingFunctionFunctionQ[variables]==False&&Length[variables]<4,
		method="RouthHurwitz",
		method="Eigenvalues"
	];
	If[verbose,Print[func,": method=",method]];
];

Which[
	method=="RouthHurwitz",
	j=EcoJacobian[traits,variables,Time->time];
	res=RouthHurwitzCriteria[j]
,
	method=="Eigenvalues",
	evs=EcoEigenvalues[traits,variables,Time->time,Multipliers->True,Evaluate[Sequence@@ecoeigenvaluesopts]];
	If[verbose,Print[func,": evs=",evs]];
	Which[
		modeltype=="DiscreteTime"||(modeltype=="ContinuousTime"&&IntepolatingFunctionFunctionQ[variables]==True),
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Max[Abs[evs]]<1+tolerance],True,
			Evaluate[Max[Abs[evs]]>1+tolerance],False,
			Else,Indeterminate
		],
		modeltype=="ContinuousTime"&&IntepolatingFunctionFunctionQ[variables]==False,
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Max[Re[evs]]>tolerance],False,
			Evaluate[Max[Re[evs]]<tolerance],True, 
			Else,Indeterminate		
		]
		(*,
		modeltype=="ContinuousTime"&&IntepolatingFunctionFunctionQ[variables]\[Equal]True,
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Abs[evs\[LeftDoubleBracket]2\[RightDoubleBracket]]<1+tolerance],True,
			Evaluate[Abs[evs\[LeftDoubleBracket]2\[RightDoubleBracket]]>1+tolerance],False,
			Else,Indeterminate
		]*)
	]
];

Which[
	simplify===True,
	Return[Simplify[res,Assumptions->assumptions]],
	simplify===Real,
	Return[RealSimplify[res,assumptions]],
	simplify===Full,
	Return[FullSimplify[res,assumptions]],
	simplify===False,
	Return[res]
];

];


EcoStableQ[traitsandpops_?TraitsAndVariablesQ,opts___?OptionQ]:=EcoStableQ[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoStableQ]={Verbose->False,VerboseAll->False,Method->Automatic,Simplify->True,Time->t,EcoEigenvaluesOpts->{},Assumptions->{},
Tolerance->0};


SelectEcoStable[traits:(_?TraitsQ):{},sol_?ListOfVariablesQ,opts___?OptionQ]:=Module[{stableqopts,stable},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

stableqopts=FilterRules[Flatten[{opts,Options[SelectEcoStable]}],Options[EcoStableQ]];

stable=EcoStableQ[traits,#,Evaluate[Sequence@@stableqopts]]&/@sol;

Return[Part[sol,Flatten[Position[stable,True]]]]
];


SelectEcoStable[traits:(_?TraitsQ):{},{},opts___?OptionQ]:={};


Options[SelectEcoStable]={};


FindEcoCycle[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{},opts:OptionsPattern[]]:=

Module[{
func=FuncStyle["FindEcoCycle"],
(* options *)
verbose,verboseall,period,method,monitor,printtrace,
findrootopts,ecosimopts,maxiterations,accuracygoal,precisiongoal,logged,fixed,
triggervar,warmup1,warmup2,warmup3,wheneventopts,
(* other variables *)
nonfixedvars,fixedvars,extrema,triggerpos,triggerval,max,ics2,ics3,ics4,diff,tmax,eq,
ic,nb,thing,eqns,unks,logd,vars,unksics,ics,res,sol,per},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

$findecocyclesteps=0;

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verboseall,verbose=True];

monitor=OptionValue[Monitor];
printtrace=OptionValue[PrintTrace];
period=OptionValue[Period];
method=OptionValue[Method];
If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0,method="EcoSim",method="FixedPoint"]];
If[Global`debug,Print[func,": method=",method]];
findrootopts=OptionValue[FindRootOpts];
ecosimopts=OptionValue[EcoSimOpts];
maxiterations=OptionValue[MaxIterations];
accuracygoal=OptionValue[AccuracyGoal];
triggervar=OptionValue[TriggerVariable];
warmup1=OptionValue[WarmUp];
warmup2=OptionValue[WarmUp2];
warmup3=OptionValue[WarmUp3];
tmax=OptionValue[TMax];
wheneventopts=OptionValue[WhenEventOpts];
logged=OptionValue[Logged];
fixed=OptionValue[Fixed];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
(*Print["fixed=",fixed];*)

(* figure out number of species in guilds *)
SetNsp[traits];

(* set up thing & unks *)
nonfixedvars=variables[[All,1]];

(* build various lists of vars *)
unks=Table[eq[var],{var,nonfixedvars}];
vars=Table[If[logged&&comptype[var]==="Extensive",Log[var],var],{var,nonfixedvars}];
ics=vars/.variables;
unksics=Transpose[{unks,ics}];
logd=Table[If[logged&&comptype[var]==="Extensive",True,False],{var,nonfixedvars}];

(*
Print["unks=",unks];
Print["unksics=",unksics];
Print["ics=",ics];
Print["logd=",logd];
Print["vars=",vars];
*)

(* "EcoSim" method for unforced ContinuousTime models *)
If[method==="EcoSim",

	If[!(modeltype=="ContinuousTime"&&modelperiod==0),Msg[FindEcoCycle::noecosim];Return[$Failed]];
	If[triggervar===Automatic,triggervar=nonfixedvars[[1]]];
	triggerpos=Position[nonfixedvars,triggervar][[1,1]];

	(* warmup #1 to get on limit cycle *)
	ics2=If[warmup1>0,
		FinalSlice[EcoSim[traits,variables,warmup1,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]],
		variables];
	If[verbose,Print[func,": ics2=",ics2]];
	
	(* warmup #2 to find maxima *)
	extrema={};
	EcoSim[traits,ics2,warmup2,WhenEvents->{
			WhenEvent[event,AppendTo[extrema,Table[var[t],{var,nonfixedvars}]],Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar'[t]==0)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

	If[extrema=={},Msg[FindEcoCycle::nomaxima];Return[$Failed]];

	max=Last@Sort[extrema,#1[[triggerpos]]<#2[[triggerpos]]&];
	ics3=Table[nonfixedvars[[i]]->max[[i]],{i,Length[nonfixedvars]}];
	If[verbose,Print[func,": ics3=",ics3]];
	
	(* warmup #3 to move a wee bit beyond the maximum *)
	ics4=FinalSlice[EcoSim[traits,ics3,warmup3,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]];

	If[verbose,Print[func,": ics4=",ics4]];

	Do[
		triggerval=triggervar/.ics4;
		
		sol=EcoSim[traits,ics4,tmax,WhenEvents->{
			WhenEvent[event,"StopIntegration",Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar[t]<triggerval)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

		diff=Sum[Abs[(var/.FinalSlice[sol])-(var/.ics4)],{var,nonfixedvars}];
		If[diff<10^-accuracygoal,Break[]];

		ics4=FinalSlice[sol];
	,{maxiterations}];

	If[diff>10^-accuracygoal,Msg[FindEcoCycle::cvmit,maxiterations]];
		
	Return[sol];
];

(* "FixedPoint" or "FindRoot" method *)

If[(modeltype=="ContinuousTime"&&modelperiod==0),
	AppendTo[unks,per];
	AppendTo[unksics,{per,period}];
	AppendTo[ics,period];
,
	If[period===Automatic,per=modelperiod,per=period];
];

(*Print["unks=",unks];Print["unksics=",unksics];Print["ics=",ics];*)

If[monitor,
	nb=CreateWindow[DialogNotebook[{
	TextCell["evaluation: "],
	Dynamic[$findecocyclesteps],
	TextCell["vars:"],
	Dynamic[Table[eq[var],{var,nonfixedvars}]]
	},
	WindowTitle->"FindEcoCycle Progress..."]];
];


(* function to advance model *)

thing[ps_?NumericListQ]:=Module[{popz,rez},
	$findecocyclesteps++;
	If[(modeltype=="ContinuousTime"&&modelperiod==0),tmax=ps[[-1]],tmax=per];
	popz=Table[If[logd[[i]],nonfixedvars[[i]]->E^ps[[i]],nonfixedvars[[i]]->ps[[i]]],{i,Length[nonfixedvars]}];
	sol=EcoSim[traits,popz,tmax,Fixed->fixed,Evaluate[Sequence@@ecosimopts],Logged->logged];
	rez=vars/.FinalSlice[sol];
	If[(modeltype=="ContinuousTime"&&modelperiod==0),AppendTo[rez,ps[[-1]]]];
	If[printtrace,Print[$findecocyclesteps,": ",FinalSlice[sol]]];
	Return[rez];
];

Which[
	method=="FindRoot",
	If[Global`debug,Print[func,": Method FindRoot"]];
	res=FindRoot[thing[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]]
,
	method=="FixedPoint",
	If[Global`debug,Print[func,": Method FixedPoint"]];
	res=FixedPoint[thing[#]&,ics,maxiterations,SameTest->(Max[Abs[#1-#2]]<10^-accuracygoal&)];
	If[$findecocyclesteps==maxiterations,Msg[FindEcoCycle::cvmit,maxiterations];Return[$Failed]]
,
	Else,
	Msg[FindEcoCycle::badmtd];Return[$Failed]
];

If[modeltype=="DiscreteTime",(* drop last point *)
	sol=ReplaceAll[sol,
		{(var_->td_List):>(var->Drop[td,-1]),(var_->td_TemporalData)->(var->TimeSeriesWindow[td,{0,per-1}])}]
];


(* return answer *)

If[monitor,NotebookClose[nb]];

Return[Sort[sol]];

]];


Options[FindEcoCycle]={
Method->Automatic,Fixed->{},FindRootOpts->{},EcoSimOpts->{},MaxIterations->100,AccuracyGoal->6,Logged->False,
WarmUp->1000,WarmUp2->100,WarmUp3->0.1,TMax->1000,TriggerVariable->Automatic,
WhenEventOpts->{(*"DetectionMethod"\[Rule]"Interpolation","LocationMethod"\[Rule]{"Brent",MaxIterations\[Rule]1000}*)},
Period->Automatic,
Monitor->False,PrintTrace->False,
Verbose->False,VerboseAll->False
};


FindEcoCycle[traitsandvariables_?TraitsAndVariablesQ,opts:OptionsPattern[]]:=
FindEcoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],opts];


FindEcoAttractor[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=
(*FindEcoAttractor[traits_?NumericRuleListQ,variables:(_?VariablesQ):{},opts___?OptionQ]:=*)

Module[{
func=FuncStyle["FindEcoAttactor"],
(*options*)
verbose,verboseall,method,chop,numtries,
solveecoeqopts,nsolveecoeqopts,findecoeqopts,ecosimopts,findecocycleopts,
warmup,tmax,finaltmax,eqthreshold,time,period,maxperiod,maxperiodmultiplier,
testvalidity,teststability,
(*other variables*)
eq,valideq,tmp,evs,ics,stableeq,res,essol,ddt,eqflag,per,ecosimflag},

Block[{Nsp},
If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(*handle options*)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[!MemberQ[{Automatic,"SolveEcoEq","NSolveEcoEq","FindEcoEq","EcoSim","FindEcoCycle"},method],
	Msg[FindEcoAttractor::badmtd];Return[$Failed]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoAttractor]}]];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
solveecoeqopts=Evaluate[SolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
nsolveecoeqopts=Evaluate[NSolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecoeqopts=Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecocycleopts=Evaluate[FindEcoCycleOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
warmup=Evaluate[WarmUp/.Flatten[{opts,Options[FindEcoAttractor]}]];
tmax=Evaluate[TMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[tmax===Automatic,If[modelperiod==0,tmax=1000,tmax=100*modelperiod]];
finaltmax=Evaluate[FinalTMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[finaltmax===Automatic,finaltmax=tmax];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqthreshold=Evaluate[EqThreshold/.Flatten[{opts,Options[FindEcoAttractor]}]];
time=Evaluate[Time/.Flatten[{opts,Options[FindEcoAttractor]}]];
period=Evaluate[Period/.Flatten[{opts,Options[FindEcoAttractor]}]];
maxperiod=Min[tmax-1,Evaluate[MaxPeriod/.Flatten[{opts,Options[FindEcoAttractor]}]]];
maxperiodmultiplier=Evaluate[MaxPeriodMultiplier/.Flatten[{opts,Options[FindEcoAttractor]}]];
testvalidity=Evaluate[TestValidity/.Flatten[{opts,Options[FindEcoAttractor]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[FindEcoAttractor]}]];

ecosimflag=False;

(* figure out number of species in guilds *)

SetNsp[traits];

If[method===Automatic,
	Which[
		modelperiod=!=0&&time===t,
		method="FindEcoCycle",
		variables=={},
		method="NSolveEcoEq",
		Else,
		If[naux+npops+Sum[Nsp[gu]*ngcomps[gu],{gu,guilds}]<=4,
			method="NSolveEcoEq",
			method="FindEcoEq"
		];
	];
];

Which[
	method=="EcoSim",Goto[ecosim],
	method=="FindEcoCycle",Goto[findecocycle]
];


(* method FindEcoEq *)

If[method=="FindEcoEq",
	If[verbose,Print[func,": FindEcoEq Mode"]];
	If[variables=={},Msg[FindEcoAttractor::novars,"FindEcoEq"];Return[$Failed]];
	If[warmup>0,
		If[verbose,
			Print[func,": Warming Up..."];
			With[{warmup=warmup,time=time,options=Sequence@@ecosimopts},
				PrintCall[FinalSlice[EcoSim[traits,variables,warmup,Time->time,options]],"ics:"]]
		];
		ics=FinalSlice[EcoSim[traits,variables,warmup,Time->time,Evaluate[Sequence@@ecosimopts]]];
	, (* else *)
		ics=variables;
	];
	If[verbose,
		With[{ics=ics,time=time,options=Sequence@@findecoeqopts},
			PrintCall[FindEcoEq[traits,ics,Time->time,options],"eq:"]]
	];
	eq={FindEcoEq[traits,ics,Time->time,Evaluate[Sequence@@findecoeqopts],VerboseAll->verboseall]};

	(* try more initial conditions if required *)

	If[numtries>=2,
		Do[
			(* perturb ICs *)
			ics=ReplacePart[#,2->#[[2]]*10^RandomReal[{-1,1}]]& /@ variables;
			If[verbose,
				With[{ics=ics,time=time,options=Sequence@@findecoeqopts},
					PrintCall[FindEcoEq[traits,ics,Time->time,options],"tmp:"]]
			];
			tmp=FindEcoEq[traits,ics,Time->time,Evaluate[Sequence@@findecoeqopts],VerboseAll->verboseall];
			(* if distinct eq, add to tmp *)
			If[tmp!={},
				If[CompoundAnd[Table[RuleListDistance[tmp,bar]>$roundofftolerance,{bar,eq}]],AppendTo[eq,tmp]];
			];
		,{numtries-1}];
	];	
];


(* method SolveEcoEq *)

If[method=="SolveEcoEq",
	If[verbose,
		Print[func,": SolveEcoEq Mode"];
		With[{time=time,options=Sequence@@solveecoeqopts},
			PrintCall[SolveEcoEq[traits,Time->time,options],"eq:"]]
	];
	eq=SolveEcoEq[traits,Time->time,Evaluate[Sequence@@solveecoeqopts],VerboseAll->verboseall];
];


(* method NSolveEcoEq *)

If[method=="NSolveEcoEq",
	If[verbose,
		Print[func,": NSolveEcoEq Mode"];
		With[{time=time,options=Sequence@@nsolveecoeqopts},
			PrintCall[Global`eq=Union[NSolveEcoEq[traits,Time->time,options]]]]
	];
	eq=Union[Flatten[{NSolveEcoEq[traits,Time->time,Evaluate[Sequence@@nsolveecoeqopts],VerboseAll->verboseall]},1]];
];

(* method FindEcoCycle *)
Label[findecocycle];

If[method=="FindEcoCycle",
	If[verbose,Print[func,": FindEcoCycle Mode"]];
	If[variables=={},Msg[FindEcoAttractor::novars,"FindEcoCycle"];Abort[]];

	(* figure out period to try *)
	If[period===Automatic,
		Which[
			modelperiod=!=0,
			per=modelperiod,
			modeltype=="DiscreteTime",
			per=1
		]
	,
		per=period
	];

	If[ecosimflag==False, (* if we haven't already been through ecosim *)
		If[warmup>0,
			If[verbose,
				Print[func,": Warming up..."];
				With[{warmup=warmup,per=per,time=time,options=Sequence@@ecosimopts},
					PrintCall[FinalSlice[EcoSim[traits,variables,Floor[warmup,per],Time->time,options]],"ics:"]]
			];
			ics=FinalSlice[EcoSim[traits,variables,Floor[warmup,per],Time->time,Evaluate[Sequence@@ecosimopts]]];
		, (* else *)
			ics=variables;
		],
		ics=FinalSlice[essol] (* if we have been through ecosim *)
	];
	
	Which[
		modeltype=="DiscreteTime",
		If[verbose,
			With[{ics=ics,per=per,maxperiodmultiplier=maxperiodmultiplier,options=Sequence@@findecocycleopts},
				PrintCall[Table[FindEcoCycle[traits,ics,options,Period->Global`permult*per],{Global`permult,maxperiodmultiplier}],"eq:"]]
		];
		eq=Table[
			FindEcoCycle[traits,ics,Evaluate[Sequence@@findecocycleopts],Period->permult*per]
		,{permult,maxperiodmultiplier}];
		(* remove $Failed & multiple period solutions *)
		eq=Select[eq,#=!=$Failed&&FindPeriod[#]==#[[1,2]]["PathLength"]&];
	,
		modeltype=="ContinuousTime",
		If[verbose,
			With[{ics=ics,options=Sequence@@findecocycleopts},
				PrintCall[FindEcoCycle[traits,ics,options],"eq:"]]
		];
		eq=Select[{FindEcoCycle[traits,ics,Evaluate[Sequence@@findecocycleopts]]},#=!=$Failed&]
	];	
];

If[verbose,Print[func,": eq=",eq]];

(* assess validity and stability of eq *)

If[testvalidity,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		valideq={}
	, 
		If[Head[eq[[1,1,2]]]=!=InterpolatingFunction,
			valideq=SelectValid[eq];
			If[verbose,Print[func,": valid eq=",valideq]];
		,
			valideq=eq (* SelectValid doesn't work on InterpolatingFunctions yet *)
		]
	];
	If[valideq=={},Msg[FindEcoAttractor::novalideq]];
];

If[teststability,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		stableeq={}
	,
		stableeq=SelectEcoStable[traits,valideq,Time->time];
		If[verbose,Print[func,": stable eq=",stableeq]];
	]
,
	stableeq=valideq
];

If[Length[stableeq]==0, (* no stable eq, try EcoSim once *)
	If[ecosimflag==False,
		Msg[FindEcoAttractor::nosteq,traits];
		method="EcoSim"
	,
		Msg[FindEcoAttractor::giveup];
		Return[EcoSim[traits,FinalSlice[essol],finaltmax,Time->time,Evaluate[Sequence@@ecosimopts],VerboseAll->verboseall]]
	]
];
If[Length[stableeq]==1,res=stableeq[[1]];Goto[done]]; (* successful *)
If[Length[stableeq]>=2,Msg[FindEcoAttractor::musteq,Length[stableeq],traits];Goto[done]];


(* if we're still here, no stable equilibrium, so switch to EcoSim *)
(* method EcoSim *)

Label[ecosim];
If[method=="EcoSim",
	If[verbose,Print[func,": EcoSim Mode"]];
	If[variables=={},Msg[FindEcoAttractor::novars,"EcoSim"];Abort[]];
	
	If[Length[ics]==0,ics=variables];
	
	If[verbose,
		With[{ics=ics,tmax=tmax,time=time,options=Sequence@@ecosimopts},
			PrintCall[EcoSim[traits,ics,tmax,Time->time,options],"essol:"]]
	];
	
	essol=EcoSim[traits,ics,tmax,Time->time,Evaluate[Sequence@@ecosimopts],VerboseAll->verboseall];
	If[verbose,Print[PlotDynamics[essol]]];

	(* check for equilibrium *)
	
	If[modelperiod=!=0,
		ddt=FinalDerivatives[essol,modelperiod][[All,2]],
		ddt=FinalDerivatives[essol][[All,2]]
	];
	If[verbose,Print[func,": d/dt=",ddt]];
	If[Max[Abs[ddt]]<eqthreshold,
		If[verbose,Print[func,": Equilibrium found"]];
		(* construct stableeq *)
		If[modelperiod=!=0,
			If[modeltype=="ContinuousTime",res=FinalSlice[essol,modelperiod]];
			If[modeltype=="DiscreteTime",res=FinalSlice[essol,modelperiod-1]]
		,
			res=FinalSlice[essol]
		];
		Goto[done];
	,
		(* steady state eq failed *)
		Msg[FindEcoAttractor::nostst,ddt,tmax];
		(* attempt to find Period using FindEcoCycle approach *)
		ecosimflag=True; (* already been through ecosim *)
		method="FindEcoCycle";
		period=FindPeriod[essol,MaxPeriod->maxperiod,Evaluate[Sequence@@findecocycleopts]];
		Goto[findecocycle];
	];
];

Label[done];

If[chop,
	Return[Chop[res]],
	Return[res]
];

]];


Options[FindEcoAttractor]={Verbose->False,VerboseAll->False,
Method->Automatic,Chop->True,NumTries->1,
SolveEcoEqOpts->{},NSolveEcoEqOpts->{},FindEcoEqOpts->{},EcoSimOpts->{},FindEcoCycleOpts->{},
WarmUp->0,TMax->Automatic,EqThreshold->10^-5,Time->t,Period->Automatic,MaxPeriod->16,MaxPeriodMultiplier->2,
TestValidity->True,TestStability->True,FinalTMax->Automatic};


PlotEcoIsoclines[traits:(_?TraitsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoIsoclines"],
(* options *)
verbose,verboseall,fixed,time,monitor,percapita,isoclinestyle,framelabel,contourplotopts,isoclinelabels,isoclinelabel1,isoclinelabel2,
(* other variables *)
fixedvars,nonfixedvars,lookup1,lookup2,style1,style2,label1,label2,g,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print["PlotEcoIsoclines: fixedvars=",fixedvars]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
isoclinelabels=Evaluate[IsoclineLabels/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
{label1,label2}={ToString[var1],ToString[var2]};
{isoclinelabel1,isoclinelabel2}=Which[
	isoclinelabels===Automatic,
	{{None,Tooltip[Null,label1]&},{None,Tooltip[Null,label2]&}},
	isoclinelabels===True,
	{Text[label1,{#1,#2},Background->White]&,Text[label2,{#1,#2},Background->White]&},
	Length[isoclinelabels]==2,
	isoclinelabels,
	Else,
	{None,None}
];

(* figure out what are the components on the x- and y-axes *)
lookup1=LookUp[var1];
lookup2=LookUp[var2];

(* set up isocline styles *)
Which[
	lookup1[[1]]=="gcomp",
	style1=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var1][0]},linestyle[var1]],isoclinestyle[[1]]],
	lookup1[[1]]=="pcomp"||lookup1[[1]]=="aux",
	style1=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var1]},linestyle[var1]],isoclinestyle[[1]]]
];

Which[
	lookup2[[1]]=="gcomp",
	style2=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var2][1]},linestyle[var2]],isoclinestyle[[2]]],
	lookup2[[1]]=="pcomp"||lookup2[[1]]=="aux",
	style2=If[isoclinestyle===Automatic,Prepend[{Thickness[0.005],color[var2]},linestyle[var2]],isoclinestyle[[2]]]
];

(*Print[{style1,style2}];
Print[{isoclinelabel1,isoclinelabel2}];*)

nonfixedvars={var1,var2};

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

contourplotopts=FilterRules[Flatten[{opts,ContourShading->None,Options[PlotEcoIsoclines]}],Options[ContourPlot]];
(*Print[contourplotopts];*)

g=(EcoEqns[traits,Fixed->fixed,NonFixedVars->nonfixedvars,opts]/.RHS/.RemoveVariablets/.{t->time})
	-Which[modeltype=="DiscreteTime"&&percapita==False,{var1,var2},modeltype=="DiscreteTime"&&percapita==True,{1,1},Else,{0,0}];
If[verbose,Print[func,": g=",g]];

res=Show[
	ContourPlot[g[[1]],{var1,var1min-10^-10,var1max},{var2,var2min-10^-10,var2max},Contours->{0},
		ContourStyle->style1,ContourLabels->isoclinelabel1,Evaluate[Sequence@@contourplotopts]],
	ContourPlot[g[[2]],{var1,var1min-10^-10,var1max},{var2,var2min-10^-10,var2max},Contours->{0},
		ContourStyle->style2,ContourLabels->isoclinelabel2,Evaluate[Sequence@@contourplotopts]],
	FrameLabel->framelabel];

If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotEcoIsoclines]={
	Monitor->False,
	Time->t,PerCapita->False,Fixed->{},
	IsoclineStyle->Automatic,FrameLabel->Automatic,IsoclineLabels->Automatic,ContourShading->False,
	MaxRecursion->3,
	Verbose->False,VerboseAll->False};


PlotEcoStreams[traits:(_?TraitsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoStreams"],
(* options *)
verbose,verboseall,fixed,time,monitor,framelabel,streamplotopts,
(* other variables *)
fixedvars,nonfixedvars,g,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEcoStreams]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoStreams]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoStreams]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEcoStreams]}],Options[StreamPlot]];

nonfixedvars={var1,var2};

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

g=(EcoEqns[traits,Fixed->fixed,NonFixedVars->nonfixedvars,opts]/.RHS/.RemoveVariablets/.{t->time})
	-If[modeltype=="DiscreteTime",{var1,var2},{0,0}];
(*Print[g];*)

res=myStreamPlot[g,{var1,var1min,var1max},{var2,var2min,var2max},
	Evaluate[Sequence@@streamplotopts],PlotRange->{{var1min,var1max},{var2min,var2max}},FrameLabel->framelabel];

If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotEcoStreams]={
	Monitor->False,Fixed->{},Time->t,
	FrameLabel->Automatic,PlotRangePadding->Scaled[0.02],StreamStyle->Gray,
	Verbose->False,VerboseAll->False};


PlotEcoPhasePlane[traits:(_?TraitsQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
plotecoisoclinesopts,plotecostreamsopts},

(* handle options *)

plotecoisoclinesopts=FilterRules[
	Flatten[{Evaluate[PlotEcoIsoclinesOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoIsoclines],Options[ContourPlot]]];
plotecostreamsopts=FilterRules[
	Flatten[{Evaluate[PlotEcoStreamsOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoStreams],Options[StreamPlot]]];

Return[Show[
	PlotEcoStreams[traits,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecostreamsopts](*,Evaluate[Sequence@@commonopts]*)],
	PlotEcoIsoclines[traits,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecoisoclinesopts](*,Evaluate[Sequence@@commonopts]*)]
]]
];


Options[PlotEcoPhasePlane]={
	Monitor->False,
	Fixed->{},Time->t,FrameLabel->Automatic,
	PlotEcoIsoclinesOpts->{},PlotEcoStreamsOpts->{},
	Verbose->False,VerboseAll->False};


PrestonPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PrestonPlot"],
(* options *)
gu,gcomp,base,minpop,bandwidth,showspecies,markerstyle,plotopts,listplotopts,plotrange,
(* other variables *)
abunds,pos,data,\[ScriptCapitalD],hist,stix
},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[PrestonPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
gcomp=Evaluate[Component/.Flatten[{opts,Options[PrestonPlot]}]];
If[gcomp===Automatic,gcomp=gcomps[gu][[1]]];
base=Evaluate[Base/.Flatten[{opts,Options[PrestonPlot]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[PrestonPlot]}]];
bandwidth=Evaluate[Bandwidth/.Flatten[{opts,Options[PrestonPlot]}]];
showspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PrestonPlot]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PrestonPlot]}]];
plotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[Plot]];
listplotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[ListPlot]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PrestonPlot]}]];

(* figure out number of species in guilds *)
SetNsp[sol];

abunds=Select[sol,#[[1,1]]===gcomp&&#[[2]]>minpop&];
pos=abunds[[All,1,2]];
data=Log[base,abunds[[All,2]]];
\[ScriptCapitalD]=SmoothKernelDistribution[data,bandwidth,{"Bounded",{Min[data],Max[data]},"Gaussian"}];
hist=Plot[PDF[\[ScriptCapitalD],x],{x,Min[data],Max[data]},Evaluate[Sequence@@plotopts]];
If[showspecies,
	If[markerstyle===Automatic,
		markerstyle=Table[color[Subscript[gcomp,i]][SpFrac[i,Nsp[gu]]],{i,pos}]];
	stix=ListPlot[
		Map[List,Transpose[{data,Table[0,Length[pos]]}]],PlotStyle->markerstyle,
		Evaluate[Sequence@@listplotopts],PlotMarkers->{"|",8}],
	stix={}];
Return[Show[stix,hist,AxesOrigin->{Max[data],0},PlotRange->plotrange]];

]];

Options[PrestonPlot]={Guild->Automatic,Component->Automatic,Base->10,MinPop->0,Bandwidth->"Scott",ShowSpecies->True,MarkerStyle->Automatic,PlotRange->{0,All}};


WhittakerPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WhittakerPlot"],
(* options *)
gu,gcomp,base,minpop,listplotopts,
(* other variables *)
abunds,data
},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[WhittakerPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
gcomp=Evaluate[Component/.Flatten[{opts,Options[WhittakerPlot]}]];
If[gcomp===Automatic,gcomp=gcomps[gu][[1]]];
base=Evaluate[Base/.Flatten[{opts,Options[WhittakerPlot]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WhittakerPlot]}]];
listplotopts=FilterRules[Flatten[{opts,Options[WhittakerPlot]}],Options[ListPlot]];

(* figure out number of species in guilds *)
SetNsp[sol];
abunds=Select[sol,#[[1,1]]===gcomp&&#[[2]]>minpop&];
data=Log[base,abunds[[All,2]]];
Return[ListPlot[Sort[data,Greater],Evaluate[Sequence@@listplotopts]]];

]];

Options[WhittakerPlot]={Guild->Automatic,Component->Automatic,Base->10,MinPop->0,PlotRange->All};


PlotTAD[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotTAD"],
(* options *)
logged,gu,gcomp,gtrait,minpop,plotstyle,markerstyle,plotopts,time,
(* other variables *)
abunds,pos,plotmin
},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
logged=Evaluate[Logged/.Flatten[{opts,Options[PlotTAD]}]];
gu=Evaluate[Guild/.Flatten[{opts,Options[PlotTAD]}]];
If[gu===Automatic,gu=guilds[[1]]];
gcomp=Evaluate[Component/.Flatten[{opts,Options[PlotTAD]}]];
If[gcomp===Automatic,gcomp=gcomps[gu][[1]]];
gtrait=Evaluate[Trait/.Flatten[{opts,Options[PlotTAD]}]];
If[gtrait===Automatic,gtrait=gtraits[gu][[1]]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[PlotTAD]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotTAD]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PlotTAD]}]];
plotopts=FilterRules[Flatten[{opts,Options[PlotTAD]}],Options[ListPlot]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotTAD]}]];

(* figure out number of species in guilds *)
SetNsp[traits,sol];

abunds=Quiet[Select[sol,#[[1,1]]===gcomp&],{Part::partd}];
If[time===t,abunds=Avg[abunds],abunds=Slice[abunds,time]];
abunds=Select[abunds,#[[2]]>minpop&];
pos=abunds[[All,1,2]];

If[markerstyle===Automatic,
	markerstyle=Table[color[Subscript[gtrait,i]][SpFrac[i,Nsp[gu]]],{i,pos}]];
	
If[logged==False,
	Return[ListPlot[
		Table[{{Subscript[gtrait,i],0},{Subscript[gtrait,i],Subscript[gcomp,i]}},{i,pos}]/.abunds/.traits,
		PlotStyle->Join[plotstyle,markerstyle],
		Evaluate[Sequence@@plotopts],
		PlotRange->All,Joined->True
	]]
,
	plotmin=Min[Table[Subscript[gcomp,i],{i,pos}]/.sol];
	Return[ListLogPlot[
		Table[{{Subscript[gtrait,i],plotmin},
		{Subscript[gtrait,i],Subscript[gcomp,i]}},{i,pos}]/.abunds/.traits,
		PlotStyle->Join[plotstyle,markerstyle],
		Evaluate[Sequence@@plotopts],
		PlotRange->{plotmin,All},Joined->True
	]]
];

]];

Options[PlotTAD]={Logged->False,Guild->Automatic,Trait->Automatic,Component->Automatic,MinPop->0,MarkerStyle->Automatic,PlotStyle->{},Time->t};


PlotTAD[sol_?TraitsAndVariablesQ,opts___?OptionQ]:=PlotTAD[ExtractTraits[sol],ExtractVariables[sol],opts];


InvSPS[traitsandpops_?TraitsAndVariablesQ,invaderin:(_?InvaderQ):{},opts:OptionsPattern[]]:=
((*Print["** traitsandpops"];*)InvSPS[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],invaderin,opts]);


InvSPS[traitsin:(_?NotInvaderTraitsQ):{},solin:(_?VariablesQ):{},invaderin:(_?InvaderQ):{},opts:OptionsPattern[]]:=Module[{
func=FuncStyle["InvSPS"],
(* options *)
verbose,verboseall,method,
guild,time,simplifyresult,frominv,rv,qssics,
ndsolveopts,qssmethod,nintegrateopts,integrateopts,solveopts,nsolveopts,findrootopts,findecocycleopts,eigensystemopts,
(* other variables *)
invader,traits,invtraits,variables,
invtype,invid,invunk,zeropcomps,sol,
inveqns,invunks,qsseqns,qssunks,qsssubs,mode,
tstart,tend,removets,qsssol,eval,evec,invsol,j,tempIF},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

$invcount++; (* increment $invcount *)

(*Print[invaderin];*)

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

method=OptionValue[Method];
time=OptionValue[Time];
qssmethod=OptionValue[QSSMethod]; 
ndsolveopts=OptionValue[NDSolveOpts];
nintegrateopts=OptionValue[NIntegrateOpts];
integrateopts=OptionValue[IntegrateOpts];
solveopts=OptionValue[SolveOpts];
nsolveopts=OptionValue[NSolveOpts];
findrootopts=OptionValue[FindRootOpts];
findecocycleopts=OptionValue[FindEcoCycleOpts];
eigensystemopts=OptionValue[EigensystemOpts];
simplifyresult=OptionValue[SimplifyResult];
guild=OptionValue[Guild];
If[guild===Automatic,guild=Append[guilds,1][[1]]];
frominv=OptionValue[FromInv];
rv=OptionValue[RV];
qssics=OptionValue[QSSICs];

(* figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
(*Print["traits=",traits];*)
variables=ExpandNspInPops[solin];
(*Print["variables=",variables];*)
SetNsp[traits,variables];
(*Print["Nsp=",Table[Nsp[gu],{gu,guilds}]];*)

(* assemble sol [resident state] *)

(* in case any extensive pops weren't given, assume they're 0 *)
zeropcomps=Flatten[Table[Table[
	If[comptype[pcomp]=="Extensive",pcomp->0,pcomp->pcomp]
,{pcomp,pcomps[pop]}],{pop,pops}]];
sol=Join[variables,zeropcomps];

(* if a time given, evaluate sol there *)
If[time=!=t&&!NumericRuleListQ[sol],sol=Slice[sol,time]];

If[Global`debug,Print[func,": sol=",sol]];

invader=Flatten[{invaderin}];
If[Global`debug,Print["invader=",invader]];
Which[
	(* no invader given *)
	invader==={},
	If[Global`debug,Print["no invader given"]];
	Which[
		nguilds!=0,{invtype,invid}={"guild",guild},
		npops!=0,{invtype,invid}={"pop",pops[[1]]}
	];
,
	(* guild invader *)
	RuleListQ[invader],
	If[Global`debug,Print["guild invader"]];
	{invtype,invid}={"guild",LookUp[invader[[1,1]]][[2]]}
,
	(* pop invader *)
	LookUp[invader[[1]]][[1]]=="pop"||LookUp[invader[[1]]][[1]]=="pcomp",
	If[Global`debug,Print["pop invader"]];
	{invtype,invid}={"pop",LookUp[invader[[1]]][[2]]};

	If[Max[Table[If[comptype[pcomp]=="Extensive",invader],{pcomp,pcomps[invid]}]/.solin]>0,
		Msg[InvSPS::nonzero];Abort[]]
,
	Else,
	Msg[InvSPS::unkinv];Return[$Failed]
];

If[Global`debug,Print[func,": {invtype,invid}=",{invtype,invid}]];

Which[
	invtype=="pop",invtraits={},
	invtype=="guild",invtraits=ExtractTraits[invader]
];
If[Global`debug,Print["invtraits=",invtraits]];

(* set up inveqns, invunks, qss stuff *)

inveqns=invunks={};
qsssubs=qsseqns=qssunks={};

Do[
	invunk=Switch[invtype,"guild",Subscript[comp,0],"pop",comp];
	If[comptype[invunk]=="Extensive",
		AppendTo[inveqns,eqn[invunk]];
		AppendTo[invunks,invunk];
		AppendTo[qsssubs,invunk->0];
	];
	If[comptype[invunk]=="Intensive",
		AppendTo[qsseqns,eqn[invunk]==0];
		If[qssmethod=="FindRoot",
			AppendTo[qssunks,{invunk,Min[range[invunk]]+0.01}],
			AppendTo[qssunks,invunk];
		];
	];
,{comp,Switch[invtype,"guild",gcomps[invid],"pop",pcomps[invid]]}];

If[Global`debug,
	Print[func,": inveqns=",inveqns];Print[func,": invunks=",invunks];
	Print[func,": qsseqns=",qsseqns];Print[func,": qsssubs=",qsssubs];Print[func,": qssunks=",qssunks]
];


(* decide on mode *)

Which[
	(modelperiod==0&&(Length[sol]==0||!MemberQ[{InterpolatingFunction,TemporalData},Head[sol[[1,2]]]]))
	||(modelperiod=!=0&&(method==="Instantaneous"||time=!=t)),
	mode="eigenvalue",
	modeltype=="ContinuousTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===InterpolatingFunction)),
	mode="continuoustime floquet",
	modeltype=="DiscreteTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===TemporalData)),
	mode="discretetime floquet"
];
(*Print[func,": mode=",mode];*)


(* calculate invasion fitness *)

Which[
	(* ContinuousTime Floquet mode *)
	mode=="continuoustime floquet",
	If[verbose,Print[func,": ContinuousTime Floquet mode"]];

	(* figure out period *)
	If[sol!={}&&Head[sol[[1,2]]]===InterpolatingFunction,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	If[Global`debug,Print[func,": {tstart,tend}=",{tstart,tend}]];
	
	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[qssics===Automatic, (* no QSS ICs given? then average corresponding components from residents *)
			qssics=Table[qssunk->
				Mean[Select[Select[FinalSlice[sol],(#[[1,0]]==Subscript)&],(#[[1,1]]==qssunk[[1]])&][[All,2]]]
			,{qssunk,qssunks}];
		];
		If[verbose,
			With[{tr=Join[traits,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[traits,invtraits],Join[FinalSlice[sol],qssics],Sequence@@findecocycleopts];
		If[qsssol==$Failed,Msg[InvSPS::noqsssol];Return[{$Failed}]];
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	If[Global`debug,Print[func,": qsssol=",qsssol]];

	removets={Subscript[x_/;comptype[x]=="Extensive",0][t]->Subscript[x,0],t->time};

	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		Which[
			method===Automatic||method=="NIntegrate",
			If[Global`debug,Print[func,": ContinuousTime Floquet mode (1 comp): NIntegrate"]];
			(*Print[invtraits];
			If[invtraits==={},Msg[InvSPS::notraits];Return[{$Failed,$Failed}]];*)
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@nintegrateopts},
				PrintCall[Global`eval=NIntegrate[eq/.Global`sol/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=NIntegrate[Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@nintegrateopts]]/(tend-tstart);
			Return[{eval,"?"}]
		,
			method=="NDSolve",
			If[Global`debug,Print[func,": ContinuousTime Floquet mode (1 comp): NDSolve"]];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
				PrintCall[Global`invsol=NDSolve[{Global`x'[t]==eq/.Global`qsssol,Global`x[tstart]==0},Global`x,{t,tstart,tend},op]];
				PrintCall[Global`eval=Global`x[tend]/dt/.Global`invsol]
			]];
			invsol=NDSolve[{x'[t]==Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol/.qsssol,x[tstart]==0},x,
				{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]][[1]];
			eval=x[tend]/(tend-tstart)/.invsol;
			Return[{eval,"?"}];
		,
			method=="Integrate",
			If[Global`debug,Print[func,": ContinuousTime Floquet mode (1 comp): Integrate"]];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@integrateopts},
				PrintCall[Global`eval=Integrate[eq/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=Integrate[Cancel[inveqns[[1]]/invunks[[1]][t]]/.removets/.traits/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@integrateopts]]/(tend-tstart);
			Return[{Chop[eval],"?"}];
		,
			Else,
			Msg[InvSPS::bdmtd];
			Return[]
		];
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		If[Global`debug,Print[func,": ContinuousTime Floquet mode (2+ comps)"]];
		j=D[inveqns/.traits/.removets,{invunks}];
		If[Global`debug,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,liu=Length[invunks],tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
			PrintCall[Global`invsol=NDSolve[{Global`x'[t]==j.Global`x[t]/.Global`sol/.Global`qsssol,Global`x[tstart]==IdentityMatrix[liu]},Global`x,{t,tstart,tend},op]];
			PrintCall[Global`eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[Global`x[tend]/.Global`invsol]/dt]
		]];
		invsol=NDSolve[{x'[t]==j.x[t]/.invtraits/.sol/.qsssol,x[tstart]==IdentityMatrix[Length[invunks]]},x,{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]];
		eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[x[tend]/.invsol]/(tend-tstart);
		Return[{eval,"?"}];
	]
,
	(* DiscreteTime Floquet mode -- add initial time? *)
	mode=="discretetime floquet",
	If[verbose,Print[func,": DiscreteTime Floquet mode"]];

	(* figure out period *)
	If[Head[sol[[1,2]]]===TemporalData,tend=FinalTime[sol],tend=modelperiod];
	If[Global`debug,Print["tend=",tend]];

	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[verbose,
			With[{tr=Join[traits,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[traits,invtraits],Join[FinalSlice[sol],qssics],Evaluate[Sequence@@findecocycleopts]]
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	If[Global`debug,Print[func,": qsssol=",qsssol]];

	removets={Subscript[x_/;comptype[x]=="Extensive",0][t]->Subscript[x,0],t->time};

	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		If[Global`debug,Print[func,": DiscreteTime Floquet mode (1 comp)"]];
		If[verbose,
			With[{eq=inveqns[[1]]/invunks[[1]][t]/.invtraits,tend=tend},
			PrintCall[Global`eval=Product[eq/.Global`sol/.Global`qsssol,{t,0,tend}]^(1/(tend+1))]
		]];
		eval=Product[inveqns[[1]]/invunks[[1]][t]/.invtraits/.sol/.qsssol,{t,0,tend}]^(1/(tend+1));
		Return[{Chop[eval],"?"}]
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		If[Global`debug,Print[func,": DiscreteTime Floquet mode (2+ comps)"]];
		j=D[inveqns/.traits/.removets,{invunks}];
		If[Global`debug,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,tend=tend,te=tend+1},
			PrintCall[Global`invsol=listMultiplier[Table[j/.Global`sol/.Global`qsssol,{t,0,tend}]]];
			PrintCall[Global`eval=Log[Max@Re@Chop@Sort@Eigenvalues[Global`invsol]^(1/te)]]
		]];
		invsol=listMultiplier[Table[j/.invtraits/.sol/.qsssol,{t,0,tend}]];		
		Return[{Log[Max@Re@Chop@Sort@Eigenvalues[invsol]^(1/(tend+1))],"?"}];
	]
,
	(* Eigenvalue mode *)
	mode=="eigenvalue",
	If[verbose,Print[func,": eigenvalue mode"]];
	
	(* subrule to remove [t]'s *)
	removets=Join[{t->time},RemoveVariablets];

	(* are there any Intensive components to be solved for? *)

	If[Length[qssunks]>0,
		Which[
			qssmethod=="Solve",
			qsssol=Solve[qsseqns/.removets/.qsssubs/.traits/.sol/.invtraits,qssunks,Evaluate[Sequence@@solveopts]],
			qssmethod=="NSolve",
			qsssol=NSolve[qsseqns/.removets/.qsssubs/.traits/.sol/.invtraits,qssunks,Evaluate[Sequence@@nsolveopts]],
			qssmethod=="FindRoot",
			qsssol={FindRoot[qsseqns/.removets/.qsssubs/.traits/.sol/.invtraits,qssunks,Evaluate[Sequence@@findrootopts]]}
		];
	,
		qsssol={{}}];
	If[verbose,Print[func,": qsssol=",qsssol]];
	(* should add SelectValid here? *)
	If[Length[invunks]==1,
		j={{Simplify[Cancel[(inveqns[[1]]/invunks[[1]])/.removets]/.qsssol[[1]]/.qsssubs/.sol/.invtraits/.traits]}}
	,
		(* make Jacobian matrix of Extensive components *)
		(* what about 0th order terms?! *)
		j=D[inveqns/.removets/.traits/.qsssol[[1]]/.invtraits,{invunks}]/.sol;
	];

	If[Global`debug,Print[func,": j=",j]];

	Which[
		Length[j]==1, (* 1 extensive component *)
		If[Global`debug,Print[func,": 1 extensive component"]];
		eval=j[[1,1]];
		evec={1};
	,
		Length[j]>1, (* >1 extensive component *)
	
		(* calculate eigenvalues *)

		If[(MatrixQ[#,NumericQ]&)[j/.qsssubs],
			(* numerical jacobian *)
			If[verbose,Print[func,": numerical Jacobian"]];
			
			If[rv,
				{{eval},{evec}}=SortedEigensystem[Transpose[j/.qsssubs],1,Sequence@@eigensystemopts],
				{{eval},{evec}}=SortedEigensystem[j/.qsssubs,1,Sequence@@eigensystemopts]
			];
			evec=evec/Sign[evec[[1]]]
		,
			(* symbolic jacobian *)
			If[verbose,Print[func,": symbolic Jacobian"]];

			If[Dimensions[j/.qsssubs]=={2,2},
				eval=Simplify[Re[1/2*(j[[1,1]]+j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])]];
				If[rv,
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[1,2]]),1}],
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[2,1]]),1}]
				]
			,
				eval=Max[Re[Eigenvalues[j/.qsssubs,Sequence@@eigensystemopts]]];
				evec="?";
				If[!frominv,Msg[InvSPS::nosymev]];
			];
		];
	];
	
	(* add [t] to InterpolatingFunctions (but not ones with [var]) *)
	eval=eval/.x_InterpolatingFunction->x[t]/.x_InterpolatingFunction[t][var_]->x[var];
	If[verbose,Print[func,": eigenvalue=",eval]];
	If[verbose,Print[func,": eigenvector=",evec]];
	
	(* return answer *)

	Which[
		modeltype=="ContinuousTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Assumptions:>{_\[Element]Reals}]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Assumptions:>{_\[Element]Reals}]]
		,
			Else,
			Return[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
	,
		modeltype=="DiscreteTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Assumptions:>{_\[Element]Reals}]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Assumptions:>{_\[Element]Reals}]]
		,
			Else,
			Return[{(Log@Max@Chop@ComplexExpand[eval])/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
		(*Return[{Simplify[Log@Max@Chop@ComplexExpand[eval],Assumptions\[Rule]{_\[Element]Reals}],evec}];*)
	];

];

]];


Options[InvSPS]={
Method->Automatic,Time->t,
NIntegrateOpts->{Method->{Automatic,"SymbolicProcessing"->0}},IntegrateOpts->{},NDSolveOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},EigensystemOpts->{},FindEcoCycleOpts->{},
QSSMethod->"NSolve",QSSICs->Automatic,
SimplifyResult->False(*True*),Guild->Automatic,FromInv->False,RV->False,
Verbose->False,VerboseAll->False};


Inv[args___]:=InvSPS[args,FromInv->True][[1]];
StablePopulationStructure[args___]:=InvSPS[args][[2]];
ReproductiveValues[args___]:=InvSPS[args,RV->True][[2]];


Options[DInv]={InvOpts->{},Method->"D",Guild->Automatic,Species->All,FindEcoAttractorOpts->{},
Chop->True,Simplify->False,RelativeStepSize->0.001,AbsoluteStepSize->0.001,Time->t,Verbose->False,VerboseAll->All};

notDInvOpts=Except[Alternatives@@Replace[Options[DInv],h_[a_,_]:>h[a,_],1]];


NumDInv[traitsin_?NumericRuleListQ,rest___]:=DInv[traitsin,rest];


DInv[traitsin:(_?TraitsQ):{},solin:(_?VariablesQ):{},{var_:All,ord_?NumberQ},pointin:notDInvOpts:{},opts:OptionsPattern[]]:=

Module[{
func=FuncStyle["DInv"],
(* options *)
verbose,verboseall,method,\[Epsilon]r,\[Epsilon]a,invopts,guild,species,time,simplify,chop,findecoattractoropts,
(* other variables *)
sol,res,res2,traits,traits2,point,targetgu,targettrait,inv,sp,vars,h,h1,h2,invl,invr,invc},

If[solin==$Failed,Return[$Failed]];

(*Print["traitsin=",traitsin];
Print["solin=",solin];
Print["{var,ord}=",{var,ord}];
Print["pointin=",pointin];*)

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

invopts=OptionValue[InvOpts];
method=OptionValue[Method];
\[Epsilon]a=OptionValue[AbsoluteStepSize];
\[Epsilon]r=OptionValue[RelativeStepSize];
guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
species=OptionValue[Species];
time=OptionValue[Time];
AppendTo[invopts,Time->time];
simplify=OptionValue[Simplify];
chop=OptionValue[Chop];
findecoattractoropts=OptionValue[FindEcoAttractorOpts];

(* handle blanks & figure out number of species in guilds *)
traits=DeleteInvaders[ExpandNspInTraits[traitsin]];
sol=ExpandNspInPops[solin];
SetNsp[traits];

If[solin==="FindEcoAttractor",
	If[verbose,
		With[{tr=traits,op=Sequence@@findecoattractoropts},
		PrintCall[Global`sol=FindEcoAttractor[trait,op]]
	]];
	sol=FindEcoAttractor[traits,Evaluate[Sequence@@findecoattractoropts]]
];
If[verbose,Print[func,": sol=",sol]];

(* thread a list of points *)
If[Length[Dimensions[pointin]]==2,Return[Map[DInv[traits,sol,{var,ord},#,opts]&,pointin]]];

(*Print["pointin=",pointin];
Print["species=",species];*)

(* figure out point where to evaluate derivative *)
If[pointin=={},
	(* no point given *)
	If[var===All,
		targetgu=guild,
		If[ListQ[var],targetgu=LookUp[var[[1]]][[2]],targetgu=LookUp[var][[2]]]
	];
	If[species===All,If[Nsp[targetgu]==0,species=0,species=Table[sp,{sp,Nsp[targetgu]}]]];
	If[ListQ[species],
		If[method=="NDInv",Return[Table[DInv[traits,sol,{var,ord},{},Species->sp,opts],{sp,species}]]];
		point=Table[Table[Subscript[gtrait,0]->Subscript[gtrait,sp],{gtrait,gtraits[targetgu]}],{sp,species}]/.traits
	,
		point=Table[Subscript[gtrait,0]->(Subscript[gtrait,species]/.traitsin),{gtrait,gtraits[targetgu]}]
	];
,
	(* point given *)
	targetgu=LookUp[pointin[[1,1]]][[2]];
	point=pointin
];
If[Global`debug,Print[func,": targetgu=",targetgu]];
If[Global`debug,Print[func,": point=",point]];

If[var===All,
	vars=Table[Subscript[gtrait,0],{gtrait,gtraits[targetgu]}],
	vars=var
];
If[Global`debug,Print[func,": vars=",vars]];

Which[
	method=="D",
	If[verbose,
		With[{tr=traits,so=sol,tg=targetgu,op=Sequence@@invopts},
		PrintCall[Global`inv=Simplify[Inv[tr,so,Guild->tg,op],Assumptions->_\[Element]Reals]]
	]];
	inv=Simplify[Inv[traits,sol,Guild->targetgu,Evaluate[Sequence@@invopts]],Assumptions->_\[Element]Reals];
	If[verbose,Print[func,": inv=",inv]];
	If[verbose,
		With[{vars=vars,inv=inv,point=point,traits=traits},
		PrintCall[Global`res=D[inv,{vars,ord}]/.point/.traits]
	]];
	res=D[inv,{vars,ord}]/.point/.traits; (* is /.traits necessary?? *)
	If[verbose,Print[func,": res=",res]];
,
	method=="NDInv",
	Which[
		ord==1,
		If[ListQ[vars],
			(* gradient *)
			Return[DInv[traits,sol,{#,ord},point,opts]& /@ vars];
		, (* first derivative *)
			If[Global`debug,Print[func,": 1st derivative (finite difference)"]];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[IntepolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invl=",invl]];
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[IntepolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invr=",invr]];
			If[invl==$Failed||invr==$Failed,Return[$Failed]];
			res=(invr-invl)/(2h);
		]
	,
		ord==2, 
		If[ListQ[vars],
			(* Hessian matrix *)
			If[Global`debug,Print[func,": Hessian matrix (finite difference)"]];
			res=ConstantArray[0,{Length[vars],Length[vars]}];
			Do[
				(* diagonal entries *)		
				h=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
				res=ReplacePart[res,{v1,v1}->
					(Inv[traits,sol,RuleListTweak[point,vars[[v1]],h],Evaluate[Sequence@@invopts]]
					-2Inv[traits,sol,point,Evaluate[Sequence@@invopts]]
					+Inv[traits,sol,RuleListTweak[point,vars[[v1]],-h],Evaluate[Sequence@@invopts]])/(h^2)
				];
				(* offdiagonal entries *)
				Do[
					h1=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
					h2=(\[Epsilon]r*vars[[v2]]/.point)+\[Epsilon]a;
					res=ReplacePart[res,{{v1,v2},{v2,v1}}->
						(Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,-h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,h2}],Evaluate[Sequence@@invopts]]
						+Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,-h2}],Evaluate[Sequence@@invopts]])/(4*h1*h2)
					];					
				,{v2,v1+1,Length[vars]}]
			,{v1,1,Length[vars]}];
		, (* second derivative *)
			If[Global`debug,Print[func,": 2nd derivative (finite difference)"]];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[IntepolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[trait,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[trait,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invl=",invl]];
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[IntepolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[trait,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[trait,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invr=",invr]];
			If[verbose,
				With[{tr=traits,so=sol,pt=point,op=Sequence@@invopts},
				If[IntepolatingFunctionFunctionQ[so],
					PrintCall[Global`invc=Inv[trait,Global`sol,pt,op]],
					PrintCall[Global`invc=Inv[trait,so,pt,op]]
				]
			]];
			invc=Inv[traits,sol,point,Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invc=",invc]];
			If[invl==$Failed||invr==$Failed||invc==$Failed,Return[$Failed]];
			res=(invr-2invc+invl)/(h^2);
			];
		]
	,
		Else,
		Msg[DInv::badmtd];
		Return[$Failed];
	];

(* postprocess & return answer *)

Which[
	simplify===True,
	res2=Simplify[res/.traits,Assumptions:>{_\[Element]Reals}],
	simplify===Full,
	res2=FullSimplify[res/.traits,Assumptions:>{_\[Element]Reals}],
	Else,
	res2=res/.traits
];

If[chop==True,Return[Chop[res2]],Return[res2]];

]];


(* first derivative abbreviated syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,1];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no point syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_?NumberQ},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,2];*)
	If[Global`debug,Print["DInv: no point given"]];
	DInv[traits,solin,{var,ord},Guild->Automatic,opts]
);


(* no order *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,3];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,4];*)
	If[Global`debug,Print["Dinv: no order, no point"]];
	DInv[traits,solin,{var,1},Guild->1,opts]
);


(* no var, no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,opts___?OptionQ]:=(
	(*AppendTo[Global`uses,5];*)
	If[Global`debug,Print["DInv: no var, no order, no point"]];
	DInv[traits,solin,{All,1},opts]
);


(* first derivative abbreviated syntax & break up traitsandpops *)
DInv[eesol_?TraitsAndVariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,6];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax & break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,1},pointin,opts]
);


(* general derivative abbreviated syntax *)
DInv[eesol_?TraitsAndVariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_Integer},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,7];*)
	If[Global`debug,Print["DInv: general derivative abbreviated syntax"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,ord},pointin,opts]
);


(* break up traitsandpops *)
DInv[eesol_?TraitsAndVariablesQ,rest___]:=(
	(*AppendTo[Global`uses,8];*)
	If[Global`debug,Print["DInv: break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],rest]
);


(* first derivative abbreviated syntax, no traits or variables *)
DInv[var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,9];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax, no traits or variables"]];
	DInv[{},{},{var,1},pointin,opts]
);


NDInv[args___]:=DInv[args,Method->"NDInv"];


PlotInv[traits:(_?TraitsQ):{},sol:(_?VariablesQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotInv"],
(* options *)
verbose,verboseall,monitor,
delayinv,invopts,time,plotopts,plotspecies,markerstyle,plottadopts,tf,axeslabel,plotrange,tadplotrange,
(* other variables *)
nb,x,iplot,
iopts,imin,imax,tmin,tmax,s,iaspectratio,iticks,iaxesorigin,iplotrangepadding,resplotrange,lmin,
gu1,tr1,per,res,inv,epilog,tad},

Block[{Nsp},

(*Print["traits=",traits];
Print["sol=",sol];
Print["{trait1,trait1min,trait1max}=",{trait1,trait1min,trait1max}];*)

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotInv]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotInv]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotInv]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotInv]}]];
If[delayinv===Automatic,If[modelperiod=!=0,delayinv=True,delayinv=False]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotInv]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotInv]}]];
plotspecies=Evaluate[PlotSpecies/.Flatten[{opts,Options[PlotInv]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PlotInv]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PlotInv]}]];
plottadopts=Evaluate[PlotTADOpts/.Flatten[{opts,Options[PlotInv]}]];
tadplotrange=PlotRange/.plottadopts;
tf=Evaluate[TADVerticalScale/.Flatten[{opts,Options[PlotInv]}]];
plotopts=FilterRules[Flatten[{opts,Options[PlotInv]}],Options[Plot]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotInv]}]];
If[axeslabel===Automatic,axeslabel={trait1}];

(* figure out what trait is on the x-axis *)
{gu1,tr1}=LookUp[trait1][[2;;3]];

(* figure out number of species in guilds *)
SetNsp[traits,sol];

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{"\[FormalX]=",Dynamic[x]}}],WindowTitle->"PlotInv Progress..."]];
];

If[delayinv,
	(* delay inv *)
	inv[\[FormalX]_?NumberQ]:=Inv[traits,sol,{Subscript[tr1,0]->\[FormalX]},Guild->gu1,Evaluate[Sequence@@invopts],Time->time,VerboseAll->verboseall];
	iplot=Plot[(x=\[FormalX];Evaluate[inv[\[FormalX]]]),{\[FormalX],trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},
		Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
,
	(* nondelay inv *)
	Off[NIntegrate::inumr];
	inv=Inv[traits,sol,Guild->gu1,Evaluate[Sequence@@invopts],Time->time,VerboseAll->verboseall];
	iplot=Plot[inv,{trait1,trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},
		Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
	On[NIntegrate::inumr]
];

Which[plotspecies==="Axis",
	If[markerstyle===Automatic,
		epilog=Table[{PointSize[0.015],color[Subscript[tr1,sp]][SpFrac[sp,Nsp[gu1]]],Point[{Subscript[tr1,sp]/.traits,0}]},{sp,Nsp[gu1]}],
		epilog=MapThread[Append,{PadRight[{},Nsp[gu1],
			Map[Flatten[{#}]&,markerstyle]],Table[Point[{Subscript[tr1,sp]/.traits,0}],{sp,Nsp[gu1]}]}]
	];
	res=Show[iplot,Epilog->epilog]
	,
	plotspecies==="TAD",
	epilog={};
	tad=PlotTAD[traits,sol,PlotRange->{{trait1min,trait1max},tadplotrange},Evaluate[Sequence@@plottadopts],
		ImagePadding->{{0,0},{0,Scaled[0.05]}},Axes->False,Guild->gu1,Time->time];
	(*Print[tad];*)
	{tmin,tmax}=(PlotRange/.AbsoluteOptions[tad,PlotRange])[[2]];
	iopts=AbsoluteOptions[iplot];
	{imin,imax}=(PlotRange/.iopts)[[2]];
	(*Print["{imin,imax}=",{imin,imax}];
	Print["{tmin,tmax}=",{tmin,tmax}];*)
	iaspectratio=AspectRatio/.iopts;
	iticks=Ticks/.iopts;
	iaxesorigin=AxesOrigin/.iopts;
	iplotrangepadding=PlotRangePadding/.iopts;
	(*Print["iaxesorigin=",iaxesorigin];
	Print["iplotrangepadding=",iplotrangepadding];*)
	s=Max[tf*imin/(tmax(tf-1)),tf*(imax-Min[0,imin])/tmax]; (* scale TAD *)
	(*Print["s=",s];*)
	resplotrange={Min[imin,tmin],Max[imax,s*tmax]};
	If[Head[iplotrangepadding[[2,2]]]===Scaled,
		lmin=imax+1.01*Differences[resplotrange][[1]]*iplotrangepadding[[2,2,1]],
		lmin=imax+iplotrangepadding[[2,2]]+0.01*Differences[resplotrange][[1]]
	];
	(*Print["lmin=",lmin];*)
	res=Show[iplot,
		PlotRange->{{trait1min,trait1max},resplotrange},Ticks->iticks,
		Epilog->{{White,Line[{{iaxesorigin[[1]],lmin},{iaxesorigin[[1]],10^10}}]},
		Inset[Show[tad,AspectRatio->iaspectratio*tf],{0,0},{0,0},Scaled[1]]}];
	(*res=Show[
		iplot,
		PlotRange\[Rule]{{trait1min,trait1max},plotrange},Ticks\[Rule]iticks,
		Epilog\[Rule]{{White,Line[{{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],lmin},{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],10^10}}]},
		Inset[Show[tad,AspectRatio\[Rule]iaspectratio*tf],{0,0},{0,0},Scaled[1]],
		Inset[Show[iplot,Axes\[Rule]False,PlotRange\[Rule]{{trait1min,trait1max},resplotrange}],{0,0},{0,0},Scaled[1]]}]*)
	,
	Else,
	res=iplot
];

If[monitor,NotebookClose[nb]];

Return[res]
]];


PlotInv[eesol_?TraitsAndVariablesQ,{trait1_,trait1min_,trait1max_},opts___?OptionQ]:=
PlotInv[ExtractTraits[eesol],ExtractVariables[eesol],{trait1,trait1min,trait1max},opts];


Options[PlotInv]={
	InvOpts->{},Fixed->{},
	DelayInv->Automatic,Time->t,
	MarkerStyle->Automatic,PlotSpecies->"TAD",PlotTADOpts->{PlotRange->{0,All}},TADVerticalScale->0.25,
	AxesLabel->Automatic,PlotRange->Automatic,
	PlotStyle->Gray,PlotPoints->5,
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotZIP[solin_:"FindEcoAttractor",{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},
invaderin_Symbol:Automatic,opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotZIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,ics,invthreshold,guild,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
fixedvars,traitinv,subrule,luv1,luv2,gu,tr1,tr2,invader,sol,inv,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotZIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotZIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotZIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotZIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotZIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotZIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotZIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotZIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotZIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotZIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotZIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotZIP]}]];
If[invthreshold===Automatic,invthreshold=If[modeltype=="DiscreteTime",1,0]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotZIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotZIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotZIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

fixedvars=fixed[[All,1]];

(* figure out what are the traits on the x- and y-axes *)

luv1=LookUp[var1];
luv2=LookUp[var2];
(*Print["LookUp[var1]=",luv1," LookUp[var2]=",luv2];*)

traitinv={};subrule={};
If[luv1[[1]]==="gtrait",
	{gu,tr1}=luv1[[2;;3]];
	AppendTo[traitinv,var1->\[FormalX]],
	AppendTo[subrule,var1->\[FormalX]]
];
If[luv2[[1]]==="gtrait",
	If[luv1[[1]]==="gtrait"&&(luv2[[2]]!=gu),Msg[PlotZIP::diffsp];Return[$Failed]];
	{gu,tr2}=luv2[[2;;3]];
	AppendTo[traitinv,var2->\[FormalY]],
	AppendTo[subrule,var2->\[FormalY]]
];

(*Print["gu=",gu];
Print["traitinv=",traitinv];
Print["subrule=",subrule];*)

If[invaderin===Automatic,
	If[MemberQ[guilds,gu],
		invader=traitinv,
		Message[PlotZIP::unkinv];Return[$Failed]
	]
,
	invader=invaderin
];
(*Print["invader=",invader];*)

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={var1,var2,"inv"},
		framelabel={var1,var2}
	]
];

(* define resident sol *)

If[solin==="FindEcoAttractor",
	If[fixed=={},
		sol[\[FormalX]_,\[FormalY]_]={}
	,
		If[ics=={},
			(* figure out number of species in guilds *)
			SetNsp[fixed];
			If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,guilds}]]];
			ics=DefaultICs;
			If[verbose,Print[func,": ics=",ics]];
		];
		If[verbose,
			With[{tr=fixed,ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[\[FormalX],\[FormalY]]=FindEcoAttractor[trait,ics,op]]
		]];
		sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
			result=FindEcoAttractor[fixed,ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			If[printtrace,Print["EcoAttractor (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
			If[result=={$Failed},Message[PlotZIP::feafail,\[FormalX],\[FormalY]]];
			Return[result]
		];
		delayinv=True]
,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{var1->\[FormalX],var2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{var1->\[FormalX],var2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]];
];

(* define inv *)

If[delayinv,
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[\[FormalX],\[FormalY]]=Inv[tr,so,in,op]/.{var1->\[FormalX],var2->\[FormalY]}]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[fixed,sol[\[FormalX],\[FormalY]],invader,Evaluate[Sequence@@invopts],VerboseAll->verboseall]/.subrule;
		If[printtrace,Print["Inv (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts,sr=subrule,trinv=traitinv},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,in,op]/.sr/.trinv]
	]];
	inv[\[FormalX]_,\[FormalY]_]=Inv[fixed,sol[\[FormalX],\[FormalY]],invader,Evaluate[Sequence@@invopts],VerboseAll->verboseall]/.subrule/.traitinv;
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]]
];

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{"\[FormalX]=",Dynamic[x]},{"\[FormalY]=",Dynamic[y]}}],WindowTitle->"PlotZIP Progress..."]];
];

Which[
	plottype=="Plot3D",
	res=Plot3D[({x,y}={\[FormalX],\[FormalY]};Evaluate[{inv[\[FormalX],\[FormalY]],invthreshold}]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"]],
	plottype=="ContourPlot",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel],
	plottype=="RegionZIP", 
	res=RegionPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="ZIP",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,
		ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel],
	Else,
	Message[PlotZIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotZIP]={
	FindEcoAttractorOpts->{},InvOpts->{},
	DelayInv->False,PlotType->"ZIP",ICs->{},Fixed->{},InvThreshold->Automatic,
	PlotOpts->{MaxRecursion->3},
	BoundaryStyle->Black,InvStyle->Gray,NonInvStyle->White,
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotPIP[solin_:"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotPIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,ics,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,res,sol,resinv,inv},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotPIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotPIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotPIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotPIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotPIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotPIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotPIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotPIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotPIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotPIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotPIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotPIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotPIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotPIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotPIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotPIP]}]];

If[zerodiagonal,inv[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={trait1,Subscript[tr1,0],"inv"},
		framelabel={trait1,Subscript[tr1,0]}
	]
];

(* fixed traits for invader *)
invfixed=Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}];

(* define resident sol *)

If[solin==="FindEcoAttractor",
	If[ics=={},
		(* figure out number of species in guilds *)
		SetNsp[Append[fixed,trait1->trait1]];
		If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,guilds}]]];
		ics=DefaultICs;
		If[verbose,Print[func,": ics=",ics]];
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ]:=Global`sol[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol[\[FormalX]_?NumberQ]:=sol[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotPIP::feafail,trait1,\[FormalX]]];
		Return[result]
	];
	delayinv=True;
,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_]=solin/.trait1->\[FormalX]]];
	sol[\[FormalX]_]=solin/.trait1->\[FormalX];
	If[verbose,Print[func,": sol[\[FormalX]]=",sol[\[FormalX]]]];
];

(* define inv *)
If[delayinv,
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
				PrintCall[Global`resinv[(System`\[FormalX])_?NumberQ]:=Global`resinv[System`\[FormalX]]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_?NumberQ]:=resinv[\[FormalX]]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		If[subtractdiagonal,result=result-resinv[\[FormalX]]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
			PrintCall[Global`resinv[(System`\[FormalX])_]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_]=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[verbose,Print[func,": resinv[\[FormalX]]=",resinv[\[FormalX]]]];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_,\[FormalY]_]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall]
		-If[subtractdiagonal==True,resinv[\[FormalX]],0];
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]];
];

If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{"\[FormalX]=",Dynamic[x]},{"\[FormalY]=",Dynamic[y]}}],WindowTitle->"PlotPIP Progress..."]];
];

Which[
	plottype=="Plot3D",
	res=Plot3D[{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold},{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"],EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="ContourPlot",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="RegionPlot", 
	res=RegionPlot[Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="PIP",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	Else,
	Message[PlotPIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotPIP]={
	FindEcoAttractorOpts->{},InvOpts->{},
	DelayInv->False,PlotType->"PIP",ICs->{},ZeroDiagonal->False,Fixed->{},SubtractDiagonal->False,InvThreshold->0,
	PlotOpts->{MaxRecursion->3},FrameLabel->Automatic,
	BoundaryStyle->Black,InvStyle->Gray,NonInvStyle->White,
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotMIP[{solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",solin2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotMIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,icsin,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,spcolors,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,gu2,tr2,sp2,ics,sol1,sol2,inv12,inv21,pip1,pip2,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotMIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotMIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotMIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotMIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotMIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotMIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotMIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotMIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotMIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotMIP]}]];
icsin=Evaluate[ICs/.Flatten[{opts,Options[PlotMIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotMIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotMIP]}]];
spcolors=Evaluate[SpeciesColors/.Flatten[{opts,Options[PlotMIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotMIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotMIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

If[zerodiagonal,inv12[\[FormalX]_,\[FormalX]_]=inv21[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* fixed traits for invader [why are there 2 of these?] *)
invfixed=Flatten[Join[
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}],
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu2],{tr2}]}]
]];

(* define resident sol *)

If[solin1==="FindEcoAttractor",
	If[icsin=={},
		(* figure out number of species in guilds *)
		SetNsp[Append[fixed,trait1->trait1]];
		If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,guilds}]]];
		ics=DefaultICs;
		If[verbose,Print[func,": ics=",ics]];
	,
		ics=icsin
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol1[(System`\[FormalX])_?NumberQ]:=Global`sol1[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol1[\[FormalX]_?NumberQ]:=sol1[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotMIP::feafail,trait1,\[FormalX]]];
		Return[result];
	];
	delayinv=True;
,
	If[verbose,PrintCall[Global`sol1[(System`\[FormalX])_]=solin1/.trait1->\[FormalX]]];
	sol1[\[FormalX]_]=solin1/.trait1->\[FormalX];
	If[verbose,Print[func,": sol1[\[FormalX]]=",sol1[\[FormalX]]]]
];

If[trait1=!=trait2,
	If[solin2==="FindEcoAttractor",
		delayinv=True;
		If[icsin=={},
			(* figure out number of species in guilds *)
			SetNsp[Append[fixed,trait2->trait2]];
			If[Global`debug,Print[func,": Nsp2=",Table[Nsp[gu],{gu,guilds}]]];
			ics=DefaultICs;
			If[verbose,Print[func,": ics=",ics]];
		,
			ics=icsin
		];
		If[verbose,
			With[{tr=Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol2[(System`\[FormalX])_?NumberQ]:=Global`sol2[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
		]];
		sol2[\[FormalX]_?NumberQ]:=sol2[\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			If[printtrace,Print["EcoAttractor (",trait2,"=",\[FormalX],"): ",result]];
			If[result=={$Failed},Message[PlotMIP::feafail,trait2,\[FormalX]]];
			Return[result];
		];
	,
		If[verbose,PrintCall[Global`sol2[(System`\[FormalX])_]=solin2/.trait2->\[FormalX]]];
		sol2[\[FormalX]_]=solin2/.trait2->\[FormalX];
		If[verbose,Print[func,": sol2[\[FormalX]]=",sol2[\[FormalX]]]]
	]
,
	sol2[\[FormalX]_]:=sol1[\[FormalX]];
	If[verbose,Print[func,": sol2[\[FormalX]]=sol1[\[FormalX]]"]]
];

(* define inv21 & inv12 *)
If[delayinv,
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Global`sol1[\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts,trinv=Subscript[trait[gu2,tr2],0]},
			PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv21[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[printtrace,Print["Inv (",trait2,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		Return[result]
	];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Global`sol2[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv12[\[FormalX],\[FormalY]]=Module[{result},
			result=Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
			If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr2,0],"=",\[FormalY],"): ",result]];
			Return[result]
		];
	,
		(* if trait1=trait2, then re-use inv21 *)
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]]
	]
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Global`sol1[\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts},
			PrintCall[Global`inv21[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_,\[FormalY]_]=
		Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Global`sol2[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_,\[FormalY]_]=
			Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall]
	,
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]];
		If[verbose,Print[func,": inv12[\[FormalX],\[FormalY]]=inv21[\[FormalX],\[FormalY]]"]]
	]
];


If[monitor,
	nb=CreateDialog[DialogNotebook[Grid[{{trait1,"=",Dynamic[x]},{SubscriptAdd[trait2,1],"=",Dynamic[y]}}],WindowTitle->"PlotMIP Progress..."]];
];

Which[
	plottype=="MIP",
	pip1=ContourPlot[({monx,mony}={\[FormalX],\[FormalY]};Evaluate[inv21[\[FormalX],\[FormalY]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[({monx,mony}={\[FormalX],\[FormalY]};Evaluate[inv12[\[FormalY],\[FormalX]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1//axisFlip
	];
	res=Show[Graphics[{invstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,Evaluate[Sequence@@plotopts],Frame->True,FrameLabel->framelabel,
		Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionMIP",
	res=RegionPlot[Evaluate[(inv12[\[FormalY],\[FormalX]]>invthreshold&&inv21[\[FormalX],\[FormalY]]>invthreshold)],
		{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="Outcome",
	pip1=ContourPlot[Evaluate[inv21[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[2]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[Evaluate[inv12[\[FormalY],\[FormalX]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[1]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1/.spcolors[[2]]->spcolors[[1]]//axisFlip
	];
	res=Show[Graphics[{noninvstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,Evaluate[Sequence@@plotopts],
		Frame->True,FrameLabel->framelabel,Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionOutcome",
	res=RegionPlot[Evaluate[{inv21[\[FormalX],\[FormalY]]>invthreshold,inv12[\[FormalY],\[FormalX]]>invthreshold}]
		,{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],BoundaryStyle->boundarystyle,
		PlotStyle->{Directive[spcolors[[1]],Opacity[0.4]],Directive[spcolors[[2]],Opacity[0.4]]},FrameLabel->framelabel],
	Else,
	Message[PlotMIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res];

]];


PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},
	opts___?OptionQ]:=
((*Print[1];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
((*Print[2];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait1,trait1min,trait1max},opts]);


PlotMIP[{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},
	opts___?OptionQ]:=
	((*Print[3];*)PlotMIP[{"FindEcoAttractor","FindEcoAttractor"},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


Options[PlotMIP]={
	PlotType->"MIP",DelayInv->False,FindEcoAttractorOpts->{},InvOpts->{},InvThreshold->0,
	ICs->{},ZeroDiagonal->False,Fixed->{},
	BoundaryStyle->Black,SpeciesColors->{Red,Blue},InvStyle->Gray,NonInvStyle->White,FrameLabel->Automatic,
	PlotOpts->{MaxRecursion->3},
	Monitor->False,Verbose->False,VerboseAll->False
};


EvoEqns[solin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=
 
Module[{
func=FuncStyle["EvoEqns"],
(* options *)
verbose,verboseall,fixed,delaydinv,dinvopts,evoeqn,traitshiftrate,nsps,ics,time,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,nonfixedtraits,
g,dtrait,pre,wt,sol,eqns},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EvoEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EvoEqns]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoEqns]}]];
(*Print["fixed=",fixed];*)
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
fixedtraits=ExtractTraits[fixed];
(*Print["fixedtraits=",fixedtraits];*)
If[Global`debug,Print[func,": fixedtraits=",fixedtraits]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];

delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EvoEqns]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[EvoEqns]}]];
If[modelperiod=!=0,AppendTo[dinvopts,InvOpts->{Method->"Instantaneous"}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[EvoEqns]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[EvoEqns]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[EvoEqns]}]];
nsps=Evaluate[Nsps/.Flatten[{opts,Options[EvoEqns]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EvoEqns]}]];

sol=ExpandNspInPops[solin];
(*Print["sol=",sol];*)

(* figure out number of species in guilds *)
If[solin==="FindEcoAttractor"&&nsps=!={},
	Evaluate[Table[Nsp[gu],{gu,guilds}]]=nsps,
	SetNsp[Join[sol,fixedvariables]]
];
If[Global`debug,Print[func,": Nsp=",Table[Nsp[gu],{gu,guilds}]]];

(* shifting traits *)
Do[
	dtrait[gu,gtrait]=If[MemberQ[traitshiftrate[[All,1]],gtrait],gtrait/.traitshiftrate,0]
,{gu,guilds},{gtrait,gtraits[gu]}];
If[Global`debug,Print[func,": dtrait=",Table[dtrait[gu,gtrait],{gu,guilds},{gtrait,gtraits[gu]}]]];

(* set up G matrices *)
Do[
	g[gu]=If[MatrixQ[G[gu]/.Gs],
		G[gu]/.Gs,
		DiagonalMatrix[Table[If[NumberQ[V[gtrait]/.Gs],V[gtrait]/.Gs,1],{gtrait,gtraits[gu]}]]
	]
,{gu,guilds}];

(* traiteqns *)
Which[
	evoeqn=="QG",
	Do[Do[pre[gu,sp]=1,{sp,0,Nsp[gu]}],{gu,guilds}],
	evoeqn=="CE",
	Do[
		Do[
			If[comptype[gcomp]=="Extensive",wt[gu,gcomp]=1,wt[gu,gcomp]=0]
		,{gcomp,gcomps[gu]}];
		Do[
			pre[gu,sp]:=Sum[wt[gu,gcomp]*Subscript[gcomp,sp],{gcomp,gcomps[gu]}]
		,{sp,0,Nsp[gu]}]
	,{gu,guilds}],
	Else,
	Msg[EvoEqns::badte];
	Return[$Failed]
];

(*Print["setting eqns..."];*)
If[delaydinv==True,
	eqns=Flatten[Table[Table[Table[
		DT[Subscript[gtrait,sp]]==pre[gu,sp]*
		Sum[g[gu][[index[gtrait],index[gtrait\[Prime]]]]NumDInv[BlankUnkTraits,sol,Subscript[gtrait\[Prime],0],Species->sp,Method->"NDInv",Evaluate[Sequence@@dinvopts],VerboseAll->verboseall],{gtrait\[Prime],gtraits[gu]}]
		-dtrait[gu,gtrait]+If[modeltype=="DiscreteTime",Unk[Subscript[gtrait,sp]],0]
	,{gtrait,gtraits[gu]}],{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,guilds}]]/.fixed
,
	If[sol==="FindEcoAttractor",sol=BlankVariables];
	eqns=Flatten[Table[Table[
		Thread[Table[DT[Subscript[gtrait,sp]],{gtrait,gtraits[gu]}]==(
		pre[gu,sp]*g[gu].DInv[BlankTraits,sol,Guild->gu,Species->sp,Time->time,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall]
		-Table[dtrait[gu,gtrait],{gtrait,gtraits[gu]}]
		+If[modeltype=="DiscreteTime",Table[Subscript[gtrait,sp],{gtrait,gtraits[gu]}],0]
		/.fixed/.AddVariablets/.AddTraitts)]
	,{sp,If[Nsp[gu]==0,0,1],Nsp[gu]}],{gu,guilds}]]
];

eqns=DeleteCases[eqns,DT[var_]==_/;MemberQ[fixedvars,var]];

Return[eqns];

]];


Options[EvoEqns]={Time->t,DelayDInv->False,DInvOpts->{},EvoEquation->"QG",TraitShiftRate->{},Fixed->{},ICs->{},Nsps->{},
Verbose->False,VerboseAll->False};


PlotEvoStreams[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoStreams"],
(* options *)
verbose,verboseall,monitor,printtrace,fixed,time,
evoeqn,fitnessgradient,dinvopts,delaydinv,findecoattractoropts,streamplotopts,framelabel,ecoattnumber,usesymmetry,zerodiagonal,
(* other variables *)
nb,evoeqns,dt,nsps,ics,sol,
gu1,tr1,sp1,gu2,tr2,sp2,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoStreams]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoStreams]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoStreams]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoStreams]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoStreams]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[fitnessgradient=="NDInv",AppendTo[dinvopts,Method->"NDInv"]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];

streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEvoStreams]}],Options[StreamPlot]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoStreams]}]];
ecoattnumber=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoStreams]}]];
usesymmetry=Evaluate[UseSymmetry/.Flatten[{opts,Options[PlotEvoStreams]}]];

If[modelperiod!=0&&time==t,delaydinv=True;AppendTo[dinvopts,InvOpts->{}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[tr2===tr1,
		framelabel={trait1,SubscriptAdd[trait1,1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	(* figure out number of species in guilds *)
	SetNsp[Join[fixed,{trait1->trait1,trait2->trait2}]];
	ics=DefaultICs;
	nsps=Table[Nsp[gu],{gu,guilds}];
	If[Global`debug,Print[func,": Nsp=",nsps]];
,
	nsps={}
];

evoeqns=EvoEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,Nsps->nsps];
If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_[t+1]->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
If[verbose,Print[func,": evoeqns=",evoeqns]];

If[solin==="FindEcoAttractor",
	(*sol[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=sol[\[FormalX],\[FormalY]]=FindEcoAttractor[BlankUnkTraits,ics,Time\[Rule]time,Evaluate[Sequence@@findecoattractoropts],VerboseAll\[Rule]verboseall]
		/.fixed/.{Unk[trait1]\[Rule]\[FormalX],Unk[trait2]\[Rule]\[FormalY]};*)
	sol[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=sol[\[FormalX],\[FormalY]]=FindEcoAttractor[{trait1->\[FormalX],trait2->\[FormalY]},ics,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall]/.fixed;

	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];
(*Print[sol[12,18]];Print[dt[12,18]];*)
(*Print[sol[0.5,0]];Print[dt[0.5,0]];*)

res=myStreamPlot[dt[\[FormalX],\[FormalY]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@streamplotopts]];

If[monitor,NotebookClose[nb]];

Return[res]

]];


PlotEvoStreams[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoStreams[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts]


Options[PlotEvoStreams]={Fixed->{},Time->t,FindEcoAttractorOpts->{},DInvOpts->{},DelayDInv->False,
FrameLabel->Automatic,StreamStyle->Gray,
UseSymmetry->False,FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,
Monitor->False,PrintTrace->False,Verbose->False,VerboseAll->False};


PlotEvoIsoclines[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoIsoclines"],
(* options *)
verbose,verboseall,fixed,time,
evoeqn,monitor,printtrace,fitnessgradient,dinvopts,findecoattractoropts,plotopts,framelabel,ics,ecoattnum,
estest,isoclinestyle,delaydinv,delaydinv2,dinv2opts,excludediagonal,
(* other variables *)
nb,evoeqns,
ics1,nsps,color1,color1es,color1nes,color2,color2es,color2nes,style1,style1es,style1nes,style2,style2es,style2nes,
sol,dt,dinv21,dinv22,gu1,tr1,sp1,gu2,tr2,sp2,pre1,pre2,iso1,iso2},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ecoattnum=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
estest=Evaluate[ESTest/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv2=Evaluate[DelayDInv2/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinv2opts=Evaluate[DInv2Opts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
excludediagonal=Evaluate[ExcludeDiagonal/.Flatten[{opts,Options[PlotEvoIsoclines]}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[excludediagonal&&{gu1,tr1}=={gu2,tr2},AppendTo[plotopts,Exclusions->{\[FormalX]==\[FormalY]}]];

If[isoclinestyle===Automatic,
	color1es=color1nes=color1=color[trait1][0];
	color2es=color2nes=color2=color[trait2][1];
	style1es=Thick;style1nes=Thin;style1=Thickness[Medium];
	style2es=Thick;style2nes=Thin;style2=Thickness[Medium];
,
	If[ListQ[isoclinestyle[[1]]],
		color1es=ExtractColors[isoclinestyle[[1,1]]];
		color1nes=ExtractColors[isoclinestyle[[1,2]]];
		style1es=Complement[isoclinestyle[[1,1]],color1es];
		style1nes=Complement[isoclinestyle[[1,2]],color1nes];
	,
		color1=ExtractColors[isoclinestyle[[1]]];
		style1=Complement[isoclinestyle[[1,1]],color1];
	];
	If[ListQ[isoclinestyle[[2]]],
		color2es=ExtractColors[isoclinestyle[[2,1]]];
		color2nes=ExtractColors[isoclinestyle[[2,2]]];
		style2es=Complement[isoclinestyle[[2,1]],color2es];
		style2nes=Complement[isoclinestyle[[2,2]],color2nes];
	,
		color2=ExtractColors[isoclinestyle[[2]]];
		style2=Complement[isoclinestyle[[2,1]],color2];
	];
];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	fitnessgradient="NDInv";
	delaydinv2=True;
	If[ics=={},
		(* figure out number of species in guilds *)
		SetNsp[Join[fixed,{trait1->trait1}]];
		ics1=DefaultICs;
		SetNsp[Join[fixed,{trait1->trait1,trait2->trait2}]];
		nsps=Table[Nsp[gu],{gu,guilds}];
		If[Global`debug,Print[func,": Nsp=",nsps]];
		ics=DefaultICs;
	];
	(* handle diagonal *)
	If[{gu1,tr1}=={gu2,tr2},
		sol[\[FormalX]_?NumberQ,\[FormalX]_?NumberQ]:=sol[\[FormalX],\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX]}],ics1,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			Return[Join[result,Table[Subscript[gcomp,sp2]->0,{gcomp,gcomps[gu1]}]]]
		]
	];
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics=ics,time=time,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[System`\[FormalX],System`\[FormalY]]=
			FindEcoAttractor[tr,ics,Time->time,op]]]
	];
	sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
		result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["FindEcoAttractor ",{trait1->\[FormalX],trait2->\[FormalY]},"=",result]];
		If[ArrayDepth[result]<2,Return[result],Print[result," ",ArrayDepth[result]];Return[result[[ecoattnum]]]]
	];
, (* sol given *)
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]]
];

evoeqns=EvoEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,Nsps->nsps];

If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_[t+1]->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
If[verbose,Print[func,": evoeqns=",evoeqns]];

If[solin==="FindEcoAttractor",
	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];

(*Print["solin=",solin];
Print[sol[0.1,0.2]];
Print[dt[0.1,0.2]];*)

iso1=ContourPlot[dt[\[FormalX],\[FormalY]][[1]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Contours->{0},ContourShading->False,
	ContourStyle->Flatten[{color1,style1}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait1]&}
];
If[Global`debug,Print[iso1]];

(* add flip option to save 50% time *)

iso2=ContourPlot[dt[\[FormalX],\[FormalY]][[2]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Contours->{0},ContourShading->False,
	ContourStyle->Flatten[{color2,style2}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait2]&}];
If[Global`debug,Print[iso2]];

If[monitor,NotebookClose[nb]];

If[estest==False,Return[Show[iso1,iso2,FrameLabel->framelabel]]];

(* ESTest\[Equal]True *)

If[delaydinv2,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv21[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv1,ts1,Method->"NDInv",Time->time,op]];
			PrintCall[Global`dinv22[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv22[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv2,ts2,Method->"NDInv",Time->time,op]]
	]];		
	dinv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv21[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	dinv22[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv22[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},sp1=sp1,sp2=sp2,
			time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv1,Species->sp1,Time->time,op]];
			PrintCall[Global`dinv22[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv2,Species->sp2,Time->time,op]]
	]];
	dinv21[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	dinv22[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	If[verbose,
		Print[func,": dinv21[\[FormalX],\[FormalY]]=",dinv21[\[FormalX],\[FormalY]]];
		Print[func,": dinv22[\[FormalX],\[FormalY]]=",dinv22[\[FormalX],\[FormalY]]]
	]
];

Return[Show[
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]>0,color1nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]<0,color1es,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]>0,color2nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]<0,color2es,{Opacity[0]}]]&)],
	Frame->True,Axes->False,AspectRatio->1,FrameLabel->framelabel,PlotRange->{{trait1min,trait1max},{trait2min,trait2max}}
]]

]];

Options[PlotEvoIsoclines]={Fixed->{},Time->t,
	FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,ExcludeDiagonal->True,
	FindEcoAttractorOpts->{},DelayDInv->False,DInvOpts->{},PlotOpts->{},FrameLabel->Automatic,
	ESTest->True,DelayDInv2->False,DInv2Opts->{},IsoclineStyle->Automatic,
	Verbose->False,VerboseAll->False,Monitor->False,PrintTrace->False};


PlotEvoIsoclines[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoIsoclines[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts];


(* two guilds *)
PlotEvoPhasePlane[{eq11:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq12:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Gu)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[{eq11,eq12},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two species *)
PlotEvoPhasePlane[eq1:(_?RuleListQ):"FindEcoAttractor",eq2:(_?RuleListQ):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Sp)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[eq1,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two traits *)
PlotEvoPhasePlane[eq0:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Tr)"],
(* options *)
plotzipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
invader,pes,pei,zip},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotzipopts=FilterRules[Flatten[{Evaluate[PlotZIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotZIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

invader=(Guild->LookUp[trait1][[2]]);

pes=PlotEvoStreams[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
zip=PlotZIP[eq0,{(trait1/.Subscript[x_,_]->Subscript[x,0]),trait1min,trait1max},{(trait2/.Subscript[x_,_]->Subscript[x,0]),trait2min,trait2max},
invader,InvStyle->Opacity[0],Evaluate[Sequence@@plotzipopts]];
If[Global`debug,Print[zip]];

Return[Show[pes,pei,zip]]
];


(* two traits - no eq0 alias *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
PlotEvoPhasePlane["FindEcoAttractor",eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts];


Options[PlotEvoPhasePlane]={PlotMIPOpts->{},PlotZIPOpts->{},PlotEvoIsoclinesOpts->{},PlotEvoStreamsOpts->{}};


EcoEvoSim[traits_?TraitsQ,variables_?VariablesQ,Gs:(_?GsQ):{},tmax_?NumericQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoSim"],
(* options *)
verbose,verboseall,
boundarydetection,ndsolveopts,wheneventopts,delaydinv,fixed,tmin,outputtmin,output,freezetraits,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,tic,ecoeqns,evoeqns,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoSim]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoSim]}]];
If[verboseall,verbose=True];

boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EcoEvoSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoEvoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoEvoSim]}]];
freezetraits=Evaluate[FreezeTraits/.Flatten[{opts,Options[EcoEvoSim]}]];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[variables,fixedvariables]];
(*Print["Nsp=",Table[Nsp[gu],{gu,guilds}]];*)

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* set up ecoeqns & evoeqns *)
ecoeqns=EcoEqns[BlankTraits,opts]/.AddTraitts;
evoeqns=EvoEqns[BlankVariables,Gs,opts];
(*Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns];*)

(* set up unks *)
unks=Join[ecoeqns,evoeqns]/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};

(* set up ics *)
ics=Table[var[tic]==(var/.traits/.variables),{var,unks}];

(* insert unks[] for delaydinv *)
If[delaydinv,
	ecoeqns=ecoeqns/.ToUnks;
(*	evoeqns=evoeqns/.(var_\[Rule]var_)\[Rule](var\[Rule]Unk[var][t])/.(var_\[Rule]Unk[var_])\[Rule](var\[Rule]Unk[var][t])
		/.var_[t+1]\[Rule]Unk[var][t+1]/.var_'[t]\[Rule]Unk[var]'[t];*)
	evoeqns=evoeqns/.ToUnkRules/.Unk[var_]->Unk[var][t]/.var_[t+1]->Unk[var][t+1]/.var_'[t]->Unk[var]'[t];
	ics=ics/.ToUnks;
	unks=unks/.ToUnks
];

(* boundary detection *)
If[boundarydetection==True,
	Which[
		modeltype=="ContinuousTime",
		bdwhens=Flatten[WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.(evoeqns/.(var_'[t]==rhs_):>{
			{event->var[t]>Max[range[var/.FromUnks]],action->in[var][t]->0},
			{event->var[t]<Min[range[var]/.FromUnks],action->in[var][t]->0},
			{event->rhs>0&&var[t]==Min[range[var/.FromUnks]],action->in[var][t]->1},
			{event->rhs<0&&var[t]==Max[range[var/.FromUnks]],action->in[var][t]->1}
		}),1];
		(*Print[func,": bdwhens="];Print[bdwhens];*)
		discretevars=evoeqns/.(var_'[t]==rhs_)->in[var];
		(*Print["discretevars=",discretevars];*)
		ics=Flatten[Join[ics,evoeqns/.(var_'[t]==rhs_)->in[var][0]==1]];
		(*Print["ics=",ics];*)
		evoeqns=evoeqns/.(var_'[t]==rhs_)->var'[t]==rhs*in[var][t]
	,
		modeltype=="DiscreteTime",
		evoeqns=evoeqns/.(var_[t+1]==rhs_)->var[t+1]==RestrictedTo[rhs,range[var]];
	];
,
	bdwhens={};
	discretevars={};
];
(*Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns];*)

If[freezetraits,
	ecoeqns=ReplaceRHS[ecoeqns,{RemoveTraitts,traits}];
	evoeqns=ReplaceRHS[evoeqns,{RemoveTraitts,traits}];
];
eqns=Join[ecoeqns,evoeqns];

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": ics="];Print[ics];
	Print[func,": unks="];Print[unks];
	Print[func,": bdwhens="];Print[bdwhens];
	Print[func,": discretevars="];Print[discretevars];
];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens,modelwhenevents]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	sol=Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TD[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
	sol=Join[sol,Table[fixedvar->TD[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[delaydinv,sol=sol/.FromUnks];

If[output=="FinalSlice",Return[VarSort[Chop[Join[FinalSlice[sol],fixed]],Join[AllVariables,AllTraits]]]];

Return[VarSort[sol,Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoSim]=
	{Fixed->{},BoundaryDetection->False,FreezeTraits->False,
	NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
	TMin->0,OutputTMin->0,Output->"Dynamics",
	Verbose->False,VerboseAll->False};


EcoEvoSim[sol_?TraitsAndVariablesQ,Gs:(_?RuleListQ):{},tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],Gs,tmax,opts];


FindEcoEvoEq[traits_?TraitsQ,variables_?VariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoEq"],
(* options *)
verbose,verboseall,method,boundarydetection,percapita,delaydinv,fixed,findrootopts,chop,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,ecoeqns,evoeqns,eqns,unks,newunk,unksics,sol},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[FindEcoEvoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoEq]}]];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[variables,fixedvariables]];

(* set up eqns *)
ecoeqns=EcoEqns[BlankTraits,opts,PerCapita->percapita];
evoeqns=EvoEqns[BlankVariables,Gs,opts];
eqns=If[delaydinv,
	Join[ecoeqns/.Eq/.RemoveVariablets/.RemoveTraitts/.ToUnks,evoeqns/.Eq/.RemoveVariablets/.RemoveTraitts/.ToUnkRules],
	Join[ecoeqns,evoeqns]/.Eq/.RemoveTraitts/.RemoveVariablets
];

(* set up unksics *)
unks=Join[ecoeqns,evoeqns]/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]-var_[t]->var,var_[t+1]->var};
unksics={};
Do[
	newunk=If[delaydinv,{var/.ToUnks,var/.traits/.variables},{var,var/.traits/.variables}];
	If[method=="Secant",AppendTo[newunk,var+0.001/.traits/.variables]];
	If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
	AppendTo[unksics,newunk];
,{var,unks}];

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unksics="];Print[unksics];
];

(* solve it *)
sol=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]];

If[Global`debug,Print[func,": sol="];Print[sol]];

If[chop,
	Return[VarSort[Chop[Join[sol,fixed]/.FromUnks],Join[AllVariables,AllTraits]]],
	Return[VarSort[Join[sol,fixed]/.FromUnks,Join[AllVariables,AllTraits]]]
];

]];


Options[FindEcoEvoEq]={Fixed->{},PerCapita->True,FindRootOpts->{},DelayDInv->False,Chop->True,Verbose->False,VerboseAll->False};


FindEcoEvoEq[sol_?TraitsAndVariablesQ,Gs_:{},opts___?OptionQ]:=FindEcoEvoEq[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


FindEcoEvoCycle[traits_?TraitsQ,variables_?VariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoCycle (Periodic)"],
(* options *)
verbose,verboseall,
method,fitnessgradient,evoeq,
ecosimopts,ndinvopts,ecoevosimopts,findrootopts,monitor,printtrace,fixed,maxiterations,accuracygoal,traitshiftrate,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,nonfixedtraits,nonfixedvars,nonfixedvariables,
thing,fw,sol,unks,unksics,res,dtrait,v,nb},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[verboseall,verbose=True];

evoeq=Evaluate[EvoEq/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[fitnessgradient===Automatic,If[evoeq==False||Max[Table[ngcomps[gu],{gu,guilds}]]==1,fitnessgradient="EcoEvoSim",fitnessgradient="NDInv"]];
If[Max[Table[ngcomps[gu],{gu,guilds}]]>1&&fitnessgradient=="EcoEvoSim",Msg[FindEcoEvoCycle::susmtd]];
If[verbose,Print[func,": FitnessGradient=",fitnessgradient]];
ndinvopts=Evaluate[NDInvOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecoevosimopts=Evaluate[EcoEvoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
maxiterations=Evaluate[MaxIterations/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
accuracygoal=Evaluate[AccuracyGoal/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[evoeq==True,AppendTo[ecoevosimopts,FreezeTraits->True]];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedtraits=traits[[All,1]];
nonfixedvariables=variables[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[variables,fixedvariables]];

Which[
	fitnessgradient=="EcoEvoSim",
	thing[varsandtraits_?NumericRuleListQ]:=Module[{},
		$findecoevocyclethingcount++;
		sol=EcoEvoSim[varsandtraits,Gs,modelperiod,Fixed->fixed,TraitShiftRate->traitshiftrate,
			Evaluate[Sequence@@ecoevosimopts]];
		If[printtrace,Print[$findecocycleevoeqthingcount," ",FinalSlice[sol]]];
		Return[Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&]]
	]
,	
	fitnessgradient=="NDInv",
	(* shifting traits *)
	Do[dtrait[tr]=If[MemberQ[traitshiftrate[[All,1]],tr[[1]]],tr[[1]]/.traitshiftrate,0],{tr,nonfixedtraits}];
	(* set up vs *)
	Do[v[tr]=V[DeleteSubscript@tr]/.Gs/.V[DeleteSubscript@tr]->1,{tr,nonfixedtraits}];

	thing[varsandtraits_?NumericRuleListQ]:=Module[{fg},
		$findecoevocyclethingcount++;
		sol=EcoSim[varsandtraits,modelperiod,Fixed->fixed,Evaluate[Sequence@@ecosimopts]];
		fg=Flatten[Table[tr->
			v[tr]*NDInv[Join[varsandtraits,fixed]//ExtractTraits,sol,tr//ZeroSubscript,{(tr//ZeroSubscript)->(tr/.varsandtraits)},
			Evaluate[Sequence@@ndinvopts]]-dtrait[tr]
		,{tr,nonfixedtraits}]];
		If[printtrace,Print[$findecoevocyclethingcount," ",FinalSlice[sol]," ",RuleListAdd[ExtractTraits[varsandtraits],fg]]];
		Return[Join[
			Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&],
			RuleListAdd[ExtractTraits[varsandtraits],fg]
		]]
	],
	Else,
	Msg[FindEcoEvoCycle::badmtd];Return[$Failed]
];

(* solve it*)
$findecoevocyclethingcount=0;
Which[
	method=="FindRoot",
	If[verbose,Print[func,": Method FindRoot"]];
	unks=nonfixedvars/.ToUnks;
	unksics=Table[{var/.ToUnks,var/.traits/.variables},{var,nonfixedvars}];
	fw[l_?NumericListQ]:=nonfixedvars/.thing[Thread[nonfixedvars->l]];
	res=FindRoot[fw[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]];
	If[monitor,NotebookClose[nb]];
	If[evoeq==True,
		Return[VarSort[Join[ExtractTraits[res/.FromUnks],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]],
		Return[VarSort[Join[sol,fixed],Join[AllVariables,AllTraits]]]
	]
,
	method=="FixedPoint",
	If[verbose,Print[func,": Method FixedPoint"]];
	res=FixedPoint[thing[#]&,Join[variables,traits],maxiterations,SameTest->(RuleListDistance[#1,#2]<10^-accuracygoal&)];
	If[monitor,NotebookClose[nb]];
	If[$findecoevocyclethingcount==maxiterations,Msg[FindEcoEvoCycle::cvmit,maxiterations]];
	If[evoeq==True,
		Return[VarSort[Join[ExtractTraits[res],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]],	
		Return[VarSort[Join[sol,fixed],Join[AllVariables,AllTraits]]]
	]
,
	Else,
	Msg[FindEcoEvoCycle::badmtd];Return[$Failed]
];

]]/;modelperiod=!=0;


Options[FindEcoEvoCycle]={
	Method->"FindRoot",FitnessGradient->Automatic,EvoEq->False,
	BoundaryDetection->False,TraitShiftRate->{},
	FindRootOpts->{},Fixed->{},EcoSimOpts->{},EcoEvoSimOpts->{},NDInvOpts->{},
	Chop->True,MaxIterations->100,AccuracyGoal->6,
	PrintTrace->False,Monitor->False,
	Verbose->False,VerboseAll->False};


FindEcoEvoCycle[traitsandvariables_?TraitsAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
FindEcoEvoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],Gs,opts];
FindEcoCycleEvoEq[stuff___]:=FindEcoEvoCycle[stuff,EvoEq->True];


EvoEq[traits:(_?TraitsQ):{},sol:(_?VariablesQ):{},Gs_List:{},opts___?OptionQ] :=
 
Module[{
func=FuncStyle["EvoEq"],
(* options *)
verbose,verboseall,method,fixed,delaydinv,solveopts,nsolveopts,findrootopts,findinstanceopts,boundarydetection,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,tounks,fromunks,evoeqns,eqns,unks,unksics,newunk,res},
   
Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts, Options[EvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts, Options[EvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoEq]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EvoEq]}]];
solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EvoEq]}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EvoEq]}]];
findinstanceopts=Evaluate[FindInstanceOpts/.Flatten[{opts,Options[EvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EvoEq]}]];

(* figure out number of species in guilds *)
SetNsp[Join[sol,fixedvariables]];

evoeqns=EvoEqns[sol,Gs,opts];
eqns=evoeqns/.Eq/.RemoveTraitts/.RemoveVariablets;

(* set up unksics *)
unks=evoeqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]-var_[t]->var,var_[t+1]->var};
If[method=="FindRoot",
	unksics={};
	Do[
		newunk={var,var/.traits};
		If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
		AppendTo[unksics,newunk];
	,{var,unks}]
];

(* solve it *)
Which[
	method=="Solve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@solveopts},
		PrintCall[Global`res=Solve[eqns,unks,op]]]];
	res=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@nsolveopts},
		PrintCall[Global`res=NSolve[eqns,unks,op]]]];
	res=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[delaydinv,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,op]/.FromUnks]]];
		res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,Evaluate[Sequence@@findrootopts]]/.FromUnks
	,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns,unksics,op]]]];
		res=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]]
	],
	method=="FindInstance",
	If[delaydinv,
		Msg[FindEvoEq::needic];Return[$Failed]
	,
		If[verbose,
			With[{eqns=eqns,unks=unks,op=Sequence@findinstanceopts},
			PrintCall[Global`res=FindInstance[eqns,unks,op][[1]]]]];
		res=FindInstance[eqns,unks,Evaluate[Sequence@@findinstanceopts]][[1]]
	],
	Else, (* else *)
	Msg[EvoEq::badmtd];Return[$Failed]
];

If[MemberQ[{Solve,NSolve},Head[res]],
	Msg[EvoEq::nosol];Return[$Failed],
	Return[VarSort[EqSort[Chop[res]],AllTraits]]
];

]];


SolveEvoEq[args___]:=EvoEq[args,Method->"Solve"];
NSolveEvoEq[args___]:=EvoEq[args,Method->"NSolve"];
FindEvoEq[sol:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=EvoEq[sol,Gs,opts,Method->"FindInstance"];
FindEvoEq[args___]:=EvoEq[args,Method->"FindRoot"];


Options[EvoEq]={Method->"None",
DelayDInv->False,DInvOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},FindInstanceOpts->{Reals},
BoundaryDetection->False,Fixed->{},
Verbose->False,VerboseAll->False};


EcoEvoJacobian[traitsin:(_?TraitsQ):{},variablesin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed variables *)
fixedvars,fixedtraits,fixedvariables,
(* other variables *)
traits,variables,eqns,unks,jmat},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
variables=ExpandNspInPops[variablesin];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[variables,fixedvariables]];

(* set up eqns & unks *)
eqns=Join[EcoEqns[BlankTraits,opts],EvoEqns[BlankVariables,Gs,opts]];
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};
eqns=eqns/.RHS/.RemoveTraitts/.RemoveVariablets;

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unks="];Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[verbose,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.variables/.traits]],
	Return[jmat/.variables/.traits]
];

]];


Options[EcoEvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EcoEvoJacobian[sol_?TraitsAndVariablesQ,Gs_List:{},opts___?OptionQ]:=EcoEvoJacobian[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];
EcoEvoJacobian[___]:=Msg[EcoEvoJacobian::noper]/;modelperiod=!=0;


EcoEvoEigenvalues[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoEigenvalues]}],Options[EcoEvoJacobian]];

	res=Eigenvalues[EcoEvoJacobian[traits,variables,Gs,eejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoEigenvalues]={EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EcoEvoEigenvalues[sol_?TraitsAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
EcoEvoEigenvalues[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


EvoJacobian[traitsin:(_?TraitsQ):{},variablesin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed vars *)
fixedvars,fixedtraits,fixedvariables,
(* other variables *)
traits,variables,eqns,unks,jmat},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=ExpandNspInTraits[traitsin];
variables=ExpandNspInPops[variablesin];

(* figure out number of species in guilds *)
SetNsp[Join[traits,fixedtraits],Join[variables,fixedvariables]];

(* set up eqns & unks *)
eqns=EvoEqns[BlankVariables,Gs,opts];
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};
eqns=eqns/.RHS/.RemoveTraitts/.RemoveVariablets;

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unks="];Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[Global`debug,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.variables/.traits]],
	Return[jmat/.variables/.traits]
];

]];


EvoJacobian[sol_?TraitsAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=EvoJacobian[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];
EvoJacobian[___]:=Msg[EvoJacobian::noper]/;modelperiod=!=0;


Options[EvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoEigenvalues[traits:(_?TraitsQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,ejopts,res},

	If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];

	chop=Evaluate[Chop/.Flatten[{opts,Options[EvoEigenvalues]}]];
	ejopts=FilterRules[Flatten[{opts,Options[EvoEigenvalues]}],Options[EvoJacobian]];

	res=Eigenvalues[EvoJacobian[traits,variables,Gs,ejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


EvoEigenvalues[sol_?TraitsAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=EvoEigenvalues[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


Options[EvoEigenvalues]={EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


MaximizeInv[traits:(_?TraitsQ):{},sol:(_?VariablesQ):{},opts:OptionsPattern[]]:=
 
Module[{
func=FuncStyle["MaximizeInv"],
(* options *)
verbose,verboseall,guild,delayinv,invopts,maximizeopts,method,constraints,
(* other variables *)
vars,unks,inv,res},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* reset $invcount *)
$invcount=0;

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
delayinv=OptionValue[DelayInv];
invopts=OptionValue[InvOpts];
maximizeopts=OptionValue[MaximizeOpts];
method=OptionValue[Method];
constraints=OptionValue[Constraints];

vars=Table[Subscript[gtrait,0],{gtrait,gtraits[guild]}];
unks=Table[Unk[Subscript[gtrait,0]],{gtrait,gtraits[guild]}];


Which[
	constraints==="None",
	constraints={};
,
	constraints===Automatic,
	constraints=Table[Min[range[gtrait]]<=Subscript[gtrait,0]<=Max[range[gtrait]],{gtrait,gtraits[guild]}]
,
	Else,
	constraints=Table[Min[range[gtrait]]<=Subscript[gtrait,0]<=Max[range[gtrait]],{gtrait,gtraits[guild]}]
];

(*Print["constraints=",constraints];*)

If[delayinv==True,
	inv[varz_?NumericListQ]:=Inv[traits,sol,Thread[vars->varz],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	res=NMaximize[Prepend[constraints/.ToUnks,inv[unks]],unks,Evaluate[Sequence@@maximizeopts]];
	, (* else *)
	Off[NIntegrate::inumr];
	inv=Inv[traits,sol,Guild->guild,Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	If[Global`debug,Print[func,": inv=",inv]];
	Which[
		method=="Maximize",
		res=Maximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]],
		method=="NMaximize",
		res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]],
		Else,
		Msg[MaximizeInv::badmtd];
		Return[$Failed]
	];
	On[NIntegrate::inumr]
];

Return[res/.FromUnks];

]];


Options[MaximizeInv]={Guild->Automatic,DelayInv->False,InvOpts->{},MaximizeOpts->{},Constraints->Automatic,Method->"NMaximize",
Verbose->False,VerboseAll->False};


MaximizeInv[sol_?TraitsAndVariablesQ,opts___?OptionQ]:=MaximizeInv[ExtractTraits[sol],ExtractVariables[sol],opts];


GlobalESSQ[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["GlobalESSQs"],
(* options *)
verbose,verboseall,
maximizeinvopts,invthreshold,
(* other variables *)
inv,tmp},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

maximizeinvopts=Evaluate[MaximizeInvOpts/.Flatten[{opts,Options[GlobalESSQ]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[GlobalESSQ]}]];
verbose=Evaluate[Verbose/.Flatten[{opts,Options[GlobalESSQ]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[GlobalESSQ]}]];
If[verboseall,verbose=True];

(* find max invader rate .. if > invthreshold, then not globaless *)

Do[
	tmp[gu]=MaximizeInv[traits,sol,Guild->gu,maximizeinvopts];
	If[verbose,Print[func,": MaximizeInv guild ",gu,"=",tmp[gu]]];
,{gu,guilds}];

Return[{
	Table[If[tmp[gu][[1]]>invthreshold,False,True],{gu,guilds}],
	Table[{tmp[gu][[1]],Table[gtrait->(Subscript[gtrait,0]/.tmp[gu][[2]]),{gtrait,gtraits[gu]}]},{gu,guilds}]}
];

]];


Options[GlobalESSQ]={MaximizeInvOpts->{},InvThreshold->$roundofftolerance,Verbose->False,VerboseAll->False};


GlobalESSQ[eesol_?TraitsAndVariablesQ,opts___?OptionQ]:=GlobalESSQ[ExtractTraits[eesol],ExtractVariables[eesol],opts];


TrackEcoEq[pops:(_?VariablesQ),{trait_,traitmin_?NumericQ,traitmax_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["TrackEcoEq"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,method,
(* other variables *)
nb,res,
fixedvars},

Block[{Nsp},

If[modelloaded!=True,Msg[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[TrackEcoEq]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[TrackEcoEq]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[TrackEcoEq]}]];

Return[res]

]];


(* Protect all package symbols *)
With[{syms = Names["EcoEvo`*"]},
  SetAttributes[syms,Protected]
];
Unprotect[Unk,t,LookUp,$findecocyclesteps,$invcount,$findecocycleevoeqthingcount];


End[];
EndPackage[];
