(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* hack to address <https://mathematica.stackexchange.com/questions/167143/setdelayedwrsym-on-first-use-of-formalx> *)
Plot[0,{x,0,1}];
ContourPlot[0,{x,0,1},{y,0,1}];


BeginPackage["EcoEvo`"];


Unprotect@@Names["EcoEvo`*"];
ClearAll@@Names["EcoEvo`*"];


EcoEvoGeneral::nomodel=
"No model loaded. Use SetModel first.";

$EcoEvoVersion::usage=
"$EcoEvoVersion gives the version of the loaded EcoEvo package.";


$InvCount;$FindEcoCycleSteps;$FindEcoEvoCycleSteps;


\[IGrave]::usage="\[IGrave] is a placeholder index in RuleList.";
Var::usage="Var indicates Variance in output of TemporalVariance and TraitVariance.";
Cov::usage="Cov indicates Covariance in output of TemporalCovariance and TraitCovariance.";


RuleListSet;InequalityToInterval;
SymmetrizeMatrix;
NMin;NMax;
Reinterpolation;MakeInterpolatingFunctionPeriodic;
SimplifyLogE;SortRuleList;OrderedComplement;RuleListComplement;EqSort;
RHS;LHS;ReplaceRHS;ReplaceLHS;Eq;ZeroLHS;
ZeroVector;
SubscriptAdd;DeleteSubscripts;ZeroSubscripts;
HighlightChanges;
ExtractColors;AxisFlip;
FuncStyle;PrintCall;
MakeRuleList;ArrayToRuleList;
RuleListQ;RuleListListQ;NumericRuleListQ;TemporalRuleListQ;
RuleListDistance;RuleListTweak;RuleListAdd;RuleListSubtract;RuleListMultiply;NumericRuleListToNumericList;RuleListInterpolation;
ClearCache;
InterpolatingFunctionFunctionQ;TemporalDataFunctionQ;
TemporalMean;TemporalVariance;TemporalCovariance;
ExtractPlotPoints;GetPlotRange;
Else;SpFrac;ModPart;
FindMaxima;FindMinima;FindExtrema;
MaximumValues;MinimumValues;ExtremumValues;
FindPeriod;
NumberedGridForm;MyStreamPlot;RealSimplify;TD;CompoundAnd;CompoundOr;
NumericListQ;NumericFlattenedListQ;
InterpolatingFunctionTake;Slice;InitialSlice;FinalSlice;FinalDerivatives;InitialTime;FinalTime;
SortedEigensystem;ListMultiplier;RunFile;RouthHurwitzCriteria;
JoinFirst;
PlotDynamics;PlotInterpolatingFunction;MyListLinePlot3D;RuleListPlot;
TrackRoot;
PartsAboveDiagonal;PrintMessage;
GrayScale;
DoubleDotProduct;


Set\[ScriptCapitalN];


EcoEvoDocs;
ExtractInteractions;ExtractTraits;ExtractAttributes;
ExtractPops;ExtractAuxs;ExtractGuilds;ExtractVariables;ExtractSpecies;ExtractVarCovs;
TraitsQ;InteractionsQ;AttributesQ;VariablesQ;ListOfVariablesQ;AttributesAndVariablesQ;AttributesVariablesAndGsQ;AttributesAndGsQ;
InvaderQ;NotInvaderTraitsQ;GsQ;
DeleteInvaders;SelectValid;
SplitSpecies;


SetModel;UnsetModel;ModelInfo;
ClearParameters;ParameterValues;
MatrixToPopComponents;MatrixToGuildComponents;
WeightedAbundance;TotalAbundance;
TraitMean;TraitVariance;TraitDistance;FunctionalDistinctiveness;
ExtantSpecies;ExtinctSpecies;
MakeGMatrix;


LookUp::usage =
"LookUp[\!\(\*
StyleBox[\"var\", \"TI\"]\)] finds the indices of a variable or trait.";

t::usage="Reserved for time.";
log::usage="Indicates a log-transformed variable.";

ModelType::usage="Type of model (\"ContinuousTime\" or \"DiscreteTime\").";
ModelName::usage="Model name.";
ModelPeriod::usage="Model period (0=unforced, \[Infinity]=aperiodic)."

Component::usage="Defines a Component of a Pop or Guild in SetModel.";
Equation::usage="Defines the equation of a Pop or Guild Component in SetModel.";
Aux::usage="Defines an Aux variable in SetModel.";
Pop::usage="Defines a Pop in SetModel.";
Guild::usage="Defines a Guild in SetModel. Also an option for various EcoEvo functions.";
Trait::usage="Defines a trait in SetModel.";
Interaction::usage="Defines an interaction in SetModel.";
Type::usage="Defines a Component type in SetModel.";
Guilds::usage="Guilds are used in defining Interactions in SetModel.";
Components::usage="";
Traits::usage="";
Transitions::usage="";
Parameters::usage="";

\[ScriptCapitalN]::usage="\!\(\*SubscriptBox[\(\[ScriptCapitalN]\), 
StyleBox[\"gu\", \"TI\"]]\) is a reserved symbol that denotes the number of species in guild \!\(\*
StyleBox[\"gu\", \"TI\"]\).  Do not set directly.";
\[FormalCapitalN]::usage="\[FormalCapitalN] is used for a placeholder for \[ScriptCapitalN].";

Color::usage="Color gives the color for a model part.";
Colors::usage="Colors is a list of default colors for model parts.";

LineStyle::usage="LineStyle gives the line style for a model part.";
LineStyles::usage="LineStyles is a list of default line styles for model parts.";

PlotMarker::usage="PlotMarker gives the plot marker for a model part.";

Unk::usage="An internal header for unknown variables.";


EcoEqns;EcoSim;
EcoEq;SolveEcoEq;NSolveEcoEq;FindEcoEq;FindEcoCycle;
EcoJacobian;EcoEigenvalues;EcoStableQ;SelectEcoStable;FindEcoAttractor;
PlotEcoIsoclines;PlotEcoStreams;PlotEcoPhasePlane;
PrestonPlot;WhittakerPlot;PlotGuild;PlotGuild;
ImpactVector;PlotImpactVector;


InvSPS;Inv;StablePopulationStructure;ReproductiveValues;
DInv;NDInv;NumDInv;
MaximizeInv;GlobalESSQ;LocalESSQ;
PlotInv;PlotZIP;PlotZNGI;PlotPIP;PlotMIP;


TraitEqns;VarEqns;
PlotEvoIsoclines;PlotEvoStreams;PlotEvoPhasePlane;
EcoEvoSim;
FindEcoEvoEq;FindEcoEvoCycle;FindEcoCycleEvoEq;
TrackEcoEvoEq;
EvoEq;SolveEvoEq;NSolveEvoEq;FindEvoEq;
EcoEvoJacobian;EcoEvoEigenvalues;EvoJacobian;EvoEigenvalues;
EcoEvoVarSim;FindEcoEvoVarEq;EcoEvoVarJacobian;EcoEvoVarEigenvalues;


AbsoluteStepSize::usage = "AbsoluteStepSize is an option for NDInv that sets the absolute step size.";
Averaged::usage = "Averaged is an option for Inv that averages growth if True, gives instantaneous growth if False.";
TemporalMeanOpts::usage = "TemporalMeanOpts is an option for TemporalVariance and TemporalCovariance that passes options to TemporalMean.";
Bandwidth::usage = "Bandwidth is an option for PrestonPlot that sets the bandwidth in SmoothKernelDistribution.";
Base::usage = "Base is an option for PrestonPlot that sets the logarithm base.";
BasePeriod::usage = "BasePeriod is an option for FindPeriod that gives the period to look at multiples of.";
BoundaryDetection::usage = "BoundaryDetection is an option for various EcoEvo functions to enforce variable/trait bounds.";
Constraints::usage = "Constraints is an option for various EcoEvo functions that add extra constraints.";
DelayDInv::usage = "DelayDInv is an option for various EcoEvo functions that delays the evaluation of DInv.";
DelayDInv2::usage = "DelayDInv2 is an option for PlotEvoIsoclines whether to delay evaluation of DInv in ESS-test.";
DelayInv::usage = "DelayInv is an option for various EcoEvo functions that delays the evaluation of Inv.";
DInv2Opts::usage = "DInvOpts is an option for PlotEvoIsoclines that passed options to DInv in ESS-test.";
DInvOpts::usage = "DInvOpts is an option for various EcoEvo functions that passes options to DInv.";
dTMaxPower::usage = "dTMaxPower is an option for FindEcoCycle that sets the stepsize base-10 power of tmax.";
EcoAttractorNumber::usage = "EcoAttractorNumber specifies which EcoAttractor to choose in the case of multiple attractors.";
EcoEigenvaluesOpts::usage = "EcoEigenvaluesOpts is an option for various EcoEvo functions that passes options to EcoEigenvalues.";
EcoEvoSimOpts::usage = "EcoEvoSimOpts is an option for various EcoEvo functions that passes options to EcoEvoSim.";
EcoSimOpts::usage = "EcoSimOpts is an option for various EcoEvo functions that passes options to EcoSim.";
EigensystemOpts::usage = "EigenvaluesOpts is an option for various EcoEvo functions that passes options to Eigenvalues.";
EigenvaluesOpts::usage = "EigenvaluesOpts passes options to Eigenvalues.";
EqStop::usage = "EqStop is an option for various EcoEvo simulation functions that stops upon reaching an equilibrium.";
EqThreshold::usage = "EqThreshold is an option for various EcoEvo simulation functions that sets the sensitivity for EqStop.";
EqTolerance::usage = "EqTolerance is an option for FindEcoAttractor that sets the minimum distance to consider two equilibria distinct.";
ESColor::usage = "ESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";
ESTest::usage = "ESTest is an option for PlotEvoIsoclines that colors isoclines according to (local) evolutionary stability.";
EvoEquation::usage = "EvoEquation is an option for EcoEvoSim that sets whether to use the breeders' equation (\"QG\" -- default) or the canonical equation (\"CE\").";
ExcludeDiagonal::usage = "ExcludeDiagonal is an option for PlotEvoIsoclines that excludes the diagonal.";
ExcludeFocalSpecies::usage = "ExcludeFocalSpecies is an option for FunctionalDistinctiveness to exclude the focal species in the total abundance in the denominator.";
FinalTMax::usage = "FinalTMax is an option for FindEcoAttractor that sets the length of an aperiodic solution.";
FindEcoAttractorOpts::usage = "FindEcoAttractorOpts is an option for various EcoEvo functions that passes options to FindEcoAttractor.";
FindEcoCycleOpts::usage = "FindEcoCycleOpts is an option for various EcoEvo functions that passes options to FindEcoCycle.";
FindEcoEqOpts::usage = "FindEcoEqOpts is an option for various EcoEvo functions that passes options to FindEcoEq.";
FindEcoEvoEqOpts::usage = "FindEcoEvoEqOpts is an option for TrackEcoEvoEq that passes options to FindEcoEvoEq.";
FindInstanceOpts::usage = "FindInstanceOpts in an option for various EcoEvo functions that passes options to FindInstance.";
FindRootOpts::usage = "FindRootOpts is an option for various EcoEvo functions that passes options to FindRoot.";
FitnessGradient::usage = "FitnessGradient is an option for various EcoEvo functions that chooses which method to use to calculate fitness gradients.";
Fixed::usage = "Fixed is an option for various EcoEvo functions that find equilibria, that fixes the values of certain species/traits.";
FreezeTraits::usage = "FreezeTraits is an option for EcoEvoSim that freezes traits at their initial conditions.";
FromInv::usage = "FromInv is an option for InvSPS when called from Inv.";
G::usage = "G is an option to set genetic variance/covariance matrix in various EcoEvo functions.";
GlobalESSQOpts::usage = "GlobalESSQOpts is an option for TrackEcoEvoEq that passes options to GlobalESSQ.";
Gradients::usage = "Gradients is an option for SetModel that provides a list of base Colorradients for guilds.";
Guild::usage = "Guild is an option for various EcoEvo functions that sets which guild to use.";
HistogramOpacity::usage = "HistogramOpacity is an option for PlotDynamics that sets the opacity in a marginal Histogram.";
HistogramOpts::usage = "HistogramOpts is an option for various EcoEvo functions that passes options to Histogram.";
HistogramPoints::usage = "HistogramPoints is an option for PlotDynamics that sets the number of points to use in making a marginal Histogram.";
HistogramPosition::usage = "HistogramPosition is an option for PlotDynamics that controls the position of a marginal Histogram.";
HistogramScale::usage = "HistogramScale is an option for PlotDynamics that controls the scale of a marginal Histogram.";
ICs::usage = "ICs is an option for PlotPIP and PlotMIP that supplies initial guesses for FindEcoAttractor.";
IndeterminateMarker::usage = "IndeterminateMarker is an option for RuleListPlot that defines the marker style for indeterminate equilibria.";
IntegrateOpts::usage = "IntegrateOpts is an option for various EcoEvo functions that passes options to Integrate.";
InterpolationOpts::usage = "InterpolationOpts is an option for various EcoEvo functions that passes options to Interpolation.";
InvOpts::usage = "InvOpts is an option for various EcoEvo functions that passes options to Inv.";
InvStyle::usage = "InvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for successful invasion.";
InvThreshold::usage = "InvThreshold is an option for PlotMIP that sets the threshold for successful invasion.";
IsoclineStyle::usage = "IsoclineStyle is an option for PlotEcoIsoclines and PlotEvoIsoclines that defines the style for isoclines.";
Logged::usage = "Logged is an option for EcoSim that logs population variables.";
MarkerStyle::usage = "MarkerStyle is an option for PrestonPlot that styles species markers.";
MaximizeInvOpts::usage = "MaximizeInvOpts is an option for GlobalESSQ that passes options to MaximizeInv.";
MaximizeOpts::usage = "MaximizeOpts is an option for various EcoEvo functions that passes options to Maximize.";
MaxBend::usage = "MaxBend is an option for TrackEcoEvoEq that sets the minimum angle to trigger refinement.";
MaxChange::usage = "MaxChange is an option for TrackEcoEvoEq that sets the minimum change to trigger refinement.";
MaxPeriod::usage = "MaxPeriod is an option for FindEcoAttactor that sets the largest discrete-time period to look for a cycle.";
MaxPeriodMultiplier::usage = "MaxPeriodMultiplier is an option for FindEcoAttractor that sets how many multiples of the Period to try.";
MinDistance::usage = "MinDistance is an option for TrackEcoEvoEq that sets the threshold for calling two species converged.";
MinPop::usage = "MinPop is an option for various EcoEvo functions that defines a minimum population size.";
MinStepSize::usage = "MinStepSize is an option for various EcoEvo functions that specifies the minimum size of a single step used in generating a result.";
Multipliers::usage = "Multipliers is an option for EcoEigenvalues that chooses Floquet multipliers (True) or exponents (False).";
NDInvOpts::usage = "NDInvOpts is an option for various EcoEvo functions that passes options to NDInv.";
NDOpts::usage = "NDOpts is an option for various EcoEvo functions that passes options to ND.";
NDSolveOpts::usage = "NDSolveOpts is an option for various EcoEvo functions that passes options to NDSolve.";
NIntegrateOpts::usage = "NIntegrateOpts is an option for various EcoEvo functions that passes options to NIntegrate.";
NInvOpts::usage = "NInvOpts is an option for various EcoEvo functions that passes options to NInv.";
NMaximizeOpts::usage = "NMaximizeOpts is an option for GlobalESSQ that passes options to NMaximize.";
NonESColor::usage = "NonESColor is an option for PlotEvoIsoclines that sets the color of non-ES contours if ESTest\[Rule]True.";
NonFixedVars::usage = "NonFixedVars is an option for EcoEqns that lists variables that need equations.";
NonInvStyle::usage = "NonInvStyle is an option for PlotMIP (PlotType->MIP) that defines the style for unsuccessful invasion.";
NormalizeDistance::usage = "NormalizeDistance is an option for FunctionalDistinctiveness whether to normalize distances to one.";
NSolveEcoEqOpts::usage = "NSolveEcoEqOpts is an option for various EcoEvo functions that passes options to NSolveEcoEq.";
NSolveOpts::usage = "NSolveOpts is an option for various EcoEvo functions that passes options to NSolve.";
\[ScriptCapitalN]s::usage = "\[ScriptCapitalN]s is an option for TraitEqns that sets the number of species in each Guild.";
NumTries::usage = "NumTries is an option for FindEcoAttractor's method \"FindRoot\" that says how many initial guesses to try.";
Output::usage = "Output is an option for various EcoEvo functions that determines the type of output.";
OutputTMin::usage = "OutputTMin is an option for EcoSim and EcoEvoSim that that sets the length of the results (default=0).";
PerCapita::usage = "PerCapita is an option for various EcoEvo functions that divides by population size.";
Period::usage = "Period is an option for EcoEvoModel that defines its period.";
PlotEcoIsoclinesOpts::usage = "PlotEcoIsoclinesOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoIsoclines.";
PlotEcoStreamsOpts::usage = "PlotEcoStreamsOpts is an option for PlotEcoPhasePlane that passes options to PlotEcoStreams.";
PlotEvoIsoclinesOpts::usage = "";
PlotEvoStreamsOpts::usage = "PlotEvoStreamsOpts is an option for PlotEvoPhasePlane that passes options to PlotEvoStreams.";
PlotMIPOpts::usage = "PlotMIPOpts is an option for PlotEvoPhasePlane that passes options to PlotMIP.";
PlotOpts::usage = "PlotOpts is an option for various EcoEvo functions that passes options to plotting functions.";
PlotGuildOpts::usage = "PlotGuildOpts is an option for PlotInv that passes options to PlotGuild.";
PlotType::usage = "PlotType is an option for PlotPIP that chooses plot type (ZeroContourPlot [default], ContourPlot, Plot3D).";
PlotZIPOpts::usage = "PlotZIPOpts is an option for PlotEvoPhasePlane that passes options to PlotZIP.";
PointStyle::usage = "PointStyle is an option for PlotInv that determines the style of points for species.";
Pop::usage = "Pop is an option for various EcoEvo functions that sets which population to use.";
PrintTrace::usage = "PrintTrace is an option for various EcoEvo functions to leave a trace of iterations.";
QSS::usage = "QSS is an option for *EcoEq that indicates that nonspecified variables should be treated as unknowns.";
QSSICs::usage = "QSSICs is an option for Inv that sets initial conditions for solving for qualitative structure of the invader.";
QSSMethod::usage = "QSSMethod is an option for Inv that selects how to solve for qualitative structure of the invader.";
RelativeStepSize::usage = "RelativeStepSize is an option for NDInv that sets the relative step size.";
RuleListDistanceOpts::usage = "RuleListDistanceOpts is an option for various EcoEvo functions that passes options to RuleListDistance.";
RV::usage = "RV is an option for InvSPS when called from ReproductiveValues.";
SameThreshold::usage = "SameThreshold is an option for various EcoEvo functions that is the threshold to consider two numbers the same.";
ShowSpecies::usage = "ShowSpecies is an option for various EcoEvo functions that specifies how to show species markers.";
SimplifyOpts::usage = "SimplifyOpts is an option for various EcoEvo functions that passes options to Simplify.";
SimplifyResult::usage = "SimplifyResult is an option for various EcoEvo functions that applies Simplify before returning results.";
Slope::usage = "Slope is an option for NMin and NMax that sets the steepness of the approximation.";
SMax::usage = "SMax is an option for TrackRoot that sets the maximum value of the pseudo-arclength.";
SMin::usage = "SMin is an option for TrackRoot that sets the minumum value of the pseudo-arclength.";
SolveEcoEqOpts::usage = "SolveEcoEqOpts is an option for various EcoEvo functions that passes options to SolveEcoEq.";
SolveOpts::usage = "SolveOpts is an option for various EcoEvo functions that passes options to Solve.";
Species::usage = "Species is an option for various EcoEvo functions that sets which species to use.";
SpeciesColors::usage = "SpeciesColors is an option for PlotMIP (PlotType->Outcome) that defines colors for each species.";
StableMarker::usage = "StableMarker is an option for RuleListPlot that defines the marker style for stable equilibria.";
SubtractDiagonal::usage = "SubtractDiagonal is an option for PlotPIP that subtracts the diagonal from all invasion rates.";
Switches::usage = "Switches is an option for EcoSimSSD that says when external mode switches occur.";
TADVerticalScale::usage = "TADVerticalScale is an option for PlotInv that sets the vertical extent of the TAD. Should be between zero and one.";
TestStability::usage = "TestStability is an option for FindEcoAttractor that determines whether to test for stable equilibria.";
TestValidity::usage = "TestValidity is an option for FindEcoAttractor that determines whether to test for valid equilibria.";
Tests::usage = "Tests is an option for TrackEcoEvoEq that gives which bifurcations/errors to look for.";
Time::usage = "Time is an option for various EcoEvo functions that specifies when to evaluation the model.";
TimeScale::usage = "TimeScale is an option for EcoSim that sets the overall timescale (default=1).";
TMax::usage = "TMax is an option for FindEcoAttractor that sets the maximum time for EcoSim.";
TMax2::usage = "TMax2 is an option for FindEcoAttractor that sets the maximum time for EcoSim.";
TMaxPowerMax::usage = "TMaxPowerMax is an option for FindEcoCycle that sets the maximum base-10 power of tmax to try.";
TMaxPowerMin::usage = "TMaxPowerMin is an option for FindEcoCycle that sets the minimum base-10 power of tmax to try.";
TMin::usage = "TMin specifies the starting time for EcoSim and EcoEvoSim.";
TraitDistanceOpts::usage = "TraitDistanceOpts is an option for various EcoEvo functions that passes options to TraitDistance.";
TraitRange::usage = "TraitRange is an option for PlotGuild that sets the range of the y-axis.";
TraitShiftRate::usage = "TraitShiftRate is an option for various evolutionary EcoEvo functions that changes into a moving frame of reference for an constantly changing environment.";
TriggerVariable::usage = "TriggerVariable is an option for FindEcoCycle that sets which variable to focus on.";
UnstableMarker::usage = "UnstableMarker is an option for RuleListPlot that defines the marker style for unstable equilibria.";
UseSymmetry::usage = "UseSymmetry is an option for PlotEvoStreams & PlotEvoIsoclines that assumes fitness gradients are symmetric.";
V::usage = "V is an option to set genetic variance in various EcoEvo functions.";
VerboseAll::usage =  "VerboseAll is an option for various EcoEvo functions that recursively turns on Verbose reporting.";
WarmUp::usage =  "WarmUp is an option for various EcoEvo functions that numerical solves a model before refining.";
WarmUp2::usage = "WarmUp2 is an option for various EcoEvo functions that numerical solves a model before refining.";
WarmUp3::usage = "WarmUp3 is an option for various EcoEvo functions that numerical solves a model before refining.";
WeightFunction::usage = "WeightFunction is an option for PlotGuild that defines abundance in structured populations.";
WeightedAbundanceOpts::usage = "WeightedAbundanceOpts is an option for various EcoEvo functions that passes options to WeightedAbundance.";
WhenEventOpts::usage = "WhenEventOpts is an option for various EcoEvo functions that passes options to WhenEvent.";
WhenEvents::usage = "WhenEvents is an option for various EcoEvo simulation functions that adds WhenEvents to NDSolve.";
ZeroDiagonal::usage =  "ZeroDiagonal is an option for PlotPIP that forces Inv=0 along the diagonal.";


Begin["`Private`"];


$EcoEvoVersion="1.7.0X (July 5, 2021)";


modelloaded=False;


NewFunction::usage=
"NewFunction[\!\(\*
StyleBox[\"args\", \"TI\"]\)] is a new function.";


NewFunction[args_,opts___?OptionQ]:=

Module[{
func=FuncStyle["NewFunction"],
(* options *)
verbose
(* other variables *)
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[NewFunction]}]];
If[Global`debug,verbose=True];
method=Evaluate[Method/.Flatten[{opts,Options[NewFunction]}]];
plotopts=FilterRules[Flatten[{opts,Options[NewFunction]}],Options[Plot]];

Return[ret]
]];


Options[NewFunction]={
};








SetOptions[NDSolve,MaxSteps->Infinity];
(*SetOptions[NIntegrate,MaxRecursion\[Rule]30];*)


RuleListSet::usage="RuleListSet[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] assigns variables according to \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* by J.M. <https://mathematica.stackexchange.com/questions/238689/> *)
SetAttributes[RuleListSet,HoldAll];
RuleListSet[rulelist:{__Rule}]:=(Set@@@Unevaluated[rulelist];)


InequalityToInverval::usage="InequalityToInverval converts an inequality to an Interval.";


(* based on <https://mathematica.stackexchange.com/a/32473/> by Kuba *)
InequalityToInterval[ineq_]:=
Replace[
	Fold[
		ReplaceAll[#,#2]&,
		ineq//LogicalExpand,
		{i_[s_?NumericQ,f_]:>Reduce[i[s,f]],{i_[s_,f_?NumericQ]:>Which[MemberQ[{Greater,GreaterEqual},i],Interval[{f,Infinity}],MemberQ[{Less,LessEqual},i],Interval[{-Infinity,f}]]},{Or->IntervalUnion,And->IntervalIntersection}}
	],
	{var_Symbol->Interval[{-\[Infinity],\[Infinity]}]}
];


SymmetrizeMatrix::usage="";


SymmetrizeMatrix[mat_?MatrixQ]:=UpperTriangularize[mat]+Transpose[UpperTriangularize[mat,1]];


NMin::usage="NMin[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)] is a numerical approximation to Min[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)].";
NMax::usage="NMax[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)] is a numerical approximation to Max[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\)].";


NMin[x_,y_,opts___]:=Module[{slope},
	slope=Evaluate[Slope/.Flatten[{opts,Options[NMin]}]];
	(\[Pi](x+y)-2.(x-y)ArcTan[slope(x-y)])/(2\[Pi])
];


NMax[x_,y_,opts___]:=Module[{slope},
	slope=Evaluate[Slope/.Flatten[{opts,Options[NMax]}]];
	(\[Pi](x+y)+2.(y-x)ArcTan[slope(y-x)])/(2\[Pi])
];


NMin[list_List,opts___]:=If[Length[list]==2,NMin[list[[1]],list[[2]],opts],Message[NMin::nottwo]];
NMax[list_List,opts___]:=If[Length[list]==2,NMax[list[[1]],list[[2]],opts],Message[NMax::nottwo]];


Options[NMin]={Slope->10000};
Options[NMax]={Slope->10000};


NMin::nottwo="NMin only works on lists of two values.";
NMax::nottwo="NMax only works on lists of two values.";


Reinterpolation::usage="Reinterpolation[\!\(\*
StyleBox[\"f\", \"TI\"]\)] reinterpolates a function containing one or more InterpolatingFunctions.";


Reinterpolation[f_,opts___?OptionQ]:=Module[{
(* options *)
interpolationopts,interpolationpoints,
(* other variables *)
xmin,xmax,ifs,grid,tmp},
	
(* handle options *)
interpolationopts=FilterRules[Flatten[{opts,Options[Reinterpolation]}],Options[Interpolation]];
interpolationpoints=Evaluate[InterpolationPoints/.Flatten[{opts,Options[Reinterpolation]}]];

ifs=Cases[f,_InterpolatingFunction,{0,\[Infinity]}];
If[ifs=={},Return[f]];

If[interpolationpoints===Automatic,
	grid=Union[Flatten[Through[ifs["Grid"]],1]],
(* using ifs\[LeftDoubleBracket]1,1\[RightDoubleBracket] because ifs\[LeftDoubleBracket]1\[RightDoubleBracket]["Domain"] fails sometimes?! - see "wtf domain.nb" *)
	(*grid=Flatten[Subdivide[Sequence@@#,interpolationpoints]&/@ifs\[LeftDoubleBracket]1,1\[RightDoubleBracket]]*)
	{xmin,xmax}=ifs[[1,1,1]];
	grid=Table[x,{x,xmin,xmax,(xmax-xmin)/(interpolationpoints-1)}];
];
(*Print["grid=",grid];*)

Quiet[
	tmp=Interpolation[Table[{Sequence@@val,f/.(if_InterpolatingFunction->if[Sequence@@val])},{val,grid}],Evaluate[Sequence@@interpolationopts]],
	{InterpolatingFunction::dmval}];

tmp[[1]]=ifs[[1,1]]; (* fix domain *)

Return[tmp]
];


Options[Reinterpolation]={InterpolationPoints->Automatic};


MakeInterpolatingFunctionPeriodic::usage="MakeInterpolatingFunctionPeriodic[\!\(\*
StyleBox[\"if\", \"TI\"]\)] makes InterpolatingFunction \!\(\*
StyleBox[\"if\", \"TI\"]\) periodic.";


MakeInterpolatingFunctionPeriodic[if_InterpolatingFunction]:=Module[{
	dorder=if[[2,3]],
	ngrid=if[[2,4]]},
	Which[
		if[[4,1]]===Developer`PackedArrayForm,
		ReplacePart[if,{
			{2,7}->{1}, (* set periodic flag *)
			{2,4}->ngrid-1 ,(* decrease ngrid by 1 *)
			{4,2}->Drop[if[[4,2]],-1], (* remove last abscissa *)
			{4,3}->Drop[if[[4,3]],-dorder-1] (* remove last dorder+1 values *)
		}]
	,
		ListQ[if[[4,1]]],
		ReplacePart[if,{
			{2,7}->{1}, (* set periodic flag *)
			{2,4}->ngrid-1, (* decrease ngrid by 1 *)
			{4}->Drop[if[[4]],-1] (* remove last point *)
		}]
	]
];


(*(* modified from <https://mathematica.stackexchange.com/a/235451/6358> by MichaelE2 *)
MakeInterpolatingFunctionPeriodic[if_InterpolatingFunction]:=Module[{periodify},
	periodify[list_List]:=Append[list,First@list];
	Interpolation[
		Transpose@{if["Grid"],
		periodify@Most@if["ValuesOnGrid"],
		periodify@Most@Derivative[1][if]["ValuesOnGrid"],
		periodify@Most@Derivative[2][if]["ValuesOnGrid"]},
		PeriodicInterpolation\[Rule]True]
];*)


SimplifyLogE::usage=
"SimplifyLogE is a replacement rule that simplifies Log[\!\(\*
StyleBox[\"a\", \"TI\"]\) \!\(\*SuperscriptBox[\(E\), 
StyleBox[\"x\", \"TI\"]]\)] to Log[\!\(\*
StyleBox[\"a\", \"TI\"]\)]+\!\(\*
StyleBox[\"x\", \"TI\"]\).";


SimplifyLogE=Log[(a_:1) E^x_]:>x+Log[a];


SortRuleList::usage=
"SortRuleList[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] sorts \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) in order of \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


SortRuleList[eq_?RuleListQ,vars_List]:=SortBy[eq,Position[vars,#[[1]]]&];


(* make Listable *)
SortRuleList[eqs_?RuleListListQ,vars_List]:=SortRuleList[#,vars]&/@eqs;


OrderedComplement::usage=
"OrderedComplement[\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"all\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)] gives the elements in \!\(\*
StyleBox[SubscriptBox[\"e\", \"all\"], \"TI\"]\) that are not in any of the \!\(\*
StyleBox[SubscriptBox[\"e\", \"i\"], \"TI\"]\), without sorting the result.";


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/30434/6358> *)
OrderedComplement[all_List, i__List]:=DeleteDuplicates[Join@##]~Drop~Length[#]&[Union@i,DeleteDuplicates@all];


RuleListComplement::usage=
"RuleListComplement[\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"all\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"e\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)] gives the elements in \!\(\*
StyleBox[SubscriptBox[\"e\", \"all\"], \"TI\"]\) whose variables don't match any of the \!\(\*
StyleBox[SubscriptBox[\"e\", \"i\"], \"TI\"]\).";


RuleListComplement[all_?RuleListQ,i__?RuleListQ]:=Complement[all,i,SameTest->(First[#1]===First[#2]&)];


EqSort::usage=
"EqSort[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] sorts \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) in order of increasing number of non-zero entries.";


(*EqSort[x_?RuleListListQ]:=SortBy[x,Reverse[Map[If[Abs[#]<$MachineEpsilon,0,1]&,#\[LeftDoubleBracket]All,2\[RightDoubleBracket]]]&];*)
EqSort[x_?RuleListListQ]:=Module[{ind},ind[y_]:=Reverse[Map[If[Abs[#[[2]]]<$MachineEpsilon,0,1,1]&,y]];SortBy[x,{Total[ind[#]]&,ind[#]&}]];


EqSort[x_?RuleListQ]:=x;


RHS::usage=
"RHS is a replacement rule that returns the right-hand side of equations.";

LHS::usage=
"LHS is a replacement rule that returns the left-hand side of equations.";


RHS=(_==rhs_->rhs);
LHS=(lhs_==_->lhs);


ReplaceRHS::usage="
ReplaceRHS[\!\(\*
StyleBox[\"eqn\", \"TI\"]\), \!\(\*
StyleBox[\"rule\", \"TI\"]\)] applies replacement rule \!\(\*
StyleBox[\"rule\", \"TI\"]\) to the right-hand side of \!\(\*
StyleBox[\"eqn\", \"TI\"]\).";

ReplaceLHS::usage="
ReplaceLHS[\!\(\*
StyleBox[\"eqn\", \"TI\"]\), \!\(\*
StyleBox[\"rule\", \"TI\"]\)] applies replacement rule \!\(\*
StyleBox[\"rule\", \"TI\"]\) to the left-hand side of \!\(\*
StyleBox[\"eqn\", \"TI\"]\).";


ReplaceRHS[eqn_,rules_]:=eqn//.(relop_[lhs_,rhs_]:>relop[lhs,rhs/.Flatten@rules]);
ReplaceLHS[eqn_,rules_]:=eqn//.(relop_[lhs_,rhs_]:>relop[lhs/.Flatten@rules,rhs]);

(* make Listable over eqns *)
ReplaceRHS[eqns_List,rules_]:=ReplaceRHS[#,rules]&/@eqns;
ReplaceLHS[eqns_List,rules_]:=ReplaceLHS[#,rules]&/@eqns;


Eq::usage=
"Eq is a replacement rule that sets time derivatives to zero and next timesteps equal to current timesteps.";


Eq={var_[t+1]->var[t],var_'[t]->0};


ZeroLHS::usage=
"ZeroLHS is a replacement rule that sets the left hand side of equations equal to zero.";


ZeroLHS=(lhs_==rhs_->0==rhs);


ZeroVector::usage="ZeroVector[\!\(\*
StyleBox[\"d\", \"TI\"]\)] returns a \!\(\*
StyleBox[\"d\", \"TI\"]\)-dimensional zero vector.";


ZeroVector[dim_Integer]:=Table[0,{i,dim}];


SubscriptAdd::usage=
"SubscriptAdd[\!\(\*
StyleBox[\"expr\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] adds \!\(\*
StyleBox[\"val\", \"TI\"]\) (default=1) to all subscripts in \!\(\*
StyleBox[\"expr\", \"TI\"]\).";


SubscriptAdd[x_Subscript,add_Integer:1]:=x/.Subscript[var_,sub_]->Subscript[var,sub+add];


DeleteSubscripts::usage=
"DeleteSubscripts[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] removes all subscripts from \!\(\*
StyleBox[\"expr\", \"TI\"]\).";


DeleteSubscripts[x_]:=x/.Subscript[var_,_]->var;


ZeroSubscripts::usage=
"ZeroSubscripts[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] sets the subscript in \!\(\*
StyleBox[\"expr\", \"TI\"]\) to zero.";


ZeroSubscripts[x_]:=x/.Subscript[var_,sub_]->Subscript[var,0];


HighlightChanges::usage=
"HighlightChanges[True] turns on change highlighting. HighlightChanges[False] turns it off.";


HighlightChanges[bool_]:=If[bool==True,
	SetOptions[EvaluationNotebook[],{
	CellProlog:>(
		SelectionMove[EvaluationCell[],All,GeneratedCell];
		$oldoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&]
	),
	CellEpilog:>(
	SelectionMove[EvaluationCell[],All,GeneratedCell];
	$newoutput=ToExpression@*First/@Select[NotebookRead[SelectedCells[]],#[[2]]=="Output"&];
	If[($oldoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"])=!=($newoutput/.x_Graphics:>ImageData@Rasterize[x,"Image"]),
	Print[Style["Output change:",Red],"\nold=",$oldoutput]];
	If[Length[$newoutput]!=0,SelectionMove[EvaluationCell[],After,CellGroup,2],SelectionMove[EvaluationCell[],After,Cell]]
	)
	}],
	SetOptions[EvaluationNotebook[],{CellProlog->{},CellEpilog->{}}]
];


ExtractColors::usage=
"ExtractColor[\!\(\*
StyleBox[\"list\", \"TI\"]\)] extracts colors from \!\(\*
StyleBox[\"list\", \"TI\"]\).";


ExtractColors[list_List]:=Select[list,ColorQ[#]||Head[#]==Opacity&]


AxisFlip::usage=
"AxisFlip exchanges axes on a Graphics object.";


(* by Mr. Wizard <https://mathematica.stackexchange.com/a/18669/6358> *)
AxisFlip=#/.{x_Line|x_GraphicsComplex:>MapAt[#~Reverse~2&,x,1],x:(PlotRange->_):>x~Reverse~2}&;


FuncStyle::usage=
"FuncStyle[\!\(\*
StyleBox[\"string\", \"TI\"]\)] formats \!\(\*
StyleBox[\"string\", \"TI\"]\) for use in debugging output.";


FuncStyle[func_]:=Style[func,Underlined];


PrintCall::usage=
"PrintCall[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] prints \!\(\*
StyleBox[\"expr\", \"TI\"]\) unevaluated.";


(* based on <https://mathematica.stackexchange.com/a/158902/6358> by Szabolcs and <https://mathematica.stackexchange.com/a/161310/6358> by Carl Woll *)
SetAttributes[PrintCall,HoldAll]
(*PrintCall[expr_]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]"Running:"]*)
(*PrintCall[expr_]:=Print[Defer[expr]];*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[Defer[expr],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=With[{expr2=Defer[expr/.Sequence[]\[Rule]Null]},
	CellPrint@ExpressionCell[Defer[expr2],CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
];*)
(*PrintCall[expr_,dingbat_:""]:=
CellPrint@ExpressionCell[Defer[expr]/.Sequence[]\[Rule]Nothing,CellMargins\[Rule]{{60,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]*)
(*PrintCall[expr_,dingbat_:""]:=CellPrint@ExpressionCell[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]],
CellBaseline\[Rule]Scaled[0.005],CellMargins\[Rule]{{66,Inherited},{Inherited,Inherited}},CellGroupingRules\[Rule]"GraphicsGrouping",CellDingbat\[Rule]dingbat]
*)
(*PrintCall[expr_]:=Print@DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]];*)
PrintCall[expr_,dingbat_:""]:=Print[DeleteCases[Unevaluated@Defer[expr],Verbatim[Sequence][],\[Infinity]]];


ColorData[1]; (* load ColorData *)

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEReds","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.083,0.4,1],Hue[0.083,0.7,1],Hue[0.083,1,1],Hue[0,1,1],Hue[0.917,1,1],Hue[0.917,1,0.7],Hue[0.917,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEReds"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGreens","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.25,0.4,1],Hue[0.25,0.7,1],Hue[0.25,1,1],Hue[0.333,1,1],Hue[0.417,1,1],Hue[0.417,1,0.7],Hue[0.417,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGreens"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBlues","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Hue[0.567,0.4,1],Hue[0.583,0.7,1],Hue[0.583,1,1],Hue[0.667,1,1],Hue[0.75,1,1],Hue[0.75,1,0.7],Hue[0.75,1,0.4]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBlues"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEBrowns","",{}},{"Gradients"},1,{0,1},
	Map[ColorConvert[#,"RGB"]&,{Lighter[Brown,0.5],Lighter[Blend[{Brown,Orange},0.5],0.5],Blend[{Brown,Orange},0.5],Darker[Blend[{Brown,Orange},0.5],0.5],Darker[Brown,0.5]}]
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEBrowns"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"EEGrays","",{}},{"Gradients"},1,{0,1},
	{LightGray,Black}
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"EEGrays"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"Black","",{}},{"Gradients"},1,{0,1},
	{Black,Black}
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"Black"];

AppendTo[DataPaclets`ColorDataDump`colorSchemes,
	{{"Gray","",{}},{"Gradients"},1,{0,1},
	{Gray,Gray}
	,""}];
AppendTo[DataPaclets`ColorDataDump`colorSchemeNames,"Gray"];

GrayScale[x_]:=GrayLevel[1-x];


ClearCache::usage=
"ClearCache[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), ...] removes memoized DownValues of \!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"g\", \"TI\"]\), etc.";


(* mostly by Simon - see <http://stackoverflow.com/questions/5086749/mathematica-how-to-clear-the-cache-for-a-symbol-i-e-unset-pattern-free-downva> *)
ClearCache[f_]:=(DownValues[f]=DeleteCases[DownValues[f],_?(FreeQ[First[#],Pattern]&)];);

(* make work on multiple arguments *)
ClearCache[f__]:=(Map[ClearCache,{f}];);


InterpolatingFunctionFunctionQ::usage=
"InterpolatingFunctionFunctionQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] is True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a InterpolatingFunction function.";


InterpolatingFunctionFunctionQ[x_]:=If[Length[Cases[x,_InterpolatingFunction,\[Infinity],Heads->True]]!=0,True,False];
(*InterpolatingFunctionFunctionQ[x_]:=If[Head[Head[x]]===InterpolatingFunction,True,False];*) (* why did I write this? <- breaks (c[t]/.sol)^2 *)


TemporalDataFunctionQ::usage=
"TemporalDataFunctionQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] is True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a TemporalData function.";


TemporalDataFunctionQ[x_]:=If[Length[Cases[x,_TemporalData,\[Infinity],Heads->True]]!=0,True,False];


TemporalMean::usage=
"TemporalMean[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the average of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=t).
TemporalMean[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] ranges from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
TemporalMean[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* thread over RuleLists *)
TemporalMean[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(x->TemporalMean[val,opts]));
TemporalMean[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["rulelist2"];*)
f/.(x_->val_):>(x->TemporalMean[val,{var,varmin,varmax},opts]));


(* thread over Lists *)
(*TemporalMean[list_List,rest___]:=TemporalMean[#,rest]&/@list;*)


(* main *)
TemporalMean[f_,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,method},
(*Print["main"];*)
	method=Evaluate[Method/.Flatten[{opts,Options[TemporalMean]}]];
	If[InterpolatingFunctionFunctionQ[f]==True,method="NIntegrate"];
	If[TemporalDataFunctionQ[f]==True,method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[TemporalMean]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalMean]}]];
	Which[
		method=="Integrate",
		Return[Integrate[f,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[f,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[f,{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Message[General::badmtd];Return[$Failed]
	];
];


(* InterpolatingFunctionFunctions *)
TemporalMean[f_?InterpolatingFunctionFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{nintegrateopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalMean]}]];
	
	ifdomains=Map[#["Domain"][[1]]&,Cases[f,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Message[TemporalMean::norange],
		numifdomains>1,
		Message[TemporalMean::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[TemporalMean[f,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


(* InterpolatingFunctions *)
TemporalMean[f_InterpolatingFunction,opts___?OptionQ]:=((*Print["IF"];*)TemporalMean[f[t],opts]);
TemporalMean[f_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)TemporalMean[f[t],{var,varmin,varmax},opts]);


(* TemporalData *)
TemporalMean[f_TemporalData,opts___?OptionQ]:=((*Print["td"];*)Mean[f]);
TemporalMean[f_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["td2"];*)
Mean[TimeSeriesWindow[f,{varmin,varmax}]]);


(* TemporalDataFunctions *)
TemporalMean[f_?TemporalDataFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{domains,numdomains,varmin,varmax},
	
	domains=Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f,_TemporalData,\[Infinity],Heads->True]];
	numdomains=Length[Union[domains]];
	
	Which[
		numdomains==0,
		Message[TemporalMean::norange],
		numdomains>1,
		Message[TemporalMean::unkrange],
		Else,
		{varmin,varmax}=domains[[1]];
		Return[TemporalMean[f,{var,varmin,varmax},opts]]
	];
];


(* fallthrough *)
TemporalMean[f_?((!RuleListQ[#]&&!InterpolatingFunctionFunctionQ[#])&),opts___?OptionQ]:=((*Print["otherwise"];*)f);


Options[TemporalMean]={Method->"Integrate",IntegrateOpts->{},NIntegrateOpts->{}};


TemporalVariance::usage=
"TemporalVariance[\!\(\*
StyleBox[\"f\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the variance of \!\(\*
StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=\!\(\*
StyleBox[\"t\", \"TI\"]\)).
TemporalVariance[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] ranges from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
TemporalVariance[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* main *)
TemporalVariance[f_,{var_,varmin_,varmax_},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg},
	method=Evaluate[Method/.Flatten[{opts,Options[TemporalVariance]}]];
	If[InterpolatingFunctionFunctionQ[f]==True,method="NIntegrate"];
	If[TemporalDataFunctionQ[f]==True,method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avg=TemporalMean[f,{var,varmin,varmax},Method->method];
	Which[
		method=="Integrate",
		Return[Integrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[(f-avg)^2,{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[(f-avg)^2,{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Message[General::badmtd];Return[$Failed];
	];
];


(* thread over RuleLists *)
TemporalVariance[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(Var[x]->TemporalVariance[val,opts]));
TemporalVariance[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=((*Print["rulelist2"];*)
f/.(x_->val_):>(Var[x]->TemporalVariance[val,{var,varmin,varmax},opts]));


(* InterpolatingFunctionFunctions *)
TemporalVariance[if_?InterpolatingFunctionFunctionQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalVariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalVariance]}]];
		
	ifdomains=Map[#["Domain"][[1]]&,Cases[if,_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Message[TemporalVariance::norange],
		numifdomains>1,
		Message[TemporalVariance::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[TemporalVariance[if,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];


(* InterpolatingFunctions *)
TemporalVariance[f_InterpolatingFunction,opts___?OptionQ]:=((*Print["raw IF"];*)TemporalVariance[f[t],opts]);
TemporalVariance[f_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)TemporalVariance[f[t],{var,varmin,varmax},opts]);


(* TemporalData *)
TemporalVariance[f_TemporalData,opts___?OptionQ]:=Module[{n},
(*Print["td"];*)
	n=(f["LastTimes"]-f["FirstTimes"])[[1]]+1;
	Variance[f]*(n-1)/n
];

TemporalVariance[f_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{n},
(*Print["td2"];*)
	n=varmax-varmin+1;
	Variance[TimeSeriesWindow[f,{varmin,varmax}]]*(n-1)/n
];


(* TemporalDataFunctions *)
TemporalVariance[f_?TemporalDataFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{domains,numdomains,varmin,varmax},
	
	domains=Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f,_TemporalData,\[Infinity],Heads->True]];
	numdomains=Length[Union[domains]];

	Which[
		numdomains==0,
		Message[TemporalVariance::norange],
		numdomains>1,
		Message[TemporalVariance::unkrange],
		Else,
		{varmin,varmax}=domains[[1]];
		Return[TemporalVariance[f,{var,varmin,varmax},opts]]
	];
];


(* fallthrough *)
TemporalVariance[f_?NumericQ,opts___?OptionQ]:=((*Print["otherwise"];*)0);


Options[TemporalVariance]={IntegrateOpts->{},NIntegrateOpts->{},TemporalMeanOpts->{},Method->"Integrate"};


TemporalCovariance::usage=
"TemporalCovariance[\!\(\*
StyleBox[\"f1\", \"TI\"]\), \!\(\*
StyleBox[\"f2\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] gives the covariance of \!\(\*
StyleBox[\"f1\", \"TI\"]\) and \!\(\*
StyleBox[\"f2\", \"TI\"]\) with respect to \!\(\*
StyleBox[\"var\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(default \!\(\*
StyleBox[\"var\", \"TI\"]\)=\!\(\*
StyleBox[\"t\", \"TI\"]\)).
TemporalCovariance[\!\(\*
StyleBox[\"f1\", \"TI\"]\), \!\(\*
StyleBox[\"f2\", \"TI\"]\), {\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"varmin\", \"TI\"]\), \!\(\*
StyleBox[\"varmax\", \"TI\"]\)}] ranges from \!\(\*
StyleBox[\"varmin\", \"TI\"]\) to \!\(\*
StyleBox[\"varmax\", \"TI\"]\).
TemporalCovariance[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) to give variances and covariances.";


(* main *)
TemporalCovariance[f1_,f2_,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{integrateopts,nintegrateopts,avgopts,method,avg1,avg2},
	method=Evaluate[Method/.Flatten[{opts,Options[TemporalCovariance]}]];
	If[(InterpolatingFunctionFunctionQ[f1]==True)||(InterpolatingFunctionFunctionQ[f2]==True),method="NIntegrate"];
	If[(TemporalDataFunctionQ[f1]==True)||(TemporalDataFunctionQ[f2]==True),method="Sum"];
	integrateopts=Evaluate[IntegrateOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	
	avg1=TemporalMean[f1,{var,varmin,varmax},Method->method];
	avg2=TemporalMean[f2,{var,varmin,varmax},Method->method];
	
	Which[
		method=="Integrate",
		Return[Integrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@integrateopts]]/(varmax-varmin)],
		method=="NIntegrate",
		Return[NIntegrate[(f1-avg1)(f2-avg2),{var,varmin,varmax},Evaluate[Sequence@@nintegrateopts]]/(varmax-varmin)],
		method=="Sum",
		Return[Sum[(f1-avg1)(f2-avg2),{var,varmin,varmax}]/(varmax-varmin+1)],
		Else,
		Message[General::badmtd];Return[$Failed];
	];
];


(* thread over rule lists *)
TemporalCovariance[f_?RuleListQ,opts___?OptionQ]:=Module[{vars,pairs},
(*Print["threading 1"];*)
	vars=Keys[f];
	pairs=Subsets[vars,{2}];
	Return[Join[
		Table[Var[var]->TemporalVariance[var/.f,opts],{var,vars}],
		Table[Cov[Evaluate@@Sequence[pair]]->TemporalCovariance[Evaluate@@Sequence[pair/.f],opts]
	,{pair,pairs}]]]
];

TemporalCovariance[f_?RuleListQ,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{vars,pairs},
(*Print["threading 2"];*)
	vars=Keys[f];
	pairs=Subsets[vars,{2}];
	Return[Join[
		Table[Var[var]->TemporalVariance[var/.f,{var,varmin,varmax},opts],{var,vars}],
		Table[Cov[Evaluate@@Sequence[pair]]->TemporalCovariance[Evaluate@@Sequence[pair/.f],{var,varmin,varmax},opts]
	,{pair,pairs}]]]
];


(* InterpolatingFunctionFunctions *)
TemporalCovariance[if1_,if2_?InterpolatingFunctionFunctionQ,var_:t,opts___?OptionQ]:=Module[{nintegrateopts,avgopts,ifdomains,numifdomains,varmin,varmax},
	nintegrateopts=Evaluate[NIntegrateOpts/.Flatten[{opts,Options[TemporalCovariance]}]];
	avgopts=Evaluate[TemporalMeanOpts/.Flatten[{opts,Options[TemporalCovariance]}]];

	ifdomains=Map[#["Domain"][[1]]&,Cases[{if1,if2},_InterpolatingFunction,\[Infinity],Heads->True]];
	numifdomains=Length[Union[ifdomains]];
	
	Which[
		numifdomains==0,
		Message[TemporalCovariance::norange],
		numifdomains>1,
		Message[TemporalCovariance::unkrange],
		Else,
		{varmin,varmax}=ifdomains[[1]];
		Return[TemporalCovariance[if1,if2,{var,varmin,varmax},Method->"NIntegrate",NIntegrateOpts->nintegrateopts]]
	];
];

TemporalCovariance[if1_?InterpolatingFunctionFunctionQ,if2_,var_:t,opts___?OptionQ]:=TemporalCovariance[if2,if1,var,opts];


(* InterpolatingFunctions *)
TemporalCovariance[f1_InterpolatingFunction,f2_InterpolatingFunction,opts___?OptionQ]:=((*Print["raw IF"];*)TemporalCovariance[f1[t],f2[t],opts]);
TemporalCovariance[f1_InterpolatingFunction,f2_InterpolatingFunction,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=
	((*Print["IF2"];*)TemporalCovariance[f1[t],f2[t],{var,varmin,varmax},opts]);


(* TemporalData *)
TemporalCovariance[f1_TemporalData,f2_TemporalData,opts___?OptionQ]:=Module[{n},
(*Print["td"];*)
	n=(f1["LastTimes"]-f1["FirstTimes"])[[1]]+1;
	Covariance[f1["Values"],f2["Values"]]*(n-1)/n
];

TemporalCovariance[f1_TemporalData,f2_TemporalData,{var_Symbol,varmin_?NumericQ,varmax_?NumericQ},opts___?OptionQ]:=Module[{n},
	n=varmax-varmin+1;
	(*Print["td2"];*)
	Covariance[TimeSeriesWindow[f1,{varmin,varmax}]["Values"],TimeSeriesWindow[f2,{varmin,varmax}]["Values"]]*(n-1)/n
];


(* TemporalDataFunctions *)
TemporalCovariance[f1_,f2_?TemporalDataFunctionQ,var_Symbol:t,opts___?OptionQ]:=Module[{domains,numdomains,varmin,varmax},
	(*Print["tdf2"];*)
	
	domains=Join[
		Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f1,_TemporalData,\[Infinity],Heads->True]],
		Map[{#["FirstTimes"][[1]],#["LastTimes"][[1]]}&,Cases[f2,_TemporalData,\[Infinity],Heads->True]]
	];
	numdomains=Length[Union[domains]];
	
	Which[
		numdomains==0,
		Message[TemporalCovariance::norange],
		numdomains>1,
		Message[TemporalCovariance::unkrange],
		Else,
		{varmin,varmax}=domains[[1]];
		Return[TemporalCovariance[f1,f2,{var,varmin,varmax},opts]]
	];
];

TemporalCovariance[f1_?TemporalDataFunctionQ,f2_,var_:t,opts___?OptionQ]:=((*Print["tdf1"];*)TemporalCovariance[f2,f1,var,opts]);


Options[TemporalCovariance]={IntegrateOpts->{},NIntegrateOpts->{},TemporalMeanOpts->{},Method->"Integrate"};


ExtractPlotPoints::usage=
"ExtractPlotPoints[\!\(\*
StyleBox[\"plot\", \"TI\"]\)] extracts lists of points from lines in \!\(\*
StyleBox[\"plot\", \"TI\"]\).";


(* by Jens <http://mathematica.stackexchange.com/a/20282/6358> *)
ExtractPlotPoints[plot_Graphics]:=Cases[Normal@plot,Line[x_]:>x,\[Infinity]];


(* prF2 by kglr <https://mathematica.stackexchange.com/a/156783/6358> *)
GetPlotRange=Through[{Min,Max}@#]&/@Transpose[Join@@Cases[#//ToBoxes,RectangleBox[x_,y_,___]:>{x,y},\[Infinity]]/.NCache[_,vals_]->vals]&;


Else::usage=
"Else is an alias for True.";


Else=True;


SpFrac::usage=
"\!\(\*
StyleBox[\"SpFrac\", \"InlineCode\"]\)\!\(\*
StyleBox[\"[\", \"InlineCode\"]\)\!\(\*
StyleBox[\"sp\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"InlineCode\"]\)\!\(\*
StyleBox[\" \", \"InlineCode\"]\)\!\(\*
StyleBox[\"nsp\", \"TI\"]\)] gives \!\(\*
StyleBox[\"sp\", \"TI\"]\)/(\!\(\*
StyleBox[\"nsp\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\",\nFontSlant->\"Plain\"]\)1).";


SpFrac[sp_Integer,nsp_Integer]:=sp/(nsp+1.);
(*SpFrac[sp_Integer,nsp_Integer]:=(sp-1)/(nsp-0.99999);*)


ModPart::usage=
"ModPart[\!\(\*
StyleBox[\"list\", \"TI\"]\), \!\(\*
StyleBox[\"part\", \"TI\"]\)] returns part number \!\(\*
StyleBox[\"part\", \"TI\"]\) of \!\(\*
StyleBox[\"list\", \"TI\"]\) like Part, but wraps around.";


ModPart[list_List,part_Integer]:=Part[list,Mod[part,Length[list],1]];


NumberedGridForm::usage=
"NumberedGridForm[\!\(\*
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"]\)] formats \!\(\*
StyleBox[\"list\", \"TI\",\nFontSlant->\"Italic\"]\) in a table with numbers";


NumberedGridForm[list_List]:=Grid[Transpose[{Range[Length[list]],list}],Alignment->Left];


FindMinima::usage=
"FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local minima of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindMinima[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358>
& a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


(* InterpolatingFunction *)
FindMinima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]>0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindMinima[if_InterpolatingFunction]:=FindMinima[if,if["Domain"][[1]]];


(* TemporalData *)
FindMinima[td_TemporalData]:=Normal[TimeSeriesMap[Minus,FindPeaks[TimeSeriesMap[Minus,td]]]];
FindMinima[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMinima[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindMinima[f_?RuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->FindMinima[val,opts]);
FindMinima[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindMinima[val,{tmin,tmax},opts]);


(* List *)
FindMinima[l_List]:=FindMinima[TimeSeries[l]];
FindMinima[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMinima[TimeSeries[l],{tmin,tmax}];


FindMaxima::usage=
"FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local maxima of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindMaxima[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358>
& a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


(* InterpolatingFunction *)
FindMaxima[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]<0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindMaxima[if_InterpolatingFunction]:=FindMaxima[if,if["Domain"][[1]]];


(* TemporalData *)
FindMaxima[td_TemporalData]:=Normal[FindPeaks[td]];
FindMaxima[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMaxima[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindMaxima[f_?RuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->FindMaxima[val,opts]);
FindMaxima[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindMaxima[val,{tmin,tmax},opts]);


(* List *)
FindMaxima[l_List]:=FindMaxima[TimeSeries[l]];
FindMaxima[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindMaxima[TimeSeries[l],{tmin,tmax}];


FindExtrema::usage=
"FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local extrema of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
FindExtrema[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(* based on idea from Daniel Lichtblau <http://mathematica.stackexchange.com/a/5591/6358>
& a trick from Mr Wizard <http://mathematica.stackexchange.com/a/67671/6358> *)


(* InterpolatingFunction *)
FindExtrema[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]:=Reap[
	NDSolve[{y'[t]==Evaluate[D[if[t],t]],WhenEvent[y'[t]==0,Sow[{t,y[t]}]],y[tmin]==if[tmin]},
	y[t],{t,tmin,tmax}]][[2]]/.{x_List}:>x;
FindExtrema[if_InterpolatingFunction]:=FindExtrema[if,if["Domain"][[1]]];


(* TemporalData *)
FindExtrema[td_TemporalData]:=Sort[Join[FindMinima[td],FindMaxima[td]]];
FindExtrema[td_TemporalData,{tmin_?NumericQ,tmax_?NumericQ}]:=FindExtrema[TimeSeriesWindow[td,{tmin,tmax}]];


(* thread over RuleLists *)
FindExtrema[f_?RuleListQ,opts___?OptionQ]:=((*Print["rulelist1"];*)f/.(x_->val_):>(x->FindExtrema[val,opts]));
FindExtrema[f_?RuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=f/.(x_->val_):>(x->FindExtrema[val,{tmin,tmax},opts]);


(* List *)
FindExtrema[l_List]:=FindExtrema[TimeSeries[l]];
FindExtrema[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=FindExtrema[TimeSeries[l],{tmin,tmax}];


MaximumValues::usage=
"MaximumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local maximum values of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
MaximumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
MaximumValues[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


MaximumValues[x:(_InterpolatingFunction|_TemporalData),opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MaximumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMaxima[x][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMaxima[x][[All,2]]]]
	];
];


MaximumValues[x:(_InterpolatingFunction|_TemporalData),{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MaximumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMaxima[x,{tmin,tmax}][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMaxima[x,{tmin,tmax}][[All,2]]]]
	];
];


(* thread over RuleLists *)
MaximumValues[f_?TemporalRuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->MaximumValues[val,opts]);
MaximumValues[f_?TemporalRuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=
	f/.(x_->val_):>(x->MaximumValues[val,{tmin,tmax},opts]);


(* non-TemporalRuleLists *)
MaximumValues[f_?RuleListQ]:=f/.(x_->val_):>(x->{val});


(* Lists *)
MaximumValues[l_List]:=MaximumValues[TimeSeries[l]];
MaximumValues[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=MaximumValues[TimeSeries[l],{tmin,tmax}];


(* Numeric *)
MaximumValues[x_?NumericQ]:={x};
MaximumValues[x_?NumericQ,{tmin_?NumericQ,tmax_?NumericQ}]:={x};


Options[MaximumValues]={SameThreshold->10^-4};


MinimumValues::usage=
"MinimumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local minimum values of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
MinimumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
MinimumValues[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


MinimumValues[x:(_InterpolatingFunction|_TemporalData),opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MinimumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMinima[x][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMinima[x][[All,2]]]]
	];
];


MinimumValues[x:(_InterpolatingFunction|_TemporalData),{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[MinimumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindMinima[x,{tmin,tmax}][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindMinima[x,{tmin,tmax}][[All,2]]]]
	];
];


(* thread over RuleLists *)
MinimumValues[f_?TemporalRuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->MinimumValues[val,opts]);
MinimumValues[f_?TemporalRuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=
	f/.(x_->val_):>(x->MinimumValues[val,{tmin,tmax},opts]);


(* non-TemporalRuleLists *)
MinimumValues[f_?RuleListQ]:=f/.(x_->val_):>(x->{val});


(* Lists *)
MinimumValues[l_List]:=MinimumValues[TimeSeries[l]];
MinimumValues[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=MinimumValues[TimeSeries[l],{tmin,tmax}];


(* Numeric *)
MinimumValues[x_?NumericQ]:={x};
MinimumValues[x_?NumericQ,{tmin_?NumericQ,tmax_?NumericQ}]:={x};


Options[MinimumValues]={SameThreshold->10^-4};


ExtremumValues::usage=
"ExtremumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] finds local extremum values of temporal rule list \!\(\*
StyleBox[\"f\", \"TI\"]\) between \!\(\*
StyleBox[\"tmin\", \"TI\"]\) and \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
ExtremumValues[\!\(\*
StyleBox[\"f\", \"TI\"]\)] looks over entire domain of \!\(\*
StyleBox[\"f\", \"TI\"]\).
ExtremumValues[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] threads over \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


ExtremumValues[x:(_InterpolatingFunction|_TemporalData),opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[ExtremumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindExtrema[x][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindExtrema[x][[All,2]]]]
	];
];


ExtremumValues[x:(_InterpolatingFunction|_TemporalData),{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=Module[{samethreshold},
samethreshold=Evaluate[SameThreshold/.Flatten[{opts,Options[ExtremumValues]}]];

	If[samethreshold!=0,
		Return[Sort[DeleteDuplicates[FindExtrema[x,{tmin,tmax}][[All,2]],Abs[#1-#2]<samethreshold&]]],
		Return[Sort[FindExtrema[x,{tmin,tmax}][[All,2]]]]
	];
];


(* thread over TemporalRuleLists *)
ExtremumValues[f_?TemporalRuleListQ,opts___?OptionQ]:=f/.(x_->val_):>(x->ExtremumValues[val,opts]);
ExtremumValues[f_?TemporalRuleListQ,{tmin_?NumericQ,tmax_?NumericQ},opts___?OptionQ]:=
	f/.(x_->val_):>(x->ExtremumValues[val,{tmin,tmax},opts]);


(* non-TemporalRuleLists *)
ExtremumValues[f_?RuleListQ]:=f/.(x_->val_):>(x->{val});


(* Lists *)
ExtremumValues[l_List]:=ExtremumValues[TimeSeries[l]];
ExtremumValues[l_List,{tmin_?NumericQ,tmax_?NumericQ}]:=ExtremumValues[TimeSeries[l],{tmin,tmax}];


(* Numeric *)
ExtremumValues[x_?NumericQ]:={x};
ExtremumValues[x_?NumericQ,{tmin_?NumericQ,tmax_?NumericQ}]:={x};


Options[ExtremumValues]={SameThreshold->10^-4};


FindPeriod::usage=
"FindPeriod[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the period of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


FindPeriod[sol_,opts:OptionsPattern[]]:=Module[{var1,res,tmp},

Which[
	Head[sol[[1,2]]]===TemporalData,
	(* based on idea from bbgodfrey, http://mathematica.stackexchange.com/a/107741/6358 *)
	res=Length[DeleteDuplicates[Transpose[
		Map[(#/.sol)["Values"][[Max[-sol[[1,2]]["PathLength"],-OptionValue[MaxPeriod]];;]]&,sol[[All,1]]]],
		Norm[#1-#2]<10^-OptionValue[AccuracyGoal]+Norm[(#1-#2)/#1]*10^-OptionValue[PrecisionGoal]&]]
,
	Head[sol[[1,2]]]===InterpolatingFunction&&OptionValue[BasePeriod]=!=None,
	var1=sol[[1,1]];
	tmp={var1->TimeSeries[Table[{t,var1/.Slice[sol,t]},{t,InitialTime[sol],FinalTime[sol],OptionValue[BasePeriod]}]]};
	res=FindPeriod[tmp]*OptionValue[BasePeriod]
,
	True, (* else *)
	Return[];
];

Return[res]

];


Options[FindPeriod]={MaxPeriod->4,AccuracyGoal->5,PrecisionGoal->5,BasePeriod->None};


MyStreamPlot::usage=
"MyStreamPlot[\!\(\*
StyleBox[\"f\", \"TI\"]\), {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"xmin\", \"TI\"]\), \!\(\*
StyleBox[\"xmax\", \"TI\"]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\), \!\(\*
StyleBox[\"ymin\", \"TI\"]\), \!\(\*
StyleBox[\"ymax\", \"TI\"]\)}] is like StreamPlot, but with better arrow spacing.";


(* originally by Rahul <http://mathematica.stackexchange.com/a/42770/6358>,
tweaked by me <https://mathematica.stackexchange.com/a/157613/6358>,
RegionFunction fixed by kglr <https://mathematica.stackexchange.com/a/193304/6358> *)

MyStreamPlot[f_,{x_,x0_,x1_},{y_,y0_,y1_},opts___?OptionQ]:=

Module[{
(* options *)
a,rf,
(* other variables *)
u,v,res,opts2},

a=Evaluate[AspectRatio/.Flatten[{opts,Options[StreamPlot]}]];
rf=Evaluate[RegionFunction/.Flatten[{opts,Options[StreamPlot]}]];

(* hack to fix visible region introduced in v12.1,
see <https://mathematica.stackexchange.com/questions/216865/blue-background-in-streamplot-output> *)
If[$VersionNumber>=12.1,opts2=Join[{opts},{RegionBoundaryStyle->None,RegionFillingStyle->None}],opts2={opts}];

res=Show[StreamPlot[
	({EcoEvo`Private`xmon,EcoEvo`Private`ymon}={Rescale[u,{0,1},{x0,x1}],Rescale[v,{0,a},{y0,y1}]};
	{1/(x1-x0),a/(y1-y0)} (f/.{x->Rescale[u,{0,1},{x0,x1}],y->Rescale[v,{0,a},{y0,y1}]})),{u,0,1},{v,0,a},
	RegionFunction->(rf[Rescale[#,{0,1},{x0,x1}],Rescale[#2,{0,a},{y0,y1}],##3]&),Evaluate[Sequence@@opts2]]
	/.Arrow[pts_]:>Arrow[Transpose[{Rescale[#,{0,1},{x0,x1}],Rescale[#2,{0,a},{y0,y1}]}&@@Transpose[pts]]],
	PlotRange->{{x0,x1},{y0,y1}}];
	
	Return[res]
];


RealSimplify::usage=
"RealSimplify[\!\(\*
StyleBox[\"expression\", \"TI\"]\)] Simplifies \!\(\*
StyleBox[\"expression\", \"TI\"]\) assuming everything is Real.";


RealSimplify[foo_]:=Simplify[foo,Assumptions->{_\[Element]Reals}];


CompoundAnd::usage=
"CompoundAnd[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if all \!\(\*
StyleBox[\"conds\", \"TI\"]\) are True.";


CompoundAnd[list_]:=Module[{},And[Evaluate[Sequence@@list]]];


CompoundOr::usage=
"CompoundOr[\!\(\*
StyleBox[\"conds\", \"TI\"]\)] is True if any of \!\(\*FormBox[
StyleBox[\"conds\", \"TI\"],
TraditionalForm]\) are True.";


CompoundOr[list_]:=Module[{},Or[Evaluate[Sequence@@list]]];


NumericListQ::usage=
"NumericListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers, False otherwise.";


NumericListQ[x_]:=VectorQ[x,NumericQ[#]&];


NumericFlattenedListQ::usage =
"NumericFlattenedListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of numbers when Flattened, False otherwise.";


NumericFlattenedListQ[x_]:=If[ListQ[x],NumericListQ[Flatten[x]],False];


NumericRuleListQ::usage=
"NumericRuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a RuleList with numeric values, False otherwise.";


NumericRuleListQ[x_]:=If[RuleListQ[x],VectorQ[x,NumericQ[#[[2]]]&],False];


MakeRuleList::usage=
"MakeRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
MakeRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), {\!\(\*
StyleBox[\"min\", \"TI\"]\), \!\(\*
StyleBox[\"max\", \"TI\"]\)}] makes a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) rules where \!\(\*
StyleBox[\"var\", \"TI\"]\) ranges from \!\(\*
StyleBox[\"min\", \"TI\"]\) to \!\(\*
StyleBox[\"max\", \"TI\"]\).
MakeRuleList[\!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"vals\", \"TI\"]\)] makes a list of rules between corresponding elements of the lists \!\(\*
StyleBox[\"vars\", \"TI\"]\) and \!\(\*
StyleBox[\"vals\", \"TI\"]\).
MakeRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ns\", \"TI\"]\), \!\(\*
StyleBox[\"val\", \"TI\"]\)] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*
StyleBox[\"var\", \"TI\"]\) takes on value \!\(\*
StyleBox[\"val\", \"TI\"]\).
MakeRuleList[{\!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(1\)]\), \[Ellipsis], \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(nv\)]\)}, {\!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(1\)]\), \[Ellipsis] , \!\(\*SubscriptBox[
StyleBox[\"n\", \"TI\"], \(nv\)]\)}, {{\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(1\)]\)}, \[Ellipsis] , {\!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(nv\)]\), \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(nv\)]\)}}] makes a list of rules with dimensions \!\(\*
StyleBox[\"ns\", \"TI\"]\) where \!\(\*SubscriptBox[
StyleBox[\"var\", \"TI\"], \(i\)]\) ranges from \!\(\*SubscriptBox[
StyleBox[\"min\", \"TI\"], \(i\)]\) to \!\(\*SubscriptBox[
StyleBox[\"max\", \"TI\"], \(i\)]\).";


MakeRuleList[vars_List,n_,vals_List]:=Flatten[Table[Subscript[vars[[j]],i]->vals[[j]],{i,n},{j,Length[vars]}]];


MakeRuleList[vars_List,ns_List,vals_List]:=Module[{n,min,max},
	Thread[
		Flatten[Table[Map[Subscript[#,i]&,vars],{i,Times[Sequence@@ns]}]]
		->
		Flatten[Outer[List,Sequence@@Table[
			n=ns[[j]];
			If[ListQ[vals[[j]]],{min,max}=vals[[j]],min=max=vals[[j]]];
			Table[min+(max-min)*(i-1)/(n-1),{i,n}]
		,{j,Length[ns]}]]]
		]
	]


MakeRuleList[var_,n_,val_]:=Table[Subscript[var,i]->val/.\[IGrave]->i,{i,n}];


MakeRuleList[var_,n_,{min_?NumericQ,max_?NumericQ}]:=Table[Subscript[var,i]->min+(max-min)*(i-1)/(n-1),{i,n}];


MakeRuleList[var_,ns_List,val_]:=
	Thread[
		Table[Subscript[var,i],{i,Times[Sequence@@ns]}]->
		Table[val,{i,Times[Sequence@@ns]}]
	]


SetAttributes[MakeRuleList,HoldAll];


ArrayToRuleList::usage=
"ArrayToRuleList[\!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"arr\", \"TI\"]\)] makes an indexed rule list from \!\(\*
StyleBox[\"arr\", \"TI\"]\)."


ArrayToRuleList[var_Symbol,arr_List]:=Flatten[MapIndexed[Subscript[var, Sequence@@#2]->#1&,arr,{-1}]];


RuleListQ::usage=
"RuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of replacement rules, False otherwise.";


RuleListQ[x_]:=VectorQ[x,(#[[0]]==Rule||#[[0]]==RuleDelayed)&];


TemporalRuleListQ::usage="TemporalRuleListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a RuleList with temporal values, False otherwise.";


TemporalRuleListQ[x_]:=If[RuleListQ[x],VectorQ[x,MatchQ[#,(*_Symbol|_Subscript*)_->_InterpolatingFunction(*|_List*)|_TemporalData]&],False];


RuleListListQ::usage=
"RuleListListQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of RuleLists, False otherwise.";


RuleListListQ[x_]:=VectorQ[x,RuleListQ[#]&];


RuleListDistance::usage=
"RuleListDistance[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] gives the distance between two rule lists.
RuleListDistance[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] gives the distance between a rule list and the origin.";


RuleListDistance[in1_?NumericRuleListQ,in2:(_?NumericRuleListQ):{},opts___?OptionQ]:=

Module[{
(* options *)
distancefunction=Evaluate[DistanceFunction/.Flatten[{opts,Options[RuleListDistance]}]],
weights=Evaluate[Weights/.Flatten[{opts,Options[RuleListDistance]}]],
(* other variables *)
list1,list2},

list1=RuleListMultiply[in1,weights];
If[in2!={},
	list2=RuleListMultiply[in2,weights],
	list2=RuleListMultiply[in1,0]
];

Return[distancefunction[Sort[list1][[All,2]],Sort[list2][[All,2]]]]
];


Options[RuleListDistance]={DistanceFunction->EuclideanDistance,Weights->{}};


RuleListTweak::usage=
"RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variable \!\(\*
StyleBox[\"var\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).
RuleListTweak[\!\(\*
StyleBox[\"point\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\), \!\(\*
StyleBox[\"h\", \"TI\"]\)] perturbs variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) in rulelist \!\(\*
StyleBox[\"point\", \"TI\"]\) by \!\(\*
StyleBox[\"h\", \"TI\"]\).";


RuleListTweak[point_?RuleListQ,var_Symbol,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_Subscript,h_]:=Append[Select[point,#[[1]]=!=var&],var->((var/.point)+h)];
RuleListTweak[point_?RuleListQ,var_List,h_List]:=Join[Select[point,!MemberQ[var,#[[1]]]&],#->((#/.point)+h[[Position[var,#][[1,1]]]])&/@var];


RuleListAdd::usage=
"RuleListAdd[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] adds corresponding elements of two rulelists.";


(*RuleListAdd[l1_?RuleListQ,l2_?RuleListQ,m2_:1,m1_:1]:=Table[e\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]m1*e\[LeftDoubleBracket]2\[RightDoubleBracket]+m2*(e\[LeftDoubleBracket]1\[RightDoubleBracket]/.l2),{e,l1}];*)
RuleListAdd[a_?RuleListQ,b_?RuleListQ]:=Normal[Merge[{a,b},Total]]


RuleListSubtract::usage=
"RuleListSubtract[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] subtracts corresponding elements of \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\) from \!\(\*
StyleBox[\"rulelist1\", \"TI\"]\).";


RuleListSubtract[a_?RuleListQ,b_?RuleListQ]:=RuleListAdd[a,RuleListMultiply[b,-1]];


RuleListMultiply::usage=
"RuleListMultiply[\!\(\*
StyleBox[\"rulelist1\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist2\", \"TI\"]\)] multiplies corresponding elements of rulelists.
RuleListMultiply[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"x\", \"TI\"]\)] or RuleListMultiply[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] multiplies elements of rulelist \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) by number \!\(\*
StyleBox[\"x\", \"TI\"]\).";


RuleListMultiply[a_?RuleListQ,x_?NumericQ]:=Normal[Merge[a,x*#[[1]]&]];
RuleListMultiply[x_?NumericQ,a_?RuleListQ]:=Normal[Merge[a,x*#[[1]]&]];
RuleListMultiply[a_?RuleListQ,b_?RuleListQ]:=Normal[Merge[{a,b},Apply[Times]]];


NumericRuleListToNumericList::usage=
"NumericRuleListToNumericList[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] converts numeric rulelist \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) to a numeric list, in order of \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


NumericRuleListToNumericList[rl_?NumericRuleListQ,vars_List]:=vars/.rl;


RuleListInterpolation::usage=
"RuleListInterpolation[\!\(\*
StyleBox[\"list\", \"TI\"]\)] converts a list of the form {{\!\(\*
StyleBox[SubscriptBox[\"x\", \"1\"], \"TI\"]\),\!\(\*
StyleBox[SubscriptBox[\"rulelist\", \"1\"], \"TI\"]\)},{\!\(\*
StyleBox[SubscriptBox[\"x\", \"2\"], \"TI\"]\),\!\(\*
StyleBox[SubscriptBox[\"rulelist\", \"2\"], \"TI\"]\)},...} to a rule list of InterpolatingFunctions.";


RuleListInterpolation[list_List,opts___?OptionQ]:=Module[{interpolationopts},
	interpolationopts=FilterRules[Flatten[{opts,Options[RuleListInterpolation]}],Options[Interpolation]];
	
	Normal@Merge[Map[ReplaceAll[#[[2]],(var_->val_?NumericQ)->(var->{#[[1]],val})]&,list],Interpolation[#,Evaluate[Sequence@@interpolationopts]]&]
];


Options[RuleListInterpolation]={};


InterpolatingFunctionTake::usage=
"InterpolatingFunctionTake[\!\(\*
StyleBox[\"if\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] takes part of an InterpolatingFunction from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";


(* based on code by MichaelE2 <https://mathematica.stackexchange.com/a/152861/6358> *)

ClearAll[ifnPart];
ifnPart["Domain"]=Sequence[1];(*bounding box for domain*)
ifnPart["X1"]=Sequence[1,1];(*lower bound for first coordinate*)
ifnPart["X2"]=Sequence[1,2];(*upper bound for first coordinate*)
ifnPart["Version"]=Sequence[2,1];
ifnPart["Flags"]=Sequence[2,2];(*flags indicating properties:bit field positions-inferred,perhaps mistaken $extrapolation=0;whether to warn about extrapolation $fullArrayBit=1;interpolation data is a full array (not ragged) $packed=2;packed array form (???) $repeatedBit=4;whether repeated abscissae are permitted*)
ifnPart["DerivativeOrder"]=Sequence[2,3];(*max derivative order*)
ifnPart["NGrid"]=Sequence[2,4];(*number of points in each coordinate grid*)
ifnPart["InterpolationOrder"]=Sequence[2,5];(*interpolation order*)
ifnPart["Derivative"]=Sequence[2,6];(*derivative to evaluate:0-->f[x],1-->f'[x],...*)
ifnPart["Periodic"]=Sequence[2,7];
ifnPart["ExtrapolationHandler"]=Sequence[2,10];
ifnPart["Coordinates"]=Sequence[3];(*list of lists,abscissae of interpolation grid*)
ifnPart["InterpolationData"]=Sequence[4];(*interpolation data (values or coefficients)*)
ifnPart["Offsets"]=Sequence[4,2];(*offsets in function/derivative array (PackedArrayForm)*)
ifnPart["FlatData"]=Sequence[4,3];(*flattened function/derivative values (PackedArrayForm)*)
ifnPart["InterpolationStructure"]=Sequence[5];(*{Automatic},or dense output interpolation structure:list of types for each unit/subinterval*)ifnPart["UnitIndices"]=Sequence[5,1,1];(*dense output:Indices (to grid) for corresponding coefficients*)
ifnPart["UnitTypes"]=Sequence[5,1,2];(*dense output types:Automatic|NDSolve`CubicHermite|NDSolve`LocalSeries|ChebyshevT*)
ifnPart["Properties"]=Cases[DownValues[ifnPart],Verbatim[ifnPart][prop_]:>prop,Infinity];

ifnPart["ValidPartQ","Chebyshev"|"Local Taylor Series","UnitIndices"|"UnitTypes",_]:=True;
ifnPart["ValidPartQ",_,"UnitIndices"|"UnitTypes",_]:=False;
ifnPart["ValidPartQ","Hermite","Offsets"|"FlatData",Developer`PackedArrayForm]:=True;
ifnPart["ValidPartQ",_,"Offsets"|"FlatData",_]:=False;
ifnPart["ValidPartQ",method_String,part_String,_]/;MemberQ[method,"Chebyshev"|"Local Taylor Series"|"Hermite"]&&MemberQ[part,ifnPart["Properties"]]:=True;
ifnPart["ValidPartQ",_,_,_]:=False;
ifnPart[if_InterpolatingFunction,part_String]/;ifnPart["ValidPartQ",if["InterpolationMethod"],part,if[[4,1]]]:=if~Part~ifnPart[part];


dupeLast[list_]:=Append[list,Last@list];

iDataTake["Local Taylor series"|"Chebyshev",data_,span_]:=Join[{data[[First@span,1;;2]]},data[[First@span+1;;Last@span]]];
iDataTake["Hermite",data:{Developer`PackedArrayForm,_,_},span:{s1_,s2_}]:=
	ReplacePart[data,{Rest@{ifnPart["Offsets"]}->data[[2,s1;;s2+1]]-data[[2,s1]],Rest@{ifnPart["FlatData"]}->data[[3,data[[2,s1]]+1;;data[[2,s2+1]]]]}];
iDataTake["Hermite",data:{__List},span_]:=data[[Span@@span]];

iStructureTake["Local Taylor series"|"Chebyshev",structure_,span_]:=
	ReplacePart[structure,{Rest@{ifnPart["UnitIndices"]}->Join[{{1}},1+structure[[##2&@ifnPart["UnitIndices"],First@span+1;;Last@span]]-structure[[##2&@ifnPart["UnitIndices"],First@span,-1]]//dupeLast],Rest@{ifnPart["UnitTypes"]}->Join[{Automatic},structure[[##2&@ifnPart["UnitTypes"],First@span+1;;Last@span]]//dupeLast]}];
iStructureTake["Hermite",structure_,span_]:=structure;

InterpolatingFunctionTake[if_InterpolatingFunction,{tmin_?NumericQ,tmax_?NumericQ}]/;Length@if["Domain"]==1:=Module[
{coords,newif=Hold@@if,span,method},

method=if["InterpolationMethod"];
coords=First@if["Coordinates"];
span=Clip[SparseArray[UnitStep[coords-tmin] UnitStep[tmax-coords]]["AdjacencyLists"][[{1,-1}]]+{-1,1},{1,Length@coords}];
newif[[ifnPart["Domain"]]]={{tmin,tmax}};
newif[[ifnPart["NGrid"]]]=1+Differences@span;
newif[[ifnPart["Coordinates"]]]=Developer`ToPackedArray@{coords[[Span@@span]]};
newif[[ifnPart["InterpolationData"]]]=iDataTake[method,if[[ifnPart["InterpolationData"]]],span];
newif[[ifnPart["InterpolationStructure"]]]=iStructureTake[method,if[[ifnPart["InterpolationStructure"]]],span];
InterpolatingFunction@@newif
];


Slice::usage=
"Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"t\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with its values at \!\(\*
StyleBox[\"t\", \"TI\"]\).
Slice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), {\!\(\*
StyleBox[\"tmin\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)}] extracts values from \!\(\*
StyleBox[\"tmin\", \"TI\"]\) to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";


Slice[sol_?(*Temporal*)RuleListQ,t:(_?NumericQ|_DirectedInfinity)]:=
Which[
	MemberQ[{InterpolatingFunction,TemporalData},Head[#[[2]]]],
	ReplacePart[#,2->(#[[1]][t]/.#)]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],#[[1]]==t&,1][[1,2]]]
,
	Else,#
]&/@sol;

Slice[sol_?(*Temporal*)RuleListQ,{t1_?NumericQ,t2_?NumericQ}]:=
Which[
	Head[#[[2]]]===InterpolatingFunction,
	ReplacePart[#,2->InterpolatingFunctionTake[#[[2]],{t1,t2}]]
,
	Head[#[[2]]]===List,
	ReplacePart[#,2->Select[sol[[1,2]],t1<=#[[1]]<=t2&]]
,
	Head[#[[2]]]===TemporalData,
	ReplacePart[#,2->TimeSeries[Transpose[{#[[2]]["Times"][[t1+1;;t2+1]],#[[2]]["Values"][[t1+1;;t2+1]]}]]]
,
	Else,#
]&/@sol

Slice[sol_?RuleListQ,___]:=sol;


InitialSlice::usage=
"InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the initial values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
InitialSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] extracts the initial values ending at \!\(\*
StyleBox[\"tmax\", \"TI\"]\).";


InitialSlice[sol_?RuleListQ,n:(_?NumericQ):0]:=Module[{x},
	x=If[modeltype=="ContinuousTime",10.^-100,0];
	If[n==0,
		Return[Slice[sol,InitialTime[sol]+x]],
		Return[Slice[sol,{InitialTime[sol]x,InitialTime[sol]+n}]]
	]
];


(*InitialSlice[sol_?RuleListQ,___]:=sol;*)


FinalSlice::usage=
"FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] extracts the final values from temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).
FinalSlice[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"tmin\", \"TI\"]\)] extracts the final values starting at \!\(\*
StyleBox[\"tmin\", \"TI\"]\).";


FinalSlice[sol_?RuleListQ,n:(_?NumericQ):0]:=
	If[n==0,
		Return[Slice[sol,FinalTime[sol]]],
		Return[Slice[sol,{FinalTime[sol]-n,FinalTime[sol]}]]
	];


(*FinalSlice[sol_?RuleListQ,___]:=sol;*)


FinalDerivatives::usage=
"FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] replaces temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\) with their final derivatives.
FinalDerivatives[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\), \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\)] averages over the final values starting at \!\(\*
StyleBox[\"\[Delta]\", \"TI\"]\).";


FinalDerivatives[sol_?TemporalRuleListQ,dt:(_?NumericQ):0]:=Module[{res},
	If[dt==0,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]]'[#[[2,1,1,2]]]/.#)}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket]'[#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]/.#)}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-2,2]])/(#[[2,-1,1]]-#[[2,-2,1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-2,1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-2]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-2]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-2\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	,
		res=Which[
			Head[#[[2]]]===InterpolatingFunction,
			ReplacePart[#,{1->#[[1]]',2->(#[[1]][#[[2,1,1,2]]]-#[[1]][#[[2,1,1,2]]-dt])/dt/.#}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]]-#\[LeftDoubleBracket]1\[RightDoubleBracket][#\[LeftDoubleBracket]2,1,1,2\[RightDoubleBracket]-dt])/dt/.#}]*)
		,
			Head[#[[2]]]===List,
			ReplacePart[#,{1->#[[1]]',2->(#[[2,-1,2]]-#[[2,-(1+dt),2]])/(#[[2,-1,1]]-#[[2,-(1+dt),1]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2,-1,2\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),2\[RightDoubleBracket])/(#\[LeftDoubleBracket]2,-1,1\[RightDoubleBracket]-#\[LeftDoubleBracket]2,-(1+dt),1\[RightDoubleBracket])}]*)
		,
			Head[#[[2]]]===TemporalData,
			ReplacePart[#,{1->#[[1]]',2->(#[[2]]["Values"][[-1]]-#[[2]]["Values"][[-(1+dt)]])/(#[[2]]["Times"][[-1]]-#[[2]]["Times"][[-(1+dt)]])}]
			(*ReplacePart[#,{2\[Rule](#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Values"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])/(#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-1\[RightDoubleBracket]-#\[LeftDoubleBracket]2\[RightDoubleBracket]["Times"]\[LeftDoubleBracket]-(1+dt)\[RightDoubleBracket])}]*)
		,
			Else,#
		]&/@sol
	];
	Return[res]
]


FinalDerivatives[sol_?NumericRuleListQ,___]:=ReplacePart[#,{1->#[[1]]',2->0}]&/@sol


InitialTime::usage=
"InitialTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the initial time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(*InitialTime[sol_]:=Which[
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===InterpolatingFunction,sol\[LeftDoubleBracket]1,2,1,1,1\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===List,sol\[LeftDoubleBracket]1,2,1,1\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===TemporalData,sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]["FirstTime"]
];*)


InitialTime[sol_?RuleListQ]:=Module[{tmp,numtmp},
	tmp=Which[
		Head[#[[2]]]===InterpolatingFunction,#[[2,1,1,1]],
		Head[#[[2]]]===List,#[[2,1,1]],
		Head[#[[2]]]===TemporalData,#[[2]]["FirstTime"],
		Else,-\[Infinity]
	]&/@sol;
	numtmp=Select[tmp,NumericQ];
	(*If[Length[Union[numtmp]]>1,Message[InitialTime::notime,numtmp];Return[$Failed]];*)
	Return[Max[tmp]];
];


InitialTime::notime="No common final time among `1`.";


FinalTime::usage=
"FinalTime[\!\(\*
StyleBox[\"rulelist\", \"TI\"]\)] returns the final time of temporal \!\(\*
StyleBox[\"rulelist\", \"TI\"]\).";


(*FinalTime[sol_]:=Which[
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===InterpolatingFunction,sol\[LeftDoubleBracket]1,2,1,1,2\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===List,sol\[LeftDoubleBracket]1,2,-1,1\[RightDoubleBracket],
	Head[sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]]===TemporalData,sol\[LeftDoubleBracket]1,2\[RightDoubleBracket]["LastTime"]
];*)


FinalTime[sol_?RuleListQ]:=Module[{tmp,numtmp},
	tmp=Which[
		Head[#[[2]]]===InterpolatingFunction,#[[2,1,1,2]],
		Head[#[[2]]]===List,#[[2,-1,1]],
		Head[#[[2]]]===TemporalData,#[[2]]["LastTime"],
		Else,\[Infinity]
	]&/@sol;
	numtmp=Select[tmp,NumericQ];
	(*If[Length[Union[numtmp,SameTest\[Rule](Abs[#1-#2]<$MachinePrecision&)]]>1,Message[FinalTime::notime,numtmp];Return[$Failed]];*)
	Return[Min[tmp]];
];


FinalTime::notime="No common final time among `1`.";


SortedEigensystem::usage=
"SortedEigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] is Eigensystem[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)], sorted from largest to smallest Re[eigenvalue].";


(* by Jens <http://mathematica.stackexchange.com/questions/59172/should-eigenvalues-be-ordered> *)
SortedEigensystem[matrix_?MatrixQ,opts___]:=
(Eigensystem[matrix+# IdentityMatrix[Dimensions[matrix]],opts]-{#,0})&@Norm[Flatten[matrix]];


ListMultiplier::usage=
"ListMultiplier[\!\(\*
StyleBox[\"list\", \"TI\"]\)] multiplies a list of matrices.";


(* by Joel Wallman <http://mathematica.stackexchange.com/a/113113/6358> *)
ListMultiplier[list_,partitionwidth_:5]:=NestWhile[Dot@@@Partition[#,partitionwidth,partitionwidth,1,{}]&,list,Dimensions[#][[1]]>1&][[1]];


RouthHurwitzCriteria::usage=
"RouthHurwitzCriteria[\!\(\*
StyleBox[\"matrix\", \"TI\"]\)] gives the modified Routh-Hurwitz stability criteria (up to 3x3).";


RouthHurwitzCriteria[a_?MatrixQ]:=Module[{c3},
	If[!SquareMatrixQ[a],Message[RouthHurwitzCriteria::nonsq];Return[a]];
	Which[
		Length[a]==1,
		Return[Piecewise[{{True,a[[1,1]]<0},{False,a[[1,1]]>0}},Indeterminate]],
		Length[a]==2,
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]>0},{False,Tr[a]>0||Det[a]<0}},Indeterminate]],
		Length[a]==3,
		c3=Det[{{a[[1,1]]+a[[2,2]],a[[2,3]],-a[[1,3]]},{a[[3,2]],a[[1,1]]+a[[3,3]],a[[1,2]]},{-a[[3,1]],a[[2,1]],a[[2,2]]+a[[3,3]]}}];
		Return[Piecewise[{{True,Tr[a]<0&&Det[a]<0&&c3<0},{False,Tr[a]>0||Det[a]>0||c3>0}},Indeterminate]],
		Length[a]>3,
		Message[RouthHurwitzCriteria::toobig];Return[a]
	]
];


JoinFirst::usage="JoinFirst[\!\(\*
StyleBox[\"l1\", \"TI\"]\), \!\(\*
StyleBox[\"l2\", \"TI\"]\)] joins two rulelists, taking the first definition in case of multiple.";


JoinFirst[l1_List,l2_List]:=If[l1!={}||l2!={},Normal@Merge[{l1,l2},First],{}];


MyListLinePlot3D::usage="MyListLinePlot3D[{{\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\)},{\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\)},\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)}] generates a 3D line plot of points with coordinates {\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)}.
MyListLinePlot3D[{\!\(\*SubscriptBox[
StyleBox[\"data\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"data\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)}] plots several collections of points, by default in different colors.";


(* based on user37744 <https://mathematica.stackexchange.com/a/107450/> *)
MyListLinePlot3D[arg_,opts___?OptionQ]:=Module[{listpointplot3dopts},
If[$VersionNumber>=12.3,(* use builtin ListLinePlot3D if available *)
	ListLinePlot3D[arg,opts],
	(* otherwise use homemade version *)
	(*Print["{opts}=",{opts}];*)
	listpointplot3dopts=FilterRules[{opts},Options[ListPointPlot3D]];
	(*Print["listpointplot3dopts=",listpointplot3dopts];*)
	If[Evaluate[Joined/.Flatten[{opts,Options[MyListLinePlot3D]}]]===False,
		ListPointPlot3D[arg,Sequence@@listpointplot3dopts],
		ListPointPlot3D[arg,Sequence@@listpointplot3dopts]/.Point[a___]:>{Thick,Line[a]}
	]
]
];


Options[MyListLinePlot3D]={Joined->True};


(*Options[MyListLinePlot3D]=If[$VersionNumber>=12.3,(* use builtin ListLinePlot3D if available *)
	Options[ListLinePlot3D],
	(* otherwise use homemade version *)
	(*FilterRules[Join[Options[ListPointPlot3D],{Joined\[Rule]True}],Except[ColorFunction]]*)
	(*Join[FilterRules[Options[ListPointPlot3D],Except[ColorFunction]],{Joined\[Rule]True}]*)
];*)


PlotDynamics::usage=
"PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots the functions in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.
PlotDynamics[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\) in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.";

PlotInterpolatingFunction::usage=
"PlotInterpolatingFunction[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots the InterpolatingFunctions in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.
PlotInterpolatingFunction[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\) in \!\(\*
StyleBox[\"sol\", \"TI\"]\) across their entire domain.";


PlotDynamics[sol_?RuleListQ,plotvarsin_List,opts___?OptionQ]:=

Module[{
(* options *)
logged,plotstyle,plotmarkers,axeslabel,plotopts,plotrange,linestyles,plottype,
histogram,histogrampoints,histogramscale,histogramposition,histogramopts,histogramopacity,
(* other variables *)
lookup,vars,plotvars,plotcolor,ls,i,yaxislabel,xinit,xfinal,ifvars,tdvars,cvars,tdsol,ifplot,tdplot,cplot,
xrange,hmax,histo,hplot},
	
Block[{\[ScriptCapitalN]},

(*If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];*)

(* handle options *)

logged=Evaluate[Logged/.Flatten[{opts,Options[PlotDynamics]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotDynamics]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[PlotDynamics]}]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotDynamics]}]];
linestyles=Flatten[{Evaluate[LineStyles/.Flatten[{opts,Options[PlotDynamics]}]]}];
histogram=Evaluate[Histogram/.Flatten[{opts,Options[PlotDynamics]}]];
histogrampoints=Evaluate[HistogramPoints/.Flatten[{opts,Options[PlotDynamics]}]];
histogramscale=Evaluate[HistogramScale/.Flatten[{opts,Options[PlotDynamics]}]];
histogramposition=Evaluate[HistogramPosition/.Flatten[{opts,Options[PlotDynamics]}]];
histogramopts=Evaluate[HistogramOpts/.Flatten[{opts,Options[PlotDynamics]}]];
histogramopacity=Evaluate[HistogramOpacity/.Flatten[{opts,Options[PlotDynamics]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotDynamics]}]];

vars=sol[[All,1]];
(*Print["vars=",vars];*)

(* figure out number of species in guilds *)
If[modelloaded,
	Do[
		\[ScriptCapitalN][gu]=Max[
			Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==gcomp)&][[All,2]]],{gcomp,gcomps[gu]}],
			Table[Max[Select[vars,(#[[0]]===Subscript)&&(#[[1]]==gtrait)&][[All,2]]],{gtrait,gtraits[gu]}]
		];
		If[\[ScriptCapitalN][gu]==-\[Infinity],\[ScriptCapitalN][gu]=0];
		If[Global`debug,Print["\[ScriptCapitalN][",gu,"]=",\[ScriptCapitalN][gu]]];
	,{gu,guilds}]
];

(*Print["plotvarsin=",plotvarsin];*)
If[plotvarsin==={All},
	plotvars=vars,
	plotvars={};
	Do[
		lookup=LookUp[var];
		If[MemberQ[{"gcomp","gtrait"},lookup[[1]]]&&Length[lookup]==3&&\[ScriptCapitalN][lookup[[2]]]!=0,
			Do[AppendTo[plotvars,Subscript[var,sp]],{sp,\[ScriptCapitalN][lookup[[2]]]}],
			AppendTo[plotvars,var]
		];
	,{var,plotvarsin}]
];
(*Print["plotvars=",plotvars];*)


If[axeslabel===Automatic,
	yaxislabel=Table[var/.{Subscript[v_,sp_]->Subscript[v,"i"]},{var,plotvars}];
	yaxislabel=Sort[Union[yaxislabel]];
	axeslabel={t,Row[yaxislabel,","]}
];
(*Print["axeslabel=",axeslabel];*)

(* split into InterpolatingFunctions, TemporalData, and constants *)
ifvars=Select[plotvars,Head[#/.sol]==InterpolatingFunction&];
(*Print["ifvars=",ifvars];*)
tdvars=Select[plotvars,Head[#/.sol]==TemporalData||Head[#/.sol]==List&];
(*Print["tdvars=",tdvars];*)
cvars=Select[plotvars,NumericQ[#/.sol]&];
(*Print["cvars=",cvars];*)

If[plotstyle==={},
	i=0;
	Do[
		i++;
		If[linestyles==={},ls=linestyle[var],ls=ModPart[linestyles,i]];
		lookup=LookUp[var];
		Which[
			(lookup[[1]]==="gcomp"||lookup[[1]]==="gtrait")&&Length[lookup]==4,
			plotcolor[var]=color[var][SpFrac[lookup[[4]],\[ScriptCapitalN][lookup[[2]]]]]
		,
			(lookup[[1]]==="gcomp"||lookup[[1]]==="gtrait")&&Length[lookup]==3,
			plotcolor[var]=color[var]
		,
			lookup[[1]]==="pcomp"||lookup[[1]]==="aux",
			plotcolor[var]=color[var]
		,
			Else,
			plotcolor[var]=ColorData[97][i];
		];
		AppendTo[plotstyle,{plotcolor[var],ls}]
	,{var,plotvars}]
];

If[CompoundAnd[Table[comptype[var]==="Extensive",{var,plotvars}]],
	If[logged==True,
		plotrange=All,
		plotrange={0,All}
	],
	(*plotrange=(IntervalUnion[Sequence@@Table[range[var],{var,plotvars}]]/.{-\[Infinity]\[Rule]All,\[Infinity]\[Rule]All})\[LeftDoubleBracket]1\[RightDoubleBracket]*)
	plotrange=All
];

If[ifvars!={},
	(*Print["ifvars=",ifvars];*)
	{xinit,xfinal}=(ifvars[[1]]/.sol)["Domain"][[1]]; (* extract domain *)
	(*Print["{xinit,xfinal}=",{xinit,xfinal}];*)
	If[logged==True,
		Which[
			plottype=="ListPlot",
			plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[ListPlot]];
			ifplot=ListLogPlot[ifvars/.sol,Evaluate[Sequence@@plotopts],PlotRange->plotrange],
			Else,
			plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[LogPlot]];
			ifplot=LogPlot[Evaluate[Table[var[x],{var,ifvars}]/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange]
		]
	,
		Which[
			plottype=="ListPlot",
			plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[ListPlot]];
			ifplot=ListPlot[ifvars/.sol,Evaluate[Sequence@@plotopts],PlotRange->plotrange],
			Else,
			plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[Plot]];
			ifplot=Plot[Evaluate[Table[var[x],{var,ifvars}]/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange]
		]
	]
,
	ifplot={};
];
(*Print[ifplot];*)

If[tdvars!={},
	If[plotmarkers==={}&&(Joined/.{opts})===False,
		plotmarkers=Table[plotmarker[var],{var,tdvars}]
	];

	If[plotmarkers=={},plotmarkers=None];
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,PlotMarkers->plotmarkers,Options[PlotDynamics]}],Options[ListPlot]];
	tdsol=Select[sol,MemberQ[tdvars,#[[1]]]&];
	{xinit,xfinal}={InitialTime[tdsol],FinalTime[tdsol]};
	If[logged==True,
		tdplot=ListLogPlot[tdvars/.sol,Evaluate[Sequence@@plotopts],PlotRange->plotrange]
	,
		tdplot=ListPlot[tdvars/.sol,Evaluate[Sequence@@plotopts],AxesOrigin->{xinit,0},PlotRange->plotrange];
	]
,
	tdplot={};
];

If[cvars!={},
	plotopts=FilterRules[Flatten[{opts,AxesLabel->axeslabel,PlotStyle->plotstyle,Options[PlotDynamics]}],Options[Plot]];
	cplot=Plot[Evaluate[cvars/.sol],{x,xinit,xfinal},Evaluate[Sequence@@plotopts],PlotRange->plotrange]
,
	cplot={}
];

If[histogram,
	xrange=(xfinal-xinit);
	hmax=Max[Table[
		histo[ifvar]=Histogram[Table[ifvar[t]/.sol,{t,xinit,xfinal,xrange/histogrampoints}],Automatic,"PDF",Evaluate[Sequence@@histogramopts]];
		GetPlotRange[histo[ifvar]][[2,2]]
	,{ifvar,ifvars}]];
	Global`tmp=hplot=Graphics[
		Flatten[
		Table[{
			{Directive[EdgeForm[Directive[Thickness[Small],Opacity[histogramopacity]]],plotcolor[ifvar],Opacity[histogramopacity]]},
			Cases[histo[ifvar]/.NCache[_,vals_]->vals
			/.(Rectangle[List[x1_,y1_],List[x2_,y2_],optz___]->Rectangle[List[y1+xfinal+xrange*histogramposition,x1],List[y2*xrange/hmax*histogramscale+xfinal+xrange*histogramposition,x2],optz])
			/.(RectangleBox[List[x1_,y1_],List[x2_,y2_],optz___]->Rectangle[List[y1+xfinal+xrange*histogramposition,x1],List[y2*xrange/hmax*histogramscale+xfinal+xrange*histogramposition,x2],optz]),
			Rectangle[List[_,_],List[_,_],___],\[Infinity]]
		},{ifvar,ifvars}]]
		]
,
	hplot={}
];
(*Print[hplot];*)

If[histogram,
	Return[Show[ifplot,tdplot,cplot,hplot,PlotRange->{{xinit,xfinal},All},PlotRangeClipping->False,ImagePadding->All(*{{20,400*histogramposition+250*histogramscale},{20,20}}*)]],
	Return[Show[ifplot,tdplot,cplot]]
];
]];


(* if only one plotvar given, doesn't need to be in a list *)
PlotDynamics[sol_?RuleListQ,plotvarin_Symbol:All,opts___?OptionQ]:=PlotDynamics[sol,{plotvarin},opts];

(* if only a rule given, doesn't need to be in a list *)
PlotDynamics[sol_Rule,plotvarsin_List,opts___?OptionQ]:=PlotDynamics[{sol},plotvarsin,opts];
PlotDynamics[sol_Rule,plotvarin_Symbol,opts___?OptionQ]:=PlotDynamics[{sol},{plotvarin},opts];
PlotDynamics[sol_Rule,opts___?OptionQ]:=PlotDynamics[{sol},All,opts];

(* thread over sols *)
PlotDynamics[list_?RuleListListQ,rest___]:=Show[PlotDynamics[#,rest]&/@list];

PlotInterpolatingFunction[sol_,plotvarsin___,opts___?OptionQ]:=PlotDynamics[sol,plotvarsin,opts,AxesLabel->None];


Options[PlotDynamics]=
{Logged->False,PlotStyle->{},PlotMarkers->{},AxesLabel->Automatic,LineStyles->{},PlotType->"Plot",Joined->True,
Histogram->False,HistogramPoints->10^5,HistogramScale->0.1,HistogramPosition->0.08,HistogramOpts->{},HistogramOpacity->0.6};

Options[PlotInterpolatingFunction]=
{Logged->False,PlotStyle->{},PlotMarkers->{},AxesLabel->Automatic,LineStyles->{},PlotType->"Plot",Joined->True,
Histogram->False,HistogramPoints->10^5,HistogramScale->0.1,HistogramPosition->0.08,HistogramOpts->{},HistogramOpacity->0.6};


RuleListPlot::usage=
"RuleListPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots a two- or three-dimensional rule list.
RuleListPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] plots \!\(\*
StyleBox[\"vars\", \"TI\"]\).
RuleListPlot[{\!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(1\)]\), \!\(\*SubscriptBox[
StyleBox[\"sol\", \"TI\"], \(2\)]\), \[Ellipsis]}] plots multiple rule lists.";


RuleListPlot[solsin_?RuleListListQ,varsin_List:{All},opts___?OptionQ]:=

Module[{
func=FuncStyle["RuleListPlot"],
(* options *)
plotstyle,plotmarkers,axeslabel,plotrange,
stablemarker,unstablemarker,indeterminatemarker,
parametricplotopts,parametricplot3dopts,listplotopts,listlineplotopts,listpointplot3dopts,listlineplot3dopts,
(* other variables *)
sol,sols,lookup,vars},
	
Block[{\[ScriptCapitalN]},

(*If[modelloaded\[NotEqual]True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];*)
If[Global`debug,Print["In ",func]];

(* handle options *)

plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[RuleListPlot]}]];
If[plotstyle===Automatic,plotstyle=ColorData[97,"ColorList"]];
If[!ListQ[plotstyle],plotstyle={plotstyle}];

stablemarker=Evaluate[StableMarker/.Flatten[{opts,Options[RuleListPlot]}]];
unstablemarker=Evaluate[UnstableMarker/.Flatten[{opts,Options[RuleListPlot]}]];
indeterminatemarker=Evaluate[IndeterminateMarker/.Flatten[{opts,Options[RuleListPlot]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[RuleListPlot]}]]/.
	{True->stablemarker,False->unstablemarker,Indeterminate->indeterminatemarker};
Which[
	plotmarkers===Automatic,
	plotmarkers={"\[FilledCircle]","\[FilledSquare]","\[FilledDiamond]","\[FilledUpTriangle]","\[FilledDownTriangle]","\[EmptyCircle]","\[EmptySquare]","\[EmptyDiamond]","\[EmptyUpTriangle]","\[EmptyDownTriangle]"},
	plotmarkers==="OpenMarkers",
	plotmarkers={"\[EmptyCircle]","\[EmptySquare]","\[EmptyDiamond]","\[EmptyUpTriangle]","\[EmptyDownTriangle]"},
	plotmarkers==="FilledMarkers",
	plotmarkers={"\[FilledCircle]","\[FilledSquare]","\[FilledDiamond]","\[FilledUpTriangle]","\[FilledDownTriangle]"}
];
(*Print[plotmarkers];*)

axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[RuleListPlot]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[RuleListPlot]}]];

parametricplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ParametricPlot]];
parametricplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ParametricPlot3D]];
listplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListPlot]];
listlineplotopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListLinePlot]];
listpointplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[ListPointPlot3D]];
listlineplot3dopts=FilterRules[Flatten[{opts,Options[RuleListPlot]}],Options[MyListLinePlot3D]];

(* figure out number of species in guilds *)
(*Set\[ScriptCapitalN][ExtractTraits[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]],ExtractVariables[solsin\[LeftDoubleBracket]1\[RightDoubleBracket]]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];*)

(* find vars for plotting *)
If[varsin==={All},
	vars=solsin[[1,All,1]],
	vars=varsin
];
(*Print["vars=",vars];*)
If[Length[vars]!=2&&Length[vars]!=3,Message[RuleListPlot::baddim,Length[vars]];Return[$Failed]];

(* split up subscripted variables (gcomps & gtraits) *)
lookup=LookUp[vars[[1]]];
If[MemberQ[{"gcomp","gtrait"},lookup[[1]]]&&Length[lookup]==3,
	sols=Flatten[GatherBy[#,#[[1,2]]&]&/@solsin,1]/.Replace[vars,var_->(Subscript[var, _]->var),1],
	sols=solsin
];
(*Print[sols];*)

If[axeslabel===Automatic,axeslabel=vars];
(*Print["axeslabel=",axeslabel];*)

Which[
	Length[vars]==2,
	If[plotrange===Automatic,
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],If[comptype[vars[[2]]]==="Extensive",{0,All},All]}
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			(*Print["parametricplotopts=",parametricplotopts];*)
			ParametricPlot[{vars[[1]][t],vars[[2]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplotopts]],
			Head[sol[[1,2]]]===List,
			ListLinePlot[Transpose[(vars/.sol)[[All,All,2]]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]],
			Head[sol[[1,2]]]===TemporalData,
			ListLinePlot[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,PlotMarkers->None,Evaluate[Sequence@@listlineplotopts]],
			Else,
			(*Print["listplotopts=",listplotopts];*)
			ListPlot[{vars/.sol},PlotStyle->ModPart[plotstyle,i],PlotMarkers->ModPart[plotmarkers,i],
				PlotRange->plotrange,Evaluate[Sequence@@listplotopts]]
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,FrameLabel->axeslabel,PlotRange->plotrange]],
	Length[vars]==3,
	If[plotrange===Automatic,
		plotrange={If[comptype[vars[[1]]]==="Extensive",{0,All},All],
			If[comptype[vars[[2]]]==="Extensive",{0,All},All],
			If[comptype[vars[[3]]]==="Extensive",{0,All},All]}
		(*plotrange={If[LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All],
			If[LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="gcomp"||LookUp[vars\[LeftDoubleBracket]3\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket]==="pcomp",{0,All},All]}*)
	];
	(*Print["plotrange=",plotrange];*)
	Return[Show[Table[
		sol=sols[[i]];
		Which[
			Head[sol[[1,2]]]===InterpolatingFunction,
			ParametricPlot3D[{vars[[1]][t],vars[[2]][t],vars[[3]][t]}/.sol,{t,InitialTime[sol],FinalTime[sol]},
				PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@parametricplot3dopts]],
			Head[sol[[1,2]]]===List,
			MyListLinePlot3D[Transpose[vars/.sol],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]],
			Head[sol[[1,2]]]===TemporalData,
			MyListLinePlot3D[Transpose[Map[(#/.sol)["Values"]&,vars]],PlotStyle->ModPart[plotstyle,i],
				PlotRange->plotrange,(*PlotMarkers\[Rule]None,*)Evaluate[Sequence@@listlineplot3dopts]],
			Else,
			ListPointPlot3D[{vars/.sol},PlotStyle->ModPart[plotstyle,i],PlotRange->plotrange,Evaluate[Sequence@@listpointplot3dopts]]
				(*/.Point[a___]\[RuleDelayed]Text[ModPart[plotmarkers,i],a]*)
		]
	,{i,Length[sols]}],AxesLabel->axeslabel,PlotRange->plotrange]]
];

]];


RuleListPlot[sol_?RuleListQ,rest___]:=RuleListPlot[{sol},rest];


Options[RuleListPlot]={
	PlotStyle->Automatic,AxesLabel->Automatic,PlotRange->Automatic,
	PlotMarkers->{Graphics[{Disk[]},ImageSize->6.5,AlignmentPoint->{0,0}]},
	StableMarker->{Graphics[{Black,Disk[]},ImageSize->6.5,AlignmentPoint->{0,0}]},
	UnstableMarker->{Graphics[{EdgeForm[{Black}],FaceForm[White],Disk[]},ImageSize->6.5,AlignmentPoint->{0,0}]},
	IndeterminateMarker->{Graphics[{EdgeForm[{Black}],FaceForm[Gray],Disk[]},ImageSize->6.5,AlignmentPoint->{0,0}]},
	PlotRangeClipping->False,BoxRatios->1,AspectRatio->1/GoldenRatio
};


RuleListPlot::baddim="RuleListPlot requires two- or three-dimensional data (# of dimensions=`1`).";


TrackRoot::usage=
"TrackRoot[\!\(\*
StyleBox[\"eqns\", \"TI\"]\), {{\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\), \!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], \(0\)]\)},...}, {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"initpar\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\)}] tracks a root of \!\(\*
StyleBox[\"eqns\", \"TI\"]\), varying \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\), starting at \!\(\*
StyleBox[\"initpar\", \"TI\"]\).";


TrackRoot::badmtd="The Method option should be a built-in method name (\"Direct\" or \"PseudoArcLength\")";


TrackRoot[eqns_List,unksnics_List,{par_Symbol,ipar_?NumericQ,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=Module[{
(* options *)
method,findrootopts,ndsolveopts,smin,smax,
(* other variables *)
whenevents,unks,subrule,breaks,isol,ics,deqns,j,sol,s1,s2,res,respart,pts},

(* handle options *)
method=Evaluate[Method/.Flatten[{opts,Options[TrackRoot]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[TrackRoot]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[TrackRoot]}]];
smin=Evaluate[SMin/.Flatten[{opts,Options[TrackRoot]}]];
smax=Evaluate[SMax/.Flatten[{opts,Options[TrackRoot]}]];

(* jacobian *)
j:=D[eqns,{unks}]/.subrule;

unks=unksnics[[All,1]];
(*Print["unks=",unks];*)

(* use FindRoot to improve initial guess *)
isol=FindRoot[eqns/.par->ipar,unksnics,Evaluate[Sequence@@findrootopts]];
If[Global`debug,Print["isol=",isol]];

whenevents={};

Which[
	method=="Direct",
	subrule=Table[unk->unk[par],{unk,unks}];
	ics=Table[unk[ipar]==(unk/.isol),{unk,unks}];
	deqns=Map[#==0&,D[eqns/.subrule,par]];	
	(* track root with NDSolve *)
	sol=NDSolve[Join[deqns,ics,whenevents],unks,{par,parmin,parmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	Return[sol]
	,
	method=="PseudoArcLength",
	subrule=Append[Table[unk->unk[s],{unk,unks}],par->par[s]];
	ics=Join[Table[unk[0]==(unk/.isol),{unk,unks}],{par[0]==ipar}];
	whenevents=Join[whenevents,{
		WhenEvent[par'[s]==0,AppendTo[breaks,s]],
		WhenEvent[par[s]==parmax,"StopIntegration"],
		WhenEvent[par[s]==parmin,"StopIntegration"]
	}];
	(*Print["whenevents="];Print[whenevents];*)
	deqns=Join[
		Map[#==0&,eqns/.subrule],
		{Total[D[unks/.subrule,s]]^2+D[par[s],s]^2==1},
		Table[unk'[0]==0,{unk,unks}],
		{par'[0]==1}
	];
	If[Global`debug,Print["deqns="];Print[deqns]];
	(* track root with NDSolve *)
	breaks={}; (* capture turning points *)
	sol=NDSolve[Join[deqns,ics,whenevents],Append[unks,par],{s,smin,smax},Evaluate[Sequence@@ndsolveopts]][[1]];
	(* beginning and ending s *)
	{s1,s2}=(par/.sol)["Domain"][[1]];
	(* add endpoints to breaks *)
	breaks=Sort[Join[{s1,s2},breaks]];
	(* construct interpolatingfunctions (unk vs par) for each segment (between breaks) *)
	res={};
	Do[
		respart={};
		Do[
			pts=Transpose[{(par/.sol)["Coordinates"][[1]],(par/.sol)["ValuesOnGrid"],(unk/.sol)["ValuesOnGrid"]}];
			AppendTo[respart,unk->Interpolation[Select[pts,breaks[[i]]<=#[[1]]<=breaks[[i+1]]&][[All,2;;3]],"ExtrapolationHandler"->{Indeterminate&,"WarningMessage"->False}]];
		,{unk,unks}];
		AppendTo[res,respart];
	,{i,Length[breaks]-1}];
	Return[res]
	,
	Else,
	Message[TrackRoot::badmtd];Return[$Failed]
];

]


(* no initpar - assume initpar=parmin *)
TrackRoot[eqns_List,unksnics_List,{par_Symbol,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=
TrackRoot[eqns,unksnics,{par,parmin,parmin,parmax},opts,SMin->0];

(* one equation, one unknown, no {} *)
TrackRoot[eqns_,unksnics_List,{par_Symbol,ipar_?NumericQ,parmin_?NumericQ,parmax_?NumericQ},opts___?OptionQ]:=
TrackRoot[{eqns},{unksnics},{par,ipar,parmin,parmax},opts];


Options[TrackRoot]={FindRootOpts->{},NDSolveOpts->{},Method->"PseudoArcLength",SMin->-100,SMax->100};


PartsAboveDiagonal[arr_?MatrixQ]:=Module[{dim},
	dim=Dimensions[arr];
	Flatten@Table[arr[[i,j]],{i,1,dim[[1]]},{j,i+1,dim[[2]]}]
]


(* by xzczd <https://mathematica.stackexchange.com/a/233122/6358> *)
PrintMessage[mess_, val__] := Print@StringForm[mess, val];


DoubleDotProduct::usage="DoubleDotProduct[]...";


DoubleDotProduct[A_?MatrixQ,B_?MatrixQ]:=Flatten[A] . Flatten[B];


Set\[ScriptCapitalN][attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{}]:=Module[{tmp,interxns,tnsp,pnsp,insp},
(*Print["In Set\[ScriptCapitalN], attributes=",attributes," variables=",variables];*)
(*Print[Table[\[ScriptCapitalN][gu]/.attributes,{gu,guilds}]];*)

If[ninteractions!=0,interxns=ExtractInteractions[attributes]];

Do[
	If[IntegerQ[\[FormalCapitalN][gu]/.attributes], (* if \[FormalCapitalN] passed, just use that *)
		tnsp[gu]=insp[gu]=(\[FormalCapitalN][gu]/.attributes),
		(*If[attributes\[NotEqual]{},*)
			(* tnsp = nsp determined from traits *)
			If[ngtraits[gu]!=0,
				(*tmp=Table[Max[Select[Select[attributes,#\[LeftDoubleBracket]1,0\[RightDoubleBracket]\[Equal]Subscript&],#\[LeftDoubleBracket]1,1\[RightDoubleBracket]\[Equal]gtrait&]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket]],{gtrait,gtraits[gu]}];*)
				tmp=Table[Max[Select[Select[attributes,#[[1,0]]==Subscript&],(#[[1,1]]==gtrait||#[[1,1,0]]==gtrait)&][[All,1,2]]],{gtrait,gtraits[gu]}];
(*Print[ExtractTraits[attributes,gu]];
Print[ExtractTraits[attributes,gu]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket]];
				tmp=ExtractTraits[attributes,gu]\[LeftDoubleBracket]All,1,2\[RightDoubleBracket];*)
				If[Length[Union[tmp]]==1,
					tnsp[gu]=tmp[[1]],
					Message[Set\[ScriptCapitalN]::badtrait,gu,tmp];
					Abort[]
				];
(*Print["tnsp[gu]=",tnsp[gu]];*)
				If[tnsp[gu]==-\[Infinity],tnsp[gu]=0];
			,
				tnsp[gu]=None
			];
			(* insp = nsp determined from interactions *)
			If[Length[interactionpos[gu]]!=0,
				tmp=Table[Max[Select[interxns,#[[1,1]]==pos[[1]]&][[All,1,pos[[2]]+1]]],{pos,interactionpos[gu]}];
				(*Print[tmp];*)
				If[Length[Union[tmp]]==1,
					insp[gu]=tmp[[1]],
					Message[Set\[ScriptCapitalN]::badinterxn,gu,tmp];
					Abort[]
				];
			,
				insp[gu]=None
			]
		(*];*)
	];
	If[IntegerQ[\[FormalCapitalN][gu]/.variables], (* if \[FormalCapitalN] passed, just use that *)
		pnsp[gu]=(\[FormalCapitalN][gu]/.variables),
		(*If[variables\[NotEqual]{},*)
			(* pnsp = nsp determined from variables *)
			tmp=Table[Max[Select[Select[variables,#[[1,0]]==Subscript&],#[[1,1]]==gcomp&][[All,1,2]]],{gcomp,gcomps[gu]}];
			If[Length[Union[tmp]]==1,
				pnsp[gu]=tmp[[1]],
				Message[Set\[ScriptCapitalN]::badcomm,gu,tmp];
				Abort[]
			];(*,
			pnsp[gu]=None
		];*)
(*Print["pnsp[gu]=",pnsp[gu]];*)
		If[pnsp[gu]==-\[Infinity],pnsp[gu]=0];
	];

	If[Global`debug,Print["Set\[ScriptCapitalN]: (",gu," tnsp=",tnsp[gu]," insp=",insp[gu]," pnsp=",pnsp[gu],")"]];
	
	Which[
		(* no traits given *)
		attributes=={},
		\[ScriptCapitalN][gu]=pnsp[gu],
		(* gu has traits & interactions *)
		ngtraits[gu]!=0&&Length[interactionpos[gu]]!=0,
		If[pnsp[gu]==tnsp[gu]==insp[gu]||(variables=={}&&tnsp[gu]==insp[gu]),
			\[ScriptCapitalN][gu]=tnsp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],tnsp[gu],insp[gu]}];
			Abort[]
		],
		(* gu has only interactions *)
		ngtraits[gu]==0&&Length[interactionpos[gu]]!=0,
		If[pnsp[gu]==insp[gu]||variables=={},
			\[ScriptCapitalN][gu]=insp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],None,insp[gu]}];
			Abort[]
		],
		(* gu has only traits *)
		ngtraits[gu]!=0&&Length[interactionpos[gu]]==0,
		If[pnsp[gu]==tnsp[gu]||variables=={},
			\[ScriptCapitalN][gu]=tnsp[gu],
			Message[Set\[ScriptCapitalN]::badnsp,gu,{pnsp[gu],insp[gu],None}];
			Abort[]
		]
	]
,{gu,guilds}]

]/;(nguilds!=0);


Set\[ScriptCapitalN]::badnsp=
"Number of species in guild `1` inconsistent: {pnsp,tnsp,insp}= `2`.";

Set\[ScriptCapitalN]::badtrait=
"Number of traits in guild `1` inconsistent: `2`.";

Set\[ScriptCapitalN]::badcomm=
"Number of components in guild `1` inconsistent: `2`.";

Set\[ScriptCapitalN]::badinterxn=
"Number of interactions in guild `1` inconsistent: `2`.";


FromUnks::usage="Internal usage only ;)";
ToUnks::usage="Internal usage only ;)";
ToUnkRules::usage="Internal usage only ;)";


FromUnks:=Unk[stuff___]->stuff


ToUnks:=Flatten[{
	Table[Table[Subscript[gcomp,\[FormalS]_]->Unk[Subscript[gcomp,\[FormalS]]],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}],
	Table[Table[Subscript[gtrait,\[FormalS]_]->Unk[Subscript[gtrait,\[FormalS]]],{gtrait,gtraits[gu]}],{gu,guilds}]
}]


ToUnkRules:=Flatten[Join[
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]_][t])->(Subscript[gcomp,\[FormalS]]->Unk[Subscript[gcomp,\[FormalS]]][t])
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[(pcomp->pcomp)->(pcomp->Unk[pcomp]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[(pcomp->pcomp[t])->(pcomp->Unk[pcomp][t]),{pcomp,pcomps[pop]}],{pop,pops}],
	Table[(aux->aux)->(aux->Unk[aux]),{aux,auxs}],
	Table[(aux->aux[t])->(aux->Unk[aux][t]),{aux,auxs}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]])
	,{gtrait,gtraits[gu]}],{gu,guilds}],
	Table[Table[
		(Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]_][t])->(Subscript[gtrait,\[FormalS]]->Unk[Subscript[gtrait,\[FormalS]]][t])
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]]


AllTraits::usage="Internal usage only ;)";
AllVariables::usage="Internal usage only ;)";
AllPopsAndAuxs::usage="Internal usage only ;)";


AllTraits:=Flatten[Table[Table[Table[
	{Subscript[gtrait,sp],Table[Subscript[gtrait[gcomp],sp],{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


AllVariables:=Flatten[Join[
	Table[Table[Table[Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


AllPopsAndAuxs:=Flatten[Join[
	Table[Table[pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux,{aux,auxs}]
]];


BlankTraits::usage="Internal usage only ;)";
BlankUnkTraits::usage="Internal usage only ;)";
BlankVariables::usage="Internal usage only ;)";
BlankUnkVariables::usage="Internal usage only ;)";


BlankTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Subscript[gtrait,sp],{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


BlankUnkTraits:=Flatten[
	Table[Table[Table[Subscript[gtrait,sp]->Unk[Subscript[gtrait,sp]],{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]];


BlankVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Subscript[gcomp,sp],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->aux,{aux,auxs}]
]];


BlankUnkVariables:=Flatten[Join[				
	Table[Table[Table[Subscript[gcomp,sp]->Unk[Subscript[gcomp,sp]],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->Unk[pcomp],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Unk[aux],{aux,auxs}]
]];


FixAttributes::usage="Internal usage only ;)";
FixVariables::usage="Internal usage only ;)";


FixAttributes[attributes_]:=attributes/.(var_->arr_?ArrayQ):>Sequence@@ArrayToRuleList[var,arr]/.{Subscript[\[ScriptCapitalN], gu_]->Subscript[\[FormalCapitalN], gu],\[ScriptCapitalN][gu_]->\[FormalCapitalN][gu]};


FixVariables[variables_]:=variables/.{Subscript[\[ScriptCapitalN], gu_]->Subscript[\[FormalCapitalN], gu],\[ScriptCapitalN][gu_]->\[FormalCapitalN][gu]};


ExpandTraits::usage="Expand traits across components.";


ExpandTraits[rulelist_]:=rulelist/.Flatten@Table[Table[
	(Subscript[trait, i_]->val_)->(Sequence@@Prepend[Table[Subscript[trait[gcomp], i]->val,{gcomp,gcomps[gu]}],Subscript[trait, i]->val])
,{trait,gtraits[gu]}],{gu,guilds}]


ExpandGs::usage="Expand variance/covariances across components.";


ExpandGs[rulelist_]:=rulelist/.Flatten@Table[
	If[ngcomps[gu]==1,
		Table[
			(entry->val_)->(Sequence@@{entry->val,Subscript[entry, _]->val})
		,{entry,Flatten@MakeGMatrix[gu]}]
	,
		Table[{
			(Subscript[entry, i_]->val_)->(Sequence@@Prepend[Table[Subscript[entry[gcomp], i]->val,{gcomp,gcomps[gu]}],Subscript[entry, i]->val]),
			(entry->val_)->(Sequence@@Prepend[Table[Subscript[entry[gcomp], _]->val,{gcomp,gcomps[gu]}],entry->val])}
		,{entry,Flatten@MakeGMatrix[gu]}]
	]
,{gu,guilds}]


ExpRule::usage="Internal: make rule list var[t]\[Rule]E^log[var][t] for all logged vars.";


(*ExpRule[vars_List,logged_]:=DeleteCases[Table[If[logged===True&&comptype[var]==="Extensive",var[t]\[Rule]E^log[var][t]],{var,vars}],Null];*)
ExpRule[vars_List,logged_]:=DeleteCases[Flatten@Table[If[logged===True&&comptype[var]==="Extensive",{var[t]->E^log[var][t],(var->Unk[var][t])->(var->E^log[Unk[var]][t])}],{var,vars}],Null];


AddUnkts::usage="Internal usage only ;)";
AddVariablets::usage="Internal usage only ;)";
AddTraitts::usage="Internal usage only ;)";
AddVarCovts::usage="Internal usage only ;)";
FixVarCovts::usage="Internal usage only ;)";
RemoveVariablets::usage="Internal usage only ;)";
RemoveTraitts::usage="Internal usage only ;)";
RemoveVarCovts::usage="Internal usage only ;)";


AddUnkts:=(var_->Unk[stuff___])->(var->Unk[stuff][t]);


AddVariablets:=DeleteDuplicates[Flatten[Join[
	Table[Table[
		{(*Subscript[gcomp,\[FormalS]_]'\[Rule]Subscript[gcomp,\[FormalS]]'[t],*)Subscript[gcomp,\[FormalS]_]->Subscript[gcomp,\[FormalS]][t],Unk[gcomp,\[FormalS]_]->Unk[gcomp,\[FormalS]][t]}
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[
		{pcomp->pcomp[t],Unk[pcomp]->Unk[pcomp][t]}
	,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[{aux->aux[t],Unk[aux]->Unk[aux][t]},{aux,auxs}]
]]];


AddTraitts:=Flatten[
	Table[Table[{
		Subscript[gtrait,\[FormalS]_]->Subscript[gtrait,\[FormalS]][t],
		Table[Subscript[gtrait[gcomp], \[FormalS]_]->Subscript[gtrait[gcomp], \[FormalS]][t],{gcomp,gcomps[gu]}],
		Unk[gtrait,\[FormalS]_]->Unk[gtrait,\[FormalS]][t]
		}
	,{gtrait,gtraits[gu]}],{gu,guilds}]
];


AddVarCovts:=Flatten[
	Table[Table[{
		Table[{
			Subscript[Var[gtrait][gcomp],\[FormalS]_]->Subscript[Var[gtrait][gcomp],\[FormalS]][t],
			Table[Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}]
			}
		,{gcomp,gcomps[gu]}],
		{Subscript[Var[gtrait],\[FormalS]_]->Subscript[Var[gtrait],\[FormalS]][t]},
		Table[Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}]}
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]


FixVarCovts:={Var[Subscript[\[FormalT]_,\[FormalS]_][t]]->Var[Subscript[\[FormalT],\[FormalS]]][t],Cov[Subscript[\[FormalT]_,\[FormalS]_][t],Subscript[\[FormalCapitalT]_,\[FormalS]_][t]]->Cov[Subscript[\[FormalT],\[FormalS]],Subscript[\[FormalCapitalT],\[FormalS]]][t]};


RemoveVariablets:=DeleteDuplicates[Flatten[Join[
	Table[Table[
		Subscript[gcomp,\[FormalS]_][t]->Subscript[gcomp,\[FormalS]]
	,{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[pcomp[t]->pcomp,{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux[t]->aux,{aux,auxs}]
]]];


RemoveTraitts:=Flatten[Table[Table[{
	Subscript[gtrait,\[FormalS]_][t]->Subscript[gtrait,\[FormalS]],
	Table[Subscript[gtrait[gcomp],\[FormalS]_][t]->Subscript[gtrait[gcomp],\[FormalS]],{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{gu,guilds}]];


(* ::Code::Initialization:: *)
RemoveVarCovts:=Flatten[Table[Table[{
	Subscript[Var[gtrait],\[FormalS]_][t]->Subscript[Var[gtrait],\[FormalS]],
	Table[Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}],
	Table[{
		Subscript[Var[gtrait][gcomp],\[FormalS]_][t]->Subscript[Var[gtrait][gcomp],\[FormalS]],
		Table[Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]_]->Subscript[Cov[gtrait,gtrait\[Prime]][gcomp],\[FormalS]][t],{gtrait\[Prime],gtraits[gu]}]}
	,{gcomp,gcomps[gu]}]}
,{gtrait,gtraits[gu]}],{gu,guilds}]];


DefaultICs::usage="Internal usage only ;)";


DefaultICs:=Quiet[Flatten[{
	Table[Table[Table[Subscript[gcomp,sp]->Min[(Min[range[gcomp]]+Max[range[gcomp]])/2,Min[range[gcomp]]+1],{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[Table[pcomp->Min[(Min[range[pcomp]]+Max[range[pcomp]])/2,Min[range[pcomp]]+1],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[aux->Min[(Min[range[aux]]+Max[range[aux]])/2,Min[range[aux]]+1],{aux,auxs}]
}]/.Indeterminate->0,{Infinity::indet}];


SetAttributes[DoubleRightArrow,HoldAllComplete];


UnpackDoubleRightArrows::usage="";


UnpackDoubleRightArrows[DoubleRightArrow[Times[c1_,var1_],Times[c2_,var2_]]]:={c1,var1,c2,var2};
UnpackDoubleRightArrows[DoubleRightArrow[var1_,Times[c2_,var2_]]]:={1,var1,c2,var2};
UnpackDoubleRightArrows[DoubleRightArrow[Times[c1_,var1_],var2_]]:={c1,var1,1,var2};
UnpackDoubleRightArrows[DoubleRightArrow[var1_,var2_]]:={1,var1,1,var2};


DoubleRightArrowsToTrans:={
DoubleRightArrow[Times[c1_,var1_],Times[c2_,var2_]]->{var1->var1-c1,var2->var2+c2},
DoubleRightArrow[var1_,Times[c2_,var2_]]->{var1->var1-1,var2->var2+c2},
DoubleRightArrow[Times[c1_,var1_],var2_]->{var1->var1-c1,var2->var2+1},
DoubleRightArrow[var1_,var2_]->{var1->var1-1,var2->var2+1}
}


AddProceduralToSum::usage="Add Method->\"Procedural\" to Sum[\!\(\*
StyleBox[\"stuff\", \"TI\"]\), {\!\(\*
StyleBox[\"ind\", \"TI\"]\), \[ScriptCapitalN][\!\(\*
StyleBox[\"gu\", \"TI\"]\)]}]'s.";


AddProceduralToSum[expr_]:=
Inactivate[expr,Sum]/.Inactive[Sum][stuff___,{ind_,\[ScriptCapitalN][gu_]}]->Sum[stuff,{ind,\[ScriptCapitalN][gu]},Method->"Procedural"]


EcoEvoDocs::usage="EcoEvoDocs opens the main EcoEvo guide.";


EcoEvoDocs:=(NotebookOpen["paclet:EcoEvo/guide/EcoEvo"];Null);


ExtractInteractions::usage=
"ExtractInteractions[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts interactions from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractTraits::usage=
"ExtractTraits[x] extracts traits from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).
ExtractTraits[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] extracts only traits from guild or species \!\(\*
StyleBox[\"target\", \"TI\"]\).";

ExtractAttributes::usage=
"ExtractAttributes[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts traits and interactions from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractGuilds::usage=
"ExtractGuilds[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts guilds from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).
ExtractGuilds[\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] extracts only guilds from guild or species \!\(\*
StyleBox[\"target\", \"TI\"]\).";

ExtractPops::usage=
"ExtractPops[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractAuxs::usage=
"ExtractAuxs[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts auxs from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractVariables::usage=
"ExtractVariables[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops, guilds, and auxs from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractSpecies::usage=
"ExtractSpecies[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts pops and guilds from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";

ExtractVarCovs::usage=
"ExtractVarCovs[\!\(\*
StyleBox[\"x\", \"TI\"]\)] extracts trait variances and covariances from rulelist or list-of-rulelists \!\(\*
StyleBox[\"x\", \"TI\"]\).";


ExtractInteractions[in_?RuleListQ]:=Module[{pattern},
	pattern=Join[
		interactions,
		Table[Subscript[interaction, _,_],{interaction,interactions}],
		Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
		Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}]
	];
	Return[FilterRules[in,pattern]]
];


ExtractTraits[in_?RuleListQ,target_:All]:=Module[{res,pattern,gu,sp},
	Which[
		target===All,
		pattern=Join[
			Flatten[Table[Table[Subscript[gtrait, _],{gtrait,gtraits[gu]}],{gu,guilds}]],
			Flatten[Table[Table[Table[Subscript[gtrait[gcomp], _],{gcomp,gcomps[gu]}],{gtrait,gtraits[gu]}],{gu,guilds}]],
			Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
			Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}]
		],
		Head[target]===Subscript,
		gu=target[[1]];sp=target[[2]];
		pattern=Table[Subscript[gtrait, sp],{gtrait,gtraits[gu]}],
		Else,
		gu=target;
		pattern=Join[
			Table[Subscript[gtrait, _],{gtrait,gtraits[gu]}],
			Flatten[Table[Table[Subscript[gtrait[gcomp], _],{gcomp,gcomps[gu]}],{gtrait,gtraits[gu]}]],
			{Subscript[\[ScriptCapitalN], gu],Subscript[\[FormalCapitalN], gu]}]
	];
	(*Print["pattern=",pattern];*)
	res=FilterRules[in,pattern];
	Return[res]
];


ExtractAttributes[in_?RuleListQ]:=Union[ExtractTraits[in],ExtractInteractions[in]];


ExtractGuilds[in_?RuleListQ,target_:All]:=Module[{res,pattern,gu,sp},
	Which[
		target===All,
		pattern=Join[
			Flatten[Table[Table[Subscript[gcomp, _],{gcomp,gcomps[gu]}],{gu,guilds}]],
			Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
			Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}],
			Table[Subscript[gu, _],{gu,guilds}]
		],
		Head[target]===Subscript,
		gu=target[[1]];sp=target[[2]];
		pattern=Join[Table[Subscript[gcomp, sp],{gcomp,gcomps[gu]}],{Subscript[gu, sp]}],
		Else,
		gu=target;
		pattern=Join[Table[Subscript[gcomp, _],{gcomp,gcomps[gu]}],{Subscript[gu, _],Subscript[\[ScriptCapitalN], gu]}]
	];
	(*Print["pattern=",pattern];*)
	res=FilterRules[in,pattern];
	Return[res]
];


ExtractAuxs[in_?RuleListQ]:=FilterRules[in,auxs];


ExtractPops[in_?RuleListQ]:=FilterRules[in,Flatten[Table[pcomps[pop],{pop,pops}]]];


ExtractVariables[in_?RuleListQ]:=Union[ExtractAuxs[in],ExtractPops[in],ExtractGuilds[in]];


ExtractSpecies[in_?RuleListQ]:=Union[ExtractPops[in],ExtractGuilds[in]];


ExtractVarCovs[in_?RuleListQ,target_:All]:=Module[{res,pattern,gu,sp},
	Which[
		target===All,
		pattern=Join[
			Flatten[Table[Table[
				{Var[gtrait],Subscript[Var[gtrait], _],
				Table[{Var[gtrait][gcomp],Subscript[Var[gtrait][gcomp], _]},{gcomp,gcomps[gu]}],
				Table[
					{Cov[gtrait,gtrait\[Prime]],Subscript[Cov[gtrait,gtrait\[Prime]], _],
					Table[{Cov[gtrait,gtrait\[Prime]][gcomp],Subscript[Cov[gtrait,gtrait\[Prime]][gcomp], _]},{gcomp,gcomps[gu]}]}
				,{gtrait\[Prime],gtraits[gu]}]}
				,{gtrait,gtraits[gu]}],{gu,guilds}]],
			Table[Subscript[\[ScriptCapitalN], gu],{gu,guilds}],
			Table[Subscript[\[FormalCapitalN], gu],{gu,guilds}]
		]
	];
	(*Print["pattern=",pattern];*)
	res=FilterRules[in,pattern];
	Return[res]
];


(* make Listable *)
ExtractTraits[in_?RuleListListQ,target___]:=ExtractTraits[#,target]&/@in;
ExtractTraits[in_?RuleListQ,target_List]:=Flatten[Union[ExtractTraits[in,#]&/@target]];
ExtractInteractions[in_?RuleListListQ]:=ExtractInteractions/@in;
ExtractAttributes[in_?RuleListListQ]:=ExtractAttributes/@in;
ExtractGuilds[in_?RuleListListQ,target___]:=ExtractGuilds[#,target]&/@in;
ExtractGuilds[in_?RuleListQ,target_List]:=Flatten[Union[ExtractGuilds[in,#]&/@target]];
ExtractAuxs[in_?RuleListListQ]:=ExtractAuxs/@in;
ExtractPops[in_?RuleListListQ]:=ExtractPops/@in;
ExtractVariables[in_?RuleListListQ]:=ExtractVariables/@in;
ExtractSpecies[in_?RuleListListQ]:=ExtractSpecies/@in;


TraitsQ::usage=
"TraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits.";

InteractionsQ::usage=
"InteractionsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of interactions.";

AttributesQ::usage=
"AttributesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits and/or interactions.";

VariablesQ::usage=
"VariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of variables.";

ListOfVariablesQ::usage=
"ListOfVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of rulelists of variables.";

AttributesAndVariablesQ::usage=
"AttributesAndVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of attributes (traits or interactions) and variables (auxs, pops, guilds).";

AttributesVariablesAndGsQ::usage=
"AttributesAndVariablesQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of attributes (traits or interactions), variables (auxs, pops, guilds), and trait variance/covariances.";

AttributesAndGsQ::usage=
"AttributesAndGsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of attributes (traits or interactions), and trait variance/covariances.";


TraitsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="gtrait"||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


InteractionsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="interaction"||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


AttributesQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(First@LookUp[#[[1]]]==="gtrait"||First@LookUp[#[[1]]]==="interaction"||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


VariablesQ[list_]:=list==="FindEcoAttractor"||VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(MemberQ[{"pcomp","gcomp","aux"},First@LookUp[#[[1]]]]||#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])&]


AttributesAndVariablesQ[list_]:=
If[RuleListQ[list]&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!=list&&
	FixVariables[ExtractVariables[list]]=!=list,
	True,False,False]


ListOfVariablesQ[x_]:=If[x==={},False,VectorQ[x,VariablesQ[#]&]];


(* ::Code::Initialization:: *)
AttributesVariablesAndGsQ[list_]:=
If[RuleListQ[list]&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!=list&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!={}&&
	FixVariables[ExtractVariables[list]]=!=list&&
	FixVariables[ExtractVariables[list]]=!={}&&
	ExtractVarCovs[list]=!=list&&
	ExtractVarCovs[list]=!={},
	True,False,False]


(* ::Code::Initialization:: *)
AttributesAndGsQ[list_]:=
If[RuleListQ[list]&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!=list&&
	FixAttributes[Union[ExtractTraits[list],ExtractInteractions[list]]]=!={}&&
	ExtractVariables[list]==={}&&
	ExtractVarCovs[list]=!=list&&
	ExtractVarCovs[list]=!={},
	True,False,False]


GsQ::usage=
"GsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a list of G matrices or V variances.";


GsQ[list_]:=VectorQ[list,(#[[0]]===Rule||#[[0]]===RuleDelayed)&&(
	(MemberQ[{G,V},#[[1,0]]])||
	MemberQ[{Var,Cov},#[[1,1,0,0]]]||
	MemberQ[{Var,Cov},#[[1,1,0]]]||
	MemberQ[{Var,Cov},#[[1,0]]]
	)&];


InvaderQ::usage=
"InvaderQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a possible invader.";

NotInvaderTraitsQ::usage=
"NotInvaderTraitsQ[\!\(\*
StyleBox[\"x\", \"TI\"]\)] returns True if \!\(\*
StyleBox[\"x\", \"TI\"]\) is a rulelist of traits with no invaders.";


InvaderQ[x_]:=If[
	x===Automatic ||
	MemberQ[Join[Flatten[Table[pcomps[pop],{pop,pops}]],pops],x]||
	(LookUp[x][[1]]==="gcomp"||LookUp[x][[1]]==="guild")||
	(x[[0]]===Rule&&Length[LookUp[x[[1]]]]>=4&&LookUp[x[[1]]][[{1,4}]]==={"gtrait",0})||
	VectorQ[x,#[[0]]===Rule&&Length[LookUp[#[[1]]]]>=4&&LookUp[#[[1]]][[{1,4}]]==={"gtrait",0}&]||
	(x[[0]]===Rule&&Length[LookUp[x[[1]]]]>=5&&LookUp[x[[1]]][[{1,5}]]==={"interaction",0})||
	VectorQ[x,#[[0]]===Rule&&Length[LookUp[#[[1]]]]>=5&&LookUp[#[[1]]][[{1,5}]]==={"interaction",0}&],
	True,False];


NotInvaderTraitsQ[list_]:=VectorQ[list,
	(#[[0]]===Rule||#[[0]]===RuleDelayed)&&
	((LookUp[#[[1]]][[1]]==="gtrait"&&LookUp[#[[1]]][[4]]=!=0)||
	(LookUp[#[[1]]][[1]]==="interaction"&&(Length[LookUp[#[[1]]]]==4||LookUp[#[[1]]][[5]]=!=0))||
	#[[1,0]]===\[ScriptCapitalN]||#[[1,0]]===\[FormalCapitalN])
&];


DeleteInvaders::usage=
"DeleteInvaders[\!\(\*
StyleBox[\"list\", \"TI\"]\)] removes invaders (with subscript 0) from \!\(\*
StyleBox[\"list\", \"TI\"]\).";


DeleteInvaders[list_List]:=DeleteCases[list,Subscript[_,0,___]->_];


SelectValid::usage=
"SelectValid[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects valid solutions in list of rule lists \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


SelectValid[sol:(_?RuleListListQ):{}]:=Module[{res},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

res={};
Do[
	If[CompoundAnd[Flatten@Table[
		Which[
			Head[el[[2]]]===TemporalData,
			Map[IntervalMemberQ[range[el[[1]]],#]&,Normal[el[[2]]][[All,2]]],
			Else,
			IntervalMemberQ[range[el[[1]]],el[[2]]]
			(*Min[range[el\[LeftDoubleBracket]1\[RightDoubleBracket]]]\[LessEqual]el\[LeftDoubleBracket]2\[RightDoubleBracket]\[LessEqual]Max[range[el\[LeftDoubleBracket]1\[RightDoubleBracket]]]*)
		]
	,{el,eq}]],AppendTo[res,eq]]
,{eq,sol}];

Return[res]

];


SplitSpecies::usage=
"SplitSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] splits \!\(\*
StyleBox[\"target\", \"TI\"]\) in two.
SplitSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"dtraits\", \"TI\"]\)] uses distance \!\(\*
StyleBox[\"dtraits\", \"TI\"]\).";


SplitSpecies[sol_?AttributesAndVariablesQ,target_,dtraitsin_:Automatic]:=Module[{
func=FuncStyle["SplitSpecies"],
(* options *)
(* other variables *)
gu,sp,dtraits,ecomps,tmp
},

Block[{\[ScriptCapitalN]},

(* figure out target sp *)
{gu,sp}=LookUp[target][[{2,4}]];

Which[
	dtraitsin===Automatic,
	dtraits=Table[trait->0.01,{trait,gtraits[gu]}],
	NumericQ[dtraitsin],
	dtraits=Table[trait->dtraitsin,{trait,gtraits[gu]}],
	Else,
	dtraits=dtraitsin
];
(*Print["dtraits=",dtraits];*)

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractAttributes[sol],ExtractVariables[sol]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

ecomps=Select[gcomps[gu],comptype[#]=="Extensive"&];

(* split target species' extensive components *)
tmp=sol/.Table[(Subscript[var, sp]->val_)->(Subscript[var, sp]->val/2),{var,ecomps}];
(*Print[tmp];*)

(* add new species' components *)
tmp=Join[tmp,Table[Subscript[var, \[ScriptCapitalN][gu]+1]->(Subscript[var, sp]/.tmp),{var,gcomps[gu]}]];
(*Print[tmp];*)

(* add new species' traits *)
tmp=Join[tmp,Table[Subscript[trait, \[ScriptCapitalN][gu]+1]->((Subscript[trait, sp]/.tmp)+(trait/.dtraits)),{trait,gtraits[gu]}]];
(*Print[tmp];*)

(* change target species' traits *)
tmp=RuleListSubtract[tmp,Table[Subscript[trait, sp]->(trait/.dtraits),{trait,gtraits[gu]}]];
(*Print[tmp];*)

Return[Sort[tmp]];
]];


SetModel::usage=
"SetModel[\!\(\*
StyleBox[\"model\", \"TI\"]\)] sets an EcoEvo \!\(\*
StyleBox[\"model\", \"TI\"]\) for analysis.";


SetModel[model_?RuleListQ,opts___?OptionQ]:=Module[{
(* options *)
colors,linestyles,plotmarkers,assumptions,parametersin,
(* other *)
parameterstmp,parintervals,stylecount,basestyle,indexcount,in,gradients,gradient,
sourcec,source,destc,dest},

(* options *)
colors=Evaluate[Colors/.Flatten[{opts,Options[SetModel]}]];
linestyles=Evaluate[LineStyles/.Flatten[{opts,Options[SetModel]}]];
plotmarkers=Evaluate[PlotMarkers/.Flatten[{opts,Options[SetModel]}]];
assumptions=Evaluate[Assumptions/.Flatten[{model,Options[SetModel]}]];

ClearParameters;UnsetModel;

parametersin=Evaluate[Parameters/.Flatten[{model,Options[SetModel]}]];
parameterstmp=Cases[parametersin,_Symbol|_Symbol[_],\[Infinity]];
(*Print["parameterstmp=",parameterstmp];*)
parintervals=InequalityToInterval/@parametersin;
(*Print["parintervals=",parintervals];*)
If[Length[parameterstmp]!=Length[parintervals]||MemberQ[parameterstmp,_?BooleanQ],Message[SetModel::badpar];Return[$Failed]];

(*Print["SetModel"];*)

modelloaded=True;

(* model name - default="UnnamedModel"*)
modelname=ModelName/.Append[model,ModelName->"UnnamedModel"];

(* model type - default="ContinuousTime" *)
modeltype=ModelType/.Append[model,ModelType->"ContinuousTime"];
If[!MemberQ[{"ContinuousTime","DiscreteTime"},modeltype],Message[SetModel::unktype]];

(* model whenevents - default={} *)
modelwhenevents:=WhenEvents/.Append[model,WhenEvents->{}];

(* period - default=0 (unforced) *)
modelperiod:=Period/.Append[model,Period->0];

(* parameters *)

parameters=parameterstmp;
parnames=ToString/@parameters;
Do[
	range[parameters[[i]]]=parintervals[[i]]
,{i,Length[parameters]}];

stylecount=0;

(* auxs *)

(*Print["Auxs"];*)
If[(Auxs/.model)===Auxs,
	auxs=Select[model,#[[1,0]]==Aux&][[All,1,1]],
	auxs=Auxs/.model
];
(*Print["auxs=",auxs];*)
naux=Length[auxs];
(*Print["naux=",naux];*)
auxeqn[au_]:=Equation/.(Aux[au]/.model);

Do[
	stylecount++;
	type[aux]="aux";
	in=Aux[aux]/.model;
	range[aux]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
	color[aux]=color[_[aux]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
	linestyle[aux]=linestyle[_[aux]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
	plotmarker[aux]=plotmarker[_[aux]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
	LookUp[aux]=LookUp[_[aux]]={"aux",aux};
,{aux,auxs}];


(* pops *)

(*Print["Pops"];*)
pops=Select[model,#[[1,0]]==Pop&][[All,1,1]];
(*Print["pops=",pops];*)
npops=Length[pops];
(*Print["npops=",npops];*)
pcompeqn[pop_,pco_]:=Equation/.If[RuleListQ[Component[pco]/.(Pop[pop]/.model)],Component[pco]/.(Pop[pop]/.model),Pop[pop]/.model];

Do[
	in=Pop[pop]/.model;
	type[pop]="pop";
	LookUp[pop]={"pop",pop};
	comps[pop]=pcomps[pop]=Select[in,#[[1,0]]==Component&][[All,1,1]];
	If[pcomps[pop]=={},comps[pop]=pcomps[pop]={pop}];
	(*Print["pcomps["<>ToString@pop<>"]=",pcomps[pop]];*)
	ncomps[pop]=npcomps[pop]=Length[pcomps[pop]];
	(*Print["npcomps["<>ToString[pop]<>"]=",npcomps[pop]];*)
	Do[
		stylecount++;
		type[pcomp]="pcomp";
		in=If[RuleListQ[Component[pcomp]/.(Pop[pop]/.model)],Component[pcomp]/.(Pop[pop]/.model),Pop[pop]/.model];
		comptype[pcomp]=Type/.Append[in,Type->"Extensive"];
		range[pcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		color[pcomp]=color[_[pcomp]]=Color/.Append[in,Color->ModPart[colors,stylecount]];
		linestyle[pcomp]=linestyle[_[pcomp]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[pcomp]=plotmarker[_[pcomp]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[pcomp]=LookUp[_[pcomp]]={"pcomp",pop,pcomp};
	,{pcomp,pcomps[pop]}];
,{pop,pops}];


(* guilds *)

(*Print["Guilds"];*)
stylecount=0;

If[(Guilds/.model)===Guilds,
	guilds=Select[model,#[[1,0]]==Guild&][[All,1,1]],
	guilds=Guilds/.model
];
(*Print["guilds=",guilds];*)
nguilds=Length[guilds];
(*Print["nguilds=",nguilds];*)

Do[
	(*Print["Guild[",gu,"]=",Guild[gu]/.model];*)
	type[gu]="guild";
	LookUp[gu]={"guild",gu};
	If[(Components/.(Guild[gu]/.model))===Components,
		(*Print["old comps"];*)
		comps[gu]=gcomps[gu]=Select[Guild[gu]/.model,#[[1,0]]==Component&][[All,1,1]];
		If[Length[gcomps[gu]]==0,comps[gu]=gcomps[gu]={Guild[gu][[1]]}]
	,
		(*Print["new comps"];*)
		comps[gu]=gcomps[gu]=Components/.(Guild[gu]/.model)
	];
	(*Print["comps[",gu,"]=",comps[gu]];*)
	comps[Subscript[gu_,sp_]]:=Replace[comps[gu],var_->Subscript[var,sp],1];
	ncomps[gu]=ngcomps[gu]=Length[gcomps[gu]];
	If[(Traits/.(Guild[gu]/.model))===Traits,
		(*Print["old traits"];*)
		gtraits[gu]=Select[Guild[gu]/.model,#[[1,0]]==Trait&][[All,1,1]],
		(*Print["new traits"];*)
		gtraits[gu]=Cases[(Traits/.(Guild[gu]/.model)),_Symbol,\[Infinity]];
		(*Print["gtraits[gu]=",gtraits[gu]];*)
		ranges=InequalityToInterval/@(Traits/.(Guild[gu]/.model));
		(*Print["ranges=",ranges];*)
		Do[
			range[gtraits[gu][[i]]]=ranges[[i]];
			range[Subscript[gtraits[gu][[i]],_]]=ranges[[i]];
		,{i,Length[gtraits[gu]]}];
	];
	ngtraits[gu]=Length[gtraits[gu]];
	(*Print["{gcomps[",gu,"], gtraits[",gu,"]}=",{gcomps[gu],gtraits[gu]}];*)

	If[nguilds==1&&ngcomps[guilds[[1]]]==1&&ngtraits[guilds[[1]]]==1,
		gradients={"Rainbow"},
		gradients={"EEGreens","EEReds","EEBlues"}
	];
	indexcount=0;
	Do[
		indexcount++;
		stylecount++;
		basestyle[gu]=stylecount;
		in=If[RuleListQ[Component[gcomp]/.(Guild[gu]/.model)],Component[gcomp]/.(Guild[gu]/.model),Guild[gu]/.model];
		type[Subscript[gcomp,_]]="gcomp";
		index[Subscript[gcomp,_]]=index[gcomp]=indexcount;
		comptype[Subscript[gcomp,_]]=comptype[gcomp]=Type/.Append[in,Type->"Extensive"];
		range[Subscript[gcomp,_]]=range[gcomp]=Range/.Append[in,Range->Interval[{0,\[Infinity]}]];
		gradient=Color/.Append[in,Color->ModPart[gradients,stylecount]];
		color[Subscript[gcomp,_]]=color[_[Subscript[gcomp,_]]]=With[{cd=ColorData[gradient]},cd[#]&];
		color[gcomp]=color[_[gcomp]]=With[{cd=ColorData[gradient]},cd[0.5]];
		linestyle[Subscript[gcomp,_]]=linestyle[gcomp]=linestyle[_[gcomp]]=LineStyle/.Append[in,LineStyle->ModPart[linestyles,stylecount]];
		plotmarker[Subscript[gcomp,_]]=plotmarker[gcomp]=plotmarker[_[gcomp]]=PlotMarker/.Append[in,PlotMarker->ModPart[plotmarkers,stylecount]];
		LookUp[gcomp]=LookUp[_[gcomp]]={"gcomp",gu,gcomp};
		LookUp[Subscript[gcomp,sp_]]=LookUp[_[Subscript[gcomp,sp_]]]={"gcomp",gu,gcomp,sp};
		If[transitions===Transitions,
			eqn[Subscript[gcomp, i_]]:=Evaluate[Equation/.If[RuleListQ[Component[gcomp]/.(Guild[gu]/.model)],Component[gcomp]/.(Guild[gu]/.model),Guild[gu]/.model]/.\[FormalI]->i],
			dndt[gcomp]=dxdt[gcomp]=dGdt[gcomp]={};
		];
	,{gcomp,gcomps[gu]}];

	(*If[transitions=!=Transitions,
	Print[Flatten@Table[Subscript[gtrait[gcomp], \[FormalI]],{gcomp,gcomps[gu]},{gtrait,gtraits[gu]}]];
		fgs[gu]=Normal[D[#,{Flatten@Table[Subscript[gtrait[gcomp], \[FormalI]],{gcomp,gcomps[gu]},{gtrait,gtraits[gu]}]}]&/@percapitaeqns];
		Print["fgs[",gu,"]=",fgs[gu]];
	];*)
	indexcount=0;
	Do[
		indexcount++;
		stylecount=basestyle[gu];
		If[(Traits/.(Guild[gu]/.model))===Traits,
			in=Trait[gtrait]/.(Guild[gu]/.model),
			in={}
		];
		type[Subscript[gtrait,_]]="gtrait";
		index[Subscript[gtrait,_]]=index[gtrait]=indexcount;
		If[(Traits/.(Guild[gu]/.model))===Traits,
			range[Subscript[gtrait,_]]=range[gtrait]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]]
		];
		gradient=Color/.Join[in,Guild[gu]/.model,{Color->ModPart[gradients,stylecount]}];
		color[Subscript[gtrait,_]]=color[_[Subscript[gtrait,_]]]=With[{cd=ColorData[gradient]},cd[#]&];
		color[gtrait]=color[_[gtrait]]=With[{cd=ColorData[gradient]},cd[0.5]];
		linestyle[Subscript[gtrait,_]]=linestyle[gtrait]=linestyle[_[gtrait]]=LineStyle/.Join[in,Guild[gu]/.model,{LineStyle->ModPart[linestyles,stylecount]}];
		plotmarker[Subscript[gtrait,_]]=plotmarker[gtrait]=PlotMarker/.Join[in,Guild[gu]/.model,{PlotMarker->ModPart[plotmarkers,stylecount]}];
		LookUp[gtrait]=LookUp[_[gtrait]]={"gtrait",gu,gtrait};
		LookUp[Subscript[gtrait,sp_]]=LookUp[_[Subscript[gtrait,sp_]]]={"gtrait",gu,gtrait,sp};
		Do[
			LookUp[Subscript[gtrait[gcomp],sp_]]=LookUp[_[Subscript[gtrait[gcomp],sp_]]]={"gtrait",gu,gtrait[gcomp],sp};
		,{gcomp,gcomps[gu]}];
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];


(* interactions *)

interactions=Select[model,#[[1,0]]==Interaction&][[All,1,1]];
(*Print["interactions=",interactions];*)
ninteractions=Length[interactions];
(*Print["ninteractions=",ninteractions];*)

Do[interactionpos[gu]={},{gu,guilds}];

Do[
	(*Print[interaction];*)
	in=Interaction[interaction]/.model;
	(*Print[in];*)
	type[Subscript[interaction,_]]=(*index[gtrait]=*)"interaction";
	index[Subscript[interaction,_]]=index[interaction]=indexcount;
	range[Subscript[interaction,_]]=range[interaction]=Range/.Append[in,Range->Interval[{-\[Infinity],\[Infinity]}]];
	{guild1[interaction],guild2[interaction]}=Guilds/.in;
	AppendTo[interactionpos[guild1[interaction]],{interaction,1}];
	AppendTo[interactionpos[guild2[interaction]],{interaction,2}];
	LookUp[interaction]=LookUp[_[interaction]]={"interaction",guild1[interaction],guild2[interaction],interaction};
	LookUp[Subscript[interaction,sp1_,sp2_]]=LookUp[_[Subscript[interaction,sp1_,sp2_]]]=
		{"interaction",guild1[interaction],guild2[interaction],interaction,sp1,sp2};
,{interaction,interactions}];


(* transitions *) (* still under development, don't use! *)

transitions=Transitions/.model;
(*Print["transitions=",transitions];*)
If[transitions=!=Transitions,
	Do[
		trans=process[[1]];
		rate=AddProceduralToSum[process[[2]]];
		Do[
			{sourcec,source,destc,dest}=DeleteSubscripts[UnpackDoubleRightArrows[tran]];
			If[Global`debug,Print["{sourcec,source,destc,dest}=",{sourcec,source,destc,dest}]];
			gu=LookUp[source][[2]];
			If[ngcomps[gu]==1,
				sourcetraits=Table[UnderBar[gtrait],{gtrait,gtraits[gu]}],
				sourcetraits=Table[UnderBar[gtrait][source],{gtrait,gtraits[gu]}]
			];
			If[Global`debug,Print["sourcetraits=",sourcetraits]];
			If[ngcomps[gu]==1,
				sourceG=
				sourceG=MakeGMatrix[Subscript[source, \[FormalI]]];
			];
			If[Global`debug,Print["sourceG=",sourceG]];
			fsource=Simplify@-sourcec*rate/Subscript[source, \[FormalI]]/.Subscript[var_, \[FormalI]]->UnderBar[var];
			If[Global`debug,Print["fsource=",fsource]];
			dfsource=Simplify@D[fsource,{sourcetraits,1}];
			If[Global`debug,Print["dfsource=",dfsource]];
			(*d2fsource=Simplify@D[fsource,{sourcetraits,2}];*)
			d2fsource=Simplify@Table[D[fsource,var1,var2],{var1,sourcetraits},{var2,sourcetraits}];
			If[Global`debug,Print["d2fsource=",d2fsource]];
			fsource\[Prime]=Simplify@fsource+1/2*DoubleDotProduct[d2fsource,sourceG];
			If[Global`debug,Print["fsource\[Prime]=",fsource\[Prime]]];
			dfsource\[Prime]=Simplify@D[fsource\[Prime],{sourcetraits,1}];
			If[Global`debug,Print["dfsource\[Prime]=",dfsource\[Prime]]];
			AppendTo[dndt[source],fsource\[Prime]*Subscript[source, \[FormalI]]/.UnderBar[var_]->Subscript[var, \[FormalI]]];
			AppendTo[dxdt[source],sourceG . dfsource\[Prime]/.UnderBar[var_]->Subscript[var, \[FormalI]]];
			AppendTo[dGdt[source],sourceG . d2fsource . sourceG/.UnderBar[var_]->Subscript[var, \[FormalI]]];
			If[dest=!=Global`\[EmptySet],
(*Print["sourceG=",sourceG];*)
				If[ngcomps[gu]==1,
					desttraits=sourcetraits,
					desttraits=Table[UnderBar[gtrait][dest],{gtrait,gtraits[gu]}];
				];
				If[Global`debug,Print["desttraits=",desttraits]];
				destG=MakeGMatrix[Subscript[dest, \[FormalI]]];
				If[Global`debug,Print["destG=",destG]];
				fdest=rate*destc/Subscript[source, \[FormalI]]/.Subscript[var_, \[FormalI]]->UnderBar[var];
				If[Global`debug,Print["fdest=",fdest]];
				dfdest=D[fdest,{sourcetraits,1}];
				d2fdest=D[fdest,{sourcetraits,2}];
				fdest\[Prime]=fdest+1/2*DoubleDotProduct[d2fdest,sourceG];
				If[Global`debug,Print["fdest\[Prime]=",fdest\[Prime]]];
				dfdest\[Prime]=D[fdest\[Prime],{sourcetraits,1}];
				If[Global`debug,Print["dfdest\[Prime]=",dfdest\[Prime]]];
(*Print["sourcetraits-desttraits=",sourcetraits-desttraits];*)
				If[Length[process]>2,
					mut=process[[3]];
					Which[
						Statistics`Library`DistributionDimensionality[mut]==1,m={{Variance[mut]}},
						Statistics`Library`DistributionDimensionality[mut]>1,m=Covariance[mut],
						Else,Message[SetModel::badmut,mut];Return[$Aborted]
					]
				,
					m=0
				];
				(*Print["m=",m];*)
				AppendTo[dndt[dest],fdest\[Prime]*Subscript[source, \[FormalI]]/.UnderBar[var_]->Subscript[var, \[FormalI]]];
				AppendTo[dxdt[dest],Subscript[source, \[FormalI]]/Subscript[dest, \[FormalI]](fdest\[Prime](sourcetraits-desttraits)+sourceG . dfdest\[Prime])/.UnderBar[var_]->Subscript[var, \[FormalI]]];
				AppendTo[dGdt[dest],Subscript[source, \[FormalI]]/Subscript[dest, \[FormalI]](fdest\[Prime](m+sourceG-destG+(sourcetraits-desttraits)^2)+sourceG . d2fdest . sourceG
					+dfdest\[Prime]*sourceG . Transpose[sourcetraits-desttraits]+(sourcetraits-desttraits) . Transpose[sourceG . dfdest\[Prime]])/.UnderBar[var_]->Subscript[var, \[FormalI]]];
(*Print[dfdest\[Prime]*sourceG.Transpose[sourcetraits-desttraits]," ",(sourcetraits-desttraits).Transpose[sourceG.dfdest\[Prime]]];*)
			];
		,{tran,trans}];
	,{process,transitions}];
];

Do[
	Do[
		If[Global`debug,Print["constructing dndt[",co,"]..."]];
		dndt[co]=Total[dndt[co]];
		If[Global`debug,Print["constructing dxdt[",co,"]..."]];
		dxdt[co]=Total[dxdt[co]];
		If[Global`debug,Print["constructing dGdt[",co,"]..."]];
		dGdt[co]=Total[dGdt[co]];
	,{co,gcomps[gu]}];
,{gu,guilds}];


(* model assumptions - default={} *)

$Assumptions=Flatten[assumptions/.Automatic->Join[
	Select[parametersin,MemberQ[{Greater,GreaterEqual,Less,LessEqual},Head[#]]&],
	Table[Region`SpecialRegionProperty[range[aux],{aux},"ImplicitDescription"],{aux,auxs}],
	Table[Table[Region`SpecialRegionProperty[range[pcomp],{pcomp},"ImplicitDescription"],{pcomp,pcomps[pop]}],{pop,pops}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gcomp],{Subscript[gcomp,sp]},"ImplicitDescription"],{sp,0,2}],{gcomp,gcomps[gu]}],{gu,guilds}],
	Table[Table[Table[
		Region`SpecialRegionProperty[range[gtrait],{Subscript[gtrait,sp]},"ImplicitDescription"],{sp,0,2}],{gtrait,gtraits[gu]}],{gu,guilds}]
]];
(*Print["$Assumptions=",$Assumptions];*)

Which[
	modeltype=="ContinuousTime",
	DT[var_]:=var'[t]
,
	modeltype=="DiscreteTime",
	DT[var_]:=var[t+1]
];

eqn[var_]:=Module[{luv=LookUp[var]},
	Which[
		luv[[1]]=="aux",auxeqn[luv[[2]]],
		luv[[1]]=="pcomp",pcompeqn[luv[[2]],luv[[3]]],
		luv[[1]]=="gcomp",gcompeqn[luv[[2]],luv[[3]]][luv[[4]]]
	]
];

(*Do[
	Do[
		eqn[Subscript[gcomp, i_]]=(Subscript[gcomp, i]/.eqns);
		Print[eqn[Subscript[gcomp, 1]]];
	,{gcomp,gcomps[gu]}]
,{gu,guilds}]*)

]


Options[SetModel]={
	LineStyles->{{}},PlotMarkers->Graphics`PlotMarkers[],
	Colors->ColorData[97,"ColorList"],
	Assumptions->{Automatic},
	Parameters->{}
};


SetModel::unktype=
"Unknown ModelType (\"ContinuousTime\", \"DiscreteTime\" currently supported).";
SetModel::badpar=
"One or more Parameters already defined. Clear them before running SetModel.";
SetModel::badmut=
"Bad mutation kernel `1`.";


UnsetModel::usage=
"UnsetModel clears the currently set EcoEvo model.";


UnsetModel:=(
	modelloaded=False;
	Clear[LookUp,type,range,comptype,color,linestyle,plotmarker,DT,
	modeltype,modelwhenevents,modelperiod,
	pops,npops,npcomps,pcomps,pcompeqn,
	auxs,nauxs,auxeqn,
	guilds,nguilds,gcomps,ngcomps,gcompeqn,gtraits,ngtraits,
	eqns];
	$Assumptions={};
);


ModelInfo::usage=
"ModelInfo gives a summary of the currently loaded EcoEvo model.";


ModelInfo:=(

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[]];

(* model name *)
Print["modelname=",modelname];

(* model type *)
Print["modeltype=",modeltype,", modelperiod=",modelperiod];

(* aux vars *)
Print["auxs=",auxs," (naux=",naux,")"];
Do[
	Print["  ",FuncStyle[aux]];
	Print["  eqn[",aux,"]=",eqn[aux]];
	Print["  range[",aux,"]=",range[aux]];
,{aux,auxs}];

(* pops *)

Print["pops=",pops," (npops=",npops,")"];
Do[
	Print["  pcomps[",pop,"]=",pcomps[pop]," (npcomps[",pop,"]=",npcomps[pop],")"];
	Do[
		Print["    ",FuncStyle[pcomp]];
		Print["    eqn[",pcomp,"]=",eqn[pcomp]];
		Print["    comptype[",pcomp,"]=",comptype[pcomp]];
		Print["    range[",pcomp,"]=",range[pcomp]];
	,{pcomp,pcomps[pop]}];
,{pop,pops}];

(* guilds *)

Print["guilds=",guilds," (nguilds=",nguilds,")"];
Do[
	Print["  gcomps[",gu,"]=",gcomps[gu]," (ngcomps[",gu,"]=",ngcomps[gu],")"];
	Do[
		Print["    ",FuncStyle[gcomp]];
		Print["    eqn[",Subscript[gcomp,Global`i],"]=",eqn[Subscript[gcomp,Global`i]]];
		Print["    comptype[",gcomp,"]=",comptype[gcomp]];
		Print["    range[",gcomp,"]=",range[gcomp]];
	,{gcomp,gcomps[gu]}];
	Print["  gtraits[",gu,"]=",gtraits[gu]," (ngtraits[",gu,"]=",ngtraits[gu],")"];
	Do[
		Print["    ",FuncStyle[gtrait]];
		Print["    range[",gtrait,"]=",range[gtrait]];
	,{gtrait,gtraits[gu]}];
,{gu,guilds}];

);


MatrixToPopComponents::usage=
"MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToPopComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";

MatrixToGuildComponents::usage=
"MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\)] constructs a structured population based on square matrix \!\(\*
StyleBox[\"a\", \"TI\"]\) and variable \!\(\*
StyleBox[\"var\", \"TI\"]\).
MatrixToGuildComponents[\!\(\*
StyleBox[\"a\", \"TI\"]\), \!\(\*
StyleBox[\"var\", \"TI\"]\), \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)] sets the number of components to \!\(\*
StyleBox[\"ncomps\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(in case of undefined matrix \!\(\*
StyleBox[\"a\", \"TI\"]\)).";


MatrixToPopComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[(Sum[a[[c,c\[Prime]]]var[c\[Prime]],{c\[Prime],ncomps}])]},{c,ncomps}];
	On[Part::partd];
	Return[res]
];


MatrixToGuildComponents[a_,var_,ncompsin_:Automatic]:=Module[{ncomps,res},
	If[ncompsin===Automatic,ncomps=Length[a],ncomps=ncompsin];
	Off[Part::partd];
	res=Table[Component[var[c]]->{Equation:>Evaluate[Sum[a[[c,c\[Prime]]]var[c\[Prime]],{c\[Prime],ncomps}]]/.{var[c_]->Subscript[var[c],\[FormalI]]}},{c,ncomps}];
	On[Part::partd];
	Return[res/.{(Equation:>eqn_)->(Equation:>(eqn))}]
];


WeightedAbundance::usage = 
"WeightedAbundance[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] totals components in all guilds and pops.";


WeightedAbundance[sol_?RuleListQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WeightedAbundance"],
(* options *)
weightfunction,minpop,
(* other variables *)
f,gu,sp
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WeightedAbundance]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[WeightedAbundance]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractAttributes[sol],ExtractVariables[sol]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Which[
	weightfunction==="Total",
	f[var_]:=Total[Select[comps[var],comptype[#]==="Extensive"&]],
	weightfunction==="Components",
	f[var_]:=Select[comps[var],comptype[#]==="Extensive"&],
	weightfunction==="PresenceAbsence",
	f[var_]:=If[Total[Select[comps[var],comptype[#]==="Extensive"&]]>minpop,1,0],
	Else,
	f[Subscript[gu_,sp_]]:=weightfunction/.(#->Subscript[#,sp]&/@comps[gu]);
	f[pop_]:=weightfunction;
];

Return[Flatten@Join[
	Table[Table[Subscript[gu, sp]->Reinterpolation[f[Subscript[gu, sp]]/.sol],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}],
	Table[pop->Reinterpolation[f[pop]/.sol],{pop,pops}],
	ExtractAuxs[sol],
	ExtractAttributes[sol]
]]
]];


Options[WeightedAbundance]={WeightFunction->"Total",MinPop->10^-10};


TotalAbundance::usage = 
"TotalAbundance[\!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the total abundance in guilds.";


TotalAbundance[solin_,opts___?OptionQ]:=
Module[{
func=FuncStyle["TotalAbundance"],
(* options *)
weightfunction,
(* other variables *)
sol,wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TotalAbundance]}]];

sol=ExtractVariables[solin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][{},sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];
Return[Table[gu->Reinterpolation[Sum[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]/.wa],{gu,guilds}]]

]];


Options[TotalAbundance]={WeightFunction->"Total"};


TraitMean::usage = 
"TraitMean[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the mean traits in guilds.";


TraitMean[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["TraitMean"],
(* options *)
weightfunction,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TraitMean]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];

Return[
	Flatten@Table[Table[
		gtrait->Reinterpolation[Moment[WeightedData[Table[Subscript[gtrait, i],{i,\[ScriptCapitalN][gu]}]/.traits,Chop[Table[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]]],1]/.wa]
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]

]];


Options[TraitMean]={
	WeightFunction->"Total"
};


(* split traitsandvariables *)
TraitMean[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
TraitMean[ExtractTraits[eesol],ExtractVariables[eesol],opts];


TraitVariance::usage = 
"TraitVariance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"pops\", \"TI\"]\)] computes the variance of traits in guilds.";


TraitVariance[traits_?TraitsQ,sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["TraitVariance"],
(* options *)
weightfunction,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[TraitVariance]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,sol];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

wa=WeightedAbundance[sol,WeightFunction->weightfunction];

Return[
	Flatten@Table[Table[
		Var[gtrait]->Reinterpolation[CentralMoment[WeightedData[Table[Subscript[gtrait, i],{i,\[ScriptCapitalN][gu]}]/.traits,Chop[Table[Subscript[gu, i],{i,\[ScriptCapitalN][gu]}]/.wa]],2]]
	,{gtrait,gtraits[gu]}],{gu,guilds}]
]

]];


Options[TraitVariance]={
	WeightFunction->"Total"
};


(* split traitsandvariables *)
TraitVariance[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
TraitVariance[ExtractTraits[eesol],ExtractVariables[eesol],opts];


TraitDistance::usage =
"TraitDistance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sp1\", \"TI\"]\), \!\(\*
StyleBox[\"sp2\", \"TI\"]\)] returns the trait distance between two species.
TraitDistance[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"guild\", \"TI\"]\)] returns a trait distance matrix between all species in a guild (default=first).";


TraitDistance[traits_?RuleListQ,sp1_Subscript,sp2_Subscript,opts___?OptionQ]:=

Module[{
func=FuncStyle["TraitDistance (2sp)"],
(* options *)
rulelistdistanceopts
},

Block[{},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
rulelistdistanceopts=FilterRules[Flatten[{opts,Options[TraitDistance]}],Options[RuleListDistance]];

(*Print[DeleteSubscripts@ExtractTraits[traits,sp1]];
Print[DeleteSubscripts@ExtractTraits[traits,sp2]];
Print[Evaluate[Sequence@@rulelistdistanceopts]];*)

Return[Reinterpolation[RuleListDistance[DeleteSubscripts@ExtractTraits[traits,sp1],DeleteSubscripts@ExtractTraits[traits,sp2],
	Evaluate[Sequence@@rulelistdistanceopts]]]];

]];


TraitDistance[traits_?RuleListQ,gu:(_Symbol|_Integer):Automatic,opts___?OptionQ]:=

Module[{
func=FuncStyle["TraitDistance (guild)"]
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

If[gu==="Automatic",gu=guilds[[1]]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][ExtractTraits@traits,{}];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Return[Table[TraitDistance[traits,Subscript[gu, i],Subscript[gu, j],opts],{i,\[ScriptCapitalN][gu]},{j,\[ScriptCapitalN][gu]}]];

]];


Options[TraitDistance]={};


TraitDistance[traits_?RuleListQ,sp1_Subscript,sp1_Subscript,opts___?OptionQ]:=0;


FunctionalDistinctiveness::usage =
"FunctionalDistinctiveness[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] calculates the functional distinctiveness of \!\(\*
StyleBox[\"target\", \"TI\"]\).";


FunctionalDistinctiveness[traits_?TraitsQ,sol:(_?VariablesQ):{},target:(_Symbol|_Integer|_Subscript):Automatic,opts___?OptionQ]:=
Module[{
func=FuncStyle["FunctionalDistinctiveness"],
(* options *)
verbose,method,weightfunction,traitdistanceopts,normalizedistance,excludefocalspecies,
(* other variables *)
gu,sp,dists,distnorm,denom,abunds,totalabundance
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
If[sol==={},method="Species",method=Evaluate[Method/.Flatten[{opts,Options[FunctionalDistinctiveness]}]]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
traitdistanceopts=Evaluate[TraitDistanceOpts/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
normalizedistance=Evaluate[NormalizeDistance/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];
excludefocalspecies=Evaluate[ExcludeFocalSpecies/.Flatten[{opts,Options[FunctionalDistinctiveness]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][traits,{}];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Which[
	(* species target *)
	Head[target]===Subscript,
	gu=target[[1]];sp=target[[2]],
	(* automatic *)
	target===Automatic,
	gu=guilds[[1]];sp="All",
	(* guild target *)
	Head[target]===Integer||Head[target]==Symbol,
	gu=target;sp="All",
	Else,
	Message[FunctionalDistinctiveness::badtgt];
	Return[$Aborted];
];

dists=TraitDistance[traits,gu,Evaluate[Sequence@@traitdistanceopts]];
If[verbose,Print[func,": dists=",dists]];
distnorm=If[normalizedistance==True,Max[Flatten[dists]],1];
If[verbose,Print[func,": distnorm=",distnorm]];

Which[
	method==="Species",
	If[excludefocalspecies==True,denom=Subscript[\[ScriptCapitalN], gu]-1,denom=Subscript[\[ScriptCapitalN], gu]];
	If[sp==="All",
		Return[Table[FunctionalDistinctiveness[Subscript[gu, sp]]->Reinterpolation[Sum[dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)],{sp,Subscript[\[ScriptCapitalN], gu]}]],
		Return[Reinterpolation[Sum[dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]]
	],
	method==="AbundanceWeighted",
	abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];
	If[verbose,Print[func,": abunds=",abunds]];
	totalabundance=gu/.TotalAbundance[sol,WeightFunction->weightfunction];
	If[verbose,Print[func,": totalabundance=",totalabundance]];
	If[sp==="All",
		Return[Table[
			If[excludefocalspecies==True,denom=totalabundance-(Subscript[gu, sp]/.abunds),denom=totalabundance];
			FunctionalDistinctiveness[Subscript[gu, sp]]->Reinterpolation[Sum[(Subscript[gu, sp\[Prime]]/.abunds)*dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]
		,{sp,Subscript[\[ScriptCapitalN], gu]}]],
		If[excludefocalspecies==True,denom=totalabundance-(Subscript[gu, sp]/.abunds),denom=totalabundance];
		Return[Reinterpolation[Sum[(Subscript[gu, sp]/.abunds)*dists[[sp,sp\[Prime]]],{sp\[Prime],Subscript[\[ScriptCapitalN], gu]}]/(distnorm*denom)]]
	],
	Else,
	Message[FunctionalDistinctiveness::badmtd];Return[$Failed]
];

]]


Options[FunctionalDistinctiveness]={
	Verbose->False,
	Method->"Species",WeightFunction->"Total",TraitDistanceOpts->{},NormalizeDistance->True,ExcludeFocalSpecies->True
};


(* break up combned traitsandpops *)
FunctionalDistinctiveness[traitsandpops_?AttributesAndVariablesQ,target:(_Symbol|_Integer|_Subscript):Automatic,opts___?OptionQ]:=
FunctionalDistinctiveness[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],target,opts];


FunctionalDistinctiveness::badmtd="The Method option should be a built-in method name (\"Species\" or \"AbundanceWeighted\").";
FunctionalDistinctiveness::badtgt="The target should be a guild, a species, or Automatic.";


ExtinctSpecies::usage=
"ExtinctSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives a list of extinct species in \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


ExtinctSpecies[sol_?RuleListQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["ExtinctSpecies"],
(* options *)
verbose,weightfunction,time,minpop,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[ExtinctSpecies]}]];
If[Global`debug,verbose=True];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[ExtinctSpecies]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[ExtinctSpecies]}]];
time=Evaluate[Time/.Flatten[{opts,Options[ExtinctSpecies]}]];

wa=ExtractSpecies[WeightedAbundance[sol,WeightFunction->weightfunction]];
(*If[verbose,Print[func,": wa=",wa]];*)

If[time===t,
	Which[
		modelperiod==0,
		wa=FinalSlice[wa],
		modelperiod<\[Infinity],
		wa=TemporalMean[FinalSlice[wa,modelperiod]],
		Else,
		wa=TemporalMean[wa]
	]
,
	wa=Slice[wa,time]
];
If[verbose,Print[func,": WeightedAbundance=",wa]];

Return[Keys[Select[Association[wa],#<=minpop&]]]
]];


Options[ExtinctSpecies]={Verbose->False,MinPop->10^-10,WeightFunction->"Total",Time->t};


ExtantSpecies::usage=
"ExtantSpecies[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives a list of extant species in \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


ExtantSpecies[sol_?RuleListQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["ExtantSpecies"],
(* options *)
verbose,weightfunction,time,minpop,
(* other variables *)
wa
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[ExtantSpecies]}]];
If[Global`debug,verbose=True];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[ExtantSpecies]}]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[ExtantSpecies]}]];
time=Evaluate[Time/.Flatten[{opts,Options[ExtantSpecies]}]];

wa=ExtractSpecies[WeightedAbundance[sol,WeightFunction->weightfunction]];
(*If[verbose,Print[func,": wa=",wa]];*)

If[time===t,
	Which[
		modelperiod==0,
		wa=FinalSlice[wa],
		modelperiod<\[Infinity],
		wa=TemporalMean[FinalSlice[wa,modelperiod]],
		Else,
		wa=TemporalMean[wa]
	]
,
	wa=Slice[wa,time]
];
If[verbose,Print[func,": WeightedAbundance=",wa]];

Return[Keys[Select[Association[wa],#>minpop&]]]
]];


Options[ExtantSpecies]={Verbose->False,MinPop->10^-10,WeightFunction->"Total",Time->t};


Subscript[\[ScriptCapitalN], gu_]:=\[ScriptCapitalN][gu];
Subscript[\[FormalCapitalN], gu_]:=\[FormalCapitalN][gu];


ClearParameters::usage="ClearParameters clears all model parameters.";


ClearParameters:=Clear[Evaluate[Sequence@@EcoEvo`Private`parnames]];


ParameterValues::usage="ParameterValues returns a rulelist of current definitions of model parameters.";


ParameterValues:=Thread[EcoEvo`Private`parnames->EcoEvo`Private`parameters];


MakeGMatrix::usage="MakeGMatrix[\!\(\*
StyleBox[\"var\", \"TI\"]\)] makes a G-matrix of Var and Cov for guild/gcomp \!\(\*
StyleBox[\"var\", \"TI\"]\).";


MakeGMatrix[var_]:=Module[{type,gu},
	{type,gu}=LookUp[var][[1;;2]];
	(*Print[{type,gu}];*)
	Which[
		type=="guild"||ngcomps[gu]==1,
		Table[Table[
			Which[
				i<j,Cov[gtraits[gu][[i]],gtraits[gu][[j]]],
				i==j,Var[gtraits[gu][[i]]],
				i>j,Cov[gtraits[gu][[j]],gtraits[gu][[i]]]
			]
		,{j,ngtraits[gu]}],{i,ngtraits[gu]}]
		,
		type=="gcomp",
		Table[Table[
			Which[
				i<j,Cov[gtraits[gu][[i]],gtraits[gu][[j]]][var],
				i==j,Var[gtraits[gu][[i]]][var],
				i>j,Cov[gtraits[gu][[j]],gtraits[gu][[i]]][var]
			]
		,{j,ngtraits[gu]}],{i,ngtraits[gu]}]
	]
];


MakeGMatrix[Subscript[var_,sp_]]:=Replace[MakeGMatrix[var],x_->Subscript[x, sp],{2}];


EcoEqns::usage=
"EcoEqns[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] sets up ecological equations using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoEqns[attributesin:(_?AttributesQ):{},opts___?OptionQ]:=Module[{

func=FuncStyle["EcoEqns"],
(* options *)
verbose,verboseall,logged,fixed,fixedvars,fixedvariables,timescale,percapita,
(* other variables *)
attributes,nonfixedvars,fixed2,eqns,gco,sp},

(*Print["attributesin=",attributesin];
Print["opts=",opts];*)

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEqns]}]];
If[verboseall,verbose=True];

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEqns]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoEqns]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[EcoEqns]}]];
nonfixedvars=Evaluate[NonFixedVars/.Flatten[{opts,Options[EcoEqns]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEqns]}]];
fixedvars=fixed[[All,1]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
(*Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];*)

If[nonfixedvars===Automatic,nonfixedvars=OrderedComplement[AllVariables,fixedvars]];
If[Global`debug,Print["nonfixedvars=",nonfixedvars]];

(* add [t] to constant fixed variables *)
fixed2=ReplaceAll[fixed,(var_/;MemberQ[AllVariables,var])->var[t]];

If[transitions===Transitions,

(* equation-based *)

(*Print["making eqns"];*)
eqns=Table[
	Which[
		logged===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			log[var][t+1]-log[var][t]==(RealSimplify[timescale*Log[eqn[var]/var]]/.AddVariablets),
			modeltype=="ContinuousTime",
			log[var]'[t]==(timescale*eqn[var]/var/.AddVariablets)
		]
	,
		percapita===True&&comptype[var]==="Extensive",
		Which[
			modeltype=="DiscreteTime",
			var[t+1]/var[t]==(timescale*eqn[var]/var/.AddVariablets),
			modeltype=="ContinuousTime",
			var'[t]==(timescale*eqn[var]/var/.AddVariablets)
		]
	,
		Else,
		Which[
			modeltype=="DiscreteTime",
			var[t+1]==(timescale*eqn[var]/.AddVariablets),
			modeltype=="ContinuousTime",
(*Print[eqn[var]];
Print[AddVariablets];
Print[eqn[var]/.AddVariablets];*)
			var'[t]==(timescale*eqn[var]/.AddVariablets)
		]
	]
,{var,nonfixedvars}];
(*Print["eqns made"];*)

Return[DeleteDuplicates[eqns/.ExpRule[nonfixedvars,logged]/.Dispatch[ExpandTraits[attributes]]/.fixed2]]

,

(* process-based *)

(*Print["nonfixedvars=",nonfixedvars];*)

eqns=Table[
	{gco,sp}=LookUp[var][[3;;4]];
	Subscript[gco, sp]'[t]==(dndt[gco]/.\[FormalI]->sp/.AddVariablets/.Dispatch[ExpandTraits[attributes]]/.AddTraitts/.AddVarCovts)
,{var,nonfixedvars}];

Return[DeleteDuplicates[eqns/.ExpRule[nonfixedvars,logged](*/.Dispatch[ExpandTraits[attributes]]*)/.fixed2]];

]

]];


Options[EcoEqns]={Fixed->{},TimeScale->1,Logged->False,PerCapita->False,NonFixedVars->Automatic};


EcoSim::usage=
"EcoSim[\!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates ecological dynamics, with initial densities in \!\(\*
StyleBox[\"init\", \"TI\"]\), from time \!\(\*
StyleBox[\"t\", \"TI\"]\)=0 to \!\(\*
StyleBox[\"tmax\", \"TI\"]\).
EcoSim[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


EcoSim[attributesin:(_?AttributesQ):{},init:(_?VariablesQ):{},Gsin:(_?GsQ):{},tmax_?NumericQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoSim"],
(* options *)
verbose,verboseall,method,
ndsolveopts,logged,interpolationpoints,interpolationopts,fixed,fixedvars,whenevents,timescale,outputtmin,randomseeding,
output,tmin,
(* other variables *)
attributes,nonfixedvars,Gs,luv,sp,eqns,unks,ics,tic,exprule,sol,res,fixedres},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoSim]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoSim]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[EcoSim]}]];
whenevents=Evaluate[WhenEvents/.Flatten[{opts,Options[EcoSim]}]];
timescale=Evaluate[TimeScale/.Flatten[{opts,Options[EcoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoSim]}]];
If[output=="FinalSlice",outputtmin=tmax];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoSim]}]];
If[outputtmin===Automatic,outputtmin=tmin];
randomseeding=Evaluate[RandomSeeding/.Flatten[{opts,Options[EcoSim]}]];
If[IntegerQ[randomseeding],SeedRandom[randomseeding]];

interpolationopts=FilterRules[Flatten[{opts,Options[EcoSim]}],Options[Interpolation]];
interpolationpoints=Evaluate[InterpolationPoints/.Flatten[{opts,Options[EcoSim]}]];

(* process fixed variables *)
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoSim]}]];
fixedvars=fixed[[All,1]];
nonfixedvars=init[[All,1]]; (* nonfixedvars are those given ICs *)
(*Print["nonfixedvars=",nonfixedvars];*)

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],
		AppendTo[fixed,var->0];
		AppendTo[fixedvars,var];
	]
,{var,AllPopsAndAuxs}];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes,Join[init,fixed]];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

(* process Gs *)
Gs=ExpandGs[Join[Gsin,Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@ConstantArray[0,{ngtraits[gu],ngtraits[gu]}]],{gu,guilds}]]];
(*Print["Gs=",Gs];*)

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-10^-15]; (* hack to ensure that events are triggered at t=tmin *)

(* set eqns, unks and ics *)
(*Print["calling EcoEqns..."];*)
eqns=EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,opts]/.RemoveVarCovts/.Gs;
unks=Table[If[logged===True&&comptype[var]==="Extensive",log[var],var],{var,nonfixedvars}];
ics=Table[If[logged===True&&comptype[var]==="Extensive",log[var][tic]==Log[var/.init],var[tic]==(var/.init)],{var,nonfixedvars}];

If[Global`debug,Print[func,": eqns=",eqns]];
If[Global`debug,Print[func,": unks=",unks]];
If[Global`debug,Print[func,": ics=",ics]];

(* solve it *)
(*Print["calling NDSolve..."];*)
Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	If[verbose,
		With[{ndsolveeqns=Join[eqns,ics,modelwhenevents,whenevents],unks=unks,outputtmin=outputtmin,options=Sequence@@ndsolveopts},
			PrintCall[Global`sol=NDSolve[ndsolveeqns,unks,{t,outputtmin,tmax},options][[1]]]
	]];
	sol=NDSolve[Join[eqns,ics,modelwhenevents,whenevents],unks,{t,outputtmin,tmax},Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	If[logged===True,
		If[output=="FinalSlice",Return[SortRuleList[FinalSlice[sol]/.(log[var_]->val_)->(var->E^val),AllVariables]]];
		res=Table[If[comptype[var]==="Extensive",
			var->Reinterpolation[E^log[var]/.sol,InterpolationPoints->interpolationpoints,Evaluate[Sequence@@interpolationopts]],
			var->(var/.sol)]
		,{var,nonfixedvars}]
	,
		res=sol
	];
	res=Join[res,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
	,
	modeltype=="DiscreteTime",
	If[verbose,
		With[{rteqns=Join[eqns,ics],unks=unks},
			PrintCall[Global`res=RecurrenceTable[rteqns,unks,{t,tmin,tmax}]]
	]];
	sol=Transpose[Replace[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax},Method->{Compiled->True}],n_?NumericQ->{n},1]]; (* Replace to deal with weird RecurrenceTable bug <https://mathematica.stackexchange.com/questions/128371/> *)
	res=Join[Table[
		If[Head[unks[[i]]]===log,unks[[i,1]],unks[[i]]]->TimeSeries[Transpose[{Table[t,{t,outputtmin,tmax}],If[Head[unks[[i]]]===log,E^sol[[i]],sol[[i,outputtmin-tmin+1;;tmax-tmin+1]]]}]]
	,{i,Length[unks]}],
	Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[Global`debug,Print[func,": res=",res]];

If[output=="FinalSlice",Return[SortRuleList[FinalSlice[res],AllVariables]]];

Return[SortRuleList[res,AllVariables]];

]];


Options[EcoSim]={Verbose->False,VerboseAll->False,
Method->Automatic,NDSolveOpts->{},Logged->False,Fixed->{},WhenEvents->{},InterpolationOrder->7,InterpolationPoints->1000,
EqStop->False,EqThreshold->10^-8,TimeScale->1,TMin->0,OutputTMin->Automatic,Output->"Dynamics",TMin->0,RandomSeeding->None};


(* split traitsandvariables *)
EcoSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoSim[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],tmax,opts];
EcoSim[sol_?AttributesAndVariablesQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoSim[ExtractTraits[sol],ExtractVariables[sol],tmax,opts];


EcoEq::usage = 
"EcoEq[] solves for ecological equilibria.
EcoEq[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
EcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).";

SolveEcoEq::usage = 
"SolveEcoEq[] solves for ecological equilibria.
SolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
SolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";

NSolveEcoEq::usage = 
"NSolveEcoEq[] numerically solves for ecological equilibria.
NSolveEcoEq[\!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses traits/interactions \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
NSolveEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"vars\", \"TI\"]\)] numerically solves for variables \!\(\*
StyleBox[\"vars\", \"TI\"]\) using trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";

FindEcoEq::usage = 
"FindEcoEq[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological equilibrium using initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoEq[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).";


EcoEq[attributesin:(_?AttributesQ):{},init:(_?VariablesQ):{},Gsin:(_?GsQ):{},vars:(_List|All):All,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEq"],
(* options *)
method,solveopts,nsolveopts,findrootopts,boundarydetection,time,fixed,chop,qss,percapita,verbose,verboseall,
(* other variables *)
attributes,nonvars,nonfixedvars,fixedvars,Gs,removets,eqns,unks,newunk,sol,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoEq]}]];
If[method===Automatic,If[init!={},method="FindRoot",method="Solve"]];
If[Global`debug,Print[func,": method=",method]];

solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EcoEq]}]];
If[$VersionNumber>=12.2,AppendTo[solveopts,Assumptions->{}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EcoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EcoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEq]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEq]}]];
qss=Evaluate[QSS/.Flatten[{opts,Options[EcoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[EcoEq]}]];

(* EcoEq doesn't work on Periodic models *)
If[modelperiod=!=0&&time===t&&method=="FindRoot",Message[EcoEq::noneq];Return[]];

(* handle blanks & figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];
(*Print[Table[\[ScriptCapitalN][gu],{gu,guilds}]];*)

(* process Gs *)
Gs=ExpandGs[Join[Gsin,Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@ConstantArray[0,{ngtraits[gu],ngtraits[gu]}]],{gu,guilds}]]];
(*Print["Gs=",Gs];*)

If[vars===All,
	nonvars={},
	nonvars=OrderedComplement[AllVariables,vars]
];
(*Print["nonvars=",nonvars];*)

If[qss==False,
	fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->0),1]],
	fixed=JoinFirst[fixed,Replace[nonvars,x_->(x->x),1]]
];
(*Print["fixed=",fixed];*)

fixedvars=fixed[[All,1]];
nonfixedvars=OrderedComplement[AllVariables,fixedvars];
(*Print["nonfixedvars=",nonfixedvars];*)

(* set eqns, unks and ics *)
eqns=EcoEqns[attributes,Fixed->fixed,PerCapita->percapita]/.Eq/.RemoveVariablets/.RemoveVarCovts/.t->time/.fixed/.attributes/.Gs;

Which[
	MemberQ[{"Solve","NSolve"},method],
	unks=nonfixedvars
,
	method=="FindRoot",
	unks=Table[
		newunk={var,(var/.Append[init,var->0])};
		If[boundarydetection,newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]];
		newunk,{var,nonfixedvars}]
];

If[Global`debug,Print[func,": eqns=",eqns]];
If[Global`debug,Print[func,": unks=",unks]];

(* solve it *)

Which[
	method=="Solve",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@solveopts},PrintCall[Global`sol=Solve[eqns,unks,options]]]];
	sol=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@nsolveopts},PrintCall[Global`sol=NSolve[eqns,unks,options]]]];
	sol=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[verbose,With[{eqns=eqns,unks=unks,options=Sequence@@findrootopts},PrintCall[Global`sol=FindRoot[eqns,unks,options]]]];
	sol=FindRoot[eqns,unks,Evaluate[Sequence@@findrootopts]],
	Else,
	Message[EcoEq::badmtd];Return[$Failed];
];

If[Global`debug,Print[func,": sol=",sol]];
If[MemberQ[{Solve,NSolve},Head[sol]],Message[EcoEq::nosol,Head[sol]];Return[$Failed]];

(* add in Fixed variables *)
Which[
	MemberQ[{"Solve","NSolve"},method],
	res=Join[DeleteCases[fixed,var_->var_],#]& /@ sol,
	method=="FindRoot",
	res=Join[DeleteCases[fixed,var_->var_],sol]
];

If[chop,
	Return[SortRuleList[EqSort[Chop[res]],AllVariables]],
	Return[SortRuleList[EqSort[res],AllVariables]]
];

]];


Options[EcoEq]={Method->Automatic,SolveOpts->{(*Reals,*)},NSolveOpts->{(*Reals,*)Method->"EndomorphismMatrix"},FindRootOpts->{},
PerCapita->False,Fixed->{},Chop->True,QSS->False,Time->t,Verbose->False};


SolveEcoEq[args___]:=EcoEq[args,Method->"Solve"];
NSolveEcoEq[args___]:=EcoEq[args,Method->"NSolve"];
FindEcoEq[args___]:=EcoEq[args,Method->"FindRoot"];


(* break up combined traitsandpops *)
SolveEcoEq[sol_?AttributesAndGsQ,opts___?OptionQ]:=SolveEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],opts];
NSolveEcoEq[sol_?AttributesAndGsQ,opts___?OptionQ]:=NSolveEcoEq[ExtractAttributes[sol],ExtractVarCovs[sol],opts];
FindEcoEq[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
FindEcoEq[ExtractAttributes[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];
FindEcoEq[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=
FindEcoEq[ExtractAttributes[sol],ExtractVariables[sol],opts];


EcoEq::noneq="Can't find equilibrium of periodically forced model with FindRoot.  Give Time option or try FindEcoCycle instead.";

EcoEq::nosol="`1` couldn't find a solution.  Try FindEcoEq instead.";


FindEcoCycle::usage = 
"FindEcoCycle[\!\(\*
StyleBox[\"init\", \"TI\"]\)] finds an ecological limit cycle using initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoCycle[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


FindEcoCycle[attributesin:(_?AttributesQ):{},variables:(_?VariablesQ):{},opts:OptionsPattern[]]:=

Module[{
func=FuncStyle["FindEcoCycle"],
(* options *)
verbose,verboseall,period,method,monitor,printtrace,
findrootopts,ecosimopts,maxiterations,accuracygoal,precisiongoal,logged,fixed,
triggervar,warmup1,warmup2,warmup3,wheneventopts,
(* other variables *)
attributes,nonfixedvars,fixedvars,extrema,triggerpos,triggerval,max,ics2,ics3,ics4,diff,tmax,eq,
ic,nb,thing,eqns,unks,logd,vars,unksics,ics,res,sol,per},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

$FindEcoCycleSteps=0;

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoCycle]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoCycle]}]];
If[verboseall,verbose=True];

monitor=OptionValue[Monitor];
printtrace=OptionValue[PrintTrace];
period=OptionValue[Period];
method=OptionValue[Method];
If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0,method="EcoSim",method="FixedPoint"]];
If[Global`debug,Print[func,": method=",method]];
findrootopts=OptionValue[FindRootOpts];
ecosimopts=OptionValue[EcoSimOpts];
maxiterations=OptionValue[MaxIterations];
accuracygoal=OptionValue[AccuracyGoal];
triggervar=OptionValue[TriggerVariable];
warmup1=OptionValue[WarmUp];
warmup2=OptionValue[WarmUp2];
warmup3=OptionValue[WarmUp3];
tmax=OptionValue[TMax];
wheneventopts=OptionValue[WhenEventOpts];
logged=OptionValue[Logged];
fixed=OptionValue[Fixed];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
(*Print["fixed=",fixed];*)


(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];

(* set up thing & unks *)
nonfixedvars=variables[[All,1]];

(* build various lists of vars *)
unks=Table[eq[var],{var,nonfixedvars}];
vars=Table[If[logged&&comptype[var]==="Extensive",Log[var],var],{var,nonfixedvars}];
ics=vars/.variables;
unksics=Transpose[{unks,ics}];
logd=Table[If[logged&&comptype[var]==="Extensive",True,False],{var,nonfixedvars}];

(*
Print["unks=",unks];
Print["unksics=",unksics];
Print["ics=",ics];
Print["logd=",logd];
Print["vars=",vars];
*)

(* "EcoSim" method for unforced ContinuousTime models *)
If[method==="EcoSim",

	If[!(modeltype=="ContinuousTime"&&modelperiod==0),Message[FindEcoCycle::noecosim];Return[$Failed]];
	If[triggervar===Automatic,triggervar=nonfixedvars[[1]]];
	triggerpos=Position[nonfixedvars,triggervar][[1,1]];

	(* warmup #1 to get on limit cycle *)
	ics2=If[warmup1>0,
		FinalSlice[EcoSim[attributes,variables,warmup1,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]],
		variables];
	If[verbose,Print[func,": ics2=",ics2]];
	
	(* warmup #2 to find maxima *)
	extrema={};
	EcoSim[attributes,ics2,warmup2,WhenEvents->{
			WhenEvent[event,AppendTo[extrema,Table[var[t],{var,nonfixedvars}]],Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar'[t]==0)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

	If[extrema=={},Message[FindEcoCycle::nomaxima];Return[$Failed]];

	max=Last@Sort[extrema,#1[[triggerpos]]<#2[[triggerpos]]&];
	ics3=Table[nonfixedvars[[i]]->max[[i]],{i,Length[nonfixedvars]}];
	If[verbose,Print[func,": ics3=",ics3]];
	
	(* warmup #3 to move a wee bit beyond the maximum *)
	ics4=FinalSlice[EcoSim[attributes,ics3,warmup3,Fixed->fixed,Evaluate[Sequence@@ecosimopts]]];

	If[verbose,Print[func,": ics4=",ics4]];

	Do[
		triggerval=triggervar/.ics4;

		sol=EcoSim[attributes,ics4,tmax,WhenEvents->{
			WhenEvent[event,"StopIntegration",Evaluate[Sequence@@wheneventopts]]
			/.event->(triggervar[t]<triggerval)},Fixed->fixed,Evaluate[Sequence@@ecosimopts]];

(*Print[Show[
PlotDynamics[sol,{Global`x},PlotRange\[Rule]{0.8221,0.82215}],
Plot[triggerval,{t,0,FinalTime[sol]}]
]];*)

		diff=Sum[Abs[(var/.FinalSlice[sol])-(var/.ics4)],{var,nonfixedvars}];
		If[diff<10^-accuracygoal,Break[]];

		ics4=FinalSlice[sol];
	,{maxiterations}];

	If[diff>10^-accuracygoal,Message[FindEcoCycle::cvmit,maxiterations]];

	(* make InterpolatingFunctions Periodic *)
	sol=sol/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if];
	
	Return[Sort[sol]];
];

(* "FixedPoint" or "FindRoot" method *)

If[(modeltype=="ContinuousTime"&&modelperiod==0),
	AppendTo[unks,per];
	AppendTo[unksics,{per,period}];
	AppendTo[ics,period];
,
	If[period===Automatic,per=modelperiod,per=period];
];

(*Print["unks=",unks];Print["unksics=",unksics];Print["ics=",ics];*)

If[monitor,
	nb=CreateDialog[{
		TextCell["evaluation: "],
		Dynamic[$FindEcoCycleSteps],
		TextCell["vars:"],
		Dynamic[FinalSlice[sol]]
	},
	WindowTitle->"FindEcoCycle Progress...",WindowSize->All];
];


(* function to advance model *)

thing[ps_?NumericListQ]:=Module[{popz,rez},
	$FindEcoCycleSteps++;
	If[(modeltype=="ContinuousTime"&&modelperiod==0),tmax=ps[[-1]],tmax=per];
	popz=Table[If[logd[[i]],nonfixedvars[[i]]->E^ps[[i]],nonfixedvars[[i]]->ps[[i]]],{i,Length[nonfixedvars]}];
	sol=EcoSim[attributes,popz,tmax,Fixed->fixed,Evaluate[Sequence@@ecosimopts],Logged->logged];
	rez=vars/.FinalSlice[sol];
	If[(modeltype=="ContinuousTime"&&modelperiod==0),AppendTo[rez,ps[[-1]]]];
	If[printtrace,Print[$FindEcoCycleSteps,": ",FinalSlice[sol]]];
	Return[rez];
];

Which[
	method=="FindRoot",
	If[Global`debug,Print[func,": Method FindRoot"]];
	res=FindRoot[thing[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]]
,
	method=="FixedPoint",
	If[Global`debug,Print[func,": Method FixedPoint"]];
	res=FixedPoint[thing[#]&,ics,maxiterations,SameTest->(Max[Abs[#1-#2]]<10^-accuracygoal&)];
	If[$FindEcoCycleSteps==maxiterations,Message[FindEcoCycle::cvmit,maxiterations];Return[$Failed]]
,
	Else,
	Message[FindEcoCycle::badmtd];Return[$Failed]
];

If[modeltype=="DiscreteTime",(* drop last point *)
	sol=ReplaceAll[sol,
		{(var_->td_List):>(var->Drop[td,-1]),(var_->td_TemporalData)->(var->TimeSeriesWindow[td,{0,per-1}])}]
];

(* make InterpolatingFunctions Periodic *)
sol=sol/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if];

(* return answer *)

If[monitor,NotebookClose[nb]];

Return[Sort[sol]];

]];


Options[FindEcoCycle]={
Method->Automatic,Fixed->{},FindRootOpts->{},EcoSimOpts->{},MaxIterations->100,AccuracyGoal->6,Logged->False,
WarmUp->1000,WarmUp2->100,WarmUp3->0.1,TMax->1000,TriggerVariable->Automatic,
WhenEventOpts->{"DetectionMethod"->"Interpolation","LocationMethod"->{"Brent",MaxIterations->1000}},
Period->Automatic,
Monitor->False,PrintTrace->False,
Verbose->False,VerboseAll->False
};


(* split traitsandvariables *)
FindEcoCycle[traitsandvariables_?AttributesAndVariablesQ,opts:OptionsPattern[]]:=
FindEcoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],opts];


FindEcoCycle::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoCycle::nomaxima=
"Found no maxima in warmup #3, probably not periodic solution.";

FindEcoCycle::badmtd=
"The Method option should be a built-in method name (\"FindRoot\", \"FixedPoint\", \"EcoSim\" or \"Automatic\")";

FindEcoCycle::noecosim=
"\"EcoSim\" Method only applicable to unforced ContinuousTime models.";


$FindEcoCycleSteps::usage="Counts the number of EcoSim calls in FindEcoCycle.";


EcoJacobian::usage = 
"EcoJacobian[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] returns the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"sol\", \"TI\"]\).
EcoJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


(* make listable across pops *)
EcoJacobian[attributes:(_?AttributesQ):{},variables_?ListOfVariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=(EcoJacobian[attributes,#,Gsin,opts]&/@variables);


EcoJacobian[attributesin:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoJacobian"],
(* options *)
time,fixed,verbose,
(* other variables *)
attributes,fixedvars,Gs,eqns,unks,jmat},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoJacobian]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoJacobian]}]];
verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoJacobian]}]];


(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];

(* process Gs *)
Gs=ExpandGs[Join[Gsin,Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@ConstantArray[0,{ngtraits[gu],ngtraits[gu]}]],{gu,guilds}]]];
(*Print["Gs=",Gs];*)

eqns=EcoEqns[attributes,opts]/.RHS/.RemoveVarCovts/.RemoveVariablets/.Gs/.t->time;
(*Print["eqns=",eqns];*)

fixedvars=fixed[[All,1]];
unks=OrderedComplement[AllVariables,fixedvars];

If[verbose,
	Print[func,": eqns="];
	Print[eqns];
	Print[func,": unks="];
	Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}];
If[verbose,Print[func,": jmat=",jmat]];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&(variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t,
	Return[TimeSeries[Table[{t\[Prime],jmat/.AddVariablets/.t->t\[Prime]},{t\[Prime],variables[[1,2]]["Times"]}]/.variables/.attributes]];
,
	(* ContinuousTime cycle *)
	variables!={}&&(variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinuousTime"&&modelperiod=!=0))&&time===t,
	Return[jmat/.AddVariablets/.variables/.attributes];
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	If[time===t,
		Return[jmat/.variables/.attributes],
		Return[jmat/.Slice[variables,time]/.attributes]
	];
];

]];


(* break up combined traitsandpops *)
EcoJacobian[traitsandpops_List,opts___?OptionQ]:=
EcoJacobian[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoJacobian]={Verbose->False,VerboseAll->False,Time->t,Fixed->{}};


EcoEigenvalues::usage = 
"EcoEigenvalues[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] returns the eigenvalues of the Jacobian matrix of the ecological equations evaluated at \!\(\*
StyleBox[\"sol\", \"TI\"]\).
EcoEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


(* make listable across pops *)
EcoEigenvalues[attributes:(_?AttributesQ):{},variables_?ListOfVariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=(EcoEigenvalues[attributes,#,Gsin,opts]&/@variables);


EcoEigenvalues[attributesin:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=
Module[{
func=FuncStyle["EcoEigenvalues"],
(* options *)
verbose,verboseall,chop,time,ndsolveopts,multipliers,fixed,
(* other variables *)
attributes,j,dim,per,xsol,res},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEigenvalues]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEigenvalues]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEigenvalues]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoEigenvalues]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEigenvalues]}]];
multipliers=Evaluate[Multipliers/.Flatten[{opts,Options[EcoEigenvalues]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEigenvalues]}]];

j=EcoJacobian[attributes,variables,Gsin,Time->time,Fixed->fixed,VerboseAll->verboseall];
If[verbose,Print[func,": Jacobian=",j]];

Which[
	(* DiscreteTime cycle *)
	variables!={}&&((variables[[1,2,0]]===TemporalData||(modeltype=="DiscreteTime"&&modelperiod=!=0))&&time===t),
	res=Eigenvalues[ListMultiplier[Table[j[t\[Prime]],{t\[Prime],j["Times"]}]]]
,
	(* ContinousTime cycle *)
	variables!={}&&((variables[[1,2,0]]===InterpolatingFunction||(modeltype=="ContinousTime"&&modelperiod=!=0))&&time===t),
	dim=Length[j];
	per=FinalTime[variables];
	xsol=NDSolve[{x'[t]==j . x[t],x[0]==IdentityMatrix[dim]},x,{t,0,per},Sequence@@ndsolveopts][[1]];
	If[Global`debug,Print[func,": x[per]/.xsol=",x[per]/.xsol]];
	If[multipliers,
		res=Eigenvalues[x[per]/.xsol],
		res=Log[Chop[Eigenvalues[x[per]/.xsol]]]/per
	]
,
	(* ContinuousTime or DiscreteTime equilibrium *)
	Else,
	res=Eigenvalues[j/.t->time]
];

If[chop,Return[Chop[res]],Return[res]];

];


EcoEigenvalues[traitsandpops_?AttributesAndVariablesQ,opts___?OptionQ]:=EcoEigenvalues[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoEigenvalues]={Verbose->False,VerboseAll->False,Chop->True,Time->t,NDSolveOpts->{},Multipliers->False,Fixed->{}};


EcoStableQ::usage=
"EcoStableQ[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] reports the linear stability of ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) as True, False, or Indeterminate.
EcoStableQ[\!\(\*
StyleBox[\"attribues\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


(* make listable across variables *)
EcoStableQ[attributes:(_?AttributesQ):{},variables_?ListOfVariablesQ,opts___?OptionQ]:=(EcoStableQ[attributes,#,opts]&/@variables);


EcoStableQ[attributesin:(_?AttributesQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoStableQ"],
(* options *)
method,verbose,verboseall,time,ecoeigenvaluesopts,tolerance,simplifyresult,fixed,
(* other variables *)
attributes,j,evs,res},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoStableQ]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoStableQ]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EcoStableQ]}]];
time=Evaluate[Time/.Flatten[{opts,Options[EcoStableQ]}]];
ecoeigenvaluesopts=Evaluate[EcoEigenvaluesOpts/.Flatten[{opts,Options[EcoStableQ]}]];
tolerance=Evaluate[Tolerance/.Flatten[{opts,Options[EcoStableQ]}]];
simplifyresult=Evaluate[SimplifyResult/.Flatten[{opts,Options[EcoStableQ]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoStableQ]}]];

If[method===Automatic,
	If[modeltype=="ContinuousTime"&&modelperiod==0&&InterpolatingFunctionFunctionQ[variables]==False&&Length[variables]<4,
		method="RouthHurwitz",
		method="Eigenvalues"
	];
	If[verbose,Print[func,": method=",method]];
];

Which[
	method=="RouthHurwitz",
	j=EcoJacobian[attributes,variables,Time->time,Fixed->fixed];
	res=RouthHurwitzCriteria[j];
	Which[
		simplifyresult===True,
		Return[Simplify[res]],
		simplifyresult===Full,
		Return[FullSimplify[res]],
		simplifyresult===Real,
		Return[RealSimplify[res]],
		Else,
		Return[res]
	]
,
	method=="Eigenvalues",
	evs=EcoEigenvalues[attributes,variables,Time->time,Fixed->fixed,Evaluate[Sequence@@ecoeigenvaluesopts]];
	Which[
		simplifyresult===True,
		evs=Simplify[evs]],
		simplifyresult===Full,
		evs=FullSimplify[evs],
		simplifyresult===Real,
		evs=RealSimplify[res]
	];
	If[verbose,Print[func,": evs=",evs]];
	Which[
		modeltype=="DiscreteTime",
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Max[Abs[evs]]<=1.+tolerance],True,
			Evaluate[Max[Abs[evs]]>1.+tolerance],False,
			Else,Indeterminate
		],
		modeltype=="ContinuousTime",
		res=Which[
			Evaluate[Max[Re[evs]]===Indeterminate],Indeterminate,
			Evaluate[Max[Re[evs]]>tolerance],False,
			Evaluate[Max[Re[evs]]<=tolerance],True, 
			Else,Indeterminate		
		]
	];

Return[res];

];


(* break up combned traitsandpops *)
EcoStableQ[traitsandpops_?AttributesAndVariablesQ,opts___?OptionQ]:=
EcoStableQ[ExtractTraits[traitsandpops],ExtractVariables[traitsandpops],opts];


Options[EcoStableQ]={Verbose->False,VerboseAll->False,Method->Automatic,SimplifyResult->Real,Time->t,EcoEigenvaluesOpts->{},Assumptions->{},
Tolerance->10^-8,Fixed->{}};


SelectEcoStable::usage=
"SelectEcoStable[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] selects stable equilibria from \!\(\*
StyleBox[\"sol\", \"TI\"]\).
SelectEcoStable[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] uses trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


SelectEcoStable[attributes:(_?AttributesQ):{},sol_?ListOfVariablesQ,opts___?OptionQ]:=Module[{stableqopts,stable},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

stableqopts=FilterRules[Flatten[{opts,Options[SelectEcoStable]}],Options[EcoStableQ]];

stable=EcoStableQ[attributes,#,Evaluate[Sequence@@stableqopts]]&/@sol;

Return[Part[sol,Flatten[Position[stable,True]]]]
];


SelectEcoStable[attributes:(_?AttributesQ):{},{},opts___?OptionQ]:={};


Options[SelectEcoStable]={};


FindEcoAttractor::usage=
"FindEcoAttractor[] tries to find an ecological attractor.
FindEcoAttractor[\!\(\*
StyleBox[\"init\", \"TI\"]\)] uses initial guess \!\(\*
StyleBox[\"init\", \"TI\"]\).
FindEcoAttractor[\!\(\*
StyleBox[\"attributes\", \"TI\"]\)] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
FindEcoAttractor[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"init\", \"TI\"]\)] uses \!\(\*
StyleBox[\"attributes\", \"TI\"]\) and \!\(\*
StyleBox[\"init\", \"TI\"]\).";


FindEcoAttractor[attributesin:(_?AttributesQ):{},variables:(_?VariablesQ):{},opts___?OptionQ]:=
(*FindEcoAttractor[traits_?NumericRuleListQ,variables:(_?VariablesQ):{},opts___?OptionQ]:=*)

Module[{
func=FuncStyle["FindEcoAttactor"],
(*options*)
verbose,verboseall,method,chop,numtries,eqtolerance,
solveecoeqopts,nsolveecoeqopts,findecoeqopts,ecosimopts,findecocycleopts,
warmup,tmax,finaltmax,eqthreshold,time,period,maxperiod,maxperiodmultiplier,
testvalidity,teststability,fixed,
(*other variables*)
attributes,eq,valideq,tmp,evs,ics,stableeq,res,essol,ddt,eqflag,per,ecosimflag},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[!MemberQ[{Automatic,"SolveEcoEq","NSolveEcoEq","FindEcoEq","EcoSim","FindEcoCycle"},method],
	Message[FindEcoAttractor::badmtd];Return[$Failed]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoAttractor]}]];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqtolerance=Evaluate[EqTolerance/.Flatten[{opts,Options[FindEcoAttractor]}]];
solveecoeqopts=Evaluate[SolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
nsolveecoeqopts=Evaluate[NSolveEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecoeqopts=Evaluate[FindEcoEqOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
findecocycleopts=Evaluate[FindEcoCycleOpts/.Flatten[{opts,Options[FindEcoAttractor]}]];
warmup=Evaluate[WarmUp/.Flatten[{opts,Options[FindEcoAttractor]}]];
tmax=Evaluate[TMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[tmax===Automatic,If[modelperiod==0||modelperiod==\[Infinity],tmax=1000,tmax=100*modelperiod]];
finaltmax=Evaluate[FinalTMax/.Flatten[{opts,Options[FindEcoAttractor]}]];
If[finaltmax===Automatic,finaltmax=tmax];
numtries=Evaluate[NumTries/.Flatten[{opts,Options[FindEcoAttractor]}]];
eqthreshold=Evaluate[EqThreshold/.Flatten[{opts,Options[FindEcoAttractor]}]];
time=Evaluate[Time/.Flatten[{opts,Options[FindEcoAttractor]}]];
period=Evaluate[Period/.Flatten[{opts,Options[FindEcoAttractor]}]];
maxperiod=Min[tmax-1,Evaluate[MaxPeriod/.Flatten[{opts,Options[FindEcoAttractor]}]]];
maxperiodmultiplier=Evaluate[MaxPeriodMultiplier/.Flatten[{opts,Options[FindEcoAttractor]}]];
testvalidity=Evaluate[TestValidity/.Flatten[{opts,Options[FindEcoAttractor]}]];
teststability=Evaluate[TestStability/.Flatten[{opts,Options[FindEcoAttractor]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoAttractor]}]];

AppendTo[solveecoeqopts,Fixed->fixed];
AppendTo[nsolveecoeqopts,Fixed->fixed];
AppendTo[findecoeqopts,Fixed->fixed];
AppendTo[ecosimopts,Fixed->fixed];
AppendTo[findecocycleopts,Fixed->fixed];

ecosimflag=False;

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes];

If[method===Automatic,
	Which[
		modelperiod==\[Infinity]&&time===t,
		method="EcoSim",
		0<modelperiod<\[Infinity]&&time===t,
		method="FindEcoCycle",
		variables=={},
		method="NSolveEcoEq",
		Else,
		If[naux+npops+Sum[\[ScriptCapitalN][gu]*ngcomps[gu],{gu,guilds}]<=4,
			method="NSolveEcoEq",
			method="FindEcoEq"
		];
	];
];

Which[
	method=="EcoSim",Goto[ecosim],
	method=="FindEcoCycle",Goto[findecocycle]
];


(* method FindEcoEq *)

If[method=="FindEcoEq",
	If[verbose,Print[func,": FindEcoEq Mode"]];
	If[variables=={},Message[FindEcoAttractor::novars,"FindEcoEq"];Return[$Failed]];
	If[warmup>0,
		If[verbose,
			Print[func,": Warming Up..."];
			With[{warmup=warmup,time=time,attributes=attributes,options=Sequence@@ecosimopts},
				PrintCall[Global`ics=FinalSlice[EcoSim[attributes,variables,warmup,Time->time,options]]]]
		];
		ics=FinalSlice[EcoSim[attributes,variables,warmup,Time->time,Evaluate[Sequence@@ecosimopts]]];
	, (* else *)
		ics=variables;
	];
	If[verbose,
		With[{ics=ics,time=time,attributes=attributes,options=Sequence@@findecoeqopts},
			PrintCall[Global`eq=FindEcoEq[attributes,ics,Time->time,options]]]
	];
	eq={FindEcoEq[attributes,ics,Time->time,Evaluate[Sequence@@findecoeqopts],VerboseAll->verboseall]};

	(* try more initial conditions if required *)

	If[numtries>=2,
		Do[
			(* perturb ICs *)
			ics=ReplacePart[#,2->#[[2]]*10^RandomReal[{-1,1}]]& /@ variables;
			If[verbose,
				With[{ics=ics,time=time,attributes=attributes,options=Sequence@@findecoeqopts},
					PrintCall[Global`tmp=FindEcoEq[attributes,ics,Time->time,options]]]
			];
			tmp=FindEcoEq[attributes,ics,Time->time,Evaluate[Sequence@@findecoeqopts],VerboseAll->verboseall];
			(* if distinct eq, add to tmp *)
			If[tmp!={},
				If[CompoundAnd[Table[RuleListDistance[tmp,bar,DistanceFunction->ChessboardDistance]>eqtolerance,{bar,eq}]],AppendTo[eq,tmp]];
			];
		,{numtries-1}];
	];	
];


(* method SolveEcoEq *)

If[method=="SolveEcoEq",
	If[verbose,
		Print[func,": SolveEcoEq Mode"];
		With[{time=time,attributes=attributes,options=Sequence@@solveecoeqopts},
			PrintCall[Global`eq=SolveEcoEq[attributes,Time->time,options]]]
	];
	eq=SolveEcoEq[attributes,Time->time,Evaluate[Sequence@@solveecoeqopts],VerboseAll->verboseall];
];


(* method NSolveEcoEq *)

If[method=="NSolveEcoEq",
	If[verbose,
		Print[func,": NSolveEcoEq Mode"];
		With[{time=time,attributes=attributes,options=Sequence@@nsolveecoeqopts},
			PrintCall[Global`eq=Union[NSolveEcoEq[attributes,Time->time,options]]]]
	];
	eq=Union[Flatten[{NSolveEcoEq[attributes,Time->time,Evaluate[Sequence@@nsolveecoeqopts],VerboseAll->verboseall]},1]];
];


(* method FindEcoCycle *)

Label[findecocycle];
If[method=="FindEcoCycle",
	If[verbose,Print[func,": FindEcoCycle Mode"]];
	If[variables=={},Message[FindEcoAttractor::novars,"FindEcoCycle"];Abort[]];

	(* figure out period to try *)
	If[period===Automatic,
		Which[
			modelperiod=!=0,
			per=modelperiod,
			modeltype=="DiscreteTime",
			per=1
		]
	,
		per=period
	];

	If[ecosimflag==False, (* if we haven't already been through ecosim *)
		If[warmup>0,
			If[verbose,
				Print[func,": Warming up..."];
				With[{warmup=warmup,per=per,time=time,attributes=attributes,options=Sequence@@ecosimopts},
					PrintCall[Global`ics=FinalSlice[EcoSim[attributes,variables,Floor[warmup,per],Time->time,options]]]]
			];
			ics=FinalSlice[EcoSim[attributes,variables,Floor[warmup,per],Time->time,Evaluate[Sequence@@ecosimopts]]];
		, (* else *)
			ics=variables;
		],
		ics=FinalSlice[essol] (* if we have been through ecosim *)
	];
	
	Which[
		modeltype=="DiscreteTime",
		If[verbose,
			With[{ics=ics,per=per,maxperiodmultiplier=maxperiodmultiplier,attributes=attributes,options=Sequence@@findecocycleopts},
				PrintCall[Global`eq=Table[FindEcoCycle[attributes,ics,options,Period->Global`permult*per],{Global`permult,maxperiodmultiplier}]]]
		];
		eq=Table[
			FindEcoCycle[attributes,ics,Evaluate[Sequence@@findecocycleopts],Period->permult*per]
		,{permult,maxperiodmultiplier}];
		(* remove $Failed & multiple period solutions *)
		eq=Select[eq,#=!=$Failed&&FindPeriod[#]==#[[1,2]]["PathLength"]&];
	,
		modeltype=="ContinuousTime",
		If[verbose,
			With[{ics=ics,attributes=attributes,options=Sequence@@findecocycleopts},
				PrintCall[Global`eq=FindEcoCycle[attributes,ics,options]]]
		];
		eq=Select[{FindEcoCycle[attributes,ics,VerboseAll->verboseall,Evaluate[Sequence@@findecocycleopts]]},#=!=$Failed&]
	];	
];

If[verbose,Print[func,": eq=",eq]];


(* assess validity and stability of eq *)

If[testvalidity,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		valideq={}
	, 
		If[Head[eq[[1,1,2]]]=!=InterpolatingFunction,
			valideq=SelectValid[eq];
			If[verbose,Print[func,": valid eq=",valideq]];
		,
			valideq=eq (* SelectValid doesn't work on InterpolatingFunctions yet *)
		]
	];
	If[valideq=={},Message[FindEcoAttractor::novalideq]];
];

If[teststability,
	If[!ListQ[eq]||eq=={}||eq==={$Failed}, (* in case of Solve/NSolve or FindEcoCycle failure *)
		stableeq={}
	,
		stableeq=SelectEcoStable[attributes,valideq,Time->time,Fixed->fixed];
		If[verbose,Print[func,": stable eq=",stableeq]];
	]
,
	stableeq=valideq
];

If[Length[stableeq]==0, (* no stable eq, try EcoSim once *)
	If[ecosimflag==False,
		Message[FindEcoAttractor::nosteq,attributes];
		method="EcoSim"
	,
		Message[FindEcoAttractor::giveup];
		Return[EcoSim[attributes,FinalSlice[essol],finaltmax,Time->time,Evaluate[Sequence@@ecosimopts],VerboseAll->verboseall]]
	]
];
If[Length[stableeq]==1,res=stableeq[[1]];Goto[done]]; (* successful *)
If[Length[stableeq]>=2,Message[FindEcoAttractor::musteq,Length[stableeq],attributes];Goto[done]];


(* if we're still here, no stable equilibrium, so switch to EcoSim *)

(* method EcoSim *)

Label[ecosim];
If[method=="EcoSim",
	If[verbose,Print[func,": EcoSim Mode"]];
	If[variables=={},Message[FindEcoAttractor::novars,"EcoSim"];Abort[]];
	
	If[Length[ics]==0,ics=variables];
	
	If[verbose,
		With[{ics=ics,tmax=tmax,time=time,attributes=attributes,options=Sequence@@ecosimopts},
			PrintCall[Global`eesol=EcoSim[attributes,ics,tmax,Time->time,options]]]
	];

	essol=EcoSim[attributes,ics,tmax,Time->time,Evaluate[Sequence@@ecosimopts],VerboseAll->verboseall];
	If[verbose,Print[PlotDynamics[essol]]];
	
	(* if aperiodically forced, we're done *)
	If[modelperiod===\[Infinity],res=essol;Goto[done]];
	
	(* otherwise check for equilibrium (or modelperiod cycle) *)
	If[0<modelperiod,
		ddt=FinalDerivatives[essol,modelperiod][[All,2]],
		ddt=FinalDerivatives[essol][[All,2]]
	];
	If[verbose,Print[func,": d/dt=",ddt]];
	If[Max[Abs[ddt]]<eqthreshold,
		If[verbose,Print[func,": Equilibrium found"]];
		(* construct stableeq *)
		If[modelperiod=!=0,
			If[modeltype=="ContinuousTime",res=FinalSlice[essol,modelperiod]];
			If[modeltype=="DiscreteTime",res=FinalSlice[essol,modelperiod-1]]
		,
			res=FinalSlice[essol]
		];
		Goto[done];
	,
		(* steady state eq failed *)
		Message[FindEcoAttractor::nostst,ddt,tmax];
		(* attempt to find Period using FindEcoCycle approach *)
		ecosimflag=True; (* already been through ecosim *)
		method="FindEcoCycle";
		period=FindPeriod[essol,MaxPeriod->maxperiod];
		Goto[findecocycle];
	];
];

Label[done];

If[chop,
	Return[Chop[res]],
	Return[res]
];

]];


Options[FindEcoAttractor]={Verbose->False,VerboseAll->False,
Method->Automatic,Chop->True,NumTries->1,EqTolerance->10^-10;
SolveEcoEqOpts->{},NSolveEcoEqOpts->{},FindEcoEqOpts->{},EcoSimOpts->{},FindEcoCycleOpts->{},
WarmUp->0,TMax->Automatic,EqThreshold->10^-5,Time->t,Period->Automatic,MaxPeriod->16,MaxPeriodMultiplier->2,
TestValidity->True,TestStability->True,FinalTMax->Automatic,Fixed->{}};


FindEcoAttractor::badmtd=
"The Method option should be a built-in method name (\"SolveEcoEq\", \"NSolveEcoEq\", \"FindEcoEq\", or \"EcoSim\")";

FindEcoAttractor::novars=
"No initial population sizes given, cannot continue with `1`.";

FindEcoAttractor::nocycle=
"Warning: couldn't find a cycle with period less than MaxPeriod=`1`.";

FindEcoAttractor::novalideq=
"Couldn't find a valid equilibrium.";

FindEcoAttractor::giveup=
"Couldn't find an equilibrium or cycle, returing EcoSim.";

FindEcoAttractor::nosteq=
"Warning: couldn't find a stable equilibrium with attributes `1`. Trying EcoSim.";

FindEcoAttractor::musteq=
"Warning: found `1` stable equilibria with attributes `2`.";

FindEcoAttractor::nostst=
"Warning: EcoSim did not find a steady state (d/dt=`1` at t=`2`). Trying FindEcoCycle.";


PlotEcoIsoclines::usage =
"PlotEcoIsoclines[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoIsoclines[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)},{\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoIsoclines[attributesin:(_?AttributesQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoIsoclines"],
(* options *)
verbose,verboseall,fixed,time,percapita,isoclinestyle,framelabel,contourplotopts,
(* other variables *)
attributes,fixedvars,nonfixedvars,lookup1,lookup2,style1,style2,label1,label2,g,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print["PlotEcoIsoclines: fixedvars=",fixedvars]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoIsoclines]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
(*isoclinelabels=Evaluate[IsoclineLabels/.Flatten[{opts,Options[PlotEcoIsoclines]}]];*)
{label1,label2}={ToString[var1],ToString[var2]};


(* figure out what are the components on the x- and y-axes *)
lookup1=LookUp[var1];
lookup2=LookUp[var2];

(* set up isocline styles *)
Which[
	lookup1[[1]]=="gcomp",
	style1=If[isoclinestyle===Automatic,Join[Flatten[{linestyle[var1]}],{Thickness[0.005],color[var1][0]}],isoclinestyle[[1]]],
	lookup1[[1]]=="pcomp"||lookup1[[1]]=="aux",
	style1=If[isoclinestyle===Automatic,Join[Flatten[{linestyle[var1]}],{Thickness[0.005],color[var1]}],isoclinestyle[[1]]]
];

Which[
	lookup2[[1]]=="gcomp",
	style2=If[isoclinestyle===Automatic,Join[Flatten[{linestyle[var2]}],{Thickness[0.005],color[var2][1]}],isoclinestyle[[2]]],
	lookup2[[1]]=="pcomp"||lookup2[[1]]=="aux",
	style2=If[isoclinestyle===Automatic,Join[Flatten[{linestyle[var2]}],{Thickness[0.005],color[var2]}],isoclinestyle[[2]]]
];

(*Print[{style1,style2}];*)

nonfixedvars={var1,var2};

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

contourplotopts=FilterRules[Flatten[{opts,ContourShading->None,Options[PlotEcoIsoclines]}],Options[ContourPlot]];
(*Print[contourplotopts];*)

g=(EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,opts]/.RHS/.RemoveVariablets/.{t->time})
	-Which[modeltype=="DiscreteTime"&&percapita==False,{var1,var2},modeltype=="DiscreteTime"&&percapita==True,{1,1},Else,{0,0}];
If[verbose,Print[func,": g=",g]];

res=ContourPlot[{g[[1]]==0,g[[2]]==0},{var1,var1min-10^-10,var1max},{var2,var2min-10^-10,var2max},
	ContourStyle->{style1,style2},Evaluate[Sequence@@contourplotopts],FrameLabel->framelabel];
	
If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotEcoIsoclines]={
	Time->t,PerCapita->False,Fixed->{},
	IsoclineStyle->Automatic,FrameLabel->Automatic,
	MaxRecursion->3,
	Verbose->False,VerboseAll->False};


PlotEcoStreams::usage =
"PlotEcoStreams[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoStreams[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoStreams[attributesin:(_?AttributesQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEcoStreams"],
(* options *)
verbose,verboseall,fixed,time,framelabel,streamplotopts,
(* other variables *)
attributes,fixedvars,nonfixedvars,g,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEcoStreams]}]];
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEcoStreams]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEcoStreams]}]];
If[framelabel===Automatic,framelabel={var1,var2}];
streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEcoStreams]}],Options[StreamPlot]];

nonfixedvars={var1,var2};

(* look for aux and pcomps not in the ICs, treat as fixed at 0 *)
Do[
	If[!MemberQ[Join[nonfixedvars,fixedvars],var],AppendTo[fixed,var->0]]
,{var,AllPopsAndAuxs}];

g=(EcoEqns[attributes,Fixed->fixed,NonFixedVars->nonfixedvars,opts]/.RHS/.RemoveVariablets/.{t->time})
	-If[modeltype=="DiscreteTime",{var1,var2},{0,0}];
If[verbose,Print[func,": g=",g]];

res=MyStreamPlot[g,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@streamplotopts],PlotRange->{{0,1},{0,1}},FrameLabel->framelabel];
		
If[monitor,NotebookClose[nb]];

Return[res]

]];

Options[PlotEcoStreams]={
	Fixed->{},Time->t,
	FrameLabel->Automatic,PlotRangePadding->Scaled[0.02],StreamStyle->Gray,StreamColorFunction->None,
	Verbose->False,VerboseAll->False};


PlotEcoPhasePlane::usage=
"PlotEcoPhasePlane[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ecological streams and isoclines in the phase plane of variables \!\(\*
StyleBox[\"var1\", \"TI\"]\) and \!\(\*
StyleBox[\"var2\", \"TI\"]\).
PlotEcoPhasePlane[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] uses trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).";


PlotEcoPhasePlane[attributes:(_?AttributesQ):{},{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
(* options *)
plotecoisoclinesopts,plotecostreamsopts},

(* handle options *)

plotecoisoclinesopts=FilterRules[
	Flatten[{Evaluate[PlotEcoIsoclinesOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoIsoclines],Options[ContourPlot]]];
plotecostreamsopts=FilterRules[
	Flatten[{Evaluate[PlotEcoStreamsOpts/.Flatten[{opts,Options[PlotEcoPhasePlane]}]],opts,Options[PlotEcoPhasePlane]}],
	Join[Options[PlotEcoStreams],Options[StreamPlot]]];

Return[Show[
	PlotEcoStreams[attributes,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecostreamsopts]],
	PlotEcoIsoclines[attributes,{var1,var1min,var1max},{var2,var2min,var2max},Evaluate[Sequence@@plotecoisoclinesopts]]
]]
];


Options[PlotEcoPhasePlane]={
	Fixed->{},Time->t,FrameLabel->Automatic,
	PlotEcoIsoclinesOpts->{},PlotEcoStreamsOpts->{},
	Verbose->False,VerboseAll->False};


PrestonPlot::usage =
"PrestonPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] makes a Preston species abundance distribution plot based on \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PrestonPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PrestonPlot"],
(* options *)
gu,minpop,bandwidth,showspecies,markerstyle,plotopts,listplotopts,plotrange,weightfunction,time,
(* other variables *)
abunds,pos,data,\[ScriptCapitalD],hist,stix
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[PrestonPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[PrestonPlot]}]];
bandwidth=Evaluate[Bandwidth/.Flatten[{opts,Options[PrestonPlot]}]];
showspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PrestonPlot]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PrestonPlot]}]];
plotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[Plot]];
listplotopts=FilterRules[Flatten[{opts,Options[PrestonPlot]}],Options[ListPlot]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PrestonPlot]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[PrestonPlot]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PrestonPlot]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][sol];

abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];

If[time===t,
	abunds=TemporalMean[abunds],
	abunds=Slice[abunds,time];
];

abunds=Select[abunds,#[[2]]>minpop&];
pos=abunds[[All,1,2]];
data=Log[abunds[[All,2]]];

\[ScriptCapitalD]=SmoothKernelDistribution[data,bandwidth,{"Bounded",{Min[data],Max[data]},"Gaussian"}];
hist=LogLinearPlot[PDF[\[ScriptCapitalD],Log[x]],{x,E^Min[data],E^Max[data]},PlotRange->All];
If[showspecies,
	stix=ListLogLinearPlot[
		Transpose[{E^data,Table[0,{Length[pos]}]}],PlotStyle->markerstyle,
		Evaluate[Sequence@@listplotopts],PlotMarkers->{"|",8}],
	stix={}];
Return[Show[stix,hist,AxesOrigin->{Max[data],0},PlotRange->plotrange]];

]];


Options[PrestonPlot]={
Guild->Automatic,WeightFunction->"Total",Time->t,
MinPop->0,Bandwidth->"Scott",ShowSpecies->True,MarkerStyle->Gray,PlotRange->{0,All}};


WhittakerPlot::usage =
"WhittakerPlot[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] makes a Whittaker rank-abundance plot based on \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


WhittakerPlot[sol_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["WhittakerPlot"],
(* options *)
gu,minpop,plotopts,weightfunction,time,
(* other variables *)
abunds,data
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
gu=Evaluate[Guild/.Flatten[{opts,Options[WhittakerPlot]}]];
If[gu===Automatic,gu=guilds[[1]]];
minpop=Evaluate[MinPop/.Flatten[{opts,Options[WhittakerPlot]}]];
plotopts=FilterRules[Flatten[{opts,Options[WhittakerPlot]}],Options[ListLogPlot]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[WhittakerPlot]}]];
time=Evaluate[Time/.Flatten[{opts,Options[WhittakerPlot]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][sol];

abunds=ExtractGuilds[WeightedAbundance[sol,WeightFunction->weightfunction],gu];

If[time===t,
	abunds=TemporalMean[abunds],
	abunds=Slice[abunds,time];
];

abunds=Sort[Table[Subscript[gu,i],{i,Subscript[\[ScriptCapitalN], gu]}]/.abunds,Greater];
abunds=Select[abunds,#>minpop&];

Return[ListLogPlot[abunds,Evaluate[Sequence@@plotopts]]];

]];


Options[WhittakerPlot]={Guild->Automatic,MinPop->0,PlotRange->All,WeightFunction->"Total",Time->t};


PlotGuild::usage =
"PlotGuild[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] plots abundance vs trait/species for the species in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PlotGuild[attributesin:(_?AttributesQ):{},solin_?VariablesQ,opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotGuild"],
(* options *)
verbose,plottype,plotpoints,
listplotopts,arrayplotopts,listplot3dopts,listlineplot3dopts,
logged,minpop,plotstyle,time,weightfunction,
gu,tr,species,
(* other variables *)
traitrange,res,dat,tmin,tmax,framelabel,
sol,traits,abunds,pos,plotmin,xcoord
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotGuild]}]];
If[Global`debug,verbose=True];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotGuild]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotGuild]}]];
logged=Evaluate[Logged/.Flatten[{opts,Options[PlotGuild]}]];

listplotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ListPlot]],
	Evaluate[ListPlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
arrayplotopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ArrayPlot]],
	Evaluate[ArrayPlotOpts/.Flatten[{opts,Options[PlotGuild]}]]];
listplot3dopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[ListPlot3D]],
	Evaluate[ListPlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]]];
listlineplot3dopts=Join[FilterRules[Flatten[{opts,Options[PlotGuild]}],Options[MyListLinePlot3D]],
	Evaluate[ListLinePlot3DOpts/.Flatten[{opts,Options[PlotGuild]}]]];

plotpoints=Evaluate[PlotPoints/.Flatten[{opts,Options[PlotGuild]}]];
traitrange=Evaluate[TraitRange/.Flatten[{opts,Options[PlotGuild]}]];

gu=Evaluate[Guild/.Flatten[{opts,Options[PlotGuild]}]];
If[gu===Automatic,gu=guilds[[1]]];
tr=Evaluate[Trait/.Flatten[{opts,Options[PlotGuild]}]];
If[tr===Automatic,If[gtraits[gu]=!={},tr=gtraits[gu][[1]],tr=None]];

minpop=Evaluate[MinPop/.Flatten[{opts,Options[PlotGuild]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotGuild]}]];
weightfunction=Evaluate[WeightFunction/.Flatten[{opts,Options[PlotGuild]}]];
(*If[weightfunction==="Components",weightfunction=Select[gcomps[gu],comptype[#]==="Extensive"&]];*)
species=Evaluate[Species/.Flatten[{opts,Options[PlotGuild]}]];

(*Print["{gu,tr}=",{gu,tr}];*)

If[ngcomps[gu]>1,
	sol=WeightedAbundance[ExtractGuilds[solin,gu],WeightFunction->weightfunction],
	sol=ExtractGuilds[solin,gu]
];

(*Print["sol=",sol];*)


(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributesin,solin];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];


If[TemporalRuleListQ[sol]&&time===t, (* temporal dynamics *)
	{tmin,tmax}={InitialTime[sol],FinalTime[sol]};
	Which[
		plottype=="ArrayPlot",
		If[plotpoints===Automatic,plotpoints=200];
		If[tr=!=None,
			traitrange={Min[Table[Subscript[tr, sp],{sp,Subscript[\[ScriptCapitalN], gu]}]/.attributesin],Max[Table[Subscript[tr, sp],{sp,Subscript[\[ScriptCapitalN], gu]}]/.attributesin]};
			framelabel={tr,"t"},
			traitrange={1,Subscript[\[ScriptCapitalN], gu]};
			framelabel={"sp","t"}
		];
		If[InterpolatingFunctionFunctionQ[sol],
			dat=Table[Subscript[gu, sp][t]/.sol,{sp,Subscript[\[ScriptCapitalN], gu]},{t,tmin,tmax,(tmax-tmin)/plotpoints}],
			dat=Table[(Subscript[gu, sp]/.sol)["Values"],{sp,Subscript[\[ScriptCapitalN], gu]}]
		];		
		res=ArrayPlot[Reverse@dat,Evaluate[Sequence@@arrayplotopts],DataRange->{{tmin,tmax},traitrange},FrameLabel->framelabel]
	,
		plottype=="Plot3D",
		If[plotpoints===Automatic,plotpoints=100];
		If[InterpolatingFunctionFunctionQ[sol],
			dat=Flatten[Table[{t,Subscript[tr, sp]/.attributesin,Subscript[gu, sp][t]/.sol},{sp,Subscript[\[ScriptCapitalN], gu]},{t,tmin,tmax,(tmax-tmin)/plotpoints}],1],
			dat=Flatten[Table[Insert[Subscript[tr, sp]/.attributesin,2]/@(Subscript[gu, sp]/.sol)["Path"],{sp,Subscript[\[ScriptCapitalN], gu]}],1]
		];
		res=ListPlot3D[dat,Evaluate[Sequence@@listplot3dopts],AxesLabel->{"t",tr,gu}]
	,
		plottype=="LinePlot3D",
		If[plotstyle===Automatic,plotstyle=Table[color[Subscript[tr,1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}]];
		If[InterpolatingFunctionFunctionQ[sol],
			res=ParametricPlot3D[Evaluate[Table[{t,Subscript[tr, sp]/.attributesin,Subscript[gu, sp][t]/.sol},{sp,Subscript[\[ScriptCapitalN], gu]}]],{t,tmin,tmax},
				PlotStyle->plotstyle,Evaluate[Sequence@@listlineplot3dopts],AxesLabel->{"t",tr,gu}]
		,
			dat=Table[Insert[Subscript[tr, sp]/.attributesin,2]/@(Subscript[gu, sp]/.sol)["Path"],{sp,Subscript[\[ScriptCapitalN], gu]}];
			res=MyListLinePlot3D[dat,PlotStyle->plotstyle,Evaluate[Sequence@@listlineplot3dopts],AxesLabel->{"t",tr,gu}]
		]
	,
		Else,
		Message[PlotGuild::badmtd];Return[$Failed]
	];
	Return[res]
];

(* non-temporal dynamics *)

sol=Slice[sol,time];
traits=Slice[attributesin,time];
(*Print["sol=",sol];
Print["traits=",traits];*)

If[plotstyle===Automatic,
	If[weightfunction==="Components",
		plotstyle=Reverse[Table[Directive[ColorData[97,i],Thick,Opacity[1]],{i,Length[Select[gcomps[gu],comptype[#]==="Extensive"&]]}]]
	,
		If[species=!=None,
			plotstyle=Table[If[i==species,
				Directive[Thick,color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]],
				Directive[Thin,color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]]]
			],{i,Subscript[\[ScriptCapitalN], gu]}],
			plotstyle=Table[color[Subscript[gu, 1]][SpFrac[i,\[ScriptCapitalN][gu]]],{i,Subscript[\[ScriptCapitalN], gu]}]
		];
	];
];
(*Print["plotstyle=",plotstyle];*)

If[tr===None,
	xcoord=i;
	framelabel={"sp",Subscript[gu,Global`sp]},
	xcoord=Subscript[tr,i];
	framelabel={Subscript[tr,Global`i],Subscript[gu,Global`i]}
];

If[logged==False,
	(* non-logged *)
	If[weightfunction==="Components",
		Return[ListPlot[
			Reverse[Transpose[{Table[xcoord,{i,Subscript[\[ScriptCapitalN], gu]}],#}/.traits]&/@Accumulate[Transpose[Table[Subscript[gu,i],{i,Subscript[\[ScriptCapitalN], gu]}]/.sol]]],
			Filling->Table[j->{Axis,ModPart[plotstyle,j]},{j,Length[Select[gcomps[gu],comptype[#]==="Extensive"&]]}],
			PlotStyle->None,
			Evaluate[Sequence@@listplotopts],
			PlotRange->All,AxesLabel->framelabel
		]]
	,
		Return[ListPlot[
			Table[{{xcoord,0},{xcoord,Subscript[gu,i]}},{i,Subscript[\[ScriptCapitalN], gu]}]/.traits/.sol,
				PlotStyle->plotstyle,
				Evaluate[Sequence@@listplotopts],
				PlotRange->All,Joined->True,AxesLabel->framelabel
			]]
		]
,
		(* logged *)
		sol=Select[sol,#[[2]]>minpop&];
		pos=sol[[All,1,2]]; (* positions *)
		plotmin=Min[Table[Subscript[gu,i],{i,pos}]/.sol];
		Return[ListLogPlot[
			Table[{{xcoord,plotmin},{xcoord,Subscript[gu,i]}},{i,pos}]/.traits/.sol,
			PlotStyle->plotstyle,
			Evaluate[Sequence@@listplotopts],
			PlotRange->{plotmin,All},Joined->True,AxesLabel->framelabel
		]]
];


]];


Options[PlotGuild]={
PlotType->"ArrayPlot",PlotStyle->Automatic,PlotPoints->Automatic,
ListPlotOpts->{},
ListPlot3DOpts->{BoxRatios->{2,1,1},PlotRange->{0,All},ColorFunction->"ThermometerColors",Mesh->None},
ArrayPlotOpts->{AspectRatio->1/2,ImageSize->Large,ColorFunction->"ThermometerColors",Mesh->None,FrameTicks->{All,All,False,False},PlotRange->All},
ListLinePlot3DOpts->{BoxRatios->{2,1,1},PlotRange->{All,All,{0,All}}},
Guild->Automatic,Trait->Automatic,Species->None,
WeightFunction->"Total",
Logged->False,MinPop->0,Time->t};


(* split combined traitsandpops *)
PlotGuild[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=
PlotGuild[ExtractTraits[sol],ExtractVariables[sol],opts];


PlotGuild::badmtd="The Method option should be a built-in method name (\"ArrayPlot\", \"Plot3D\", or \"ListLinePlot3D\" for temporal dynamics).";


ImpactVector::usage=
"ImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\)] returns the impact of \!\(\*
StyleBox[\"sp\", \"TI\"]\) on {\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}.";


ImpactVector[{var1_,var2_},sp_]:=D[{eqn[var1],eqn[var2]}/.RemoveVariablets,sp];


PlotImpactVector::usage=
"PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] plots the impact vector of \!\(\*
StyleBox[\"sp\", \"TI\"]\) on {\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)} at \!\(\*
StyleBox[\"point\", \"TI\"]\).
PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, {\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"sp\", \"TI\"], \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"sp\", \"2\"], \"TI\"]\), \[Ellipsis]}, \!\(\*
StyleBox[\"point\", \"TI\"]\)] plots impact vectors of multiple species.
PlotImpactVector[{\!\(\*
StyleBox[SubscriptBox[\"var\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"var\", \"2\"], \"TI\"]\)}, \!\(\*
StyleBox[\"sp\", \"TI\"]\), {\!\(\*
StyleBox[SubscriptBox[\"point\", \"1\"], \"TI\"]\), \!\(\*
StyleBox[SubscriptBox[\"point\", \"2\"], \"TI\"]\), \[Ellipsis]}] plots at multiple points.";


(* make listable across points *)
PlotImpactVector[{var1_,var2_},sp_,points_?RuleListListQ,opts___?OptionQ]:=(PlotImpactVector[{var1,var2},sp,#,opts]&/@points);


(* make listable across sps *)
PlotImpactVector[{var1_,var2_},sps_List,point_?RuleListQ,opts___?OptionQ]:=Module[{plotstyles,nsp},
	plotstyles=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotImpactVector]}]];
	nsp=Length[sps];
	If[plotstyles===Automatic,plotstyles=Table[Automatic,{nsp}]];
	Table[
		PlotImpactVector[{var1,var2},sps[[i]],point,PlotStyle->ModPart[plotstyles,i],opts]
	,{i,nsp}]
];


PlotImpactVector[{var1_,var2_},sp_,point_?RuleListQ,opts___?OptionQ]:=Module[{scale,plotstyle},
(* handle options *)
scale=Evaluate[Scale/.Flatten[{opts,Options[PlotImpactVector]}]];
plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotImpactVector]}]];
If[plotstyle===Automatic,plotstyle={color[sp],linestyle[sp]}];

Graphics[Join[Flatten[{plotstyle}],{Arrow[{{var1,var2},{var1,var2}+scale*Normalize@ImpactVector[{var1,var2},sp]}/.point]}]]
];


Options[PlotImpactVector]={Scale->1,PlotStyle->Automatic};


Inv::usage=
"Inv[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
Inv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

StablePopulationStructure::usage=
"StablePopulationStructure[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
StablePopulationStructure[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

ReproductiveValues::usage =
"ReproductiveValues[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the reproductive values of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the reproductive value of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
ReproductiveValues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";

InvSPS::usage =
"InvSPS[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"inv\", \"TI\"]\)] calculates the growth rate and stable population structure of invader \!\(\*
StyleBox[\"inv\", \"TI\"]\) invading the resident community \!\(\*
StyleBox[\"sol\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), Guild\[Rule]\!\(\*
StyleBox[\"guild\", \"TI\"]\)] calculates the growth rate and stable population structure of an invader in guild \!\(\*
StyleBox[\"guild\", \"TI\"]\) (default=first), using resident trait values / interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\).
InvSPS[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"traitinv\", \"TI\"]\)] uses invader traits \!\(\*
StyleBox[\"traitinv\", \"TI\"]\).";


InvSPS[traitsandpops_?AttributesAndVariablesQ,invaderin:(_?InvaderQ):{},opts:OptionsPattern[]]:=
InvSPS[ExtractAttributes[traitsandpops],ExtractVariables[traitsandpops],invaderin,opts];


InvSPS[attributesin:(_?NotInvaderTraitsQ):{},solin:(_?VariablesQ):{},invaderin:(_?InvaderQ):{},opts:OptionsPattern[]]:=Module[{
func=FuncStyle["InvSPS"],
(* options *)
verbose,verboseall,method,
guild,time,simplifyresult,frominv,rv,qssics,
qssmethod,
ndsolveopts,nintegrateopts,integrateopts,
solveopts,nsolveopts,findrootopts,
findecocycleopts,eigensystemopts,simplifyopts,
(* other variables *)
attributes,invader,invtraits,variables,
invtype,invid,invunk,zeropcomps,sol,
inveqns,invunks,qsseqns,qssunks,qsssubs,mode,
tstart,tend,removets,qsssols,qsssol,eval,evec,invsol,j,tempIF},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

attributes=FixAttributes[attributesin];

$InvCount++; (* increment $InvCount *)

If[Global`debug,
	Print["attributesin=",attributesin];
	Print["solin=",solin];
	Print["invaderin=",invaderin];
	Print["opts=",opts];
];

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

method=OptionValue[Method];
time=OptionValue[Time];
qssmethod=OptionValue[QSSMethod]; 
ndsolveopts=OptionValue[NDSolveOpts];
nintegrateopts=OptionValue[NIntegrateOpts];
integrateopts=OptionValue[IntegrateOpts];
solveopts=OptionValue[SolveOpts];
nsolveopts=OptionValue[NSolveOpts];
findrootopts=OptionValue[FindRootOpts];
findecocycleopts=OptionValue[FindEcoCycleOpts];
eigensystemopts=OptionValue[EigensystemOpts];
simplifyresult=OptionValue[SimplifyResult];
simplifyopts=OptionValue[SimplifyOpts];
guild=OptionValue[Guild];
If[guild===Automatic,guild=Append[guilds,1][[1]]];
frominv=OptionValue[FromInv];
rv=OptionValue[RV];
qssics=OptionValue[QSSICs];

(* figure out number of species in guilds *)
variables=FixVariables[solin];
(*variables=solin;*)
(*Print["variables=",variables];*)
Set\[ScriptCapitalN][attributes,variables];
(*Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];*)

If[modelwhenevents!={},Message[InvSPS::whenevents]];

(* assemble sol [resident state] *)

(* in case any extensive pops weren't given, assume they're 0 *)
zeropcomps=Flatten[Table[Table[
	If[comptype[pcomp]=="Extensive",pcomp->0,pcomp->pcomp]
,{pcomp,pcomps[pop]}],{pop,pops}]];
sol=JoinFirst[variables,zeropcomps];
(*Print[sol];*)

(* if a time given, evaluate sol there *)
If[time=!=t&&!NumericRuleListQ[sol],sol=Slice[sol,time]];

If[Global`debug,Print[func,": sol=",sol]];

invader=Flatten[{invaderin}];
If[Global`debug,Print["invader=",invader]];
(* what kind of invader do we have? *)
invtraits={};
Which[
	(* no invader given *)
	invader==={},
	If[Global`debug,Print["no invader given"]];
	Which[
		nguilds!=0,{invtype,invid}={"guild ghost",guild},
		npops!=0,{invtype,invid}={"pop",pops[[1]]}
	];
,
	(* specific guild ghost invader *)
	AttributesQ[invader],
	If[Global`debug,Print["specific guild ghost invader"]];
	{invtype,invid}={"guild ghost",LookUp[invader[[1,1]]][[2]]};
	invtraits=ExtractAttributes[invader];
,
	(* whole-guild ghost invader *)
	LookUp[invader[[1]]][[1]]=="guild"&&Length[LookUp[invader[[1]]]]==2,
	If[Global`debug,Print["whole-guild ghost invader"]];
	{invtype,invid}={"guild ghost",invader[[1]]};
,
	(* whole-gcomp ghost invader -- is this even a good idea?! *)
	LookUp[invader[[1]]][[1]]=="gcomp"&&Length[LookUp[invader[[1]]]]==3,
	If[Global`debug,Print["whole-gcomp ghost invader"]];
	{invtype,invid}={"gcomp ghost",invader[[1]]};
	Return[{Simplify[eqn[Subscript[invid,0]]/Subscript[invid,0]/.sol/.attributes],"N/A"}]
,
	(* guild member invader *)
	LookUp[invader[[1]]][[1]]=="guild"||LookUp[invader[[1]]][[1]]=="gcomp",
	If[Global`debug,Print["guild member invader"]];
	{invtype,invid}={"guild member",invader[[1]]};
(*Print[invid," -- ",invid/.WeightedAbundance[sol]];*)
	If[(invid/.WeightedAbundance[sol])>0,Message[InvSPS::nonzero](*;Abort[]*)],
	(* pop invader *)
	LookUp[invader[[1]]][[1]]=="pop"||LookUp[invader[[1]]][[1]]=="pcomp",
	If[Global`debug,Print["pop invader"]];
	{invtype,invid}={"pop",LookUp[invader[[1]]][[2]]};
(*Print[invid," -- ",invid/.WeightedAbundance[sol]];*)
(*Print[comps[invid]];
Print[FilterRules[sol,comps[invid]]];
Print[TemporalMean@FilterRules[sol,comps[invid]]];
Print[WeightedAbundance@TemporalMean@FilterRules[sol,comps[invid]]];*)
	If[(invid/.WeightedAbundance@TemporalMean@FilterRules[sol,comps[invid]])>0,Message[InvSPS::nonzero](*;Abort[]*)]
,
	Else,
	Message[InvSPS::unkinv];Return[$Failed]
];

If[Global`debug,Print[func,": {invtype,invid}=",{invtype,invid}]];
If[Global`debug,Print["invtraits=",invtraits]];


(* set up inveqns, invunks, qss stuff *)

inveqns=invunks={};
qsssubs=qsseqns=qssunks={};

Do[
(*Print["comp=",comp];*)
	invunk=Switch[invtype,"guild ghost",Subscript[comp,0],"guild member",Subscript[comp,invid[[2]]],"pop",comp];
	If[comptype[invunk]=="Extensive",
		AppendTo[inveqns,eqn[invunk]];
		AppendTo[invunks,invunk];
		If[invtype=="guild ghost",AppendTo[qsssubs,invunk->0]];
	];
	If[comptype[invunk]=="Intensive",
		AppendTo[qsseqns,eqn[invunk]==0];
		If[qssmethod=="FindRoot",
			AppendTo[qssunks,{invunk,Min[range[invunk]]+0.01}],
			AppendTo[qssunks,invunk];
		];
	];
,{comp,Switch[invtype,"guild ghost",gcomps[invid],"guild member",gcomps[LookUp[invader[[1,1]]][[2]]],"pop",pcomps[invid]]}];

If[Global`debug,
	Print[func,": inveqns=",inveqns];Print[func,": invunks=",invunks];
	Print[func,": qsseqns=",qsseqns];Print[func,": qsssubs=",qsssubs];Print[func,": qssunks=",qssunks]
];


(* decide on mode *)

Which[
	(modelperiod==0&&(Length[sol]==0||!MemberQ[{InterpolatingFunction,TemporalData},Head[sol[[1,2]]]]))
	||(modelperiod=!=0&&(method==="Instantaneous"||time=!=t)),
	mode="eigenvalue",
	modeltype=="ContinuousTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===InterpolatingFunction)),
	mode="continuoustime floquet",
	modeltype=="DiscreteTime"&&
	((modelperiod=!=0&&method=!="Instantaneous"&&time===t)||(Length[sol]>0&&Head[sol[[1,2]]]===TemporalData)),
	mode="discretetime floquet"
];
(*Print[func,": mode=",mode];*)


(* calculate invasion fitness *)

Which[
	(* ContinuousTime Floquet mode *)
	mode=="continuoustime floquet",
	If[verbose,Print[func,": ContinuousTime Floquet mode"]];

	(* figure out period *)
	If[sol!={}&&Head[sol[[1,2]]]===InterpolatingFunction,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	If[Global`debug,Print[func,": {tstart,tend}=",{tstart,tend}]];
	
	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[qssics===Automatic, (* no QSS ICs given? then average corresponding components from residents *)
			qssics=Table[qssunk->
				Mean[Select[Select[FinalSlice[sol],(#[[1,0]]==Subscript)&],(#[[1,1]]==qssunk[[1]])&][[All,2]]]
			,{qssunk,qssunks}];
		];
		If[verbose,
			With[{tr=Join[attributes,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[attributes,invtraits],Join[FinalSlice[sol],qssics],Sequence@@findecocycleopts];
		If[qsssol==$Failed,Message[InvSPS::noqsssol];Return[{$Failed}]];
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	If[Global`debug,Print[func,": qsssol=",qsssol]];


	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		Which[
			method===Automatic||method=="NIntegrate",
			If[verbose,Print[func,": ContinuousTime Floquet mode (1 comp): NIntegrate"]];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@nintegrateopts},
				PrintCall[Global`eval=NIntegrate[eq/.Global`sol/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=NIntegrate[Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@nintegrateopts]]/(tend-tstart);
(*Print["eval=",eval];*)
			Return[{eval,"?"}]
		,
			method=="NDSolve",
			If[Global`debug,Print[func,": ContinuousTime Floquet mode (1 comp): NDSolve"]];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
				PrintCall[Global`invsol=NDSolve[{Global`x'[t]==eq/.Global`qsssol,Global`x[tstart]==0},Global`x,{t,tstart,tend},op]];
				PrintCall[Global`eval=Global`x[tend]/dt/.Global`invsol]
			]];
			invsol=NDSolve[{x'[t]==Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,x[tstart]==0},x,
				{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]][[1]];
			eval=x[tend]/(tend-tstart)/.invsol;
			Return[{eval,"?"}];
		,
			method=="Integrate",
			If[verbose,Print[func,": ContinuousTime Floquet mode (1 comp): Integrate"]];
			If[verbose,
				With[{eq=Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol,
				tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@integrateopts},
				PrintCall[Global`eval=Integrate[eq/.Global`qsssol,{t,tstart,tend},op]/dt]
			]];
			eval=Integrate[Cancel[inveqns[[1]]/invunks[[1]]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol,{t,tstart,tend},Evaluate[Sequence@@integrateopts]]/(tend-tstart);
			Return[{Chop[eval],"?"}];
		,
			method=="EcoSim",
			sol=EcoSim[];
		,
			Else,
			Message[InvSPS::bdmtd];
			Return[]
		];
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		If[verbose,Print[func,": ContinuousTime Floquet mode (2+ comps)"]];
		removets={Subscript[x_/;(comptype[x]=="Extensive"),0][t]->Subscript[x,0],t->time};
(*Print[removets];*)
		j=D[inveqns/.AddVariablets/.attributes/.removets,{invunks}];
		If[Global`debug,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,liu=Length[invunks],tstart=tstart,tend=tend,dt=tend-tstart,op=Sequence@@ndsolveopts},
			PrintCall[Global`invsol=NDSolve[{Global`x'[t]==j . Global`x[t]/.Global`sol/.Global`qsssol,Global`x[tstart]==IdentityMatrix[liu]},Global`x,{t,tstart,tend},op]];
			PrintCall[Global`eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[Global`x[tend]/.Global`invsol]/dt]
		]];
		invsol=NDSolve[{x'[t]==j . x[t]/.invtraits/.sol/.qsssol,x[tstart]==IdentityMatrix[Length[invunks]]},x,{t,tstart,tend},Evaluate[Sequence@@ndsolveopts]];
		eval=Max@Re@Log@Chop@Sort@Eigenvalues@Evaluate[x[tend]/.invsol]/(tend-tstart);
		Return[{eval,"?"}];
	]
,
	(* DiscreteTime Floquet mode *)
	mode=="discretetime floquet",
	If[verbose,Print[func,": DiscreteTime Floquet mode"]];

	(* figure out time range *)
	If[Head[sol[[1,2]]]===TemporalData,
		{tstart,tend}={InitialTime[sol],FinalTime[sol]},
		{tstart,tend}={0,modelperiod}
	];
	If[Global`debug,Print["{tstart,tend}=",{tstart,tend}]];

	(* are there any Intensive components to be solved for? *)
	If[Length[qssunks]>0,
		If[verbose,
			With[{tr=Join[attributes,invtraits],ic=Join[FinalSlice[sol],qssics],op=Sequence@@findecocycleopts},
			PrintCall[Global`qsssol=FindEcoCycle[trait,ic,op]]
		]];
		qsssol=FindEcoCycle[Join[attributes,invtraits],Join[FinalSlice[sol],qssics],Evaluate[Sequence@@findecocycleopts]]
	,
		If[verbose,PrintCall[Global`qsssol={}]];
		qsssol={}
	];
	If[Global`debug,Print[func,": qsssol=",qsssol]];

	removets={Subscript[x_/;comptype[x]=="Extensive",0][t]->Subscript[x,0],t->time};

	Which[
		(* one extensive component: use log pop eqn *)
		Length[invunks]==1,
		If[verbose,Print[func,": DiscreteTime Floquet mode (1 comp)"]];
		If[verbose,
			With[{eq=Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits]/.SimplifyLogE],tstart=tstart,tend=tend,te=tend-tstart+1},
			(*PrintCall[Global`eval=Product[eq/.Global`sol/.Global`qsssol,{t,tstart,tend}]^(1/te)]*)
			PrintCall[Global`eval=Sum[eq/.Global`sol/.Global`qsssol,{t,tstart,tend}]/te]
		]];
		(*eval=Product[inveqns\[LeftDoubleBracket]1\[RightDoubleBracket]/invunks\[LeftDoubleBracket]1\[RightDoubleBracket]/.AddVariablets/.invtraits/.sol/.qsssol,{t,tstart,tend}]^(1/(tend-tstart+1));
		(*Print["eval=",eval];*)
		Return[{(Log@Chop@ComplexExpand[eval])/.SimplifyLogE,"?"}]*)
		eval=Sum[Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol]/.SimplifyLogE],{t,tstart,tend}]/(tend-tstart+1);
		If[tend==\[Infinity],
			Return[{With[{tstart=tstart,tend=tend,eq=Simplify[Log[inveqns[[1]]/invunks[[1]]/.AddVariablets/.attributes/.invtraits/.sol/.qsssol]/.SimplifyLogE]},Unevaluated@Defer[Sum[eq,{t,tstart,tend}]/\[Infinity]]],"?"}],
			Return[{eval,"?"}]
		]
	,
		(* more than one extensive component, calculate Floquet exponent *)
		Length[invunks]>1,
		If[verbose,Print[func,": DiscreteTime Floquet mode (2+ comps)"]];
		j=D[inveqns/.AddVariablets/.attributes/.removets,{invunks}];
		If[verbose,Print[func,": j=",j]];
		If[verbose,
			With[{j=j/.invtraits,tend=tend,te=tend+1},
			PrintCall[Global`invsol=ListMultiplier[Table[j/.Global`sol/.Global`qsssol,{t,0,tend}]]];
			PrintCall[Global`eval=Log[Max@Re@Chop@Sort@Eigenvalues[Global`invsol]^(1/te)]]
		]];
		invsol=ListMultiplier[Table[j/.invtraits/.sol/.qsssol,{t,0,tend}]];		
		Return[{Log[Max@Re@Chop@Sort@Eigenvalues[invsol]^(1/(tend+1))],"?"}];
	]
,
	(* Eigenvalue mode *)
	mode=="eigenvalue",
	If[verbose,Print[func,": eigenvalue mode"]];
	
	(* subrule to remove [t]'s *)
	(*removets={t\[Rule]time};*)

	(* are there any Intensive components to be solved for? *)

	If[Length[qssunks]>0,
		Which[
			qssmethod=="Solve",
			qsssols=Solve[qsseqns/.qsssubs/.attributes/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@solveopts]],
			qssmethod=="NSolve",
			qsssols=NSolve[qsseqns/.qsssubs/.attributes/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@nsolveopts]],
			qssmethod=="FindRoot",
			qsssols={FindRoot[qsseqns/.qsssubs/.attributes/.sol/.invtraits/.t->time,qssunks,Evaluate[Sequence@@findrootopts]]}
		];
	,
		qsssols={{}}];
	If[verbose,Print[func,": qsssols=",qsssols]];
	If[VectorQ[qsssols,NumericRuleListQ[#]&],
		qsssol=SelectValid[qsssols], (* should add SelectEcoStable here? *)
		qsssol=qsssols
	];
	If[verbose,Print[func,": qsssol=",qsssol]];
	If[Length[qsssol]!=1,Message[InvSPS::noqsssol,Length[qsssol]];Return[{$Failed}]];
	If[Length[invunks]==1,
		j={{Cancel[(inveqns[[1]]/invunks[[1]])]/.qsssol[[1]]/.qsssubs/.sol/.invtraits/.attributes/.t->time}}
	,
		(* make Jacobian matrix of Extensive components *)
		(* what about 0th order terms?! *)
		j=D[inveqns/.attributes/.qsssol[[1]]/.invtraits,{invunks}]/.sol/.t->time;
	];

	If[Global`debug,Print[func,": j=",j]];

	Which[
		Length[j]==1, (* 1 extensive component *)
		If[verbose,Print[func,": 1 extensive component"]];
		eval=j[[1,1]];
		evec={1};
	,
		Length[j]>1, (* >1 extensive component *)
	
		(* calculate eigenvalues *)

		If[(MatrixQ[#,NumericQ]&)[j/.qsssubs],
			(* numerical jacobian *)
			If[verbose,Print[func,": numerical Jacobian"]];
			
			If[rv,
				{{eval},{evec}}=SortedEigensystem[Transpose[j/.qsssubs],1,Sequence@@eigensystemopts],
				{{eval},{evec}}=SortedEigensystem[j/.qsssubs,1,Sequence@@eigensystemopts]
			];
			evec=evec/Sign[evec[[1]]]
		,
			(* symbolic jacobian *)
			If[verbose,Print[func,": symbolic Jacobian"]];

			If[Dimensions[j/.qsssubs]=={2,2},
				eval=Simplify[Re[1/2*(j[[1,1]]+j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])]];
				If[rv,
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[1,2]]),1}],
					evec=Simplify[{(j[[1,1]]-j[[2,2]]+Sqrt[j[[1,1]]^2+4j[[1,2]]j[[2,1]]-2j[[1,1]]j[[2,2]]+j[[2,2]]^2])/(2j[[2,1]]),1}]
				]
			,
				eval=Max[Re[Eigenvalues[j/.qsssubs,Sequence@@eigensystemopts]]];
				evec="?";
				If[!frominv,Message[InvSPS::nosymev]];
			];
		];
	];
	
	(* add [t] to InterpolatingFunctions (but not ones with [var]) *)
	eval=eval/.x_InterpolatingFunction->x[t]/.x_InterpolatingFunction[t][var_]->x[var];
	If[verbose,Print[func,": eigenvalue=",eval]];
	If[verbose,Print[func,": eigenvector=",evec]];
	
	(* return answer *)
	Quiet[Which[
		modeltype=="ContinuousTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			simplifyresult===Real,
			Return[RealSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			Else,
			Return[{eval,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
	,
		modeltype=="DiscreteTime",
		Which[
			simplifyresult===True,
			Return[Simplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			simplifyresult===Full,
			Return[FullSimplify[{Log@Max@Chop@ComplexExpand[eval]/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]},Evaluate[Sequence@@simplifyopts]]]
		,
			Else,
			Return[{(Log@Max@Chop@ComplexExpand[eval])/.SimplifyLogE,Sort[Join[Thread[Rule[invunks,evec]],qsssol[[1]]]]}]
		]
		(*Return[{Simplify[Log@Max@Chop@ComplexExpand[eval],Assumptions\[Rule]{_\[Element]Reals}],evec}];*)
	],{Simplify::time,Simplify::gtime}];


];

]];


Options[InvSPS]={
Method->Automatic,Time->t,
NIntegrateOpts->{Method->{Automatic,"SymbolicProcessing"->0}},IntegrateOpts->{},NDSolveOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},EigensystemOpts->{},FindEcoCycleOpts->{},
QSSMethod->"NSolve",QSSICs->Automatic,
SimplifyResult->True,SimplifyOpts->{_\[Element]Reals,TimeConstraint->{0.1,1}},
Guild->Automatic,FromInv->False,RV->False,
Verbose->False,VerboseAll->False};


Inv[args___]:=InvSPS[args,FromInv->True][[1]];
StablePopulationStructure[args___]:=InvSPS[args][[2]];
ReproductiveValues[args___]:=InvSPS[args,RV->True][[2]];


InvSPS::nosymev=
"Warning: don't know how to find analytical StablePopulationStructure for > 2x2 matrix.";

InvSPS::unkinv=
"Can't figure out who's invading: please specify.";

InvSPS::nonzero=
"Warning: invasion rate only defined for rare invaders.";

InvSPS::noqsssol=
"Found `1` QSS solutions for invader's Intensive components, need one.";

InvSPS::notraits=
"Trait of invader not defined, so NIntegrate can't work.  Try Method->\"Integrate\" or give invader traits.";

InvSPS::whenevents=
"Warning: WhenEvents involving populations and guilds are not handled properly in InvSPS yet.";


$InvCount::usage = "Counts number of times Inv called.";
$InvCount=0;


DInv::usage =
"DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] calculates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident trait values \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"sol\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where DInv will be evaluated.
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
DInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives derivatives for all traits in Guild (default=first).";

NDInv::usage =
"NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\), \!\(\*
StyleBox[\"point\", \"TI\"]\)] numerically approximates a derivative of invasion fitness with respect to \!\(\*
StyleBox[\"target\", \"TI\"]\), with resident traits \!\(\*
StyleBox[\"traits\", \"TI\"]\) and community \!\(\*
StyleBox[\"sol\", \"TI\"]\)\!\(\*
StyleBox[\".\", \"Code\"]\)
\!\(\*
StyleBox[\"target\", \"TI\"]\) can be \!\(\*
StyleBox[\"x\", \"TI\"]\) for a single trait, {\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)} for multiple traits, {\!\(\*
StyleBox[\"x\", \"TI\"]\),2} for the second derivative with respect to x, {{\!\(\*
StyleBox[\"x1\", \"TI\"]\),\!\(\*
StyleBox[\"x2\", \"TI\"]\),...,\!\(\*
StyleBox[\"xn\", \"TI\"]\)},2} for the Hessian matrix.
\!\(\*
StyleBox[\"point\", \"TI\"]\) is where NDInv will be evaluated.
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"target\", \"TI\"]\)] gives derivatives for all species in a guild determined from \!\(\*
StyleBox[\"target\", \"TI\"]\).
NDInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] gives derivatives for all traits in Guild (default=first).";


Options[DInv]={Fixed->{},InvOpts->{},Method->"D",Guild->Automatic,Species->All,FindEcoAttractorOpts->{},
Chop->True,SimplifyResult->False,RelativeStepSize->0.001,AbsoluteStepSize->0.001,Time->t,Verbose->False,VerboseAll->All};

notDInvOpts=Except[Alternatives@@Replace[Options[DInv],h_[a_,_]:>h[a,_],1]];


NumDInv[traitsin_?NumericRuleListQ,rest___]:=DInv[traitsin,rest];


DInv[traitsin:(_?TraitsQ):{},solin:(_?VariablesQ):{},{var_:All,ord_?NumberQ},pointin:notDInvOpts:{},opts:OptionsPattern[]]:=

Module[{
func=FuncStyle["DInv"],
(* options *)
verbose,verboseall,fixed,fixedattributes,fixedvariables,method,\[Epsilon]r,\[Epsilon]a,invopts,guild,species,time,simplifyresult,chop,findecoattractoropts,
(* other variables *)
sol,res,res2,traits,traits2,point,targetgu,targettrait,inv,sp,vars,
pt1,pt2,
h,h1,h2,invl,invr,invc},

If[solin==$Failed,Return[$Failed]];

(*Print["traitsin=",traitsin];
Print["solin=",solin];
Print["{var,ord}=",{var,ord}];
Print["pointin=",pointin];*)

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

fixed=OptionValue[Fixed];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
If[Global`debug,Print[func,": fixedattributes=",fixedattributes]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];

invopts=OptionValue[InvOpts];
method=OptionValue[Method];
\[Epsilon]a=OptionValue[AbsoluteStepSize];
\[Epsilon]r=OptionValue[RelativeStepSize];
guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
species=OptionValue[Species];
time=OptionValue[Time];
AppendTo[invopts,Time->time];
simplifyresult=OptionValue[SimplifyResult];
chop=OptionValue[Chop];
findecoattractoropts=OptionValue[FindEcoAttractorOpts];

(* handle blanks & figure out number of species in guilds *)
traits=DeleteInvaders[FixAttributes[traitsin]];
(*Print["traits=",traits];*)
sol=FixVariables[solin];
Set\[ScriptCapitalN][Join[traits,fixedattributes]];
(*Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];*)

If[solin==="FindEcoAttractor",
	If[verbose,
		With[{tr=traits,op=Sequence@@findecoattractoropts},
		PrintCall[Global`sol=FindEcoAttractor[tr,op]]
	]];
	sol=FindEcoAttractor[traits,Evaluate[Sequence@@findecoattractoropts]]
];
If[verbose,Print[func,": sol=",sol]];

(* thread a list of points *)
If[Length[Dimensions[pointin]]==2,
	(*Print["mapping over points"];*)
	Return[Map[DInv[traits,sol,{var,ord},#,opts]&,pointin]]
];

(*Print["pointin=",pointin];
Print["species=",species];*)

(* figure out point where to evaluate derivative *)
If[pointin=={},
	(* no point given *)
	If[var===All,
		targetgu=guild,
		If[ListQ[var],targetgu=LookUp[var[[1]]][[2]],targetgu=LookUp[var][[2]]]
	];
	If[species===All,If[\[ScriptCapitalN][targetgu]==0,species=0,species=Table[sp,{sp,\[ScriptCapitalN][targetgu]}]]];
	If[ListQ[species],
		If[method=="NDInv",Return[Table[DInv[traits,sol,{var,ord},{},Species->sp,opts],{sp,species}]]];
		point=Table[Table[Subscript[gtrait,0]->Subscript[gtrait,sp],{gtrait,gtraits[targetgu]}],{sp,species}]/.traits
	,
		pt1=Table[
			If[guild1[interaction]===targetgu,Subscript[interaction,0,sp\[Prime]_]->(Subscript[interaction,species,sp\[Prime]]/.traitsin),Nothing]
		,{interaction,interactions}];
		pt2=Table[
			If[guild2[interaction]===targetgu,Subscript[interaction,sp\[Prime]_,0]->(Subscript[interaction,sp\[Prime],species]/.traitsin),Nothing]
		,{interaction,interactions}];
		point=Join[pt1,pt2,Table[Subscript[gtrait,0]->(Subscript[gtrait,species]/.traitsin),{gtrait,gtraits[targetgu]}]]
	];
,
	(* point given *)
	targetgu=LookUp[pointin[[1,1]]][[2]];
	point=pointin
];
If[Global`debug,Print[func,": targetgu=",targetgu]];
If[Global`debug,Print[func,": point=",point]];

If[var===All,
	vars=Table[Subscript[gtrait,0],{gtrait,gtraits[targetgu]}],
	vars=var
];
If[Global`debug,Print[func,": vars=",vars]];

Which[
	method=="D",
	If[verbose,
		With[{tr=traits,so=sol,tg=targetgu,op=Sequence@@invopts},
		PrintCall[Global`inv=Simplify[Inv[tr,so,Guild->tg,op],Assumptions->_\[Element]Reals]]
	]];
	inv=Inv[Join[traits,fixedattributes],Join[sol,fixedvariables],Guild->targetgu,Evaluate[Sequence@@invopts]];
	If[verbose,Print[func,": inv=",inv]];
	If[verbose,
		With[{vars=vars,inv=inv,point=point,traits=traits},
		PrintCall[Global`res=D[inv,{vars,ord}]/.point/.traits]
	]];
	res=D[inv,{vars,ord}]/.point/.traits/.fixed; (* is /.traits necessary?? *)
	If[verbose,Print[func,": res=",res]];
,
	method=="NDInv",
	Which[
		ord==1,
		If[ListQ[vars],
			(* gradient *)
			Return[DInv[traits,sol,{#,ord},point,opts]& /@ vars];
		, (* first derivative *)
			If[Global`debug,Print[func,": 1st derivative (finite difference)"]];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invl=",invl]];
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invr=",invr]];
			If[invl==$Failed||invr==$Failed,Return[$Failed]];
			res=(invr-invl)/(2h);
		]
	,
		ord==2, 
		If[ListQ[vars],
			(* Hessian matrix *)
			If[Global`debug,Print[func,": Hessian matrix (finite difference)"]];
			res=ConstantArray[0,{Length[vars],Length[vars]}];
			Do[
				(* diagonal entries *)		
				h=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
				res=ReplacePart[res,{v1,v1}->
					(Inv[traits,sol,RuleListTweak[point,vars[[v1]],h],Evaluate[Sequence@@invopts]]
					-2Inv[traits,sol,point,Evaluate[Sequence@@invopts]]
					+Inv[traits,sol,RuleListTweak[point,vars[[v1]],-h],Evaluate[Sequence@@invopts]])/(h^2)
				];
				(* offdiagonal entries *)
				Do[
					h1=(\[Epsilon]r*vars[[v1]]/.point)+\[Epsilon]a;
					h2=(\[Epsilon]r*vars[[v2]]/.point)+\[Epsilon]a;
					res=ReplacePart[res,{{v1,v2},{v2,v1}}->
						(Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{h1,-h2}],Evaluate[Sequence@@invopts]]
						-Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,h2}],Evaluate[Sequence@@invopts]]
						+Inv[traits,sol,RuleListTweak[point,vars[[{v1,v2}]],{-h1,-h2}],Evaluate[Sequence@@invopts]])/(4*h1*h2)
					];					
				,{v2,v1+1,Length[vars]}]
			,{v1,1,Length[vars]}];
		, (* second derivative *)
			If[Global`debug,Print[func,": 2nd derivative (finite difference)"]];
			h=(\[Epsilon]r*var/.point)+\[Epsilon]a;
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,-h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invl=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invl=Inv[tr,so,pt,op]]
				]
			]];
			invl=Inv[traits,sol,RuleListTweak[point,vars,-h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invl=",invl]];
			If[verbose,
				With[{tr=traits,so=sol,pt=RuleListTweak[point,vars,h],op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invr=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invr=Inv[tr,so,pt,op]]
				]
			]];
			invr=Inv[traits,sol,RuleListTweak[point,vars,h],Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invr=",invr]];
			If[verbose,
				With[{tr=traits,so=sol,pt=point,op=Sequence@@invopts},
				If[InterpolatingFunctionFunctionQ[so],
					PrintCall[Global`invc=Inv[tr,Global`sol,pt,op]],
					PrintCall[Global`invc=Inv[tr,so,pt,op]]
				]
			]];
			invc=Inv[traits,sol,point,Evaluate[Sequence@@invopts]];
			If[verbose,Print[func," invc=",invc]];
			If[invl==$Failed||invr==$Failed||invc==$Failed,Return[$Failed]];
			res=(invr-2invc+invl)/(h^2);
			];
		]
	,
		Else,
		Message[DInv::badmtd];
		Return[$Failed];
	];

(* postprocess & return answer *)

Which[
	simplifyresult===True,
	res2=Simplify[res/.traits],
	simplifyresult===Real,
	res2=RealSimplify[res/.traits],
	simplifyresult===Full,
	res2=FullSimplify[res/.traits,Assumptions:>{_\[Element]Reals}],
	Else,
	res2=res/.traits
];

If[chop==True,Return[Chop[res2]],Return[res2]];

]];


(* first derivative abbreviated syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,1];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no point syntax *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_?NumberQ},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,2];*)
	If[Global`debug,Print["DInv: no point given"]];
	DInv[traits,solin,{var,ord},Guild->Automatic,opts]
);


(* no order *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,3];*)
	If[Global`debug,Print["DInv: assuming first-order derivative."]];
	DInv[traits,solin,{var,1},pointin,opts]
);


(* no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,{var:(_Subscript|_List|_Symbol):All},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,4];*)
	If[Global`debug,Print["Dinv: no order, no point"]];
	DInv[traits,solin,{var,1},Guild->1,opts]
);


(* no var, no order, no point *)
DInv[traits_?TraitsQ,solin_?VariablesQ,opts___?OptionQ]:=(
	(*AppendTo[Global`uses,5];*)
	If[Global`debug,Print["DInv: no var, no order, no point"]];
	DInv[traits,solin,{All,1},opts]
);


(* first derivative abbreviated syntax & break up traitsandpops *)
DInv[eesol_?AttributesAndVariablesQ,var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,6];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax & break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,1},pointin,opts]
);


(* general derivative abbreviated syntax *)
DInv[eesol_?AttributesAndVariablesQ,{var:(_Subscript|_List|_Symbol):All,ord_Integer},pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,7];*)
	If[Global`debug,Print["DInv: general derivative abbreviated syntax"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],{var,ord},pointin,opts]
);


(* break up traitsandpops *)
DInv[eesol_?AttributesAndVariablesQ,rest___]:=(
	(*AppendTo[Global`uses,8];*)
	If[Global`debug,Print["DInv: break up traitsandpops"]];
	DInv[ExtractTraits[eesol],ExtractVariables[eesol],rest]
);


(* first derivative abbreviated syntax, no traits or variables *)
DInv[var:(_Subscript|_List|_Symbol):All,pointin:notDInvOpts:{},opts___?OptionQ]:=(
	(*AppendTo[Global`uses,9];*)
	If[Global`debug,Print["DInv: first derivative abbreviated syntax, no traits or variables"]];
	DInv[{},{},{var,1},pointin,opts]
);


NDInv[args___]:=DInv[args,Method->"NDInv"];


MaximizeInv::usage = 
"MaximizeInv[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds the trait value(s) that maximize invasion fitness into a community with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


MaximizeInv[traits:(_?AttributesQ):{},sol:(_?VariablesQ):{},opts:OptionsPattern[]]:=
 
Module[{
func=FuncStyle["MaximizeInv"],
(* options *)
verbose,verboseall,guild,delayinv,invopts,maximizeopts,method,constraints,
(* other variables *)
vars,unks,inv,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* reset $InvCount *)
$InvCount=0;

(* handle options *)

verbose=OptionValue[Verbose];
If[Global`debug,verbose=True];
verboseall=OptionValue[VerboseAll];
If[verboseall,verbose=True];

guild=OptionValue[Guild];
If[guild===Automatic,guild=guilds[[1]]];
delayinv=OptionValue[DelayInv];
invopts=OptionValue[InvOpts];
maximizeopts=OptionValue[MaximizeOpts];
method=OptionValue[Method];
constraints=OptionValue[Constraints];

vars=Table[Subscript[gtrait,0],{gtrait,gtraits[guild]}];
unks=Table[Unk[Subscript[gtrait,0]],{gtrait,gtraits[guild]}];


Which[
	constraints==="None",
	constraints={};
,
	constraints===Automatic,
	constraints=Table[Min[range[gtrait]]<=Subscript[gtrait,0]<=Max[range[gtrait]],{gtrait,gtraits[guild]}]
,
	Else,
	constraints=Table[Min[range[gtrait]]<=Subscript[gtrait,0]<=Max[range[gtrait]],{gtrait,gtraits[guild]}]
];

If[Global`debug,Print["constraints=",constraints]];

If[delayinv==True,
	inv[varz_?NumericListQ]:=Inv[traits,sol,Thread[vars->varz],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	res=NMaximize[Prepend[constraints/.ToUnks,inv[unks]],unks,Evaluate[Sequence@@maximizeopts]];
	, (* else *)
	Off[NIntegrate::inumr];
	inv=Inv[traits,sol,Guild->guild,Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	If[Global`debug,Print[func,": inv=",inv]];
	Which[
		method=="Maximize",
		res=Maximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]],
		method=="NMaximize",
		(* see https://mathematica.stackexchange.com/questions/245404/ *)
		If[$VersionNumber==12.2,
			Block[{Optimization`UseConvexMinimize=False},res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]]],
			res=NMaximize[Prepend[constraints,inv],vars,Evaluate[Sequence@@maximizeopts]]
		],
		Else,
		Message[MaximizeInv::badmtd];
		Return[$Failed]
	];
	On[NIntegrate::inumr]
];

Return[res/.FromUnks];

]];


Options[MaximizeInv]={Guild->Automatic,DelayInv->False,InvOpts->{},MaximizeOpts->{},Constraints->Automatic,Method->"NMaximize",
Verbose->False,VerboseAll->False};


(* break up combined traitsandpops *)
MaximizeInv[sol_?AttributesAndVariablesQ,opts___?OptionQ]:=
	MaximizeInv[ExtractAttributes[sol],ExtractVariables[sol],opts];


GlobalESSQ::usage =
"GlobalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks global ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


GlobalESSQ[traits_?AttributesQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["GlobalESSQ"],
(* options *)
verbose,verboseall,
maximizeinvopts,invthreshold,
(* other variables *)
inv,tmp},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

maximizeinvopts=Evaluate[MaximizeInvOpts/.Flatten[{opts,Options[GlobalESSQ]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[GlobalESSQ]}]];
verbose=Evaluate[Verbose/.Flatten[{opts,Options[GlobalESSQ]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[GlobalESSQ]}]];
If[verboseall,verbose=True];

(* find max invader rate .. if > invthreshold, then not globaless *)

Do[
	tmp[gu]=MaximizeInv[traits,sol,Guild->gu,maximizeinvopts];
	If[verbose,Print[func,": MaximizeInv guild ",gu,"=",tmp[gu]]];
,{gu,guilds}];

Return[{
	Table[If[tmp[gu][[1]]>invthreshold,False,True],{gu,guilds}],
	Table[{tmp[gu][[1]],Table[gtrait->(Subscript[gtrait,0]/.tmp[gu][[2]]),{gtrait,gtraits[gu]}]},{gu,guilds}]}
];

]];


Options[GlobalESSQ]={MaximizeInvOpts->{},InvThreshold->10^-10,Verbose->False,VerboseAll->False};


GlobalESSQ[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=
	GlobalESSQ[ExtractAttributes[eesol],ExtractVariables[eesol],opts];


LocalESSQ::usage=
"LocalESSQ[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] checks local ESS stability with \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological attractor \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


LocalESSQ[traits_?AttributesQ,sol_?VariablesQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["LocalESSQ"],
(* options *)
verbose,
(* other variables *)
res
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoSim]}]];
If[Global`debug,verbose=True];

res=Table[
	NegativeDefiniteMatrixQ/@DInv[traits,sol,{Replace[gtraits[gu],var_Symbol->Subscript[var, 0],1],2}]
,{gu,guilds}];

Return[res]
]];


Options[LocalESSQ]={
};


LocalESSQ[eesol_?AttributesAndVariablesQ,opts___?OptionQ]:=LocalESSQ[ExtractAttributes[eesol],ExtractVariables[eesol],opts];


PlotInv::usage =
"PlotInv[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] plots a fitness landscape, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).";


PlotInv[attributes:(_?AttributesQ):{},sol:(_?VariablesQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotInv"],
(* options *)
verbose,verboseall,monitor,
fixed,species,delayinv,invopts,time,plotopts,plotspecies,markerstyle,plotguildopts,tf,axeslabel,plotrange,tadplotrange,
(* other variables *)
nb,x,iplot,
iopts,imin,imax,tmin,tmax,s,iaspectratio,iticks,iaxesorigin,iplotrangepadding,resplotrange,lmin,
gu,tr,per,res,inv,epilog,tad},

Block[{\[ScriptCapitalN]},

(*Print["attributes=",attributes];
Print["sol=",sol];
Print["{trait1,trait1min,trait1max}=",{trait1,trait1min,trait1max}];*)

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotInv]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotInv]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotInv]}]];
species=Evaluate[Species/.Flatten[{opts,Options[PlotInv]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotInv]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotInv]}]];
If[delayinv===Automatic,If[modelperiod=!=0,delayinv=True,delayinv=False]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotInv]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotInv]}]];
plotspecies=Evaluate[ShowSpecies/.Flatten[{opts,Options[PlotInv]}]];
markerstyle=Evaluate[MarkerStyle/.Flatten[{opts,Options[PlotInv]}]];
plotrange=Evaluate[PlotRange/.Flatten[{opts,Options[PlotInv]}]];
plotguildopts=Join[Evaluate[PlotGuildOpts/.Flatten[{opts,Options[PlotInv]}]],{PlotRange->{0,All}}];
tadplotrange=PlotRange/.plotguildopts;
tf=Evaluate[TADVerticalScale/.Flatten[{opts,Options[PlotInv]}]];
plotopts=FilterRules[Flatten[{opts,Options[PlotInv]}],Options[Plot]];
axeslabel=Evaluate[AxesLabel/.Flatten[{opts,Options[PlotInv]}]];
If[axeslabel===Automatic,axeslabel={trait1}];

(* figure out what trait is on the x-axis *)
{gu,tr}=LookUp[trait1][[2;;3]];

(* add to fixed if species is given *)
If[species=!=None,
	fixed=Flatten@{
		fixed,
		Table[
			{If[guild1[interaction]===gu,Subscript[interaction,0,sp\[Prime]_]->(Subscript[interaction,species,sp\[Prime]]/.attributes),Nothing],
			If[guild2[interaction]===gu,Subscript[interaction,sp\[Prime]_,0]->(Subscript[interaction,sp\[Prime],species]/.attributes),Nothing]}
		,{interaction,EcoEvo`Private`interactions}],
		Table[If[Subscript[gtrait,0]=!=trait1,Subscript[gtrait,0]->(Subscript[gtrait,species]/.attributes),Nothing],{gtrait,gtraits[gu]}]
		}
];
(*Print["fixed=",fixed];*)

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][attributes,sol];

If[monitor,PrintTemporary[Dynamic[ToString[TraditionalForm@trait1]<>"="<>ToString[TraditionalForm@x]]]];

(* plot fitness function *)
If[delayinv,
	(* delay inv *)
	inv[\[FormalX]_?NumberQ]:=Inv[attributes,sol,Join[{Subscript[tr,0]->\[FormalX]},fixed],Guild->gu,Evaluate[Sequence@@invopts],Time->time,VerboseAll->verboseall];
	iplot=Plot[(x=\[FormalX];Evaluate[inv[\[FormalX]]]),{\[FormalX],trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
,
	(* nondelay inv *)
	Off[NIntegrate::inumr];
	inv=Inv[attributes,sol,Guild->gu,Evaluate[Sequence@@invopts],Time->time,VerboseAll->verboseall]/.fixed/.attributes;
	iplot=Plot[inv,{trait1,trait1min,trait1max},
		AxesLabel->axeslabel,PlotRange->{{trait1min,trait1max},plotrange},Evaluate[Sequence@@plotopts],AxesOrigin->{trait1min,0}];
	On[NIntegrate::inumr]
];

(*Print[iplot];*)

(* plot species markers *)
If[Subscript[\[ScriptCapitalN], gu]==0,plotspecies="None"];
Which[
	plotspecies==="Axis",
	If[markerstyle===Automatic,
		epilog=Table[{PointSize[0.015],color[Subscript[tr,sp]][SpFrac[sp,\[ScriptCapitalN][gu]]],Point[{Subscript[tr,sp]/.attributes,0}]},{sp,\[ScriptCapitalN][gu]}],
		epilog=MapThread[Append,{PadRight[{},\[ScriptCapitalN][gu],
			Map[Flatten[{#}]&,markerstyle]],Table[Point[{Subscript[tr,sp]/.attributes,0}],{sp,\[ScriptCapitalN][gu]}]}]
	];
	res=Show[iplot,Epilog->epilog]
,
	plotspecies==="TAD",
	epilog={};
	tad=PlotGuild[attributes,TemporalMean[sol],PlotRange->{{trait1min,trait1max},tadplotrange},Evaluate[Sequence@@plotguildopts],
		ImagePadding->{{0,0},{0,Scaled[0.05]}},Axes->False,Guild->gu,Species->species,Time->time];
(*Print[tad];*)
	{tmin,tmax}=(PlotRange/.AbsoluteOptions[tad,PlotRange])[[2]];
	iopts=AbsoluteOptions[iplot];
	{imin,imax}=(PlotRange/.iopts)[[2]];
	(*Print["{imin,imax}=",{imin,imax}];
	Print["{tmin,tmax}=",{tmin,tmax}];*)
	iaspectratio=AspectRatio/.iopts;
	iticks=Ticks/.iopts;
	iaxesorigin=AxesOrigin/.iopts;
	iplotrangepadding=PlotRangePadding/.iopts;
	(*Print["iaxesorigin=",iaxesorigin];
	Print["iplotrangepadding=",iplotrangepadding];*)
	s=Max[tf*imin/(tmax(tf-1)),tf*(imax-Min[0,imin])/tmax]; (* scale TAD *)
	(*Print["s=",s];*)
	resplotrange={Min[imin,tmin],Max[imax,s*tmax]};
	If[Head[iplotrangepadding[[2,2]]]===Scaled,
		lmin=imax+1.01*Differences[resplotrange][[1]]*iplotrangepadding[[2,2,1]],
		lmin=imax+iplotrangepadding[[2,2]]+0.01*Differences[resplotrange][[1]]
	];
	(*Print["lmin=",lmin];*)
	res=Show[iplot,
		PlotRange->{{trait1min,trait1max},resplotrange},Ticks->iticks,
		Prolog->{{White,Thick,Line[{{iaxesorigin[[1]],lmin},{iaxesorigin[[1]],10^10}}]},
		Inset[Show[tad,AspectRatio->iaspectratio*tf],{0,0},{0,0},Scaled[1]]}];
	(*res=Show[
		iplot,
		PlotRange\[Rule]{{trait1min,trait1max},plotrange},Ticks\[Rule]iticks,
		Epilog\[Rule]{{White,Line[{{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],lmin},{iaxesorigin\[LeftDoubleBracket]1\[RightDoubleBracket],10^10}}]},
		Inset[Show[tad,AspectRatio\[Rule]iaspectratio*tf],{0,0},{0,0},Scaled[1]],
		Inset[Show[iplot,Axes\[Rule]False,PlotRange\[Rule]{{trait1min,trait1max},resplotrange}],{0,0},{0,0},Scaled[1]]}]*)
,
	Else,
	res=iplot
];

If[monitor,NotebookClose[nb]];

Return[res]
]];


(* split combined traitsandpops *)
PlotInv[traitsandpops_?AttributesAndVariablesQ,{trait1_,trait1min_,trait1max_},opts___?OptionQ]:=
PlotInv[ExtractAttributes[traitsandpops],ExtractVariables[traitsandpops],{trait1,trait1min,trait1max},opts];


Options[PlotInv]={
	InvOpts->{},Fixed->{},Species->None,
	DelayInv->Automatic,Time->t,
	MarkerStyle->Automatic,ShowSpecies->"TAD",PlotGuildOpts->{},TADVerticalScale->0.25,
	AxesLabel->Automatic,PlotRange->Automatic,
	PlotStyle->Gray,PlotPoints->5,
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotZIP::usage =
"PlotZIP[{\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] creates a zero invasion plot, with invader \!\(\*
StyleBox[\"inv\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)(inferred if omitted).
PlotZIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}, \!\(\*
StyleBox[\"inv\", \"TI\"]\)] uses equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


PlotZIP[solin_:"FindEcoAttractor",{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},
invaderin:(_?InvaderQ):Automatic,opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotZIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,ics,invthreshold,guild,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
fixedvars,traitinv,subrule,luv1,luv2,gu,tr1,tr2,invader,sol,inv,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotZIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotZIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotZIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotZIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotZIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotZIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotZIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotZIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotZIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotZIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotZIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotZIP]}]];
If[invthreshold===Automatic,invthreshold=If[modeltype=="DiscreteTime",1,0]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotZIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotZIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotZIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

fixedvars=fixed[[All,1]];

(* figure out what are the traits on the x- and y-axes *)

luv1=LookUp[var1];
luv2=LookUp[var2];
(*Print["LookUp[var1]=",luv1," LookUp[var2]=",luv2];*)

traitinv={};subrule={};
If[luv1[[1]]==="gtrait",
	{gu,tr1}=luv1[[2;;3]];
	AppendTo[traitinv,var1->\[FormalX]],
	AppendTo[subrule,var1->\[FormalX]]
];
If[luv2[[1]]==="gtrait",
	If[luv1[[1]]==="gtrait"&&(luv2[[2]]!=gu),Message[PlotZIP::diffsp];Return[$Failed]];
	{gu,tr2}=luv2[[2;;3]];
	AppendTo[traitinv,var2->\[FormalY]],
	AppendTo[subrule,var2->\[FormalY]]
];

(*Print["gu=",gu];
Print["traitinv=",traitinv];
Print["subrule=",subrule];*)

If[
	invaderin===Automatic,
	If[MemberQ[guilds,gu],
		invader=traitinv,
		Message[PlotZIP::unkinv];Return[$Failed]
	]
,
	invader=invaderin
];
(*Print["invader=",invader];*)

If[boundarystyle===Automatic,
	If[LookUp[invader][[1]]=="pcomp",
		boundarystyle={color[invader],Opacity[1]},
		boundarystyle={Black,Opacity[1]}]
];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={var1,var2,"inv"},
		framelabel={var1,var2}
	]
];

(* define resident sol *)
If[solin==="FindEcoAttractor",
	If[fixed=={},
		sol[\[FormalX]_,\[FormalY]_]={}
	,
		If[ics=={},
			(* figure out number of species in guilds *)
			Set\[ScriptCapitalN][fixed];
			If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];
			ics=DefaultICs;
			If[verbose,Print[func,": ics=",ics]];
		];
		If[verbose,
			With[{tr=fixed,ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[\[FormalX],\[FormalY]]=FindEcoAttractor[trait,ics,op]]
		]];
		sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
			result=FindEcoAttractor[fixed,ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			If[printtrace,Print["EcoAttractor (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
			If[result=={$Failed},Message[PlotZIP::feafail,\[FormalX],\[FormalY]]];
			Return[result]
		];
		delayinv=True]
,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{var1->\[FormalX],var2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{var1->\[FormalX],var2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]];
];

(* define inv *)

If[delayinv,
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[\[FormalX],\[FormalY]]=Inv[tr,so,in,op]/.{var1->\[FormalX],var2->\[FormalY]}]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[fixed,sol[\[FormalX],\[FormalY]],invader,Evaluate[Sequence@@invopts],VerboseAll->verboseall]/.subrule;
		If[printtrace,Print["Inv (",var1,"=",\[FormalX],", ",var2,"=",\[FormalY],"): ",result]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=fixed,so=sol[\[FormalX],\[FormalY]],in=invader,op=Sequence@@invopts,sr=subrule,trinv=traitinv},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,in,op]/.sr/.trinv]
	]];
	inv[\[FormalX]_,\[FormalY]_]=Inv[fixed,sol[\[FormalX],\[FormalY]],invader/.Subscript[var_, sub_]->Subscript[var, 0],Evaluate[Sequence@@invopts],VerboseAll->verboseall]/.subrule/.traitinv;
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]]
];

If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[var1],TextCell["="],Dynamic[x]},
		{ExpressionCell[var2],TextCell["="],Dynamic[y]}
		}],WindowTitle->"PlotZIP Progress...",WindowSize->All];
];


Which[
	plottype=="Plot3D",
	res=Plot3D[({x,y}={\[FormalX],\[FormalY]};{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold}),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"]],
	plottype=="ContourPlot",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,PlotRange->{{var1min,var1max},{var2min,var2max}}],
	plottype=="RegionZIP", 
	res=RegionPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="ZIP",
	res=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv[\[FormalX],\[FormalY]]]),{\[FormalX],var1min,var1max},{\[FormalY],var2min,var2max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,
		ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,
		PlotRange->{{var1min,var1max},{var2min,var2max}}],
	Else,
	Message[PlotZIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotZIP]={
	FindEcoAttractorOpts->{},InvOpts->{},
	DelayInv->False,PlotType->"ZIP",ICs->{},Fixed->{},InvThreshold->Automatic,
	PlotOpts->{MaxRecursion->3},
	BoundaryStyle->Automatic,InvStyle->Gray,NonInvStyle->Opacity[0],
	Monitor->False,
	Verbose->False,VerboseAll->False
};


PlotZIP::unkinv=
"Can't figure out who's invading: please specify.";

PlotZIP::diffsp=
"\!\(\*
StyleBox[\"x\", \"TI\"]\)- and \!\(\*
StyleBox[\"y\", \"TI\"]\)-axes should have the same species.";


PlotZNGI::usage =
"PlotZNGI[\!\(\*
StyleBox[\"sp\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots a zero net growth isocline of \!\(\*
StyleBox[\"sp\", \"TI\"]\).
PlotZNGI[{\!\(\*
StyleBox[\"sp1\", \"TI\"]\), \!\(\*
StyleBox[\"sp2\", \"TI\"]\), \[Ellipsis]}, {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots multiple ZNGIs.
PlotZNGI[\!\(\*
StyleBox[\"traits\", \"TI\"]\), {\!\(\*
StyleBox[\"var1\", \"TI\"]\), \!\(\*
StyleBox[\"var1min\", \"TI\"]\), \!\(\*
StyleBox[\"var1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"var2\", \"TI\"]\), \!\(\*
StyleBox[\"var2min\", \"TI\"]\), \!\(\*
StyleBox[\"var2max\", \"TI\"]\)}] plots ZNGIs with \!\(\*
StyleBox[\"traits\", \"TI\"]\).";


PlotZNGI[invaders_?RuleListQ,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotZNGI"],
(* options *)
plotstyle,
(* other variables *)
boundarystyle
},
Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

plotstyle=Evaluate[PlotStyle/.Flatten[{opts,Options[PlotZNGI]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][invaders];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Return[Show[Table[Table[
	If[plotstyle===Automatic,
		boundarystyle={color[Subscript[gcomps[gu][[1]],0]][SpFrac[sp,\[ScriptCapitalN][gu]]],Opacity[1]},
		boundarystyle=Flatten[{plotstyle,Opacity[1]}]
	];
	PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},Table[Subscript[gtrait, 0]->Subscript[gtrait, sp]/.invaders,{gtrait,gtraits[gu]}],
		opts,InvStyle->Opacity[0],BoundaryStyle->boundarystyle]
,{sp,\[ScriptCapitalN][gu]}],{gu,guilds}]]]
]
];


PlotZNGI[invaders_List,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=
	Show[PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},#,opts,InvStyle->Opacity[0]]&/@invaders];


PlotZNGI[invader_,{var1_,var1min_?NumericQ,var1max_?NumericQ},{var2_,var2min_?NumericQ,var2max_?NumericQ},opts___?OptionQ]:=
	PlotZIP[{},{var1,var1min,var1max},{var2,var2min,var2max},invader,opts,InvStyle->Opacity[0]];


Options[PlotZNGI]={
	PlotStyle->Automatic
};


PlotPIP::usage =
"PlotPIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a pairwise invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotPIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.";


PlotPIP[solin_:"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotPIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,randomseeding,
plotopts,plottype,ics,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,res,sol,resinv,inv},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotPIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotPIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotPIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotPIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotPIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotPIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotPIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotPIP]}]];
randomseeding=Evaluate[RandomSeeding/.Flatten[{opts,Options[PlotPIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotPIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotPIP]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotPIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotPIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotPIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotPIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotPIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotPIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotPIP]}]];

If[zerodiagonal,inv[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];

If[framelabel===Automatic,
	If[plottype=="Plot3D",
		framelabel={trait1,Subscript[tr1,0],"inv"},
		framelabel={trait1,Subscript[tr1,0]}
	]
];

(* fixed traits for invader *)
invfixed=Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}];

(* define resident sol *)

Which[
	solin==="FindEcoAttractor",
	If[ics=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Append[fixed,trait1->trait1]];
		If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];
		ics=DefaultICs;
		If[verbose,Print[func,": ics=",ics]];
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ]:=Global`sol[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol[\[FormalX]_?NumberQ]:=sol[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],EcoSimOpts->{RandomSeeding->randomseeding},VerboseAll->verboseall];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotPIP::feafail,trait1,\[FormalX]]];
		Return[result]
	];
	delayinv=True;
,
	TemporalRuleListQ[solin],
	sol[\[FormalX]_]=solin/.(var_->if_)->(var->if[\[FormalX]]);
,
	Else,
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_]=solin/.trait1->\[FormalX]]];
	sol[\[FormalX]_]=solin/.trait1->\[FormalX];
	If[verbose,Print[func,": sol[\[FormalX]]=",sol[\[FormalX]]]];
];

(* define inv *)
If[delayinv,
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
				PrintCall[Global`resinv[(System`\[FormalX])_?NumberQ]:=Global`resinv[System`\[FormalX]]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_?NumberQ]:=resinv[\[FormalX]]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		If[subtractdiagonal,result=result-resinv[\[FormalX]]];
		Return[result];
	];
,
	(* nondelay inv *)
	If[subtractdiagonal==True,
		If[verbose,
			With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalX]],op=Sequence@@invopts},
			PrintCall[Global`resinv[(System`\[FormalX])_]=Inv[tr,so,ti,op]]
		]];
		resinv[\[FormalX]_]=Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalX]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[verbose,Print[func,": resinv[\[FormalX]]=",resinv[\[FormalX]]]];
	];
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=sol[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts,
			sub=If[subtractdiagonal==True,Global`resinv[\[FormalX]],0]},
			PrintCall[Global`inv[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]-sub]
	]];
	inv[\[FormalX]_,\[FormalY]_]=
		Inv[Append[fixed,trait1->\[FormalX]],sol[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall]
		-If[subtractdiagonal==True,resinv[\[FormalX]],0];
	If[verbose,Print[func,": inv[\[FormalX],\[FormalY]]=",inv[\[FormalX],\[FormalY]]]];
];

If[monitor,PrintTemporary[Grid[{{Dynamic[ToString[TraditionalForm@trait1]<>"="<>ToString[TraditionalForm@x]],
Dynamic[ToString[TraditionalForm@Subscript[tr1,0]]<>"="<>ToString[TraditionalForm@y]]}},ItemSize->10,Alignment->Left]]];

Which[
	plottype=="Plot3D",
	res=Plot3D[{Evaluate[inv[\[FormalX],\[FormalY]]],invthreshold},{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],AxesLabel->Append[framelabel,"inv"],EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="ContourPlot",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="RegionPlot", 
	res=RegionPlot[Evaluate[inv[\[FormalX],\[FormalY]]>invthreshold],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},
		Evaluate[Sequence@@plotopts],PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	plottype=="PIP",
	res=ContourPlot[Evaluate[inv[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait1min,trait1max},Evaluate[Sequence@@plotopts],
		PlotRange->All,Contours->{invthreshold},ContourStyle->{boundarystyle},ContourShading->True,ColorFunction->(If[#>invthreshold,invstyle,noninvstyle]&),
		AspectRatio->1,Method->{"TransparentPolygonMesh"->True},ColorFunctionScaling->False,FrameLabel->framelabel,EvaluationMonitor:>{{x,y}={\[FormalX],\[FormalY]}}],
	Else,
	Message[PlotPIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res]

]];


Options[PlotPIP]={
	FindEcoAttractorOpts->{},InvOpts->{},RandomSeeding->1234,
	DelayInv->False,PlotType->"PIP",ICs->{},ZeroDiagonal->False,Fixed->{},SubtractDiagonal->False,InvThreshold->0,
	PlotOpts->{MaxRecursion->3},FrameLabel->Automatic,
	BoundaryStyle->Black,InvStyle->Gray,NonInvStyle->White,
	Monitor->False,Verbose->False,VerboseAll->False
};


PlotPIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";


PlotMIP::usage =
"PlotMIP[{\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] creates a mutual invasibility plot, where \!\(\*
StyleBox[\"trait\", \"TI\"]\) varies from \!\(\*
StyleBox[\"traitmin\", \"TI\"]\) to \!\(\*
StyleBox[\"traitmax\", \"TI\"]\).
PlotMIP[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait\", \"TI\"]\), \!\(\*
StyleBox[\"traitmin\", \"TI\"]\), \!\(\*
StyleBox[\"traitmax\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotMIP[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotMIP[{\!\(\*
StyleBox[\"sol1\", \"TI\"]\), \!\(\*
StyleBox[\"sol2\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibria \!\(\*
StyleBox[\"sol1\", \"TI\"]\) and \!\(\*
StyleBox[\"sol2\", \"TI\"]\).";


PlotMIP[{solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",solin2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotMIP"],
(* options *)
verbose,verboseall,printtrace,monitor,
fixed,delayinv,findecoattractoropts,invopts,plotopts,plottype,icsin,zerodiagonal,subtractdiagonal,invthreshold,
boundarystyle,spcolors,invstyle,noninvstyle,framelabel,
(* other variables *)
nb,x,y,
invfixed,gu1,tr1,sp1,gu2,tr2,sp2,ics,sol1,sol2,inv12,inv21,pip1,pip2,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotMIP]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotMIP]}]];
If[verboseall,verbose=True];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotMIP]}]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotMIP]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotMIP]}]];
delayinv=Evaluate[DelayInv/.Flatten[{opts,Options[PlotMIP]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotMIP]}]];
invopts=Evaluate[InvOpts/.Flatten[{opts,Options[PlotMIP]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotMIP]}]];
plottype=Evaluate[PlotType/.Flatten[{opts,Options[PlotMIP]}]];
icsin=Evaluate[ICs/.Flatten[{opts,Options[PlotMIP]}]];
zerodiagonal=Evaluate[ZeroDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
subtractdiagonal=Evaluate[SubtractDiagonal/.Flatten[{opts,Options[PlotMIP]}]];
invthreshold=Evaluate[InvThreshold/.Flatten[{opts,Options[PlotMIP]}]];
boundarystyle=Evaluate[BoundaryStyle/.Flatten[{opts,Options[PlotMIP]}]];
spcolors=Evaluate[SpeciesColors/.Flatten[{opts,Options[PlotMIP]}]];
invstyle=Evaluate[InvStyle/.Flatten[{opts,Options[PlotMIP]}]];
noninvstyle=Evaluate[NonInvStyle/.Flatten[{opts,Options[PlotMIP]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotMIP]}]];

If[zerodiagonal,inv12[\[FormalX]_,\[FormalX]_]=inv21[\[FormalX]_,\[FormalX]_]=0];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* fixed traits for invader [why are there 2 of these?] *)
invfixed=Flatten[Join[
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu1],{tr1}]}],
	Table[Subscript[trt,0]->(Subscript[trt,sp1]/.fixed),{trt,Complement[gtraits[gu2],{tr2}]}]
]];

(* define resident sol *)

Which[
	solin1==="FindEcoAttractor",
	If[icsin=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Append[fixed,trait1->trait1]];
		If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];
		ics=DefaultICs;
		If[verbose,Print[func,": ics=",ics]];
	,
		ics=icsin
	];
	If[verbose,
		With[{tr=Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol1[(System`\[FormalX])_?NumberQ]:=Global`sol1[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
	]];
	sol1[\[FormalX]_?NumberQ]:=sol1[\[FormalX]]=Module[{result},
		result=FindEcoAttractor[Join[fixed/.trait1->\[FormalX],{trait1->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["EcoAttractor (",trait1,"=",\[FormalX],"): ",result]];
		If[result=={$Failed},Message[PlotMIP::feafail,trait1,\[FormalX]]];
		Return[result];
	];
	delayinv=True;
,
	TemporalRuleListQ[solin1],
	sol1[\[FormalX]_]=solin1/.(var_->if_)->(var->if[\[FormalX]]);
,
	Else,
	If[verbose,PrintCall[Global`sol1[(System`\[FormalX])_]=solin1/.trait1->\[FormalX]]];
	sol1[\[FormalX]_]=solin1/.trait1->\[FormalX];
	If[verbose,Print[func,": sol1[\[FormalX]]=",sol1[\[FormalX]]]]
];

If[trait1=!=trait2,
	Which[
		solin2==="FindEcoAttractor",
		delayinv=True;
		If[icsin=={},
			(* figure out number of species in guilds *)
			Set\[ScriptCapitalN][Append[fixed,trait2->trait2]];
			If[Global`debug,Print[func,": \[ScriptCapitalN]2=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];
			ics=DefaultICs;
			If[verbose,Print[func,": ics=",ics]];
		,
			ics=icsin
		];
		If[verbose,
			With[{tr=Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics=ics,op=Sequence@@findecoattractoropts},
				PrintCall[Global`sol2[(System`\[FormalX])_?NumberQ]:=Global`sol2[System`\[FormalX]]=FindEcoAttractor[tr,ics,op]]
		]];
		sol2[\[FormalX]_?NumberQ]:=sol2[\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed/.trait2->\[FormalX],{trait2->\[FormalX]}],ics,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			If[printtrace,Print["EcoAttractor (",trait2,"=",\[FormalX],"): ",result]];
			If[result=={$Failed},Message[PlotMIP::feafail,trait2,\[FormalX]]];
			Return[result];
		];
	,
		TemporalRuleListQ[solin2],
		sol2[\[FormalX]_]=solin2/.(var_->if_)->(var->if[\[FormalX]]);
	,
		Else,
		If[verbose,PrintCall[Global`sol2[(System`\[FormalX])_]=solin2/.trait2->\[FormalX]]];
		sol2[\[FormalX]_]=solin2/.trait2->\[FormalX];
		If[verbose,Print[func,": sol2[\[FormalX]]=",sol2[\[FormalX]]]]
	]
,
	sol2[\[FormalX]_]:=sol1[\[FormalX]];
	If[verbose,Print[func,": sol2[\[FormalX]]=sol1[\[FormalX]]"]]
];

(* define inv21 & inv12 *)
If[delayinv,
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Defer[Global`sol1][\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts,trinv=Subscript[trait[gu2,tr2],0]},
			PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv21[\[FormalX],\[FormalY]]=Module[{result},
		result=Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
		If[printtrace,Print["Inv (",trait2,"=",\[FormalX]," ",Subscript[tr1,0],"=",\[FormalY],"): ",result]];
		Return[result]
	];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Defer[Global`sol2][\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`inv21[System`\[FormalX],System`\[FormalY]]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=inv12[\[FormalX],\[FormalY]]=Module[{result},
			result=Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
			If[printtrace,Print["Inv (",trait1,"=",\[FormalX]," ",Subscript[tr2,0],"=",\[FormalY],"): ",result]];
			Return[result]
		];
	,
		(* if trait1=trait2, then re-use inv21 *)
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]]
	]
,
	(* nondelay inv *)
	If[verbose,
		With[{tr=Append[fixed,trait1->\[FormalX]],so=Defer[Global`sol1][\[FormalX]],ti=Append[invfixed,Subscript[tr2,0]->\[FormalY]],op=Sequence@@invopts},
			PrintCall[Global`inv21[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
	]];
	inv21[\[FormalX]_,\[FormalY]_]=
		Inv[Join[fixed,{trait1->\[FormalX]}],sol1[\[FormalX]],Append[invfixed,Subscript[tr2,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall];
	If[trait1=!=trait2,
		If[verbose,
			With[{tr=Append[fixed,trait2->\[FormalX]],so=Global`sol2[\[FormalX]],ti=Append[invfixed,Subscript[tr1,0]->\[FormalY]],op=Sequence@@invopts},
				PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]=Inv[tr,so,ti,op]]
		]];
		inv12[\[FormalX]_,\[FormalY]_]=
			Inv[Join[fixed,{trait2->\[FormalX]}],sol2[\[FormalX]],Append[invfixed,Subscript[tr1,0]->\[FormalY]],Evaluate[Sequence@@invopts],VerboseAll->verboseall]
	,
		If[verbose,PrintCall[Global`inv12[(System`\[FormalX])_,(System`\[FormalY])_]:=Global`inv21[System`\[FormalX],System`\[FormalY]]]];
		inv12[\[FormalX]_,\[FormalY]_]:=inv21[\[FormalX],\[FormalY]];
		If[verbose,Print[func,": inv12[\[FormalX],\[FormalY]]=inv21[\[FormalX],\[FormalY]]"]]
	]
];


If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[trait1],TextCell["="],Dynamic[x]},
		{ExpressionCell[If[trait2===trait1,Subscript[tr1,sp1+1],trait2]],TextCell["="],Dynamic[y]}
		}],WindowTitle->"PlotMIP Progress...",WindowSize->All];
];


Which[
	plottype=="MIP",
	pip1=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv21[\[FormalX],\[FormalY]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[({x,y}={\[FormalX],\[FormalY]};Evaluate[inv12[\[FormalY],\[FormalX]]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->(If[#>invthreshold,Opacity[0],noninvstyle]&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1//AxisFlip
	];
	res=Show[Graphics[{invstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,Frame->True,FrameLabel->framelabel,
		Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionMIP",
	res=RegionPlot[Evaluate[(inv12[\[FormalY],\[FormalX]]>invthreshold&&inv21[\[FormalX],\[FormalY]]>invthreshold)],
		{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		PlotStyle->invstyle,BoundaryStyle->boundarystyle,FrameLabel->framelabel],
	plottype=="Outcome",
	pip1=ContourPlot[Evaluate[inv21[\[FormalX],\[FormalY]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
		Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[2]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False];
	If[trait1=!=trait2,
		pip2=ContourPlot[Evaluate[inv12[\[FormalY],\[FormalX]]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],
			Contours->{invthreshold},PlotRange->All,ColorFunction->({Opacity[0.5#],spcolors[[1]]}&),ContourShading->True,ContourStyle->boundarystyle,ColorFunctionScaling->False],
		pip2=pip1/.spcolors[[2]]->spcolors[[1]]//AxisFlip
	];
	res=Show[Graphics[{noninvstyle,Rectangle[{trait1min,trait2min},{trait1max,trait2max}]}],pip2,pip1,
		Frame->True,FrameLabel->framelabel,Method->{"TransparentPolygonMesh"->True},AspectRatio->1],
	plottype=="RegionOutcome",
	res=RegionPlot[Evaluate[{inv21[\[FormalX],\[FormalY]]>invthreshold,inv12[\[FormalY],\[FormalX]]>invthreshold}]
		,{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@plotopts],BoundaryStyle->boundarystyle,
		PlotStyle->{Directive[spcolors[[1]],Opacity[0.4]],Directive[spcolors[[2]],Opacity[0.4]]},FrameLabel->framelabel],
	Else,
	Message[PlotMIP::badmtd];Return[$Failed]
];

If[monitor,NotebookClose[nb]];

Return[res];

]];


(* only one sol given *)
PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},
	{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
((*Print[1];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


(* only one sol given *)
PlotMIP[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},
	opts___?OptionQ]:=
((*Print[2];*)PlotMIP[{solin1,solin1},{trait1,trait1min,trait1max},{trait1,trait1min,trait1max},opts]);


(* no sol given *)
PlotMIP[{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},
	opts___?OptionQ]:=
((*Print[3];*)PlotMIP[{"FindEcoAttractor","FindEcoAttractor"},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts]);


Options[PlotMIP]={
	PlotType->"MIP",DelayInv->False,FindEcoAttractorOpts->{},InvOpts->{},InvThreshold->0,
	ICs->{},ZeroDiagonal->False,Fixed->{},
	BoundaryStyle->Black,SpeciesColors->{Red,Blue},InvStyle->Gray,NonInvStyle->White,FrameLabel->Automatic,
	PlotOpts->{MaxRecursion->3},
	Monitor->False,Verbose->False,VerboseAll->False
};


PlotMIP::feafail=
"FindEcoAttractor failed at `1`=`2`.";

PlotMIP::badmtd=
"The PlotType option should be a built-in method name (\"MIP\", \"RegionMIP\", \"Outcome\", or \"RegionOutcome\").";


TraitEqns::usage=
"TraitEqns[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] sets up trait equations with ecological solution \!\(\*
StyleBox[\"sol\", \"TI\"]\) and trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


TraitEqns[solin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=
 
Module[{
func=FuncStyle["TraitEqns"],
(* options *)
verbose,verboseall,fixed,logged,delaydinv,dinvopts,evoeqn,traitshiftrate,nsps,ics,time,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedtraits,
g,dtrait,pre,wt,sol,eqns},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[TraitEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[TraitEqns]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[TraitEqns]}]];
(*Print["fixed=",fixed];*)
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
If[Global`debug,Print[func,": fixedattributes=",fixedattributes]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];

logged=Evaluate[Logged/.Flatten[{opts,Options[TraitEqns]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[TraitEqns]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[TraitEqns]}]];
If[modelperiod=!=0,AppendTo[dinvopts,InvOpts->{Method->"Instantaneous"}]];
evoeqn=Evaluate[EvoEquation/.Flatten[{opts,Options[TraitEqns]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[TraitEqns]}]];
nsps=Evaluate[\[ScriptCapitalN]s/.Flatten[{opts,Options[TraitEqns]}]];
time=Evaluate[Time/.Flatten[{opts,Options[TraitEqns]}]];

sol=FixVariables[solin];
(*Print["sol=",sol];*)

(* figure out number of species in guilds *)
If[solin==="FindEcoAttractor"&&nsps=!={},
	Evaluate[Table[\[ScriptCapitalN][gu],{gu,guilds}]]=nsps,
	Set\[ScriptCapitalN][Join[sol,fixedvariables]]
];
If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

(* shifting traits *)
Do[
	dtrait[gu,gtrait]=If[MemberQ[traitshiftrate[[All,1]],gtrait],gtrait/.traitshiftrate,0]
,{gu,guilds},{gtrait,gtraits[gu]}];
If[Global`debug,Print[func,": dtrait=",Table[dtrait[gu,gtrait],{gu,guilds},{gtrait,gtraits[gu]}]]];

(* set up G matrices *)

Do[
	g[gu]=If[MatrixQ[G[gu]/.Gs],
		SymmetrizeMatrix[G[gu]/.Gs],
		DiagonalMatrix[Table[If[Head[Var[gtrait]/.Gs]=!=Var,Var[gtrait]/.Gs,1],{gtrait,gtraits[gu]}]]
	];
	(*g[gu]=SymmetrizeMatrix[Table[If[tr1===tr2,Var[tr1],Cov[tr1,tr2]],{tr1,gtraits[gu]},{tr2,gtraits[gu]}]];*)
,{gu,guilds}];

If[transitions===Transitions,

(* equation-based *)

Which[
	evoeqn=="QG",
	Do[Do[pre[gu,sp]=1,{sp,0,\[ScriptCapitalN][gu]}],{gu,guilds}],
	evoeqn=="CE",
	Do[
		Do[
			If[comptype[gcomp]=="Extensive",wt[gu,gcomp]=1,wt[gu,gcomp]=0]
		,{gcomp,gcomps[gu]}];
		Do[
			pre[gu,sp]:=Sum[wt[gu,gcomp]*Subscript[gcomp,sp],{gcomp,gcomps[gu]}]
		,{sp,0,\[ScriptCapitalN][gu]}]
	,{gu,guilds}],
	Else,
	Message[TraitEqns::badte];
	Return[$Failed]
];

(*Print["setting eqns..."];
Print[Join[BlankTraits,ExtractAttributes[solin]]];*)
If[delaydinv==True,
	eqns=Flatten[Table[Table[Table[
		DT[Subscript[gtrait,sp]]==pre[gu,sp]*
		Sum[Replace[g[gu],var_Symbol->Subscript[var,sp][t],\[Infinity]][[index[gtrait],index[gtrait\[Prime]]]]NumDInv[BlankUnkTraits,sol,Subscript[gtrait\[Prime],0],Species->sp,Method->"NDInv",Evaluate[Sequence@@dinvopts],VerboseAll->verboseall],{gtrait\[Prime],gtraits[gu]}]
		-dtrait[gu,gtrait]+If[modeltype=="DiscreteTime",Unk[Subscript[gtrait,sp]],0]
	,{gtrait,gtraits[gu]}],{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]]/.fixed
,
	If[sol==="FindEcoAttractor",sol=BlankVariables];
	eqns=Flatten[Table[Table[
		Thread[Table[DT[Subscript[gtrait,sp]],{gtrait,gtraits[gu]}]==(
		pre[gu,sp]*Replace[g[gu],var_Symbol->Subscript[var,sp],\[Infinity]] . DInv[BlankTraits,sol,Guild->gu,Species->sp,Time->time,Fixed->fixed,Evaluate[Sequence@@dinvopts],VerboseAll->verboseall]
		-Table[dtrait[gu,gtrait],{gtrait,gtraits[gu]}]
		+If[modeltype=="DiscreteTime",Table[Subscript[gtrait,sp],{gtrait,gtraits[gu]}],0]
		/.fixed/.AddVariablets/.AddTraitts)]
	,{sp,If[\[ScriptCapitalN][gu]==0,0,1],\[ScriptCapitalN][gu]}],{gu,guilds}]]/.FixVarCovts
];

eqns=DeleteCases[eqns,DT[var_]==_/;MemberQ[fixedvars,var]];

(*Print["AllVariables=",AllVariables];
Print["logged=",logged];
Print["ExpRule[AllVariables,logged]=",ExpRule[AllVariables,logged]];
Print["returning ",eqns/.ExpRule[AllVariables,logged]];*)

Return[eqns/.ExpRule[AllVariables,logged]];

,

(* process-based *)

Return[
	Flatten@Table[Table[
		If[ngcomps[gu]==1,
			Thread[Table[Subscript[tr, sp]'[t],{tr,gtraits[gu]}]==(dxdt[gcomps[gu][[1]]]/.\[FormalI]->sp/.fixed/.Dispatch[ExpandGs[Gs]]/.AddVariablets/.AddTraitts/.AddVarCovts)]
		,
			Table[Thread[Table[Subscript[tr[co], sp]'[t],{tr,gtraits[gu]}]==(dxdt[co]/.\[FormalI]->sp/.fixed/.Dispatch[ExpandGs[Gs]]/.AddVariablets/.AddTraitts/.AddVarCovts)],{co,gcomps[gu]}]
		]
	,{sp,\[ScriptCapitalN][gu]}],{gu,guilds}]
]

]

]];


Options[TraitEqns]={Time->t,DelayDInv->False,DInvOpts->{},EvoEquation->"QG",TraitShiftRate->{},Fixed->{},\[ScriptCapitalN]s->{},Logged->False,
Verbose->False,VerboseAll->False};


VarEqns::usage=
"VarEqns[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] sets up trait variance/covariance equations with traits in \!\(\*
StyleBox[\"traits\", \"TI\"]\) and ecological solution \!\(\*
StyleBox[\"sol\", \"TI\"]\).";


VarEqns[attributesin:(_?AttributesQ):{},solin:(_?VariablesQ):{},opts___?OptionQ]:=
 
Module[{
func=FuncStyle["VarEqns"],
(* options *)
verbose,verboseall,fixed,logged,delaydinv,dinvopts,evoeqn,traitshiftrate,nsps,ics,time,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedtraits,
sol,attributes},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[VarEqns]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[VarEqns]}]];
If[verboseall,verbose=True];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[VarEqns]}]];
(*Print["fixed=",fixed];*)
fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
fixedattributes=ExtractAttributes[fixed];
(*Print["fixedattributes=",fixedattributes];*)
If[Global`debug,Print[func,": fixedattributes=",fixedattributes]];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvariables=",fixedvariables]];

time=Evaluate[Time/.Flatten[{opts,Options[VarEqns]}]];

sol=FixVariables[solin];
attributes=FixAttributes[attributesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[sol,fixedvariables],attributes];

If[Global`debug,Print[func,": \[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

Return[Chop@Flatten[Table[Table[Table[
	Thread[Flatten[Evaluate[Replace[MakeGMatrix[Subscript[gcomp, \[FormalI]]],x_->x'[t],{2}]]]==(Flatten[Total@dGdt[gcomp]]/.AddTraitts/.AddVarCovts/.AddVariablets)/.\[FormalI]->sp]
	,{gcomp,gcomps[gu]}],{sp,\[ScriptCapitalN][gu]}],{gu,guilds}]
]

]

]];


Options[VarEqns]={Time->t,Fixed->{},Verbose->False,VerboseAll->False};


PlotEvoStreams::usage=
"PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary streams.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoStreams[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


PlotEvoStreams[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoStreams"],
(* options *)
verbose,verboseall,monitor,printtrace,fixed,time,
evoeqn,fitnessgradient,dinvopts,delaydinv,findecoattractoropts,streamplotopts,framelabel,ecoattnumber,usesymmetry,zerodiagonal,
(* other variables *)
nb,evoeqns,dt,nsps,ics,sol,
x,y,
gu1,tr1,sp1,gu2,tr2,sp2,res},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoStreams]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoStreams]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoStreams]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoStreams]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoStreams]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[PlotEvoStreams]}]];
If[fitnessgradient=="NDInv",AppendTo[dinvopts,Method->"NDInv"]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoStreams]}]];

streamplotopts=FilterRules[Flatten[{FrameLabel->framelabel,opts,Options[PlotEvoStreams]}],Options[StreamPlot]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoStreams]}]];
ecoattnumber=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoStreams]}]];
usesymmetry=Evaluate[UseSymmetry/.Flatten[{opts,Options[PlotEvoStreams]}]];

If[modelperiod!=0&&time==t,delaydinv=True;AppendTo[dinvopts,InvOpts->{}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[framelabel===Automatic,
	If[tr2===tr1,
		framelabel={trait1,SubscriptAdd[trait1,1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	(* figure out number of species in guilds *)
	Set\[ScriptCapitalN][Join[fixed,{trait1->trait1,trait2->trait2}]];
	ics=DefaultICs;
	nsps=Table[\[ScriptCapitalN][gu],{gu,guilds}];
	If[Global`debug,Print[func,": \[ScriptCapitalN]=",nsps]];
,
	nsps={}
];

evoeqns=TraitEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,\[ScriptCapitalN]s->nsps];
If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_[t+1]->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
If[verbose,Print[func,": evoeqns=",evoeqns]];

If[solin==="FindEcoAttractor",
	sol[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=sol[\[FormalX],\[FormalY]]=FindEcoAttractor[{trait1->\[FormalX],trait2->\[FormalY]},ics,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall]/.fixed;
	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=({x,y}={\[FormalX],\[FormalY]};evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=({x,y}={\[FormalX],\[FormalY]};evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];
(*Print[sol[12,18]];Print[dt[12,18]];*)
(*Print[sol[0.5,0]];Print[dt[0.5,0]];*)

If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[trait1],TextCell["="],Dynamic[EcoEvo`Private`xmon]},
		{ExpressionCell[If[tr2===tr1,SubscriptAdd[trait1,1],trait2]],TextCell["="],Dynamic[EcoEvo`Private`ymon]}
		}],WindowTitle->"PlotEvoStreams Progress...",WindowSize->All];
];

res=MyStreamPlot[dt[\[FormalX],\[FormalY]],{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},Evaluate[Sequence@@streamplotopts]];

If[monitor,NotebookClose[nb]];

Return[res]

]];


PlotEvoStreams[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoStreams[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts]


Options[PlotEvoStreams]={Fixed->{},Time->t,FindEcoAttractorOpts->{},DInvOpts->{},DelayDInv->False,
FrameLabel->Automatic,StreamColorFunction->None,StreamStyle->Gray,
UseSymmetry->False,FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,TraitShiftRate->{},
Monitor->False,PrintTrace->False,Verbose->False,VerboseAll->False};


PlotEvoIsoclines::usage=
"PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] plots two-species evolutionary isoclines.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses two-species ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\) for improved speed.
PlotEvoIsoclines[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits.
PlotEvoIsoclines[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
PlotEvoStreams[\!\(\*
StyleBox[\"sol\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


PlotEvoIsoclines[solin:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=

Module[{
func=FuncStyle["PlotEvoIsoclines"],
(* options *)
verbose,verboseall,fixed,time,
monitor,printtrace,dinvopts,findecoattractoropts,plotopts,framelabel,ics,ecoattnum,
estest,isoclinestyle,delaydinv,delaydinv2,dinv2opts,excludediagonal,
(* other variables *)
nb,evoeqns,
ics1,nsps,color1,color1es,color1nes,color2,color2es,color2nes,style1,style1es,style1nes,style2,style2es,style2nes,
sol,dt,dinv21,dinv22,gu1,tr1,sp1,gu2,tr2,sp2,pre1,pre2,iso1,iso2},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
If[verboseall,verbose=True];

monitor=Evaluate[Monitor/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
time=Evaluate[Time/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
findecoattractoropts=Evaluate[FindEcoAttractorOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinvopts=Evaluate[DInvOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
plotopts=Evaluate[PlotOpts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
framelabel=Evaluate[FrameLabel/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ics=Evaluate[ICs/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
ecoattnum=Evaluate[EcoAttractorNumber/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
estest=Evaluate[ESTest/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
isoclinestyle=Evaluate[IsoclineStyle/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
delaydinv2=Evaluate[DelayDInv2/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
dinv2opts=Evaluate[DInv2Opts/.Flatten[{opts,Options[PlotEvoIsoclines]}]];
excludediagonal=Evaluate[ExcludeDiagonal/.Flatten[{opts,Options[PlotEvoIsoclines]}]];

(* figure out what are the traits on the x- and y-axes *)
{gu1,tr1,sp1}=LookUp[trait1][[2;;4]];
{gu2,tr2,sp2}=LookUp[trait2][[2;;4]];

If[excludediagonal&&{gu1,tr1}=={gu2,tr2},AppendTo[plotopts,Exclusions->{\[FormalX]==\[FormalY]}]];

If[isoclinestyle===Automatic,
	color1es=color1nes=color1=color[trait1][0];
	color2es=color2nes=color2=color[trait2][1];
	style1es=Thick;style1nes=Thin;style1=Thickness[Medium];
	style2es=Thick;style2nes=Thin;style2=Thickness[Medium];
,
	If[ListQ[isoclinestyle[[1]]],
		color1es=ExtractColors[isoclinestyle[[1,1]]];
		color1nes=ExtractColors[isoclinestyle[[1,2]]];
		style1es=Complement[isoclinestyle[[1,1]],color1es];
		style1nes=Complement[isoclinestyle[[1,2]],color1nes];
	,
		color1=ExtractColors[isoclinestyle[[1]]];
		style1=Complement[isoclinestyle[[1,1]],color1];
	];
	If[ListQ[isoclinestyle[[2]]],
		color2es=ExtractColors[isoclinestyle[[2,1]]];
		color2nes=ExtractColors[isoclinestyle[[2,2]]];
		style2es=Complement[isoclinestyle[[2,1]],color2es];
		style2nes=Complement[isoclinestyle[[2,2]],color2nes];
	,
		color2=ExtractColors[isoclinestyle[[2]]];
		style2=Complement[isoclinestyle[[2,1]],color2];
	];
];

If[framelabel===Automatic,
	If[trait2===trait1,
		framelabel={trait1,Subscript[tr1,sp1+1]},
		framelabel={trait1,trait2}
	]
];

(* set up sol *)

If[solin==="FindEcoAttractor",
	delaydinv2=True;
	If[ics=={},
		(* figure out number of species in guilds *)
		Set\[ScriptCapitalN][Join[fixed,{trait1->trait1}]];
		ics1=DefaultICs;
		Set\[ScriptCapitalN][Join[fixed,{trait1->trait1,trait2->trait2}]];
		nsps=Table[\[ScriptCapitalN][gu],{gu,guilds}];
		If[Global`debug,Print[func,": \[ScriptCapitalN]=",nsps]];
		ics=DefaultICs;
	];
	(* handle diagonal *)
	If[{gu1,tr1}=={gu2,tr2},
		sol[\[FormalX]_?NumberQ,\[FormalX]_?NumberQ]:=sol[\[FormalX],\[FormalX]]=Module[{result},
			result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX]}],ics1,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
			Return[Join[result,Table[Subscript[gcomp,sp2]->0,{gcomp,gcomps[gu1]}]]]
		]
	];
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics=ics,time=time,op=Sequence@@findecoattractoropts},
			PrintCall[Global`sol[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`sol[System`\[FormalX],System`\[FormalY]]=
			FindEcoAttractor[tr,ics,Time->time,op]]]
	];
	sol[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=sol[\[FormalX],\[FormalY]]=Module[{result},
		result=FindEcoAttractor[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],ics,Time->time,Evaluate[Sequence@@findecoattractoropts],VerboseAll->verboseall];
		If[printtrace,Print["FindEcoAttractor ",{trait1->\[FormalX],trait2->\[FormalY]},"=",result]];
		If[ArrayDepth[result]<2,Return[result],Print[result," ",ArrayDepth[result]];Return[result[[ecoattnum]]]]
	];
, (* sol given *)
	If[verbose,PrintCall[Global`sol[(System`\[FormalX])_,(System`\[FormalY])_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]}]];
	sol[\[FormalX]_,\[FormalY]_]=solin/.{trait1->\[FormalX],trait2->\[FormalY]};
	If[verbose,Print[func,": sol[\[FormalX],\[FormalY]]=",sol[\[FormalX],\[FormalY]]]]
];

evoeqns=TraitEqns[solin,Gs,DInvOpts->dinvopts,DelayDInv->delaydinv,opts,\[ScriptCapitalN]s->nsps];

If[modeltype=="DiscreteTime",
	evoeqns=(evoeqns/.RHS/.var_[t]->var/.fixed)-(evoeqns/.LHS/.var_[t+1]->var),
	evoeqns=evoeqns/.RHS/.var_[t]->var/.fixed
];
	
If[verbose,Print[func,": evoeqns=",evoeqns]];

If[solin==="FindEcoAttractor",
	If[delaydinv,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/."FindEcoAttractor"->sol[\[FormalX],\[FormalY]]/.{Unk[trait1]->\[FormalX],Unk[trait2]->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	,
		dt[\[FormalX]_?NumericQ,\[FormalY]_?NumericQ]:=(dt[\[FormalX],\[FormalY]]=evoeqns/.sol[\[FormalX],\[FormalY]]/.{trait1->\[FormalX],trait2->\[FormalY]}/.t->time)
		/;(trait1min<=\[FormalX]<=trait1max&&trait2min<=\[FormalY]<=trait2max&&\[FormalX]!=\[FormalY])
	]
,
	dt[\[FormalX]_,\[FormalY]_]=(evoeqns/.solin/.{trait1->\[FormalX],trait2->\[FormalY]})
];

(*Print["solin=",solin];
Print[sol[0.1,0.2]];
Print[dt[0.1,0.2]];*)

If[monitor,
	nb=CreateDialog[Grid[{
		{ExpressionCell[trait1],TextCell["="],Dynamic[EcoEvo`Private`xmon]},
		{ExpressionCell[trait2],TextCell["="],Dynamic[EcoEvo`Private`ymon]}
		}],WindowTitle->"PlotEvoIsoclines Progress...",WindowSize->All];
];

iso1=ContourPlot[({EcoEvo`Private`xmon,EcoEvo`Private`ymon}={\[FormalX],\[FormalY]};dt[\[FormalX],\[FormalY]][[1]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},
	Contours->{0},ContourShading->False,ContourStyle->Flatten[{color1,style1}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait1]&}
];
If[Global`debug,Print[iso1]];

(* add flip option to save 50% time *)

iso2=ContourPlot[({EcoEvo`Private`xmon,EcoEvo`Private`ymon}={\[FormalX],\[FormalY]};dt[\[FormalX],\[FormalY]][[2]]),{\[FormalX],trait1min,trait1max},{\[FormalY],trait2min,trait2max},
	Contours->{0},ContourShading->False,ContourStyle->Flatten[{color2,style2}],Evaluate[Sequence@@plotopts],ContourLabels->{None,Tooltip[Null,trait2]&}];
If[Global`debug,Print[iso2]];

If[monitor,NotebookClose[nb]];

If[estest==False,
	Return[Show[iso1,iso2,FrameLabel->framelabel]]
];

(* ESTest\[Equal]True *)

If[delaydinv2,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv21[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv1,ts1,Method->"NDInv",Time->time,op]];
			PrintCall[Global`dinv22[(System`\[FormalX])_?NumberQ,(System`\[FormalY])_?NumberQ]:=Global`dinv22[System`\[FormalX],System`\[FormalY]]=
				DInv[tr,so,trinv2,ts2,Method->"NDInv",Time->time,op]]
	]];		
	dinv21[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv21[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	dinv22[\[FormalX]_?NumberQ,\[FormalY]_?NumberQ]:=dinv22[\[FormalX],\[FormalY]]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Method->"NDInv",Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
,
	If[verbose,
		With[{tr=Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],so=sol[\[FormalX],\[FormalY]],
			trinv1={Subscript[tr1,0],2},trinv2={Subscript[tr2,0],2},sp1=sp1,sp2=sp2,
			time=time,op=Sequence@@dinvopts},
			PrintCall[Global`dinv21[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv1,Species->sp1,Time->time,op]];
			PrintCall[Global`dinv22[System`\[FormalX],System`\[FormalY]]=DInv[tr,so,trinv2,Species->sp2,Time->time,op]]
	]];
	dinv21[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr1,0],2},Species->sp1,
			Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	dinv22[\[FormalX]_,\[FormalY]_]=
		DInv[Join[fixed,{trait1->\[FormalX],trait2->\[FormalY]}],sol[\[FormalX],\[FormalY]],{Subscript[tr2,0],2},Species->sp2,
			Time->time,Evaluate[Sequence@@dinv2opts],VerboseAll->verboseall];
	If[verbose,
		Print[func,": dinv21[\[FormalX],\[FormalY]]=",dinv21[\[FormalX],\[FormalY]]];
		Print[func,": dinv22[\[FormalX],\[FormalY]]=",dinv22[\[FormalX],\[FormalY]]]
	]
];

Return[Show[
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]>0,color1nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso1],trait1],PlotStyle->style1es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv21[#1,#2]<0,color1es,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2nes,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]>0,color2nes,{Opacity[0]}]]&)],
	ListLinePlot[Tooltip[ExtractPlotPoints[iso2],trait2],PlotStyle->style2es,ColorFunctionScaling->False,ColorFunction->(Unevaluated[If[dinv22[#1,#2]<0,color2es,{Opacity[0]}]]&)],
	Frame->True,Axes->False,AspectRatio->1,FrameLabel->framelabel,PlotRange->{{trait1min,trait1max},{trait2min,trait2max}}
]]

]];


PlotEvoIsoclines[solin1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs_List:{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
PlotEvoIsoclines[solin1,Gs,{trait1,trait1min,trait1max},{SubscriptAdd[trait1],trait1min,trait1max},opts];


Options[PlotEvoIsoclines]={Fixed->{},Time->t,
	FitnessGradient->"DInv",ICs->{},EvoEquation->"QG",EcoAttractorNumber->1,ExcludeDiagonal->True,TraitShiftRate->{},
	FindEcoAttractorOpts->{},DelayDInv->False,DInvOpts->{},PlotOpts->{},FrameLabel->Automatic,
	ESTest->True,DelayDInv2->False,DInv2Opts->{},IsoclineStyle->Automatic,
	Verbose->False,VerboseAll->False,Monitor->False,PrintTrace->False};


PlotEvoPhasePlane::usage=
"PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] combines PlotMIP, PlotEvoStreams and PlotEvoIsoclines.
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq1\", \"TI\"]\), \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}] uses one-species ecological equilibrium \!\(\*
StyleBox[\"eq1\", \"TI\"]\) and two-species ecological equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) for improved speed (2 species).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] allows for two different traits (within or between guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses one-species ecological equilibria \!\(\*
StyleBox[\"eq11\", \"TI\"]\) and \!\(\*
StyleBox[\"eq12\", \"TI\"]\) and two-species ecological equilibrium \!\(\*
StyleBox[\"eq2\", \"TI\"]\) (2 guilds).
PlotEvoPhasePlane[{\!\(\*
StyleBox[\"eq11\", \"TI\"]\), \!\(\*
StyleBox[\"eq12\", \"TI\"]\)}, \!\(\*
StyleBox[\"eq2\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).
PlotEvoPhasePlane[\!\(\*
StyleBox[\"eq0\", \"TI\"]\), \!\(\*
StyleBox[\"eq1\", \"TI\"]\), {\!\(\*
StyleBox[\"trait1\", \"TI\"]\), \!\(\*
StyleBox[\"trait1min\", \"TI\"]\), \!\(\*
StyleBox[\"trait1max\", \"TI\"]\)}, {\!\(\*
StyleBox[\"trait2\", \"TI\"]\), \!\(\*
StyleBox[\"trait2min\", \"TI\"]\), \!\(\*
StyleBox[\"trait2max\", \"TI\"]\)}] combines PlotZIP, PlotEvoStreams and PlotEvoIsoclines (2 traits)";


(* two guilds *)
PlotEvoPhasePlane[{eq11:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq12:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor"},
eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Gu)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[{eq11,eq12},{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two species *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq2:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",Gs:(_?RuleListQ):{},
{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Sp)"],
(* options *)
plotmipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
pes,pei,mip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotmipopts=FilterRules[Flatten[{Evaluate[PlotMIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotMIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

pes=PlotEvoStreams[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq2,Gs,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
mip=PlotMIP[eq1,{trait1,trait1min,trait1max},Evaluate[Sequence@@plotmipopts],InvStyle->Opacity[0]];
If[Global`debug,Print[mip]];

Return[Show[pes,pei,mip]]
];


(* two traits *)
PlotEvoPhasePlane[eq0:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
Module[{
func=FuncStyle["PlotEvoIsoclines (2Tr)"],
(* options *)
plotzipopts,plotevoisoclinesopts,plotevostreamsopts,verbose,verboseall,
(* other variables *)
invader,pes,pei,zip},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

(* handle options *)

plotzipopts=FilterRules[Flatten[{Evaluate[PlotZIPOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotZIP]];
plotevoisoclinesopts=FilterRules[Flatten[{Evaluate[PlotEvoIsoclinesOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoIsoclines]];
plotevostreamsopts=FilterRules[Flatten[{Evaluate[PlotEvoStreamsOpts/.Flatten[{opts,Options[PlotEvoPhasePlane]}]],opts,Options[PlotEvoPhasePlane]}],Options[PlotEvoStreams]];

verbose=Evaluate[Verbose/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[PlotEvoPhasePlane]}]];
If[verboseall,verbose=True];

If[verbose,Print["In ",func]];

invader=(Guild->LookUp[trait1][[2]]);

pes=PlotEvoStreams[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevostreamsopts]];
If[Global`debug,Print[pes]];
pei=PlotEvoIsoclines[eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},Evaluate[Sequence@@plotevoisoclinesopts]];
If[Global`debug,Print[pei]];
zip=PlotZIP[eq0,{(trait1/.Subscript[x_,_]->Subscript[x,0]),trait1min,trait1max},{(trait2/.Subscript[x_,_]->Subscript[x,0]),trait2min,trait2max},
invader,InvStyle->Opacity[0],NonInvStyle->White,Evaluate[Sequence@@plotzipopts]];
If[Global`debug,Print[zip]];

Return[Show[pes,pei,zip]]
];


(* two traits - no eq0 alias *)
PlotEvoPhasePlane[eq1:(_?RuleListQ|_?(#=="FindEcoAttractor"&)):"FindEcoAttractor",
Gs:(_?RuleListQ):{},{trait1_,trait1min_?NumericQ,trait1max_?NumericQ},{trait2_,trait2min_?NumericQ,trait2max_?NumericQ},opts___?OptionQ]:=
PlotEvoPhasePlane["FindEcoAttractor",eq1,Gs,{trait1,trait1min,trait1max},{trait2,trait2min,trait2max},opts];


Options[PlotEvoPhasePlane]={PlotMIPOpts->{},PlotZIPOpts->{},PlotEvoIsoclinesOpts->{},PlotEvoStreamsOpts->{}};


EcoEvoSim::usage=
"EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
EcoEvoSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoSim[traits_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},tmax_?NumericQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoSim"],
(* options *)
verbose,verboseall,
logged,boundarydetection,ndsolveopts,wheneventopts,delaydinv,fixed,tmin,outputtmin,output,freezetraits,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedvars,
Gs,tic,ecoeqns,evoeqns,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

If[Max[Table[ngcomps[gu],{gu,guilds}]]>1&&modelperiod!=0,Message[EcoEvoSim::susmtd]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoSim]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoSim]}]];
If[verboseall,verbose=True];

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEvoSim]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoSim]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EcoEvoSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoEvoSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoEvoSim]}]];
freezetraits=Evaluate[FreezeTraits/.Flatten[{opts,Options[EcoEvoSim]}]];

fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedvars=Join[traits[[All,1]],variables[[All,1]]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
If[Global`debug,Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* set up ics *)
ics=Table[
	If[logged===True&&comptype[var]==="Extensive",
		log[var][tic]==Log[var/.variables],
		var[tic]==(var/.traits/.variables)]
,{var,nonfixedvars}];

(* insert unks[] for delaydinv *)
If[delaydinv,ics=ics/.ToUnks];

(* expand Gs *)
Gs=Join[ExpandGs[Gsin],Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]];
(*Print["Gs=",Gs];*)

(* set up ecoeqns & evoeqns *)
(*ecoeqns=EcoEqns[Join[BlankTraits,ExtractInteractions[traits]],opts]/.AddTraitts;*)
(*ecoeqns=EcoEqns[Join[BlankTraits,fixedattributes],opts]/.AddTraitts;*)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts]/.RemoveVarCovts/.Gs(*/.AddTraitts*);
(*evoeqns=TraitEqns[ExtractInteractions[traits],BlankVariables,Gs,opts];*)
evoeqns=TraitEqns[BlankVariables,Gs,opts];
If[Global`debug,Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns]];

(* insert Unks[] for delaydinv *)
If[delaydinv,
	ecoeqns=ecoeqns/.ToUnks;
	evoeqns=evoeqns/.ToUnkRules/.Unk[var_]->Unk[var][t]/.var_[t+1]->Unk[var][t+1]/.var_'[t]->Unk[var]'[t]/.ExpRule[AllVariables,logged];
];
(*Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns];*)

(* boundary detection *)
If[boundarydetection==True,
	Which[
		modeltype=="ContinuousTime",
		bdwhens=Flatten[WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.(evoeqns/.(var_'[t]==rhs_):>{
			{event->var[t]>Max[range[var/.FromUnks]],action->in[var][t]->0},
			{event->var[t]<Min[range[var]/.FromUnks],action->in[var][t]->0},
			{event->rhs>0&&var[t]==Min[range[var/.FromUnks]],action->in[var][t]->1},
			{event->rhs<0&&var[t]==Max[range[var/.FromUnks]],action->in[var][t]->1}
		}),1];
		(*Print[func,": bdwhens="];Print[bdwhens];*)
		discretevars=evoeqns/.(var_'[t]==rhs_)->in[var];
		(*Print["discretevars=",discretevars];*)
		ics=Flatten[Join[ics,evoeqns/.(var_'[t]==rhs_)->in[var][0]==1]];
		(*Print["ics=",ics];*)
		evoeqns=evoeqns/.(var_'[t]==rhs_)->var'[t]==rhs*in[var][t]
	,
		modeltype=="DiscreteTime",
		evoeqns=evoeqns/.(var_[t+1]==rhs_):>var[t+1]==Clip[rhs,{Min[range[var]],Max[range[var]]}];
	];
,
	bdwhens={};
	discretevars={};
];
(*Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns];*)

If[freezetraits,
	ecoeqns=ReplaceRHS[ecoeqns,{RemoveTraitts,traits}];
	evoeqns=ReplaceRHS[evoeqns,{RemoveTraitts,traits}];
];

eqns=Join[ecoeqns,evoeqns];

(* set up unks *)
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};


If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": ics="];Print[ics];
	Print[func,": unks="];Print[unks];
	Print[func,": bdwhens="];Print[bdwhens];
	Print[func,": discretevars="];Print[discretevars];
];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens,modelwhenevents]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	sol=Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TimeSeries[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
	sol=Join[sol,Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[delaydinv,sol=sol/.FromUnks];

If[logged===True,
	res=Table[
		If[Head[var]===log,
			var[[1]]->Reinterpolation[E^var/.sol],
			var->(var/.sol)]
	,{var,Keys[sol]}]
,
	res=sol
];
	
If[output=="FinalSlice",Return[SortRuleList[Chop[Join[FinalSlice[res],fixed]],Join[AllVariables,AllTraits]]]];

Return[SortRuleList[res,Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoSim]={
	Fixed->{},Logged->False,BoundaryDetection->False,FreezeTraits->False,
	NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
	TMin->0,OutputTMin->0,Output->"Dynamics",
	Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],tmax,opts];
EcoEvoSim[sol_?AttributesAndVariablesQ,Gs:(_?RuleListQ):{},tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoSim[ExtractTraits[sol],ExtractVariables[sol],Gs,tmax,opts];


EcoEvoSim::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

EcoEvoSim::susmtd=
"Warning: EcoEvoSim is likely to be inappropriate when there are multiple components and non-equilibrium dynamics.";


FindEcoEvoEq::usage =
"FindEcoEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an eco-evolutionary equilibrium with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).";


FindEcoEvoEq[traits_?AttributesQ,variables_?VariablesQ,Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoEq"],
(* options *)
verbose,verboseall,method,boundarydetection,percapita,delaydinv,fixed,findrootopts,chop,
(* other variables *)
Gs,fixedvars,fixedattributes,fixedvariables,ecoeqns,evoeqns,eqns,unks,newunk,unksics,sol},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[FindEcoEvoEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoEq]}]];

fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
(*Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]];*)

(* expand Gs *)
Gs=Join[ExpandGs[Gsin],Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]];
(*Print["Gs=",Gs];*)

(* set up eqns *)
(*ecoeqns=EcoEqns[Join[BlankTraits,fixedattributes],opts,PerCapita\[Rule]percapita];*)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],opts,PerCapita->percapita];
(*Print["ecoeqns=",ecoeqns];*)
evoeqns=TraitEqns[BlankVariables,Gs,opts];
(*Print["evoeqns=",evoeqns];*)
eqns=If[delaydinv,
	Join[ecoeqns/.Eq/.RemoveVariablets/.RemoveTraitts/.ToUnks,evoeqns/.Eq/.RemoveVariablets/.RemoveTraitts/.ToUnkRules],
	Join[ecoeqns,evoeqns]/.Eq/.RemoveTraitts/.RemoveVariablets/.RemoveVarCovts/.Gs
];

(* set up unksics *)
unks=Join[ecoeqns,evoeqns]/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]-var_[t]->var,var_[t+1]->var};
unksics={};
Do[
	newunk=If[delaydinv,{var/.ToUnks,var/.traits/.variables},{var,var/.traits/.variables}];
	If[method=="Secant",AppendTo[newunk,var+0.001/.traits/.variables]];
	If[boundarydetection,
		newunk=Join[newunk,{Min[range[var]],Max[range[var]]}];
		If[((var/.traits/.variables)<Min[range[var]])||((var/.traits/.variables)>Max[range[var]]),
			Message[FindEcoEvoEq::streg,var,var/.traits/.variables,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
			Abort[];
		];
	];
	AppendTo[unksics,newunk];
,{var,unks}];

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unksics="];Print[unksics];
];

(* solve it *)
sol=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]];
If[Global`debug,Print[func,": sol="];Print[sol]];
If[Length[$MessageList]>0&&$MessageList[[-1]]===HoldForm[FindRoot::reged],Message[FindEcoEvoEq::reged]];

If[chop,
	Return[SortRuleList[Chop[Join[sol,fixed]/.FromUnks],Join[AllVariables,AllTraits]]],
	Return[SortRuleList[Join[sol,fixed]/.FromUnks,Join[AllVariables,AllTraits]]]
];

]];


Options[FindEcoEvoEq]={Fixed->{},PerCapita->True,FindRootOpts->{},DelayDInv->False,Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
FindEcoEvoEq[sol_?AttributesAndVariablesQ,Gs_:{},opts___?OptionQ]:=
	FindEcoEvoEq[ExtractTraits[sol],ExtractVariables[sol],Gs,opts];


FindEcoEvoEq::badfg="Bad FitnessGradient method (should be either DInv or NDInv).";

FindEcoEvoEq::badte="Bad TraitEqn (should be either \"QG\" or \"CE\").";

FindEcoEvoEq::streg="Initial value of `1` = `2` is outside the range `3` < `1` < `4`. Either fix it or set BoundaryDetection\[Rule]False.";

FindEcoEvoEq::reged="Warning: FindRoot reached boundary, don't trust result (maybe try again using Fixed to fix variables on the boundary).";


TrackEcoEvoEq::usage=
"TrackEcoEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\), {\!\(\*
StyleBox[\"par\", \"TI\"]\), \!\(\*
StyleBox[\"parmin\", \"TI\"]\), \!\(\*
StyleBox[\"parmax\", \"TI\"]\), \!\(\*
StyleBox[\"dpar\", \"TI\"]\)}] tracks an eco-evolutionary equilibrium, with initial guess \!\(\*
StyleBox[\"sol\", \"TI\"]\), over parameter \!\(\*
StyleBox[\"par\", \"TI\"]\) from \!\(\*
StyleBox[\"parmin\", \"TI\"]\) to \!\(\*
StyleBox[\"parmax\", \"TI\"]\), with initial step size \!\(\*
StyleBox[\"dpar\", \"TI\"]\).";


TrackEcoEvoEq[init_?AttributesAndVariablesQ,{parname_,parmin_?NumericQ,parmax_?NumericQ,dparin_:Automatic},opts___?OptionQ]:=

Module[{
func=FuncStyle["TrackEcoEvoEq"],
(* options *)
verbose,monitor,printtrace,
tests,
minstepsize,maxstepsize,maxsteps,mindist,maxbend,maxchange,
findecoevoeqopts,interpolationopts,
(* other variables *)
par,dpar,tmp,ics,unks,count,sol,
m0,m1,list
},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)
verbose=Evaluate[Verbose/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[Global`debug,verbose=True];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[TrackEcoEvoEq]}]];

printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[dparin===Automatic,dpar=Sign[parmax-parmin],dpar=dparin];
minstepsize=Evaluate[MinStepSize/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[minstepsize===Automatic,minstepsize=dpar*2^-10];
maxstepsize=Evaluate[MaxStepSize/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
If[maxstepsize===Automatic,maxstepsize=dpar*2^3];
maxsteps=Evaluate[MaxSteps/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
mindist=Evaluate[MinDistance/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
maxbend=Evaluate[MaxBend/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
maxchange=Evaluate[MaxChange/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
tests=Evaluate[Tests/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
findecoevoeqopts=Evaluate[FindEcoEvoEqOpts/.Flatten[{opts,Options[TrackEcoEvoEq]}]];
interpolationopts=Evaluate[InterpolationOpts/.Flatten[{opts,Options[TrackEcoEvoEq]}]];

If[monitor,PrintTemporary[Dynamic[count]," ",parname,"=",Dynamic[par]," d",parname,"=",Dynamic[dpar]]];

Evaluate[parname]:=par;

unks=Keys[init];
tmp={};
par=parmin;
dpar=dpar/2;
ics=init;
count=0;

While[count<maxsteps,
	count++;
	sol=Check[FindEcoEvoEq[ics,Evaluate[Sequence@@findecoevoeqopts]],"err"];
	If[printtrace&&sol=!="err",Print[Defer@parname,"=",NumberForm@par," sol=",sol]];
	(*Print[Flatten[Table[PartsAboveDiagonal[TraitDistance[sol,gu]],{gu,guilds}]]];*)
	(*Print[Table[{
				m1=((unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])-(unk/.tmp\[LeftDoubleBracket]-2,2\[RightDoubleBracket]))/(tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]-tmp\[LeftDoubleBracket]-2,1\[RightDoubleBracket]);
				m0=((unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket]))/(par-tmp\[LeftDoubleBracket]-1,1\[RightDoubleBracket]);
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]],
				Abs[(unk/.sol)-(unk/.tmp\[LeftDoubleBracket]-1,2\[RightDoubleBracket])]/(Differences@MinMax[Table[unk/.ent\[LeftDoubleBracket]2\[RightDoubleBracket],{ent,tmp}]])\[LeftDoubleBracket]1\[RightDoubleBracket]}
			,{unk,unks}]];*)
	Which[
		sol==="err",
		If[par==parmin,Message[TrackEcoEvoEq::ferr,Defer@parname,NumberForm@par];Return[$Aborted]];
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," FindEcoEvoEq error"]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::err,Defer@parname,NumberForm@par];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"CSS"]&&Max[Re[EcoEvoEigenvalues[sol]]]>0,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-CSS, EcoEvoEigenvalues[sol]=",EcoEvoEigenvalues[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::noncss,Defer@parname,NumberForm@par,EcoEvoEigenvalues[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"LocalESS"]&&!CompoundAnd[Flatten[LocalESSQ[sol]]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-local ESS, LocalESSQ[sol]=",LocalESSQ[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::nonless,Defer@parname,NumberForm@par,LocalESSQ[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"GlobalESS"]&&!CompoundAnd[GlobalESSQ[sol][[1]]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," non-global ESS, GlobalESSQ[sol]=",GlobalESSQ[sol]]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::nongess,Defer@parname,NumberForm@par,GlobalESSQ[sol]];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"Extinction"]&&Cases[ExtinctSpecies[sol],_Subscript]!={},
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," extinction, sol=",sol]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::extinct,Defer@parname,NumberForm@par,sol];Break[]];
		par=par-dpar
	,
		MemberQ[tests,"Convergence"]&&Min[Flatten[Table[PartsAboveDiagonal[TraitDistance[sol,gu]],{gu,guilds}]]]<mindist,
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," traits converged, sol=",sol]];
		dpar=dpar/2;
		If[Abs[dpar]<Abs[minstepsize],Message[TrackEcoEvoEq::converged,Defer@parname,NumberForm@par,sol];Break[]];
		par=par-dpar;
	,
		MemberQ[tests,"MaxBend"]&&Length[tmp]>=2&&CompoundOr[Table[
				m1=((unk/.tmp[[-1,2]])-(unk/.tmp[[-2,2]]))/(tmp[[-1,1]]-tmp[[-2,1]]);
				m0=((unk/.sol)-(unk/.tmp[[-1,2]]))/(par-tmp[[-1,1]]);
				list=Table[unk/.ent[[2]],{ent,tmp}];
				180/\[Pi] ArcTan[Abs[(m0-m1)/(1+m0 m1)]]>maxbend
				&&
				Abs[(unk/.sol)-(unk/.tmp[[-1,2]])]/(10^-10+Differences[{Min[list],Max[list]}][[1]])>maxchange
			,{unk,unks}]],
		If[printtrace,Print[Defer@parname,"=",NumberForm@par," MaxBend exceeded"]];
		If[dpar>0,dpar=Max[minstepsize,dpar/2],dpar=Min[minstepsize,dpar/2]];
		par=par-dpar;			
	,
		True,
		AppendTo[tmp,{par,sol}];
		If[par==parmax,Break[]]; (* reached end *)
		If[dpar>0,
			dpar=Min[maxstepsize,2dpar];
			par=Min[parmax,par+dpar];
		,
			dpar=Max[maxstepsize,2dpar];
			par=Max[parmax,par+dpar];
		];
	];
	ics=Quiet[Slice[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]],par],{Interpolation::inhr,InterpolatingFunction::dmval}];
];

If[count==maxsteps,Message[TrackEcoEvoEq::mxst,maxsteps,Defer@parname,NumberForm@par]];

Clear[parname];

Return[RuleListInterpolation[tmp,Evaluate[Sequence@@interpolationopts]]]
]];


Options[TrackEcoEvoEq]={
	Verbose->False,PrintTrace->False,Monitor->True,
	MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->200,
	Tests->{"CSS","LocalESS","GlobalESS","Extinction","Convergence","MaxBend"},
	FindEcoEvoEqOpts->{},InterpolationOpts->{},
	MinDistance->10^-10,MaxBend->3,MaxChange->0.01
};


TrackEcoEvoEq::err="FindEcoEvoEq failed at `1`=`2`.";
TrackEcoEvoEq::ferr="FindEcoEvoEq failed at initial parameter value,`1`=`2`, can not continue.";
TrackEcoEvoEq::noncss="Non-convergence stable EcoEvoEq at `1`=`2`, eigenvalues=`3`).";
TrackEcoEvoEq::nonless="Not a local ESS at `1`=`2`, LocalESSQ=`3`.";
TrackEcoEvoEq::nongess="Not a global ESS at `1`=`2`, GlobalESSQ=`3`.";
TrackEcoEvoEq::extinct="Extinction at `1`=`2`, sol=`3`.";
TrackEcoEvoEq::converged="Traits converged at `1`=`2`, sol=`3`.";
TrackEcoEvoEq::mxst="Maximum number of `1` steps reached at `2`=`3`";


FindEcoEvoCycle::usage=
"FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an eco-evolutionary cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
FindEcoEvoCycle[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";

FindEcoCycleEvoEq::usage=
"FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\)] finds an evolutionary equilibrium with an ecological cycle, with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
FindEcoCycleEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varscovars\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


(* Periodic system *)
FindEcoEvoCycle[traitsin_?TraitsQ,variablesin_?VariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoCycle (Periodic)"],
(* options *)
verbose,verboseall,
method,fitnessgradient,evoeq,
ecosimopts,ndinvopts,ecoevosimopts,findrootopts,monitor,printtrace,fixed,traitshiftrate,
maxiterations,rulelistdistanceopts,
accuracygoal,traitaccuracygoal,variableaccuracygoal,
precisiongoal,traitprecisiongoal,variableprecisiongoal,
(* other variables *)
traits,variables,
fixedvars,fixedtraits,fixedvariables,nonfixedtraits,nonfixedvars,nonfixedvariables,
thing,fw,sol,unks,unksics,res,dtrait,v,nb},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
evoeq=Evaluate[EvoEq/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fitnessgradient=Evaluate[FitnessGradient/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[fitnessgradient===Automatic,
	If[evoeq==False||Max[Table[ngcomps[gu],{gu,guilds}]]==1,fitnessgradient="EcoEvoSim",fitnessgradient="NDInv"]];
If[Max[Table[ngcomps[gu],{gu,guilds}]]>1&&fitnessgradient=="EcoEvoSim",Message[FindEcoEvoCycle::susmtd]];
If[verbose,Print[func,": FitnessGradient=",fitnessgradient]];
ndinvopts=Evaluate[NDInvOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecosimopts=Evaluate[EcoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
ecoevosimopts=Evaluate[EcoEvoSimOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[evoeq==True,AppendTo[ecoevosimopts,FreezeTraits->True]];
monitor=Evaluate[Monitor/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
printtrace=Evaluate[PrintTrace/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
traitshiftrate=Evaluate[TraitShiftRate/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
maxiterations=Evaluate[MaxIterations/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
accuracygoal=Evaluate[AccuracyGoal/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[ListQ[accuracygoal],
	{variableaccuracygoal,traitaccuracygoal}=accuracygoal[[1;;2]],
	variableaccuracygoal=traitaccuracygoal=accuracygoal];
precisiongoal=Evaluate[PrecisionGoal/.Flatten[{opts,Options[FindEcoEvoCycle]}]];
If[ListQ[precisiongoal],
	{variableprecisiongoal,traitprecisiongoal}=precisiongoal[[1;;2]],
	variableprecisiongoal=traitprecisiongoal=precisiongoal];
rulelistdistanceopts=Evaluate[RuleListDistanceOpts/.Flatten[{opts,Options[FindEcoEvoCycle]}]];

(* drop fixed variables from traits and variables *)
traits=RuleListComplement[traitsin,fixed];
variables=RuleListComplement[variablesin,fixed];

fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedtraits=traits[[All,1]];
nonfixedvariables=variables[[All,1]];
nonfixedvars=Join[nonfixedvariables,nonfixedtraits];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedtraits],Join[variables,fixedvariables]];

Which[
	fitnessgradient=="EcoEvoSim",
	thing[varsandtraits_?NumericRuleListQ]:=Module[{},
		$FindEcoEvoCycleSteps++;
		sol=EcoEvoSim[varsandtraits,Gs,modelperiod,Fixed->fixed,TraitShiftRate->traitshiftrate,
			Evaluate[Sequence@@ecoevosimopts]];
		If[printtrace,Print[$FindEcoEvoCycleSteps," ",FinalSlice[sol]]];
		Return[Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&]]
	]
,	
	fitnessgradient=="NDInv",
	(* shifting traits *)
	Do[dtrait[tr]=If[MemberQ[traitshiftrate[[All,1]],tr[[1]]],tr[[1]]/.traitshiftrate,0],{tr,nonfixedtraits}];
	(* set up vs *)
	Do[v[tr]=V[DeleteSubscripts@tr]/.Gs/.V[DeleteSubscripts@tr]->1,{tr,nonfixedtraits}];

	thing[varsandtraits_?NumericRuleListQ]:=Module[{fg},
		$FindEcoEvoCycleSteps++;
		sol=EcoSim[varsandtraits,modelperiod,Fixed->fixed,Evaluate[Sequence@@ecosimopts]];
		fg=Flatten[Table[tr->
			v[tr]*NDInv[Join[varsandtraits,fixed]//ExtractTraits,sol,tr//ZeroSubscripts,{(tr//ZeroSubscripts)->(tr/.varsandtraits)},
			Evaluate[Sequence@@ndinvopts]]-dtrait[tr]
		,{tr,nonfixedtraits}]];
		If[printtrace,Print[$FindEcoEvoCycleSteps," ",FinalSlice[sol]," ",RuleListAdd[ExtractTraits[varsandtraits],fg]]];
		Return[Join[
			Select[FinalSlice[sol],MemberQ[nonfixedvars,#[[1]]]&],
			RuleListAdd[ExtractTraits[varsandtraits],fg]
		]]
	],
	Else,
	Message[FindEcoEvoCycle::badmtd];Return[$Failed]
];

If[monitor,
	nb=CreateDialog[{
		TextCell["evaluation: "],
		Dynamic[$FindEcoEvoCycleSteps],
		TextCell["vars:"],
		Dynamic[FinalSlice[sol]]
	},
	WindowTitle->"FindEcoEvoCycle Progress...",WindowSize->All];
];

(* solve it *)
$FindEcoEvoCycleSteps=0;
Which[
	method=="FindRoot",
	If[verbose,Print[func,": Method FindRoot"]];
	unks=nonfixedvars/.ToUnks;
	unksics=Table[{var/.ToUnks,var/.traits/.variables},{var,nonfixedvars}];
	fw[l_?NumericListQ]:=nonfixedvars/.thing[Thread[nonfixedvars->l]];
	res=FindRoot[fw[unks]==unks,unksics,Evaluate[Sequence@@findrootopts]];
	If[monitor,NotebookClose[nb]];
	If[evoeq==True,
		Return[SortRuleList[Join[ExtractTraits[res/.FromUnks],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]],
		Return[SortRuleList[Join[sol,fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]]
	]
,
	method=="FixedPoint",
	If[verbose,Print[func,": Method FixedPoint"]];
	(*res=FixedPoint[thing[#]&,Join[variables,traits],maxiterations,SameTest\[Rule](RuleListDistance[#1,#2,Evaluate[Sequence@@rulelistdistanceopts]]<10^-accuracygoal&)];*)
	res=FixedPoint[thing[#]&,Join[variables,traits],maxiterations,SameTest->(
		RuleListDistance[ExtractTraits[#1],ExtractTraits[#2],Evaluate[Sequence@@rulelistdistanceopts]]<10^-traitaccuracygoal
			+RuleListDistance[ExtractTraits[#1],Evaluate[Sequence@@rulelistdistanceopts]]*10^-traitprecisiongoal &&
		RuleListDistance[ExtractVariables[#1],ExtractVariables[#2],Evaluate[Sequence@@rulelistdistanceopts]]<10^-variableaccuracygoal
			+RuleListDistance[ExtractVariables[#1],Evaluate[Sequence@@rulelistdistanceopts]]*10^-variableprecisiongoal
	&)];
	If[monitor,NotebookClose[nb]];
	If[$FindEcoEvoCycleSteps==maxiterations,Message[FindEcoEvoCycle::cvmit,maxiterations]];
	If[evoeq==True,
		Return[SortRuleList[Join[ExtractTraits[res],ExtractVariables[sol],fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]],	
		Return[SortRuleList[Join[sol,fixed],Join[AllVariables,AllTraits]]/.if_InterpolatingFunction->MakeInterpolatingFunctionPeriodic[if]]
	]
,
	Else,
	Message[FindEcoEvoCycle::badmtd];Return[$Failed]
];

]]/;modelperiod=!=0;


Options[FindEcoEvoCycle]={
	Method->"FindRoot",FitnessGradient->Automatic,EvoEq->False,
	RuleListDistanceOpts->{},
	BoundaryDetection->False,TraitShiftRate->{},
	FindRootOpts->{},Fixed->{},EcoSimOpts->{},EcoEvoSimOpts->{},NDInvOpts->{},
	Chop->True,MaxIterations->100,AccuracyGoal->4,PrecisionGoal->{4,\[Infinity]},
	PrintTrace->False,Monitor->False,
	Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
FindEcoEvoCycle[traitsandvariables_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
FindEcoEvoCycle[ExtractTraits[traitsandvariables],ExtractVariables[traitsandvariables],Gs,opts];
FindEcoCycleEvoEq[stuff___]:=FindEcoEvoCycle[stuff,EvoEq->True];


FindEcoCycleEvoEq::cvmit=
"Failed to converge to the requested accuracy within \[NoBreak]`1`\[NoBreak] iterations.";

FindEcoEvoCycle::susmtd=
"Warning: FitnessGradient\[Rule]\"EcoEvoSim\" is likely to be inappropriate when there are multiple components. Try EvoEq\[Rule]True and FitnessGradient\[Rule]\"EcoEvoSim\".";


EvoEq::usage = 
"EvoEq contains SolveEvoEq, NSolveEvoEq, and FindEvoEq. Use them instead.";

SolveEvoEq::usage = 
"SolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

NSolveEvoEq::usage = 
"NSolveEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] numerically solves for evolutionary equilibria using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).";

FindEvoEq::usage = 
"FindEvoEq[\!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\).
FindEvoEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"sol\", \"TI\"]\)] finds an evolutionary equilibrium using ecological equilibrium \!\(\*
StyleBox[\"sol\", \"TI\"]\), with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\).";


EvoEq[traits:(_?AttributesQ):{},sol:(_?VariablesQ):{},Gs_List:{},opts___?OptionQ] :=
 
Module[{
func=FuncStyle["EvoEq"],
(* options *)
verbose,verboseall,method,fixed,delaydinv,solveopts,nsolveopts,findrootopts,findinstanceopts,boundarydetection,
(* other variables *)
fixedvars,fixedtraits,fixedvariables,tounks,fromunks,evoeqns,eqns,unks,unksics,newunk,res},
   
Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts, Options[EvoEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts, Options[EvoEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoEq]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

method=Evaluate[Method/.Flatten[{opts,Options[EvoEq]}]];
delaydinv=Evaluate[DelayDInv/.Flatten[{opts,Options[EvoEq]}]];
solveopts=Evaluate[SolveOpts/.Flatten[{opts,Options[EvoEq]}]];
If[$VersionNumber>=12.2,AppendTo[solveopts,Assumptions->{}]];
nsolveopts=Evaluate[NSolveOpts/.Flatten[{opts,Options[EvoEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[EvoEq]}]];
findinstanceopts=Evaluate[FindInstanceOpts/.Flatten[{opts,Options[EvoEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EvoEq]}]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[sol,fixedvariables]];

evoeqns=TraitEqns[sol,Gs,opts];
eqns=evoeqns/.Eq/.RemoveTraitts/.RemoveVariablets;

(* set up unksics *)
unks=evoeqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]-var_[t]->var,var_[t+1]->var};
If[method=="FindRoot",
	unksics={};
	Do[
		newunk={var,var/.traits};
		If[boundarydetection,
			If[((var/.traits)<Min[range[var]])||((var/.traits)>Max[range[var]]),
				Message[FindEvoEq::streg,var,var/.traits,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
				Abort[];
			];
			newunk=Join[newunk,{Min[range[var]],Max[range[var]]}]
		];
		AppendTo[unksics,newunk];
	,{var,unks}]
];

(* solve it *)
Which[
	method=="Solve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@solveopts},
		PrintCall[Global`res=Solve[eqns,unks,op]]]];
	res=Solve[eqns,unks,Evaluate[Sequence@@solveopts]],
	method=="NSolve",
	If[verbose,
		With[{eqns=eqns,unks=unks,op=Sequence@@nsolveopts},
		PrintCall[Global`res=NSolve[eqns,unks,op]]]];
	res=NSolve[eqns,unks,Evaluate[Sequence@@nsolveopts]],
	method=="FindRoot",
	If[delaydinv,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,op]/.FromUnks]]];
		res=FindRoot[eqns/.ToUnkRules,unksics/.ToUnks,Evaluate[Sequence@@findrootopts]]/.FromUnks
	,
		If[verbose,
			With[{eqns=eqns,unksics=unksics,op=Sequence@@findrootopts},
			PrintCall[Global`res=FindRoot[eqns,unksics,op]]]];
		res=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]]
	],
	method=="FindInstance",
	If[delaydinv,
		Message[FindEvoEq::needic];Return[$Failed]
	,
		If[verbose,
			With[{eqns=eqns,unks=unks,op=Sequence@findinstanceopts},
			PrintCall[Global`res=FindInstance[eqns,unks,op][[1]]]]];
		res=FindInstance[eqns,unks,Evaluate[Sequence@@findinstanceopts]][[1]]
	],
	Else, (* else *)
	Message[EvoEq::badmtd];Return[$Failed]
];

If[MemberQ[{Solve,NSolve},Head[res]],
	Message[EvoEq::nosol];Return[$Failed],
	Return[SortRuleList[EqSort[Chop[res]],AllTraits]]
];

]];


SolveEvoEq[args___]:=EvoEq[args,Method->"Solve"];
NSolveEvoEq[args___]:=EvoEq[args,Method->"NSolve"];
FindEvoEq[sol:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=EvoEq[sol,Gs,opts,Method->"FindInstance"];
FindEvoEq[args___]:=EvoEq[args,Method->"FindRoot"];


Options[EvoEq]={
Method->"None",
DelayDInv->False,DInvOpts->{},SolveOpts->{},NSolveOpts->{},FindRootOpts->{},FindInstanceOpts->{Reals},
BoundaryDetection->False,Fixed->{},
Verbose->False,VerboseAll->False};


EvoEq::nosol="Solve/NSolve couldn't find a solution.  Try FindEcoEq instead.";

EvoEq::badmtd="The Method option should be \"Solve\", \"NSolve\", \"FindRoot\", or \"FindInstance\".";

FindEvoEq::needic="Method FindInstance doesn't work with DelayDInv.  Give an initial guess to use Method FindRoot instead.";

FindEvoEq::streg="Initial value of `1` = `2` is outside the range `3` < `1` < `4`. Either fix it or set BoundaryDetection\[Rule]False.";


EcoEvoJacobian::usage= 
"EcoEvoJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoJacobian[attributesin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed *)
fixedvars,fixedattributes,fixedvariables,
(* other variables *)
attributes,variables,interactions,ecoeqns,evoeqns,eqns,unks,jmat},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
attributes=FixAttributes[attributesin];
variables=FixVariables[variablesin];

(*interactions=ExtractInteractions[attributesin];*)
interactions=ExtractInteractions[attributes];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[attributes,fixedattributes],Join[variables,fixedvariables]];

(* expand Gs *)
Gs=Join[ExpandGs[Gsin],Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]];
(*Print["Gs=",Gs];*)

(* set up eqns & unks *)
ecoeqns=EcoEqns[Join[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],interactions,fixedattributes],opts]/.RemoveVarCovts/.Gs;
evoeqns=TraitEqns[BlankVariables,Gs,opts,Fixed->interactions];
If[verbose,
	Print[func,": ecoeqns="];Print[ecoeqns];
	Print[func,": evoeqns="];Print[evoeqns];
];
eqns=Join[ecoeqns,evoeqns];
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};
eqns=eqns/.RHS/.RemoveTraitts/.RemoveVariablets;

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unks="];Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[verbose,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.variables/.attributes]],
	Return[jmat/.variables/.attributes]
];

]];


Options[EcoEvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoJacobian[sol_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
	EcoEvoJacobian[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EcoEvoJacobian[___]:=Message[EcoEvoJacobian::noper]/;modelperiod=!=0;


EcoEvoJacobian::noper="EcoEvoJacobian can't handle periodic models yet.";


EcoEvoEigenvalues::usage= 
"EcoEvoEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoEigenvalues[attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoEigenvalues]}],Options[EcoEvoJacobian]];

	res=Eigenvalues[EcoEvoJacobian[attributes,variables,Gs,eejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoEigenvalues]={(*EvoEquation\[Rule]"QG",Fixed\[Rule]{},TraitShiftRate\[Rule]{},*)
Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoEigenvalues[sol_?AttributesAndVariablesQ,Gs_List:{},opts___?OptionQ]:=
	EcoEvoEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];


EcoEvoEigenvalues::noper="EcoEvoEigenvalues can't handle periodic models yet.";


EvoJacobian::usage = 
"EvoJacobian[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EvoJacobian[traitsin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EvoJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed vars *)
fixedvars,fixedtraits,fixedvariables,
(* other variables *)
traits,variables,eqns,unks,jmat},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedtraits=ExtractTraits[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
traits=FixAttributes[traitsin];
variables=FixVariables[variablesin];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedtraits],Join[variables,fixedvariables]];

(* set up eqns & unks *)
eqns=TraitEqns[BlankVariables,Gs,opts];
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};
eqns=eqns/.RHS/.RemoveTraitts/.RemoveVariablets;

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unks="];Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[Global`debug,Print[func,": jmat=",jmat]];

If[chop,
	Return[Chop[jmat/.variables/.traits]],
	Return[jmat/.variables/.traits]
];

]];


(* split traitsandvariables *)
EvoJacobian[sol_?AttributesAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=
EvoJacobian[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EvoJacobian[___]:=Message[EvoJacobian::noper]/;modelperiod=!=0;


Options[EvoJacobian]=
{EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoJacobian::noper="EvoJacobian can't handle periodic models yet.";


EvoEigenvalues::usage = 
"EvoEigenvalues[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an evolutionary equilibrium with \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EvoEigenvalues[traits:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,ejopts,res},

	If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];

	chop=Evaluate[Chop/.Flatten[{opts,Options[EvoEigenvalues]}]];
	ejopts=FilterRules[Flatten[{opts,Options[EvoEigenvalues]}],Options[EvoJacobian]];

	res=Eigenvalues[EvoJacobian[traits,variables,Gs,ejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


(* split traitsandvariables *)
EvoEigenvalues[sol_?AttributesAndVariablesQ,Gs:(_?GsQ):{},opts___?OptionQ]:=
EvoEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],Gs,opts];

EvoEigenvalues[___]:=Message[EvoEigenvalues::noper]/;modelperiod=!=0;


Options[EvoEigenvalues]={EvoEquation->"QG",Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


EvoEigenvalues::noper="EvoEigenvalues can't handle periodic models yet.";


EcoEvoVarSim::usage=
"EcoEvoVarSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] simulates coupled ecological and evolutionary dynamics, with initial \!\(\*
StyleBox[\"traits\", \"TI\"]\) and \!\(\*
StyleBox[\"variables\", \"TI\"]\).
EcoEvoVarSim[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] uses trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarSim[traits_?AttributesQ,variables_?VariablesQ,Gsin_?GsQ,tmax_?NumericQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoVarSim"],
(* options *)
verbose,verboseall,
logged,boundarydetection,ndsolveopts,wheneventopts,delaydinv,fixed,tmin,outputtmin,output,freezetraits,
(* other variables *)
fixedvars,fixedattributes,fixedvariables,nonfixedvars,
Gs,tic,ecoeqns,evoeqns,vareqns,eqns,ics,unks,discretevars,bdwhens,res,sol},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoVarSim]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoVarSim]}]];
If[verboseall,verbose=True];

logged=Evaluate[Logged/.Flatten[{opts,Options[EcoEvoVarSim]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[EcoEvoVarSim]}]];
ndsolveopts=Evaluate[NDSolveOpts/.Flatten[{opts,Options[EcoEvoVarSim]}]];
wheneventopts=Evaluate[WhenEventOpts/.Flatten[{opts,Options[EcoEvoVarSim]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoVarSim]}]];
tmin=Evaluate[TMin/.Flatten[{opts,Options[EcoEvoVarSim]}]];
outputtmin=Evaluate[OutputTMin/.Flatten[{opts,Options[EcoEvoVarSim]}]];
output=Evaluate[Output/.Flatten[{opts,Options[EcoEvoVarSim]}]];
freezetraits=Evaluate[FreezeTraits/.Flatten[{opts,Options[EcoEvoVarSim]}]];

fixedvars=fixed[[All,1]];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
nonfixedvars=Join[traits[[All,1]],variables[[All,1]],Gsin[[All,1]]];
If[Global`debug,Print[func,": nonfixedvars=",nonfixedvars]];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
If[Global`debug,Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

(* find time for ICs *)
tic=If[modelwhenevents=={},tmin,tmin-$MachineEpsilon]; (* hack to ensure that events are triggered at t=tmin *)

(* expand Gs *)
Gs=Join[ExpandGs[Gsin],Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]];
(*Print["Gs=",Gs];*)

(* set up ics *)
ics=Table[
	If[logged===True&&comptype[var]==="Extensive",
		log[var][tic]==Log[var/.variables],
		var[tic]==(var/.traits/.variables/.Gs)]
,{var,nonfixedvars}];

(* insert unks[] for delaydinv *)
If[delaydinv,ics=ics/.ToUnks];


(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts];
If[Global`debug,
	Print["ecoeqns="];Print[ecoeqns];
	Print["evoeqns="];Print[evoeqns];
	Print["vareqns="];Print[vareqns];
];

(* boundary detection *)
If[boundarydetection==True,
	Which[
		modeltype=="ContinuousTime",
		bdwhens=Flatten[WhenEvent[event,action,Evaluate[Sequence@@wheneventopts]]/.(evoeqns/.(var_'[t]==rhs_):>{
			{event->var[t]>Max[range[var/.FromUnks]],action->in[var][t]->0},
			{event->var[t]<Min[range[var]/.FromUnks],action->in[var][t]->0},
			{event->rhs>0&&var[t]==Min[range[var/.FromUnks]],action->in[var][t]->1},
			{event->rhs<0&&var[t]==Max[range[var/.FromUnks]],action->in[var][t]->1}
		}),1];
		(*Print[func,": bdwhens="];Print[bdwhens];*)
		discretevars=evoeqns/.(var_'[t]==rhs_)->in[var];
		(*Print["discretevars=",discretevars];*)
		ics=Flatten[Join[ics,evoeqns/.(var_'[t]==rhs_)->in[var][0]==1]];
		(*Print["ics=",ics];*)
		evoeqns=evoeqns/.(var_'[t]==rhs_)->var'[t]==rhs*in[var][t]
	,
		modeltype=="DiscreteTime",
		evoeqns=evoeqns/.(var_[t+1]==rhs_):>var[t+1]==Clip[rhs,{Min[range[var]],Max[range[var]]}];
	];
,
	bdwhens={};
	discretevars={};
];
(*Print["ecoeqns=",ecoeqns];Print["evoeqns=",evoeqns];*)

If[freezetraits,
	ecoeqns=ReplaceRHS[ecoeqns,{RemoveTraitts,traits}];
	evoeqns=ReplaceRHS[evoeqns,{RemoveTraitts,traits}];
];

eqns=Join[ecoeqns,evoeqns,vareqns];

(* set up unks *)
unks=eqns/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};


If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": ics="];Print[ics];
	Print[func,": unks="];Print[unks];
	Print[func,": bdwhens="];Print[bdwhens];
	Print[func,": discretevars="];Print[discretevars];
];

(* solve it *)

Which[
	modeltype=="ContinuousTime",
	Off[NDSolve::wenset]; (* in case a modelwhenevent involves a fixed variable *)
	sol=NDSolve[Flatten[Join[eqns,ics,bdwhens,modelwhenevents]],unks,{t,outputtmin,tmax},DiscreteVariables->discretevars,
		Evaluate[Sequence@@ndsolveopts]][[1]];
	On[NDSolve::wenset];
	sol=Join[sol,Table[fixedvar->Interpolation[{{tmin,fixedvar/.fixed},{tmax,fixedvar/.fixed}},InterpolationOrder->0],{fixedvar,fixedvars}]];
,
	modeltype=="DiscreteTime",
(* Method\[Rule]{Compiled\[Rule]False} workaround for bug in RecurrenceTable 11.0.1 *)
	res=Transpose[RecurrenceTable[Join[eqns,ics],unks,{t,tmin,tmax}(*,Method\[Rule]{Compiled\[Rule]False}*)]];
	sol=Table[unks[[i]]->TimeSeries[Transpose[{Table[t,{t,tmin,tmax}],res[[i]]}]],{i,Length[unks]}];
	sol=Join[sol,Table[fixedvar->TimeSeries[Table[{t,fixedvar/.fixed},{t,tmin,tmax}]],{fixedvar,fixedvars}]];
];

If[delaydinv,sol=sol/.FromUnks];

If[logged===True,
	res=Table[
		If[Head[var]===log,
			var[[1]]->Reinterpolation[E^var/.sol],
			var->(var/.sol)]
	,{var,Keys[sol]}]
,
	res=sol
];
	
If[output=="FinalSlice",Return[SortRuleList[Chop[Join[FinalSlice[res],fixed]],Join[AllVariables,AllTraits]]]];

Return[SortRuleList[res,Join[AllVariables,AllTraits]]];

]]


Options[EcoEvoVarSim]={
	Fixed->{},Logged->False,BoundaryDetection->False,FreezeTraits->False,
	NDSolveOpts->{MaxSteps->\[Infinity]},WhenEventOpts->{},DInvOpts->{},DelayDInv->False,EvoEquation->"QG",TraitShiftRate->{},
	TMin->0,OutputTMin->0,Output->"Dynamics",
	Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoVarSim[sol_?AttributesVariablesAndGsQ,tmax_?NumericQ,opts___?OptionQ]:=
EcoEvoVarSim[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],tmax,opts];


FindEcoEvoVarEq::usage=
"FindEcoEvoVarEq[\!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"tmax\", \"TI\"]\)] finds an eco-evolutionary equilibrium (abundance, traits, variances) with initial guess \!\(\*
StyleBox[\"traits\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), and \!\(\*
StyleBox[\"varscovs\", \"TI\"]\).";


FindEcoEvoVarEq[traits_?AttributesQ,variables_?VariablesQ,Gsin_?GsQ,opts___?OptionQ]:=

Module[{
func=FuncStyle["FindEcoEvoVarEq"],
(* options *)
verbose,verboseall,method,boundarydetection,percapita,fixed,findrootopts,chop,
(* other variables *)
Gs,fixedvars,fixedattributes,fixedvariables,ecoeqns,evoeqns,vareqns,eqns,unks,newunk,unksics,sol},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
If[verboseall,verbose=True];

method=Evaluate[Method/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
boundarydetection=Evaluate[BoundaryDetection/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
percapita=Evaluate[PerCapita/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
fixed=Evaluate[Fixed/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
findrootopts=Evaluate[FindRootOpts/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];
chop=Evaluate[Chop/.Flatten[{opts,Options[FindEcoEvoVarEq]}]];

fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];


(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[traits,fixedattributes],Join[variables,fixedvariables]];
If[Global`debug,Print["\[ScriptCapitalN]=",Table[\[ScriptCapitalN][gu],{gu,guilds}]]];

(* expand Gs *)
Gs=Join[ExpandGs[Gsin],Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]];
(*Print["Gs=",Gs];*)

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts,PerCapita->percapita];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts];
If[Global`debug,
	Print["ecoeqns="];Print[ecoeqns];
	Print["evoeqns="];Print[evoeqns];
	Print["vareqns="];Print[vareqns];
];

eqns=Join[ecoeqns,evoeqns,vareqns]/.Eq/.RemoveTraitts/.RemoveVariablets/.RemoveVarCovts;

(* set up unks *)
unks=Join[ecoeqns,evoeqns,vareqns]/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};
unksics={};
Do[
	newunk={var,var/.traits/.variables/.Gs};
	If[method=="Secant",AppendTo[newunk,var+0.001/.traits/.variables/.Gs]];
	If[boundarydetection,
		newunk=Join[newunk,{Min[range[var]],Max[range[var]]}];
		If[((var/.traits/.variables)<Min[range[var]])||((var/.traits/.variables)>Max[range[var]]),
			Message[FindEcoEvoEq::streg,var,var/.traits/.variables,NumberForm@Min[range[var]],NumberForm@Max[range[var]]];
			Abort[];
		];
	];
	AppendTo[unksics,newunk];
,{var,unks}];


If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unksics="];Print[unksics];
];

(* solve it *)
sol=FindRoot[eqns,unksics,Evaluate[Sequence@@findrootopts]];
If[Global`debug,Print[func,": sol="];Print[sol]];
If[Length[$MessageList]>0&&$MessageList[[-1]]===HoldForm[FindRoot::reged],Message[FindEcoEvoEq::reged]];

If[chop,
	Return[SortRuleList[Chop[Join[sol,fixed]/.FromUnks],Join[AllVariables,AllTraits]]],
	Return[SortRuleList[Join[sol,fixed]/.FromUnks,Join[AllVariables,AllTraits]]]
];

]]


Options[FindEcoEvoVarEq]={
	PerCapita->True,FindRootOpts->{},Chop->True,Fixed->{},
	Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
FindEcoEvoVarEq[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
FindEcoEvoVarEq[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];


EcoEvoVarJacobian::usage= 
"EcoEvoVarJacobian[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the Jacobian of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarJacobian[attributesin:(_?AttributesQ):{},variablesin:(_?VariablesQ):{},Gsin:(_?GsQ):{},opts___?OptionQ]:=

Module[{
func=FuncStyle["EcoEvoVarJacobian"],
(* options *)
verbose,verboseall,fixed,chop,
(* rules *)
removets,
(* fixed *)
fixedvars,fixedattributes,fixedvariables,
(* other variables *)
Gs,attributes,variables,interactions,ecoeqns,evoeqns,vareqns,eqns,unks,jmat},

Block[{\[ScriptCapitalN]},

If[modelloaded!=True,Message[EcoEvoGeneral::nomodel];Return[$Failed]];
If[Global`debug,Print["In ",func]];

(* handle options *)

verbose=Evaluate[Verbose/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[Global`debug,verbose=True];
verboseall=Evaluate[VerboseAll/.Flatten[{opts,Options[EcoEvoJacobian]}]];
If[verboseall,verbose=True];

chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoJacobian]}]];

fixed=Evaluate[Fixed/.Flatten[{opts,Options[EcoEvoJacobian]}]];
fixedvars=fixed[[All,1]];
fixedattributes=ExtractAttributes[fixed];
fixedvariables=ExtractVariables[fixed];
If[Global`debug,Print[func,": fixedvars=",fixedvars]];

(* handle blanks & figure out number of species in guilds *)
attributes=FixAttributes[attributesin];
variables=FixVariables[variablesin];

(*interactions=ExtractInteractions[attributesin];*)
interactions=ExtractInteractions[attributes];

(* figure out number of species in guilds *)
Set\[ScriptCapitalN][Join[attributes,fixedattributes],Join[variables,fixedvariables]];

(* expand Gs *)
(*Gs=Join[ExpandGs[Gsin],Flatten@Table[Thread[Flatten@MakeGMatrix[gu]->Flatten@IdentityMatrix[ngtraits[gu]]],{gu,guilds}]];*)
Gs=ExpandGs[Gsin];
(*Print["Gs=",Gs];*)

(* set up eqns *)
ecoeqns=EcoEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts,PerCapita->percapita];
evoeqns=TraitEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts];
vareqns=VarEqns[Table[\[FormalCapitalN][gu]->\[ScriptCapitalN][gu],{gu,guilds}],Fixed->fixed,opts];
If[Global`debug,
	Print["ecoeqns="];Print[ecoeqns];
	Print["evoeqns="];Print[evoeqns];
	Print["vareqns="];Print[vareqns];
];

eqns=Join[ecoeqns,evoeqns,vareqns]/.RHS/.RemoveTraitts/.RemoveVariablets/.RemoveVarCovts;
unks=Join[ecoeqns,evoeqns,vareqns]/.LHS/.{var_'[t]->var,var_[t+1]/var_[t]->var,var_[t+1]->var};

If[verbose,
	Print[func,": eqns="];Print[eqns];
	Print[func,": unks="];Print[unks];
];

(* set up jacobian *)
jmat=D[eqns,{unks}]; 
If[verbose,Print[func,": jmat=",jmat]];
If[Global`debug,
	Print["variables=",variables];
	Print["attributes=",attributes];
	Print["Gs=",Gs];
];

If[chop,
	Return[Chop[jmat/.variables/.attributes/.Gs]],
	Return[jmat/.variables/.attributes/.Gs]
];

]];


Options[EcoEvoVarJacobian]=
{Fixed->{},TraitShiftRate->{},Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoVarJacobian[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
EcoEvoVarJacobian[ExtractTraits[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];





EcoEvoVarEigenvalues::usage= 
"EcoEvoVarEigenvalues[\!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), \!\(\*
StyleBox[\"varcovars\", \"TI\"]\)] calculates the eigenvalues of an eco-evolutionary equilibrium with trait values/interaction coefficients \!\(\*
StyleBox[\"attributes\", \"TI\"]\), \!\(\*
StyleBox[\"variables\", \"TI\"]\), trait variances/covariances in \!\(\*
StyleBox[\"varcovars\", \"TI\"]\).";


EcoEvoVarEigenvalues[attributes:(_?AttributesQ):{},variables:(_?VariablesQ):{},Gs:(_?GsQ):{},opts___?OptionQ]:=Module[{chop,eejopts,res},

	chop=Evaluate[Chop/.Flatten[{opts,Options[EcoEvoVarEigenvalues]}]];
	eejopts=FilterRules[Flatten[{opts,Options[EcoEvoVarEigenvalues]}],Options[EcoEvoVarJacobian]];

	res=Eigenvalues[EcoEvoVarJacobian[attributes,variables,Gs,eejopts]];

	If[chop,Return[Chop[res]],Return[res]];
];


Options[EcoEvoVarEigenvalues]={(*EvoEquation\[Rule]"QG",Fixed\[Rule]{},TraitShiftRate\[Rule]{},*)
Chop->True,Verbose->False,VerboseAll->False};


(* split traitsandvariables *)
EcoEvoVarEigenvalues[sol_?AttributesVariablesAndGsQ,opts___?OptionQ]:=
	EcoEvoVarEigenvalues[ExtractAttributes[sol],ExtractVariables[sol],ExtractVarCovs[sol],opts];





(* Protect all package symbols *)
With[{syms = Names["EcoEvo`*"]},
  SetAttributes[syms,Protected]
];
Unprotect[Unk,t,LookUp,$FindEcoCycleSteps,$InvCount,$FindEcoEvoCycleSteps];


End[];
EndPackage[];


"EcoEvo Package Version "<>$EcoEvoVersion<>"
Christopher A. Klausmeier <christopher.klausmeier@gmail.com>"
